// Package listingsItems20210801 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.4 DO NOT EDIT.
package listingsItems20210801

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for IssueSeverity.
const (
	ERROR   IssueSeverity = "ERROR"
	INFO    IssueSeverity = "INFO"
	WARNING IssueSeverity = "WARNING"
)

// Defines values for ItemOfferByMarketplaceOfferType.
const (
	B2B ItemOfferByMarketplaceOfferType = "B2B"
	B2C ItemOfferByMarketplaceOfferType = "B2C"
)

// Defines values for ItemSummaryByMarketplaceConditionType.
const (
	ClubClub               ItemSummaryByMarketplaceConditionType = "club_club"
	CollectibleAcceptable  ItemSummaryByMarketplaceConditionType = "collectible_acceptable"
	CollectibleGood        ItemSummaryByMarketplaceConditionType = "collectible_good"
	CollectibleLikeNew     ItemSummaryByMarketplaceConditionType = "collectible_like_new"
	CollectibleVeryGood    ItemSummaryByMarketplaceConditionType = "collectible_very_good"
	NewNew                 ItemSummaryByMarketplaceConditionType = "new_new"
	NewOem                 ItemSummaryByMarketplaceConditionType = "new_oem"
	NewOpenBox             ItemSummaryByMarketplaceConditionType = "new_open_box"
	RefurbishedRefurbished ItemSummaryByMarketplaceConditionType = "refurbished_refurbished"
	UsedAcceptable         ItemSummaryByMarketplaceConditionType = "used_acceptable"
	UsedGood               ItemSummaryByMarketplaceConditionType = "used_good"
	UsedLikeNew            ItemSummaryByMarketplaceConditionType = "used_like_new"
	UsedVeryGood           ItemSummaryByMarketplaceConditionType = "used_very_good"
)

// Defines values for ItemSummaryByMarketplaceStatus.
const (
	BUYABLE      ItemSummaryByMarketplaceStatus = "BUYABLE"
	DISCOVERABLE ItemSummaryByMarketplaceStatus = "DISCOVERABLE"
)

// Defines values for ListingsItemPutRequestRequirements.
const (
	LISTING            ListingsItemPutRequestRequirements = "LISTING"
	LISTINGOFFERONLY   ListingsItemPutRequestRequirements = "LISTING_OFFER_ONLY"
	LISTINGPRODUCTONLY ListingsItemPutRequestRequirements = "LISTING_PRODUCT_ONLY"
)

// Defines values for ListingsItemSubmissionResponseStatus.
const (
	ACCEPTED ListingsItemSubmissionResponseStatus = "ACCEPTED"
	INVALID  ListingsItemSubmissionResponseStatus = "INVALID"
)

// Defines values for PatchOperationOp.
const (
	Add     PatchOperationOp = "add"
	Delete  PatchOperationOp = "delete"
	Replace PatchOperationOp = "replace"
)

// Defines values for GetListingsItemParamsIncludedData.
const (
	GetListingsItemParamsIncludedDataAttributes              GetListingsItemParamsIncludedData = "attributes"
	GetListingsItemParamsIncludedDataFulfillmentAvailability GetListingsItemParamsIncludedData = "fulfillmentAvailability"
	GetListingsItemParamsIncludedDataIssues                  GetListingsItemParamsIncludedData = "issues"
	GetListingsItemParamsIncludedDataOffers                  GetListingsItemParamsIncludedData = "offers"
	GetListingsItemParamsIncludedDataProcurement             GetListingsItemParamsIncludedData = "procurement"
	GetListingsItemParamsIncludedDataSummaries               GetListingsItemParamsIncludedData = "summaries"
)

// Decimal A decimal number with no loss of precision. Useful when precision loss is unnaceptable, as with currencies. Follows RFC7159 for number representation.
type Decimal = string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	Errors []Error `json:"errors"`
}

// FulfillmentAvailability Fulfillment availability details for the listings item.
type FulfillmentAvailability struct {
	// FulfillmentChannelCode Designates which fulfillment network will be used.
	FulfillmentChannelCode string `json:"fulfillmentChannelCode"`

	// Quantity The quantity of the item you are making available for sale.
	Quantity *int `json:"quantity,omitempty"`
}

// Issue An issue with a listings item.
type Issue struct {
	// AttributeNames Names of the attributes associated with the issue, if applicable.
	AttributeNames *[]string `json:"attributeNames,omitempty"`

	// Code An issue code that identifies the type of issue.
	Code string `json:"code"`

	// Message A message that describes the issue.
	Message string `json:"message"`

	// Severity The severity of the issue.
	Severity IssueSeverity `json:"severity"`
}

// IssueSeverity The severity of the issue.
type IssueSeverity string

// Item A listings item.
type Item struct {
	// Attributes JSON object containing structured listings item attribute data keyed by attribute name.
	Attributes *ItemAttributes `json:"attributes,omitempty"`

	// FulfillmentAvailability Fulfillment availability for the listings item.
	FulfillmentAvailability *[]FulfillmentAvailability `json:"fulfillmentAvailability,omitempty"`

	// Issues Issues associated with the listings item.
	Issues *ItemIssues `json:"issues,omitempty"`

	// Offers Offer details for the listings item.
	Offers *ItemOffers `json:"offers,omitempty"`

	// Procurement Vendor procurement information for the listings item.
	Procurement *ItemProcurement `json:"procurement,omitempty"`

	// Sku A selling partner provided identifier for an Amazon listing.
	Sku string `json:"sku"`

	// Summaries Summary details of a listings item.
	Summaries *ItemSummaries `json:"summaries,omitempty"`
}

// ItemAttributes JSON object containing structured listings item attribute data keyed by attribute name.
type ItemAttributes map[string]interface{}

// ItemImage Image for the listings item.
type ItemImage struct {
	// Height Height of the image in pixels.
	Height int `json:"height"`

	// Link Link, or URL, for the image.
	Link string `json:"link"`

	// Width Width of the image in pixels.
	Width int `json:"width"`
}

// ItemIssues Issues associated with the listings item.
type ItemIssues = []Issue

// ItemOfferByMarketplace Offer details of a listings item for an Amazon marketplace.
type ItemOfferByMarketplace struct {
	// MarketplaceId Amazon marketplace identifier.
	MarketplaceId string `json:"marketplaceId"`

	// OfferType Type of offer for the listings item.
	OfferType ItemOfferByMarketplaceOfferType `json:"offerType"`

	// Points The number of Amazon Points offered with the purchase of an item, and their monetary value. Note that the Points element is only returned in Japan (JP).
	Points *Points `json:"points,omitempty"`

	// Price The currency type and the amount.
	Price Money `json:"price"`
}

// ItemOfferByMarketplaceOfferType Type of offer for the listings item.
type ItemOfferByMarketplaceOfferType string

// ItemOffers Offer details for the listings item.
type ItemOffers = []ItemOfferByMarketplace

// ItemProcurement Vendor procurement information for the listings item.
type ItemProcurement struct {
	// CostPrice The currency type and the amount.
	CostPrice Money `json:"costPrice"`
}

// ItemSummaries Summary details of a listings item.
type ItemSummaries = []ItemSummaryByMarketplace

// ItemSummaryByMarketplace Summary details of a listings item for an Amazon marketplace.
type ItemSummaryByMarketplace struct {
	// Asin Amazon Standard Identification Number (ASIN) of the listings item.
	Asin string `json:"asin"`

	// ConditionType Identifies the condition of the listings item.
	ConditionType *ItemSummaryByMarketplaceConditionType `json:"conditionType,omitempty"`

	// CreatedDate Date the listings item was created, in ISO 8601 format.
	CreatedDate time.Time `json:"createdDate"`

	// FnSku Fulfillment network stock keeping unit is an identifier used by Amazon fulfillment centers to identify each unique item.
	FnSku *string `json:"fnSku,omitempty"`

	// ItemName Name, or title, associated with an Amazon catalog item.
	ItemName string `json:"itemName"`

	// LastUpdatedDate Date the listings item was last updated, in ISO 8601 format.
	LastUpdatedDate time.Time `json:"lastUpdatedDate"`

	// MainImage Image for the listings item.
	MainImage *ItemImage `json:"mainImage,omitempty"`

	// MarketplaceId A marketplace identifier. Identifies the Amazon marketplace for the listings item.
	MarketplaceId string `json:"marketplaceId"`

	// ProductType The Amazon product type of the listings item.
	ProductType string `json:"productType"`

	// Status Statuses that apply to the listings item.
	Status []ItemSummaryByMarketplaceStatus `json:"status"`
}

// ItemSummaryByMarketplaceConditionType Identifies the condition of the listings item.
type ItemSummaryByMarketplaceConditionType string

// ItemSummaryByMarketplaceStatus defines model for ItemSummaryByMarketplace.Status.
type ItemSummaryByMarketplaceStatus string

// ListingsItemPatchRequest The request body schema for the patchListingsItem operation.
type ListingsItemPatchRequest struct {
	// Patches One or more JSON Patch operations to perform on the listings item.
	Patches []PatchOperation `json:"patches"`

	// ProductType The Amazon product type of the listings item.
	ProductType string `json:"productType"`
}

// ListingsItemPutRequest The request body schema for the putListingsItem operation.
type ListingsItemPutRequest struct {
	// Attributes JSON object containing structured listings item attribute data keyed by attribute name.
	Attributes map[string]interface{} `json:"attributes"`

	// ProductType The Amazon product type of the listings item.
	ProductType string `json:"productType"`

	// Requirements The name of the requirements set for the provided data.
	Requirements *ListingsItemPutRequestRequirements `json:"requirements,omitempty"`
}

// ListingsItemPutRequestRequirements The name of the requirements set for the provided data.
type ListingsItemPutRequestRequirements string

// ListingsItemSubmissionResponse Response containing the results of a submission to the Selling Partner API for Listings Items.
type ListingsItemSubmissionResponse struct {
	// Issues Listings item issues related to the listings item submission.
	Issues *[]Issue `json:"issues,omitempty"`

	// Sku A selling partner provided identifier for an Amazon listing.
	Sku string `json:"sku"`

	// Status The status of the listings item submission.
	Status ListingsItemSubmissionResponseStatus `json:"status"`

	// SubmissionId The unique identifier of the listings item submission.
	SubmissionId string `json:"submissionId"`
}

// ListingsItemSubmissionResponseStatus The status of the listings item submission.
type ListingsItemSubmissionResponseStatus string

// Money The currency type and the amount.
type Money struct {
	// Amount A decimal number with no loss of precision. Useful when precision loss is unnaceptable, as with currencies. Follows RFC7159 for number representation.
	Amount Decimal `json:"amount"`

	// CurrencyCode Three-digit currency code. In ISO 4217 format.
	CurrencyCode string `json:"currencyCode"`
}

// PatchOperation Individual JSON Patch operation for an HTTP PATCH request.
type PatchOperation struct {
	// Op Type of JSON Patch operation. Supported JSON Patch operations include add, replace, and delete. See <https://tools.ietf.org/html/rfc6902>.
	Op PatchOperationOp `json:"op"`

	// Path JSON Pointer path of the element to patch. See <https://tools.ietf.org/html/rfc6902>.
	Path string `json:"path"`

	// Value JSON value to add, replace, or delete.
	Value *[]map[string]interface{} `json:"value,omitempty"`
}

// PatchOperationOp Type of JSON Patch operation. Supported JSON Patch operations include add, replace, and delete. See <https://tools.ietf.org/html/rfc6902>.
type PatchOperationOp string

// Points The number of Amazon Points offered with the purchase of an item, and their monetary value. Note that the Points element is only returned in Japan (JP).
type Points struct {
	PointsNumber int `json:"pointsNumber"`
}

// DeleteListingsItemParams defines parameters for DeleteListingsItem.
type DeleteListingsItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IssueLocale A locale for localization of issues. When not provided, the default language code of the first marketplace is used. Examples: "en_US", "fr_CA", "fr_FR". Localized messages default to "en_US" when a localization is not available in the specified locale.
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`
}

// GetListingsItemParams defines parameters for GetListingsItem.
type GetListingsItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IssueLocale A locale for localization of issues. When not provided, the default language code of the first marketplace is used. Examples: "en_US", "fr_CA", "fr_FR". Localized messages default to "en_US" when a localization is not available in the specified locale.
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`

	// IncludedData A comma-delimited list of data sets to include in the response. Default: summaries.
	IncludedData *[]GetListingsItemParamsIncludedData `form:"includedData,omitempty" json:"includedData,omitempty"`
}

// GetListingsItemParamsIncludedData defines parameters for GetListingsItem.
type GetListingsItemParamsIncludedData string

// PatchListingsItemParams defines parameters for PatchListingsItem.
type PatchListingsItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IssueLocale A locale for localization of issues. When not provided, the default language code of the first marketplace is used. Examples: "en_US", "fr_CA", "fr_FR". Localized messages default to "en_US" when a localization is not available in the specified locale.
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`
}

// PutListingsItemParams defines parameters for PutListingsItem.
type PutListingsItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IssueLocale A locale for localization of issues. When not provided, the default language code of the first marketplace is used. Examples: "en_US", "fr_CA", "fr_FR". Localized messages default to "en_US" when a localization is not available in the specified locale.
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`
}

// PatchListingsItemJSONRequestBody defines body for PatchListingsItem for application/json ContentType.
type PatchListingsItemJSONRequestBody = ListingsItemPatchRequest

// PutListingsItemJSONRequestBody defines body for PutListingsItem for application/json ContentType.
type PutListingsItemJSONRequestBody = ListingsItemPutRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteListingsItem request
	DeleteListingsItem(ctx context.Context, sellerId string, sku string, params *DeleteListingsItemParams) (*http.Response, error)

	// GetListingsItem request
	GetListingsItem(ctx context.Context, sellerId string, sku string, params *GetListingsItemParams) (*http.Response, error)

	// PatchListingsItemWithBody request with any body
	PatchListingsItemWithBody(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*http.Response, error)

	PatchListingsItem(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*http.Response, error)

	// PutListingsItemWithBody request with any body
	PutListingsItemWithBody(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*http.Response, error)

	PutListingsItem(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*http.Response, error)
}

func (c *Client) DeleteListingsItem(ctx context.Context, sellerId string, sku string, params *DeleteListingsItemParams) (*http.Response, error) {
	req, err := NewDeleteListingsItemRequest(c.Server, sellerId, sku, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetListingsItem(ctx context.Context, sellerId string, sku string, params *GetListingsItemParams) (*http.Response, error) {
	req, err := NewGetListingsItemRequest(c.Server, sellerId, sku, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PatchListingsItemWithBody(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPatchListingsItemRequestWithBody(c.Server, sellerId, sku, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PatchListingsItem(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*http.Response, error) {
	req, err := NewPatchListingsItemRequest(c.Server, sellerId, sku, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PutListingsItemWithBody(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutListingsItemRequestWithBody(c.Server, sellerId, sku, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PutListingsItem(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*http.Response, error) {
	req, err := NewPutListingsItemRequest(c.Server, sellerId, sku, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewDeleteListingsItemRequest generates requests for DeleteListingsItem
func NewDeleteListingsItemRequest(server string, sellerId string, sku string, params *DeleteListingsItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListingsItemRequest generates requests for GetListingsItem
func NewGetListingsItemRequest(server string, sellerId string, sku string, params *GetListingsItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IncludedData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedData", runtime.ParamLocationQuery, *params.IncludedData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchListingsItemRequest calls the generic PatchListingsItem builder with application/json body
func NewPatchListingsItemRequest(server string, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchListingsItemRequestWithBody(server, sellerId, sku, params, "application/json", bodyReader)
}

// NewPatchListingsItemRequestWithBody generates requests for PatchListingsItem with any type of body
func NewPatchListingsItemRequestWithBody(server string, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutListingsItemRequest calls the generic PutListingsItem builder with application/json body
func NewPutListingsItemRequest(server string, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutListingsItemRequestWithBody(server, sellerId, sku, params, "application/json", bodyReader)
}

// NewPutListingsItemRequestWithBody generates requests for PutListingsItem with any type of body
func NewPutListingsItemRequestWithBody(server string, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteListingsItemWithResponse request
	DeleteListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *DeleteListingsItemParams) (*DeleteListingsItemResp, error)

	// GetListingsItemWithResponse request
	GetListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *GetListingsItemParams) (*GetListingsItemResp, error)

	// PatchListingsItemWithBodyWithResponse request with any body
	PatchListingsItemWithBodyWithResponse(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*PatchListingsItemResp, error)

	PatchListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*PatchListingsItemResp, error)

	// PutListingsItemWithBodyWithResponse request with any body
	PutListingsItemWithBodyWithResponse(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*PutListingsItemResp, error)

	PutListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*PutListingsItemResp, error)
}

type DeleteListingsItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListingsItemSubmissionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r DeleteListingsItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteListingsItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListingsItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Item
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetListingsItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListingsItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchListingsItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListingsItemSubmissionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r PatchListingsItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchListingsItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutListingsItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListingsItemSubmissionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r PutListingsItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutListingsItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteListingsItemWithResponse request returning *DeleteListingsItemResp
func (c *ClientWithResponses) DeleteListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *DeleteListingsItemParams) (*DeleteListingsItemResp, error) {
	rsp, err := c.DeleteListingsItem(ctx, sellerId, sku, params)
	if err != nil {
		return nil, err
	}
	return ParseDeleteListingsItemResp(rsp)
}

// GetListingsItemWithResponse request returning *GetListingsItemResp
func (c *ClientWithResponses) GetListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *GetListingsItemParams) (*GetListingsItemResp, error) {
	rsp, err := c.GetListingsItem(ctx, sellerId, sku, params)
	if err != nil {
		return nil, err
	}
	return ParseGetListingsItemResp(rsp)
}

// PatchListingsItemWithBodyWithResponse request with arbitrary body returning *PatchListingsItemResp
func (c *ClientWithResponses) PatchListingsItemWithBodyWithResponse(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*PatchListingsItemResp, error) {
	rsp, err := c.PatchListingsItemWithBody(ctx, sellerId, sku, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePatchListingsItemResp(rsp)
}

func (c *ClientWithResponses) PatchListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*PatchListingsItemResp, error) {
	rsp, err := c.PatchListingsItem(ctx, sellerId, sku, params, body)
	if err != nil {
		return nil, err
	}
	return ParsePatchListingsItemResp(rsp)
}

// PutListingsItemWithBodyWithResponse request with arbitrary body returning *PutListingsItemResp
func (c *ClientWithResponses) PutListingsItemWithBodyWithResponse(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*PutListingsItemResp, error) {
	rsp, err := c.PutListingsItemWithBody(ctx, sellerId, sku, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutListingsItemResp(rsp)
}

func (c *ClientWithResponses) PutListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*PutListingsItemResp, error) {
	rsp, err := c.PutListingsItem(ctx, sellerId, sku, params, body)
	if err != nil {
		return nil, err
	}
	return ParsePutListingsItemResp(rsp)
}

// ParseDeleteListingsItemResp parses an HTTP response from a DeleteListingsItemWithResponse call
func ParseDeleteListingsItemResp(rsp *http.Response) (*DeleteListingsItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteListingsItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListingsItemSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetListingsItemResp parses an HTTP response from a GetListingsItemWithResponse call
func ParseGetListingsItemResp(rsp *http.Response) (*GetListingsItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListingsItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePatchListingsItemResp parses an HTTP response from a PatchListingsItemWithResponse call
func ParsePatchListingsItemResp(rsp *http.Response) (*PatchListingsItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchListingsItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListingsItemSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePutListingsItemResp parses an HTTP response from a PutListingsItemWithResponse call
func ParsePutListingsItemResp(rsp *http.Response) (*PutListingsItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutListingsItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListingsItemSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
