// Package warehousingdistributionv20240509 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package warehousingdistributionv20240509

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for CarrierCodeType.
const (
	SCAC CarrierCodeType = "SCAC"
)

// Defines values for DimensionUnitOfMeasurement.
const (
	CENTIMETERS DimensionUnitOfMeasurement = "CENTIMETERS"
	INCHES      DimensionUnitOfMeasurement = "INCHES"
)

// Defines values for DistributionPackageType.
const (
	CASE   DistributionPackageType = "CASE"
	PALLET DistributionPackageType = "PALLET"
)

// Defines values for InboundShipmentStatus.
const (
	InboundShipmentStatusCANCELLED InboundShipmentStatus = "CANCELLED"
	InboundShipmentStatusCLOSED    InboundShipmentStatus = "CLOSED"
	InboundShipmentStatusCREATED   InboundShipmentStatus = "CREATED"
	InboundShipmentStatusDELIVERED InboundShipmentStatus = "DELIVERED"
	InboundShipmentStatusINTRANSIT InboundShipmentStatus = "IN_TRANSIT"
	InboundShipmentStatusRECEIVING InboundShipmentStatus = "RECEIVING"
	InboundShipmentStatusSHIPPED   InboundShipmentStatus = "SHIPPED"
)

// Defines values for InventoryUnitOfMeasurement.
const (
	CASES        InventoryUnitOfMeasurement = "CASES"
	PALLETS      InventoryUnitOfMeasurement = "PALLETS"
	PRODUCTUNITS InventoryUnitOfMeasurement = "PRODUCT_UNITS"
)

// Defines values for VolumeUnitOfMeasurement.
const (
	CBM  VolumeUnitOfMeasurement = "CBM"
	CC   VolumeUnitOfMeasurement = "CC"
	CUIN VolumeUnitOfMeasurement = "CU_IN"
)

// Defines values for WeightUnitOfMeasurement.
const (
	KILOGRAMS WeightUnitOfMeasurement = "KILOGRAMS"
	POUNDS    WeightUnitOfMeasurement = "POUNDS"
)

// Defines values for ListInboundShipmentsParamsSortBy.
const (
	CREATEDAT ListInboundShipmentsParamsSortBy = "CREATED_AT"
	UPDATEDAT ListInboundShipmentsParamsSortBy = "UPDATED_AT"
)

// Defines values for ListInboundShipmentsParamsSortOrder.
const (
	ListInboundShipmentsParamsSortOrderASCENDING  ListInboundShipmentsParamsSortOrder = "ASCENDING"
	ListInboundShipmentsParamsSortOrderDESCENDING ListInboundShipmentsParamsSortOrder = "DESCENDING"
)

// Defines values for ListInboundShipmentsParamsShipmentStatus.
const (
	ListInboundShipmentsParamsShipmentStatusCANCELLED ListInboundShipmentsParamsShipmentStatus = "CANCELLED"
	ListInboundShipmentsParamsShipmentStatusCLOSED    ListInboundShipmentsParamsShipmentStatus = "CLOSED"
	ListInboundShipmentsParamsShipmentStatusCREATED   ListInboundShipmentsParamsShipmentStatus = "CREATED"
	ListInboundShipmentsParamsShipmentStatusDELIVERED ListInboundShipmentsParamsShipmentStatus = "DELIVERED"
	ListInboundShipmentsParamsShipmentStatusINTRANSIT ListInboundShipmentsParamsShipmentStatus = "IN_TRANSIT"
	ListInboundShipmentsParamsShipmentStatusRECEIVING ListInboundShipmentsParamsShipmentStatus = "RECEIVING"
	ListInboundShipmentsParamsShipmentStatusSHIPPED   ListInboundShipmentsParamsShipmentStatus = "SHIPPED"
)

// Defines values for GetInboundShipmentParamsSkuQuantities.
const (
	GetInboundShipmentParamsSkuQuantitiesHIDE GetInboundShipmentParamsSkuQuantities = "HIDE"
	GetInboundShipmentParamsSkuQuantitiesSHOW GetInboundShipmentParamsSkuQuantities = "SHOW"
)

// Defines values for ListInventoryParamsSortOrder.
const (
	ListInventoryParamsSortOrderASCENDING  ListInventoryParamsSortOrder = "ASCENDING"
	ListInventoryParamsSortOrderDESCENDING ListInventoryParamsSortOrder = "DESCENDING"
)

// Defines values for ListInventoryParamsDetails.
const (
	ListInventoryParamsDetailsHIDE ListInventoryParamsDetails = "HIDE"
	ListInventoryParamsDetailsSHOW ListInventoryParamsDetails = "SHOW"
)

// Address Shipping address that represents the origin or destination location.
type Address struct {
	// AddressLine1 First line of the address text.
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Optional second line of the address text.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 Optional third line of the address text.
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// City Optional city where this address is located.
	City *string `json:"city,omitempty"`

	// CountryCode Two-digit, ISO 3166-1 alpha-2 formatted country code where this address is located.
	CountryCode string `json:"countryCode"`

	// County Optional county where this address is located.
	County *string `json:"county,omitempty"`

	// District Optional district where this address is located.
	District *string `json:"district,omitempty"`

	// Name Name of the person, business, or institution at this address.
	Name string `json:"name"`

	// PhoneNumber Optional E.164-formatted phone number for an available contact at this address.
	PhoneNumber *string `json:"phoneNumber,omitempty"`

	// PostalCode Optional postal code where this address is located.
	PostalCode *string `json:"postalCode,omitempty"`

	// StateOrRegion State or region where this address is located. Note that this is contextual to the specified country code.
	StateOrRegion string `json:"stateOrRegion"`
}

// CarrierCode Identifies the carrier that will deliver the shipment.
type CarrierCode struct {
	// CarrierCodeType Denotes the type for the carrier.
	CarrierCodeType *CarrierCodeType `json:"carrierCodeType,omitempty"`

	// CarrierCodeValue Value of the carrier code.
	CarrierCodeValue *string `json:"carrierCodeValue,omitempty"`
}

// CarrierCodeType Denotes the type for the carrier.
type CarrierCodeType string

// DimensionUnitOfMeasurement Unit of measurement for package dimensions.
type DimensionUnitOfMeasurement string

// DistributionPackage Represents an AWD distribution package.
type DistributionPackage struct {
	// Contents Represents the contents inside a package, which can be products or a nested package.
	Contents DistributionPackageContents `json:"contents"`

	// Measurements Package weight and dimension.
	Measurements MeasurementData `json:"measurements"`

	// Type Type of distribution packages.
	Type DistributionPackageType `json:"type"`
}

// DistributionPackageContents Represents the contents inside a package, which can be products or a nested package.
type DistributionPackageContents struct {
	// Packages This is required only when `DistributionPackageType=PALLET`.
	Packages *[]DistributionPackageQuantity `json:"packages,omitempty"`

	// Products This is required only when `DistributionPackageType=CASE`.
	Products *[]ProductQuantity `json:"products,omitempty"`
}

// DistributionPackageQuantity Represents a distribution package with its respective quantity.
type DistributionPackageQuantity struct {
	// Count Number of cases or pallets with the same package configuration.
	Count int32 `json:"count"`

	// DistributionPackage Represents an AWD distribution package.
	DistributionPackage DistributionPackage `json:"distributionPackage"`
}

// DistributionPackageType Type of distribution packages.
type DistributionPackageType string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList This exception is thrown when client inputs are invalid.
type ErrorList struct {
	// Errors A list of errors describing the failures.
	Errors []Error `json:"errors"`
}

// InboundShipment Represents an AWD inbound shipment.
type InboundShipment struct {
	// CarrierCode Identifies the carrier that will deliver the shipment.
	CarrierCode *CarrierCode `json:"carrierCode,omitempty"`

	// CreatedAt Timestamp when the shipment was created. The date is returned in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DestinationAddress Shipping address that represents the origin or destination location.
	DestinationAddress Address `json:"destinationAddress"`

	// ExternalReferenceId Client-provided reference ID that can correlate this shipment to client resources. For example, to map this shipment to an internal bookkeeping order record.
	ExternalReferenceId *string `json:"externalReferenceId,omitempty"`

	// OrderId The AWD inbound order ID that this inbound shipment belongs to.
	OrderId string `json:"orderId"`

	// OriginAddress Shipping address that represents the origin or destination location.
	OriginAddress Address `json:"originAddress"`

	// ReceivedQuantity Quantity received (at the receiving end) as part of this shipment.
	ReceivedQuantity *[]InventoryQuantity `json:"receivedQuantity,omitempty"`

	// ShipBy Timestamp when the shipment will be shipped.
	ShipBy *time.Time `json:"shipBy,omitempty"`

	// ShipmentContainerQuantities Packages that are part of this shipment.
	ShipmentContainerQuantities []DistributionPackageQuantity `json:"shipmentContainerQuantities"`

	// ShipmentId Unique shipment ID.
	ShipmentId string `json:"shipmentId"`

	// ShipmentSkuQuantities Quantity details at SKU level for the shipment. This attribute will only appear if the skuQuantities parameter in the request is set to SHOW.
	ShipmentSkuQuantities *[]SkuQuantity `json:"shipmentSkuQuantities,omitempty"`

	// ShipmentStatus Possible shipment statuses used by shipments.
	ShipmentStatus InboundShipmentStatus `json:"shipmentStatus"`

	// TrackingId Carrier-unique tracking ID for this shipment.
	TrackingId *string `json:"trackingId,omitempty"`

	// UpdatedAt Timestamp when the shipment was updated. The date is returned in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// WarehouseReferenceId An AWD-provided reference ID that you can use to interact with the warehouse. For example, a carrier appointment booking.
	WarehouseReferenceId *string `json:"warehouseReferenceId,omitempty"`
}

// InboundShipmentStatus Possible shipment statuses used by shipments.
type InboundShipmentStatus string

// InboundShipmentSummary Summary for an AWD inbound shipment containing the shipment ID, which can be used to retrieve the actual shipment.
type InboundShipmentSummary struct {
	// CreatedAt Timestamp when the shipment was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// ExternalReferenceId Optional client-provided reference ID that can be used to correlate this shipment with client resources. For example, to map this shipment to an internal bookkeeping order record.
	ExternalReferenceId *string `json:"externalReferenceId,omitempty"`

	// OrderId The AWD inbound order ID that this inbound shipment belongs to.
	OrderId string `json:"orderId"`

	// ShipmentId A unique shipment ID.
	ShipmentId string `json:"shipmentId"`

	// ShipmentStatus Possible shipment statuses used by shipments.
	ShipmentStatus InboundShipmentStatus `json:"shipmentStatus"`

	// UpdatedAt Timestamp when the shipment was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// InventoryDetails Additional inventory details. This object is only displayed if the details parameter in the request is set to `SHOW`.
type InventoryDetails struct {
	// AvailableDistributableQuantity Quantity that is available for downstream channel replenishment.
	AvailableDistributableQuantity *int64 `json:"availableDistributableQuantity,omitempty"`

	// ReservedDistributableQuantity Quantity that is reserved for a downstream channel replenishment order that is being prepared for shipment.
	ReservedDistributableQuantity *int64 `json:"reservedDistributableQuantity,omitempty"`
}

// InventoryListing AWD inventory payload.
type InventoryListing struct {
	// Inventory List of inventory summaries.
	Inventory []InventorySummary `json:"inventory"`

	// NextToken Token to retrieve the next set of paginated results.
	NextToken *string `json:"nextToken,omitempty"`
}

// InventoryQuantity Quantity of inventory with an associated measurement unit context.
type InventoryQuantity struct {
	// Quantity Quantity of the respective inventory.
	Quantity float32 `json:"quantity"`

	// UnitOfMeasurement Unit of measurement for the inventory.
	UnitOfMeasurement InventoryUnitOfMeasurement `json:"unitOfMeasurement"`
}

// InventorySummary Summary of inventory per SKU.
type InventorySummary struct {
	// InventoryDetails Additional inventory details. This object is only displayed if the details parameter in the request is set to `SHOW`.
	InventoryDetails *InventoryDetails `json:"inventoryDetails,omitempty"`

	// Sku The seller or merchant SKU.
	Sku string `json:"sku"`

	// TotalInboundQuantity Total quantity that is in-transit from the seller and has not yet been received at an AWD Distribution Center
	TotalInboundQuantity *int64 `json:"totalInboundQuantity,omitempty"`

	// TotalOnhandQuantity Total quantity that is present in AWD distribution centers.
	TotalOnhandQuantity *int64 `json:"totalOnhandQuantity,omitempty"`
}

// InventoryUnitOfMeasurement Unit of measurement for the inventory.
type InventoryUnitOfMeasurement string

// MeasurementData Package weight and dimension.
type MeasurementData struct {
	// Dimensions Dimensions of the package.
	Dimensions *PackageDimensions `json:"dimensions,omitempty"`

	// Volume Represents the volume of the package with a unit of measurement.
	Volume *PackageVolume `json:"volume,omitempty"`

	// Weight Represents the weight of the package with a unit of measurement.
	Weight PackageWeight `json:"weight"`
}

// PackageDimensions Dimensions of the package.
type PackageDimensions struct {
	// Height Height of the package.
	Height float64 `json:"height"`

	// Length Length of the package.
	Length float64 `json:"length"`

	// UnitOfMeasurement Unit of measurement for package dimensions.
	UnitOfMeasurement DimensionUnitOfMeasurement `json:"unitOfMeasurement"`

	// Width Width of the package.
	Width float64 `json:"width"`
}

// PackageVolume Represents the volume of the package with a unit of measurement.
type PackageVolume struct {
	// UnitOfMeasurement Unit of measurement for the package volume.
	UnitOfMeasurement VolumeUnitOfMeasurement `json:"unitOfMeasurement"`

	// Volume The package volume value.
	Volume float64 `json:"volume"`
}

// PackageWeight Represents the weight of the package with a unit of measurement.
type PackageWeight struct {
	// UnitOfMeasurement Unit of measurement for the package weight.
	UnitOfMeasurement WeightUnitOfMeasurement `json:"unitOfMeasurement"`

	// Weight The package weight value.
	Weight float64 `json:"weight"`
}

// ProductAttribute Product instance attribute that is not described at the SKU level in the catalog.
type ProductAttribute struct {
	// Name Product attribute name.
	Name *string `json:"name,omitempty"`

	// Value Product attribute value.
	Value *string `json:"value,omitempty"`
}

// ProductQuantity Represents a product with the SKU details and the corresponding quantity.
type ProductQuantity struct {
	// Attributes Attributes for this instance of the product. For example, already-prepped, or other attributes that distinguish the product beyond the SKU.
	Attributes *[]ProductAttribute `json:"attributes,omitempty"`

	// Quantity Product quantity.
	Quantity int32 `json:"quantity"`

	// Sku The seller or merchant SKU.
	Sku string `json:"sku"`
}

// ShipmentListing A list of inbound shipment summaries filtered by the attributes specified in the request.
type ShipmentListing struct {
	// NextToken Token to retrieve the next set of paginated results.
	NextToken *string `json:"nextToken,omitempty"`

	// Shipments List of inbound shipment summaries.
	Shipments *[]InboundShipmentSummary `json:"shipments,omitempty"`
}

// SkuQuantity Quantity details for a SKU as part of a shipment
type SkuQuantity struct {
	// ExpectedQuantity Quantity of inventory with an associated measurement unit context.
	ExpectedQuantity InventoryQuantity `json:"expectedQuantity"`

	// ReceivedQuantity Quantity of inventory with an associated measurement unit context.
	ReceivedQuantity *InventoryQuantity `json:"receivedQuantity,omitempty"`

	// Sku The merchant stock keeping unit
	Sku string `json:"sku"`
}

// VolumeUnitOfMeasurement Unit of measurement for the package volume.
type VolumeUnitOfMeasurement string

// WeightUnitOfMeasurement Unit of measurement for the package weight.
type WeightUnitOfMeasurement string

// ListInboundShipmentsParams defines parameters for ListInboundShipments.
type ListInboundShipmentsParams struct {
	// SortBy Field to sort results by. By default, the response will be sorted by UPDATED_AT.
	SortBy *ListInboundShipmentsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort the response in ASCENDING or DESCENDING order. By default, the response will be sorted in DESCENDING order.
	SortOrder *ListInboundShipmentsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// ShipmentStatus Filter by inbound shipment status.
	ShipmentStatus *ListInboundShipmentsParamsShipmentStatus `form:"shipmentStatus,omitempty" json:"shipmentStatus,omitempty"`

	// UpdatedAfter List the inbound shipments that were updated after a certain time (inclusive). The date must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	UpdatedAfter *time.Time `form:"updatedAfter,omitempty" json:"updatedAfter,omitempty"`

	// UpdatedBefore List the inbound shipments that were updated before a certain time (inclusive). The date must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	UpdatedBefore *time.Time `form:"updatedBefore,omitempty" json:"updatedBefore,omitempty"`

	// MaxResults Maximum number of results to return.
	MaxResults *int32 `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// NextToken Token to retrieve the next set of paginated results.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// ListInboundShipmentsParamsSortBy defines parameters for ListInboundShipments.
type ListInboundShipmentsParamsSortBy string

// ListInboundShipmentsParamsSortOrder defines parameters for ListInboundShipments.
type ListInboundShipmentsParamsSortOrder string

// ListInboundShipmentsParamsShipmentStatus defines parameters for ListInboundShipments.
type ListInboundShipmentsParamsShipmentStatus string

// GetInboundShipmentParams defines parameters for GetInboundShipment.
type GetInboundShipmentParams struct {
	// SkuQuantities If equal to `SHOW`, the response includes the shipment SKU quantity details.
	//
	// Defaults to `HIDE`, in which case the response does not contain SKU quantities
	SkuQuantities *GetInboundShipmentParamsSkuQuantities `form:"skuQuantities,omitempty" json:"skuQuantities,omitempty"`
}

// GetInboundShipmentParamsSkuQuantities defines parameters for GetInboundShipment.
type GetInboundShipmentParamsSkuQuantities string

// ListInventoryParams defines parameters for ListInventory.
type ListInventoryParams struct {
	// Sku Filter by seller or merchant SKU for the item.
	Sku *string `form:"sku,omitempty" json:"sku,omitempty"`

	// SortOrder Sort the response in `ASCENDING` or `DESCENDING` order.
	SortOrder *ListInventoryParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// Details Set to `SHOW` to return summaries with additional inventory details. Defaults to `HIDE,` which returns only inventory summary totals.
	Details *ListInventoryParamsDetails `form:"details,omitempty" json:"details,omitempty"`

	// NextToken Token to retrieve the next set of paginated results.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// MaxResults Maximum number of results to return.
	MaxResults *int32 `form:"maxResults,omitempty" json:"maxResults,omitempty"`
}

// ListInventoryParamsSortOrder defines parameters for ListInventory.
type ListInventoryParamsSortOrder string

// ListInventoryParamsDetails defines parameters for ListInventory.
type ListInventoryParamsDetails string

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListInboundShipments request
	ListInboundShipments(ctx context.Context, params *ListInboundShipmentsParams) (*http.Response, error)

	// GetInboundShipment request
	GetInboundShipment(ctx context.Context, shipmentId string, params *GetInboundShipmentParams) (*http.Response, error)

	// ListInventory request
	ListInventory(ctx context.Context, params *ListInventoryParams) (*http.Response, error)
}

func (c *Client) ListInboundShipments(ctx context.Context, params *ListInboundShipmentsParams) (*http.Response, error) {
	req, err := NewListInboundShipmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInboundShipment(ctx context.Context, shipmentId string, params *GetInboundShipmentParams) (*http.Response, error) {
	req, err := NewGetInboundShipmentRequest(c.Server, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListInventory(ctx context.Context, params *ListInventoryParams) (*http.Response, error) {
	req, err := NewListInventoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewListInboundShipmentsRequest generates requests for ListInboundShipments
func NewListInboundShipmentsRequest(server string, params *ListInboundShipmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/awd/2024-05-09/inboundShipments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ShipmentStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipmentStatus", runtime.ParamLocationQuery, *params.ShipmentStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.UpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedAfter", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.UpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedBefore", runtime.ParamLocationQuery, *params.UpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInboundShipmentRequest generates requests for GetInboundShipment
func NewGetInboundShipmentRequest(server string, shipmentId string, params *GetInboundShipmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/awd/2024-05-09/inboundShipments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkuQuantities != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skuQuantities", runtime.ParamLocationQuery, *params.SkuQuantities); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInventoryRequest generates requests for ListInventory
func NewListInventoryRequest(server string, params *ListInventoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/awd/2024-05-09/inventory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sku != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sku", runtime.ParamLocationQuery, *params.Sku); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Details != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "details", runtime.ParamLocationQuery, *params.Details); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListInboundShipmentsWithResponse request
	ListInboundShipmentsWithResponse(ctx context.Context, params *ListInboundShipmentsParams) (*ListInboundShipmentsResp, error)

	// GetInboundShipmentWithResponse request
	GetInboundShipmentWithResponse(ctx context.Context, shipmentId string, params *GetInboundShipmentParams) (*GetInboundShipmentResp, error)

	// ListInventoryWithResponse request
	ListInventoryWithResponse(ctx context.Context, params *ListInventoryParams) (*ListInventoryResp, error)
}

type ListInboundShipmentsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShipmentListing
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListInboundShipmentsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboundShipmentsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInboundShipmentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InboundShipment
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetInboundShipmentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInboundShipmentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInventoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InventoryListing
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListInventoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInventoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListInboundShipmentsWithResponse request returning *ListInboundShipmentsResp
func (c *ClientWithResponses) ListInboundShipmentsWithResponse(ctx context.Context, params *ListInboundShipmentsParams) (*ListInboundShipmentsResp, error) {
	rsp, err := c.ListInboundShipments(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListInboundShipmentsResp(rsp)
}

// GetInboundShipmentWithResponse request returning *GetInboundShipmentResp
func (c *ClientWithResponses) GetInboundShipmentWithResponse(ctx context.Context, shipmentId string, params *GetInboundShipmentParams) (*GetInboundShipmentResp, error) {
	rsp, err := c.GetInboundShipment(ctx, shipmentId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetInboundShipmentResp(rsp)
}

// ListInventoryWithResponse request returning *ListInventoryResp
func (c *ClientWithResponses) ListInventoryWithResponse(ctx context.Context, params *ListInventoryParams) (*ListInventoryResp, error) {
	rsp, err := c.ListInventory(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListInventoryResp(rsp)
}

// ParseListInboundShipmentsResp parses an HTTP response from a ListInboundShipmentsWithResponse call
func ParseListInboundShipmentsResp(rsp *http.Response) (*ListInboundShipmentsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboundShipmentsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShipmentListing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetInboundShipmentResp parses an HTTP response from a GetInboundShipmentWithResponse call
func ParseGetInboundShipmentResp(rsp *http.Response) (*GetInboundShipmentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInboundShipmentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InboundShipment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListInventoryResp parses an HTTP response from a ListInventoryWithResponse call
func ParseListInventoryResp(rsp *http.Response) (*ListInventoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInventoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InventoryListing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
