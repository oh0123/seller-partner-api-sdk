// Package productfeesv0 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package productfeesv0

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/bytedance/sonic"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ConditionType.
const (
	ConditionTypeClub        ConditionType = "Club"
	ConditionTypeCollectible ConditionType = "Collectible"
	ConditionTypeNew         ConditionType = "New"
	ConditionTypeRefurbished ConditionType = "Refurbished"
	ConditionTypeUsed        ConditionType = "Used"
)

// Defines values for CustomerType.
const (
	CustomerTypeBusiness CustomerType = "Business"
	CustomerTypeConsumer CustomerType = "Consumer"
)

// Defines values for DetailedShippingTimeTypeAvailabilityType.
const (
	FUTUREWITHDATE    DetailedShippingTimeTypeAvailabilityType = "FUTURE_WITH_DATE"
	FUTUREWITHOUTDATE DetailedShippingTimeTypeAvailabilityType = "FUTURE_WITHOUT_DATE"
	NOW               DetailedShippingTimeTypeAvailabilityType = "NOW"
)

// Defines values for FulfillmentChannelType.
const (
	Amazon   FulfillmentChannelType = "Amazon"
	Merchant FulfillmentChannelType = "Merchant"
)

// Defines values for HttpMethod.
const (
	DELETE HttpMethod = "DELETE"
	GET    HttpMethod = "GET"
	PATCH  HttpMethod = "PATCH"
	POST   HttpMethod = "POST"
	PUT    HttpMethod = "PUT"
)

// Defines values for ItemCondition.
const (
	ItemConditionClub        ItemCondition = "Club"
	ItemConditionCollectible ItemCondition = "Collectible"
	ItemConditionNew         ItemCondition = "New"
	ItemConditionRefurbished ItemCondition = "Refurbished"
	ItemConditionUsed        ItemCondition = "Used"
)

// Defines values for OfferCustomerType.
const (
	OfferCustomerTypeB2B OfferCustomerType = "B2B"
	OfferCustomerTypeB2C OfferCustomerType = "B2C"
)

// Defines values for QuantityDiscountType.
const (
	QUANTITYDISCOUNT QuantityDiscountType = "QUANTITY_DISCOUNT"
)

// Defines values for GetCompetitivePricingParamsItemType.
const (
	GetCompetitivePricingParamsItemTypeAsin GetCompetitivePricingParamsItemType = "Asin"
	GetCompetitivePricingParamsItemTypeSku  GetCompetitivePricingParamsItemType = "Sku"
)

// Defines values for GetCompetitivePricingParamsCustomerType.
const (
	GetCompetitivePricingParamsCustomerTypeBusiness GetCompetitivePricingParamsCustomerType = "Business"
	GetCompetitivePricingParamsCustomerTypeConsumer GetCompetitivePricingParamsCustomerType = "Consumer"
)

// Defines values for GetItemOffersParamsItemCondition.
const (
	GetItemOffersParamsItemConditionClub        GetItemOffersParamsItemCondition = "Club"
	GetItemOffersParamsItemConditionCollectible GetItemOffersParamsItemCondition = "Collectible"
	GetItemOffersParamsItemConditionNew         GetItemOffersParamsItemCondition = "New"
	GetItemOffersParamsItemConditionRefurbished GetItemOffersParamsItemCondition = "Refurbished"
	GetItemOffersParamsItemConditionUsed        GetItemOffersParamsItemCondition = "Used"
)

// Defines values for GetItemOffersParamsCustomerType.
const (
	GetItemOffersParamsCustomerTypeBusiness GetItemOffersParamsCustomerType = "Business"
	GetItemOffersParamsCustomerTypeConsumer GetItemOffersParamsCustomerType = "Consumer"
)

// Defines values for GetListingOffersParamsItemCondition.
const (
	GetListingOffersParamsItemConditionClub        GetListingOffersParamsItemCondition = "Club"
	GetListingOffersParamsItemConditionCollectible GetListingOffersParamsItemCondition = "Collectible"
	GetListingOffersParamsItemConditionNew         GetListingOffersParamsItemCondition = "New"
	GetListingOffersParamsItemConditionRefurbished GetListingOffersParamsItemCondition = "Refurbished"
	GetListingOffersParamsItemConditionUsed        GetListingOffersParamsItemCondition = "Used"
)

// Defines values for GetListingOffersParamsCustomerType.
const (
	GetListingOffersParamsCustomerTypeBusiness GetListingOffersParamsCustomerType = "Business"
	GetListingOffersParamsCustomerTypeConsumer GetListingOffersParamsCustomerType = "Consumer"
)

// Defines values for GetPricingParamsItemType.
const (
	GetPricingParamsItemTypeAsin GetPricingParamsItemType = "Asin"
	GetPricingParamsItemTypeSku  GetPricingParamsItemType = "Sku"
)

// Defines values for GetPricingParamsItemCondition.
const (
	Club        GetPricingParamsItemCondition = "Club"
	Collectible GetPricingParamsItemCondition = "Collectible"
	New         GetPricingParamsItemCondition = "New"
	Refurbished GetPricingParamsItemCondition = "Refurbished"
	Used        GetPricingParamsItemCondition = "Used"
)

// Defines values for GetPricingParamsOfferType.
const (
	GetPricingParamsOfferTypeB2B GetPricingParamsOfferType = "B2B"
	GetPricingParamsOfferTypeB2C GetPricingParamsOfferType = "B2C"
)

// ASINIdentifier defines model for ASINIdentifier.
type ASINIdentifier struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN string `json:"ASIN"`

	// MarketplaceId A marketplace identifier.
	MarketplaceId string `json:"MarketplaceId"`
}

// AttributeSetList A list of product attributes if they are applicable to the product that is returned.
type AttributeSetList = []map[string]interface{}

// BatchOffersRequestParams defines model for BatchOffersRequestParams.
type BatchOffersRequestParams struct {
	// CustomerType Indicates whether to request Consumer or Business offers. Default is Consumer.
	CustomerType *CustomerType `json:"CustomerType,omitempty"`

	// ItemCondition Filters the offer listings to be considered based on item condition. Possible values: New, Used, Collectible, Refurbished, Club.
	ItemCondition ItemCondition `json:"ItemCondition"`

	// MarketplaceId A marketplace identifier. Specifies the marketplace for which prices are returned.
	MarketplaceId MarketplaceId `json:"MarketplaceId"`
}

// BatchOffersResponse defines model for BatchOffersResponse.
type BatchOffersResponse struct {
	// Body The response schema for the `getListingOffers` and `getItemOffers` operations.
	Body GetOffersResponse `json:"body"`

	// Headers A mapping of additional HTTP headers to send/receive for the individual batch request.
	Headers *HttpResponseHeaders `json:"headers,omitempty"`

	// Status The HTTP status line associated with the response.  For more information, consult [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html).
	Status *GetOffersHttpStatusLine `json:"status,omitempty"`
}

// BatchRequest Common properties of batch requests against individual APIs.
type BatchRequest struct {
	// Headers A mapping of additional HTTP headers to send/receive for the individual batch request.
	Headers *HttpRequestHeaders `json:"headers,omitempty"`

	// Method The HTTP method associated with the individual APIs being called as part of the batch request.
	Method HttpMethod `json:"method"`

	// Uri The resource path of the operation you are calling in batch without any query parameters.
	//
	// If you are calling `getItemOffersBatch`, supply the path of `getItemOffers`.
	//
	// **Example:** `/products/pricing/v0/items/B000P6Q7MY/offers`
	//
	// If you are calling `getListingOffersBatch`, supply the path of `getListingOffers`.
	//
	// **Example:** `/products/pricing/v0/listings/B000P6Q7MY/offers`
	Uri string `json:"uri"`
}

// BuyBoxEligibleOffers defines model for BuyBoxEligibleOffers.
type BuyBoxEligibleOffers = []OfferCountType

// BuyBoxPriceType defines model for BuyBoxPriceType.
type BuyBoxPriceType struct {
	LandedPrice  MoneyType `json:"LandedPrice"`
	ListingPrice MoneyType `json:"ListingPrice"`
	Points       *Points   `json:"Points,omitempty"`
	Shipping     MoneyType `json:"Shipping"`

	// Condition Indicates the condition of the item. For example: New, Used, Collectible, Refurbished, or Club.
	Condition            string                `json:"condition"`
	OfferType            *OfferCustomerType    `json:"offerType,omitempty"`
	QuantityDiscountType *QuantityDiscountType `json:"quantityDiscountType,omitempty"`

	// QuantityTier Indicates at what quantity this price becomes active.
	QuantityTier *int32 `json:"quantityTier,omitempty"`

	// SellerId The seller identifier for the offer.
	SellerId *string `json:"sellerId,omitempty"`
}

// BuyBoxPrices defines model for BuyBoxPrices.
type BuyBoxPrices = []BuyBoxPriceType

// CompetitivePriceList A list of competitive pricing information.
type CompetitivePriceList = []CompetitivePriceType

// CompetitivePriceType defines model for CompetitivePriceType.
type CompetitivePriceType struct {
	// CompetitivePriceId The pricing model for each price that is returned.
	//
	// Possible values:
	//
	// * 1 - New Buy Box Price.
	// * 2 - Used Buy Box Price.
	CompetitivePriceId string    `json:"CompetitivePriceId"`
	Price              PriceType `json:"Price"`

	// BelongsToRequester  Indicates whether or not the pricing information is for an offer listing that belongs to the requester. The requester is the seller associated with the SellerId that was submitted with the request. Possible values are: true and false.
	BelongsToRequester *bool `json:"belongsToRequester,omitempty"`

	// Condition Indicates the condition of the item whose pricing information is returned. Possible values are: New, Used, Collectible, Refurbished, or Club.
	Condition            *string               `json:"condition,omitempty"`
	OfferType            *OfferCustomerType    `json:"offerType,omitempty"`
	QuantityDiscountType *QuantityDiscountType `json:"quantityDiscountType,omitempty"`

	// QuantityTier Indicates at what quantity this price becomes active.
	QuantityTier *int32 `json:"quantityTier,omitempty"`

	// SellerId The seller identifier for the offer.
	SellerId *string `json:"sellerId,omitempty"`

	// Subcondition Indicates the subcondition of the item whose pricing information is returned. Possible values are: New, Mint, Very Good, Good, Acceptable, Poor, Club, OEM, Warranty, Refurbished Warranty, Refurbished, Open Box, or Other.
	Subcondition *string `json:"subcondition,omitempty"`
}

// CompetitivePricingType Competitive pricing information for the item.
type CompetitivePricingType struct {
	// CompetitivePrices A list of competitive pricing information.
	CompetitivePrices CompetitivePriceList `json:"CompetitivePrices"`

	// NumberOfOfferListings The number of active offer listings for the item that was submitted. The listing count is returned by condition, one for each listing condition value that is returned.
	NumberOfOfferListings NumberOfOfferListingsList `json:"NumberOfOfferListings"`
	TradeInValue          *MoneyType                `json:"TradeInValue,omitempty"`
}

// ConditionType Indicates the condition of the item. Possible values: New, Used, Collectible, Refurbished, Club.
type ConditionType string

// CustomerType Indicates whether to request Consumer or Business offers. Default is Consumer.
type CustomerType string

// DetailedShippingTimeType The time range in which an item will likely be shipped once an order has been placed.
type DetailedShippingTimeType struct {
	// AvailabilityType Indicates whether the item is available for shipping now, or on a known or an unknown date in the future. If known, the availableDate property indicates the date that the item will be available for shipping. Possible values: NOW, FUTURE_WITHOUT_DATE, FUTURE_WITH_DATE.
	AvailabilityType *DetailedShippingTimeTypeAvailabilityType `json:"availabilityType,omitempty"`

	// AvailableDate The date when the item will be available for shipping. Only displayed for items that are not currently available for shipping.
	AvailableDate *string `json:"availableDate,omitempty"`

	// MaximumHours The maximum time, in hours, that the item will likely be shipped after the order has been placed.
	MaximumHours *int64 `json:"maximumHours,omitempty"`

	// MinimumHours The minimum time, in hours, that the item will likely be shipped after the order has been placed.
	MinimumHours *int64 `json:"minimumHours,omitempty"`
}

// DetailedShippingTimeTypeAvailabilityType Indicates whether the item is available for shipping now, or on a known or an unknown date in the future. If known, the availableDate property indicates the date that the item will be available for shipping. Possible values: NOW, FUTURE_WITHOUT_DATE, FUTURE_WITH_DATE.
type DetailedShippingTimeTypeAvailabilityType string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional information that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition in a human-readable form.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// Errors A list of error responses returned when a request is unsuccessful.
type Errors struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors ErrorList `json:"errors"`
}

// FulfillmentChannelType Indicates whether the item is fulfilled by Amazon or by the seller (merchant).
type FulfillmentChannelType string

// GetItemOffersBatchRequest The request associated with the `getItemOffersBatch` API call.
type GetItemOffersBatchRequest struct {
	// Requests A list of `getListingOffers` batched requests to run.
	Requests *ItemOffersRequestList `json:"requests,omitempty"`
}

// GetItemOffersBatchResponse The response associated with the `getItemOffersBatch` API call.
type GetItemOffersBatchResponse struct {
	// Responses A list of `getItemOffers` batched responses.
	Responses *ItemOffersResponseList `json:"responses,omitempty"`
}

// GetListingOffersBatchRequest The request associated with the `getListingOffersBatch` API call.
type GetListingOffersBatchRequest struct {
	// Requests A list of `getListingOffers` batched requests to run.
	Requests *ListingOffersRequestList `json:"requests,omitempty"`
}

// GetListingOffersBatchResponse The response associated with the `getListingOffersBatch` API call.
type GetListingOffersBatchResponse struct {
	// Responses A list of `getListingOffers` batched responses.
	Responses *ListingOffersResponseList `json:"responses,omitempty"`
}

// GetOffersHttpStatusLine The HTTP status line associated with the response.  For more information, consult [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html).
type GetOffersHttpStatusLine struct {
	// ReasonPhrase The HTTP response Reason-Phase.
	ReasonPhrase *string `json:"reasonPhrase,omitempty"`

	// StatusCode The HTTP response Status Code.
	StatusCode *int `json:"statusCode,omitempty"`
}

// GetOffersResponse The response schema for the `getListingOffers` and `getItemOffers` operations.
type GetOffersResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList       `json:"errors,omitempty"`
	Payload *GetOffersResult `json:"payload,omitempty"`
}

// GetOffersResult defines model for GetOffersResult.
type GetOffersResult struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN *string `json:"ASIN,omitempty"`

	// Identifier Information that identifies an item.
	Identifier ItemIdentifier `json:"Identifier"`

	// ItemCondition Indicates the condition of the item. Possible values: New, Used, Collectible, Refurbished, Club.
	ItemCondition ConditionType `json:"ItemCondition"`

	// MarketplaceID A marketplace identifier.
	MarketplaceID string          `json:"MarketplaceID"`
	Offers        OfferDetailList `json:"Offers"`

	// SKU The stock keeping unit (SKU) of the item.
	SKU *string `json:"SKU,omitempty"`

	// Summary Contains price information about the product, including the LowestPrices and BuyBoxPrices, the ListPrice, the SuggestedLowerPricePlusShipping, and NumberOfOffers and NumberOfBuyBoxEligibleOffers.
	Summary Summary `json:"Summary"`

	// Status The status of the operation.
	Status string `json:"status"`
}

// GetPricingResponse The response schema for the `getPricing` and `getCompetitivePricing` operations.
type GetPricingResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList `json:"errors,omitempty"`
	Payload *PriceList `json:"payload,omitempty"`
}

// HttpMethod The HTTP method associated with the individual APIs being called as part of the batch request.
type HttpMethod string

// HttpRequestHeaders A mapping of additional HTTP headers to send/receive for the individual batch request.
type HttpRequestHeaders map[string]string

// HttpResponseHeaders A mapping of additional HTTP headers to send/receive for the individual batch request.
type HttpResponseHeaders struct {
	// Date The timestamp that the API request was received.  For more information, consult [RFC 2616 Section 14](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html).
	Date *string `json:"Date,omitempty"`

	// XAmznRequestId Unique request reference ID.
	XAmznRequestId       *string           `json:"x-amzn-RequestId,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// IdentifierType Specifies the identifiers used to uniquely identify an item.
type IdentifierType struct {
	MarketplaceASIN ASINIdentifier       `json:"MarketplaceASIN"`
	SKUIdentifier   *SellerSKUIdentifier `json:"SKUIdentifier,omitempty"`
}

// ItemCondition Filters the offer listings to be considered based on item condition. Possible values: New, Used, Collectible, Refurbished, Club.
type ItemCondition string

// ItemIdentifier Information that identifies an item.
type ItemIdentifier struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN *string `json:"ASIN,omitempty"`

	// ItemCondition Indicates the condition of the item. Possible values: New, Used, Collectible, Refurbished, Club.
	ItemCondition ConditionType `json:"ItemCondition"`

	// MarketplaceId A marketplace identifier. Specifies the marketplace from which prices are returned.
	MarketplaceId string `json:"MarketplaceId"`

	// SellerSKU The seller stock keeping unit (SKU) of the item.
	SellerSKU *string `json:"SellerSKU,omitempty"`
}

// ItemOffersRequest defines model for ItemOffersRequest.
type ItemOffersRequest struct {
	// CustomerType Indicates whether to request Consumer or Business offers. Default is Consumer.
	CustomerType *CustomerType `json:"CustomerType,omitempty"`

	// ItemCondition Filters the offer listings to be considered based on item condition. Possible values: New, Used, Collectible, Refurbished, Club.
	ItemCondition ItemCondition `json:"ItemCondition"`

	// MarketplaceId A marketplace identifier. Specifies the marketplace for which prices are returned.
	MarketplaceId MarketplaceId `json:"MarketplaceId"`

	// Headers A mapping of additional HTTP headers to send/receive for the individual batch request.
	Headers *HttpRequestHeaders `json:"headers,omitempty"`

	// Method The HTTP method associated with the individual APIs being called as part of the batch request.
	Method HttpMethod `json:"method"`

	// Uri The resource path of the operation you are calling in batch without any query parameters.
	//
	// If you are calling `getItemOffersBatch`, supply the path of `getItemOffers`.
	//
	// **Example:** `/products/pricing/v0/items/B000P6Q7MY/offers`
	//
	// If you are calling `getListingOffersBatch`, supply the path of `getListingOffers`.
	//
	// **Example:** `/products/pricing/v0/listings/B000P6Q7MY/offers`
	Uri string `json:"uri"`
}

// ItemOffersRequestList A list of `getListingOffers` batched requests to run.
type ItemOffersRequestList = []ItemOffersRequest

// ItemOffersRequestParams defines model for ItemOffersRequestParams.
type ItemOffersRequestParams struct {
	// Asin The Amazon Standard Identification Number (ASIN) of the item. This is the same Asin passed as a request parameter.
	Asin *string `json:"Asin,omitempty"`

	// CustomerType Indicates whether to request Consumer or Business offers. Default is Consumer.
	CustomerType *CustomerType `json:"CustomerType,omitempty"`

	// ItemCondition Filters the offer listings to be considered based on item condition. Possible values: New, Used, Collectible, Refurbished, Club.
	ItemCondition ItemCondition `json:"ItemCondition"`

	// MarketplaceId A marketplace identifier. Specifies the marketplace for which prices are returned.
	MarketplaceId MarketplaceId `json:"MarketplaceId"`
}

// ItemOffersResponse defines model for ItemOffersResponse.
type ItemOffersResponse struct {
	// Body The response schema for the `getListingOffers` and `getItemOffers` operations.
	Body GetOffersResponse `json:"body"`

	// Headers A mapping of additional HTTP headers to send/receive for the individual batch request.
	Headers *HttpResponseHeaders    `json:"headers,omitempty"`
	Request ItemOffersRequestParams `json:"request"`

	// Status The HTTP status line associated with the response.  For more information, consult [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html).
	Status *GetOffersHttpStatusLine `json:"status,omitempty"`
}

// ItemOffersResponseList A list of `getItemOffers` batched responses.
type ItemOffersResponseList = []ItemOffersResponse

// ListingOffersRequest defines model for ListingOffersRequest.
type ListingOffersRequest struct {
	// CustomerType Indicates whether to request Consumer or Business offers. Default is Consumer.
	CustomerType *CustomerType `json:"CustomerType,omitempty"`

	// ItemCondition Filters the offer listings to be considered based on item condition. Possible values: New, Used, Collectible, Refurbished, Club.
	ItemCondition ItemCondition `json:"ItemCondition"`

	// MarketplaceId A marketplace identifier. Specifies the marketplace for which prices are returned.
	MarketplaceId MarketplaceId `json:"MarketplaceId"`

	// Headers A mapping of additional HTTP headers to send/receive for the individual batch request.
	Headers *HttpRequestHeaders `json:"headers,omitempty"`

	// Method The HTTP method associated with the individual APIs being called as part of the batch request.
	Method HttpMethod `json:"method"`

	// Uri The resource path of the operation you are calling in batch without any query parameters.
	//
	// If you are calling `getItemOffersBatch`, supply the path of `getItemOffers`.
	//
	// **Example:** `/products/pricing/v0/items/B000P6Q7MY/offers`
	//
	// If you are calling `getListingOffersBatch`, supply the path of `getListingOffers`.
	//
	// **Example:** `/products/pricing/v0/listings/B000P6Q7MY/offers`
	Uri string `json:"uri"`
}

// ListingOffersRequestList A list of `getListingOffers` batched requests to run.
type ListingOffersRequestList = []ListingOffersRequest

// ListingOffersRequestParams defines model for ListingOffersRequestParams.
type ListingOffersRequestParams struct {
	// CustomerType Indicates whether to request Consumer or Business offers. Default is Consumer.
	CustomerType *CustomerType `json:"CustomerType,omitempty"`

	// ItemCondition Filters the offer listings to be considered based on item condition. Possible values: New, Used, Collectible, Refurbished, Club.
	ItemCondition ItemCondition `json:"ItemCondition"`

	// MarketplaceId A marketplace identifier. Specifies the marketplace for which prices are returned.
	MarketplaceId MarketplaceId `json:"MarketplaceId"`

	// SellerSKU The seller stock keeping unit (SKU) of the item. This is the same SKU passed as a path parameter.
	SellerSKU string `json:"SellerSKU"`
}

// ListingOffersResponse defines model for ListingOffersResponse.
type ListingOffersResponse struct {
	// Body The response schema for the `getListingOffers` and `getItemOffers` operations.
	Body GetOffersResponse `json:"body"`

	// Headers A mapping of additional HTTP headers to send/receive for the individual batch request.
	Headers *HttpResponseHeaders        `json:"headers,omitempty"`
	Request *ListingOffersRequestParams `json:"request,omitempty"`

	// Status The HTTP status line associated with the response.  For more information, consult [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html).
	Status *GetOffersHttpStatusLine `json:"status,omitempty"`
}

// ListingOffersResponseList A list of `getListingOffers` batched responses.
type ListingOffersResponseList = []ListingOffersResponse

// LowestPriceType defines model for LowestPriceType.
type LowestPriceType struct {
	LandedPrice  *MoneyType `json:"LandedPrice,omitempty"`
	ListingPrice MoneyType  `json:"ListingPrice"`
	Points       *Points    `json:"Points,omitempty"`
	Shipping     *MoneyType `json:"Shipping,omitempty"`

	// Condition Indicates the condition of the item. For example: New, Used, Collectible, Refurbished, or Club.
	Condition string `json:"condition"`

	// FulfillmentChannel Indicates whether the item is fulfilled by Amazon or by the seller.
	FulfillmentChannel   string                `json:"fulfillmentChannel"`
	OfferType            *OfferCustomerType    `json:"offerType,omitempty"`
	QuantityDiscountType *QuantityDiscountType `json:"quantityDiscountType,omitempty"`

	// QuantityTier Indicates at what quantity this price becomes active.
	QuantityTier *int32 `json:"quantityTier,omitempty"`
}

// LowestPrices defines model for LowestPrices.
type LowestPrices = []LowestPriceType

// MarketplaceId A marketplace identifier. Specifies the marketplace for which prices are returned.
type MarketplaceId = string

// MoneyType defines model for MoneyType.
type MoneyType struct {
	// Amount The monetary value.
	Amount *float32 `json:"Amount,omitempty"`

	// CurrencyCode The currency code in ISO 4217 format.
	CurrencyCode *string `json:"CurrencyCode,omitempty"`
}

// NumberOfOfferListingsList The number of active offer listings for the item that was submitted. The listing count is returned by condition, one for each listing condition value that is returned.
type NumberOfOfferListingsList = []OfferListingCountType

// NumberOfOffers defines model for NumberOfOffers.
type NumberOfOffers = []OfferCountType

// OfferCountType The total number of offers for the specified condition and fulfillment channel.
type OfferCountType struct {
	// OfferCount The number of offers in a fulfillment channel that meet a specific condition.
	OfferCount *int32 `json:"OfferCount,omitempty"`

	// Condition Indicates the condition of the item. For example: New, Used, Collectible, Refurbished, or Club.
	Condition *string `json:"condition,omitempty"`

	// FulfillmentChannel Indicates whether the item is fulfilled by Amazon or by the seller (merchant).
	FulfillmentChannel *FulfillmentChannelType `json:"fulfillmentChannel,omitempty"`
}

// OfferCustomerType defines model for OfferCustomerType.
type OfferCustomerType string

// OfferDetail defines model for OfferDetail.
type OfferDetail struct {
	// ConditionNotes Information about the condition of the item.
	ConditionNotes *string `json:"ConditionNotes,omitempty"`

	// IsBuyBoxWinner When true, the offer is currently in the Buy Box. There can be up to two Buy Box winners at any time per ASIN, one that is eligible for Prime and one that is not eligible for Prime.
	IsBuyBoxWinner *bool `json:"IsBuyBoxWinner,omitempty"`

	// IsFeaturedMerchant When true, the seller of the item is eligible to win the Buy Box.
	IsFeaturedMerchant *bool `json:"IsFeaturedMerchant,omitempty"`

	// IsFulfilledByAmazon When true, the offer is fulfilled by Amazon.
	IsFulfilledByAmazon bool      `json:"IsFulfilledByAmazon"`
	ListingPrice        MoneyType `json:"ListingPrice"`

	// MyOffer When true, this is the seller's offer.
	MyOffer *bool   `json:"MyOffer,omitempty"`
	Points  *Points `json:"Points,omitempty"`

	// PrimeInformation Amazon Prime information.
	PrimeInformation *PrimeInformationType `json:"PrimeInformation,omitempty"`

	// SellerFeedbackRating Information about the seller's feedback, including the percentage of positive feedback, and the total number of ratings received.
	SellerFeedbackRating *SellerFeedbackType `json:"SellerFeedbackRating,omitempty"`

	// SellerId The seller identifier for the offer.
	SellerId *string   `json:"SellerId,omitempty"`
	Shipping MoneyType `json:"Shipping"`

	// ShippingTime The time range in which an item will likely be shipped once an order has been placed.
	ShippingTime DetailedShippingTimeType `json:"ShippingTime"`

	// ShipsFrom The state and country from where the item is shipped.
	ShipsFrom *ShipsFromType `json:"ShipsFrom,omitempty"`

	// SubCondition The subcondition of the item. Subcondition values: New, Mint, Very Good, Good, Acceptable, Poor, Club, OEM, Warranty, Refurbished Warranty, Refurbished, Open Box, or Other.
	SubCondition           string                       `json:"SubCondition"`
	OfferType              *OfferCustomerType           `json:"offerType,omitempty"`
	QuantityDiscountPrices *[]QuantityDiscountPriceType `json:"quantityDiscountPrices,omitempty"`
}

// OfferDetailList defines model for OfferDetailList.
type OfferDetailList = []OfferDetail

// OfferListingCountType The number of offer listings with the specified condition.
type OfferListingCountType struct {
	// Count The number of offer listings.
	Count int32 `json:"Count"`

	// Condition The condition of the item.
	Condition string `json:"condition"`
}

// OfferType defines model for OfferType.
type OfferType struct {
	BuyingPrice PriceType `json:"BuyingPrice"`

	// FulfillmentChannel The fulfillment channel for the offer listing. Possible values:
	//
	// * Amazon - Fulfilled by Amazon.
	// * Merchant - Fulfilled by the seller.
	FulfillmentChannel string `json:"FulfillmentChannel"`

	// ItemCondition The item condition for the offer listing. Possible values: New, Used, Collectible, Refurbished, or Club.
	ItemCondition string `json:"ItemCondition"`

	// ItemSubCondition The item subcondition for the offer listing. Possible values: New, Mint, Very Good, Good, Acceptable, Poor, Club, OEM, Warranty, Refurbished Warranty, Refurbished, Open Box, or Other.
	ItemSubCondition string    `json:"ItemSubCondition"`
	RegularPrice     MoneyType `json:"RegularPrice"`

	// SellerSKU The seller stock keeping unit (SKU) of the item.
	SellerSKU              string                       `json:"SellerSKU"`
	BusinessPrice          *MoneyType                   `json:"businessPrice,omitempty"`
	OfferType              *OfferCustomerType           `json:"offerType,omitempty"`
	QuantityDiscountPrices *[]QuantityDiscountPriceType `json:"quantityDiscountPrices,omitempty"`
}

// OffersList A list of offers.
type OffersList = []OfferType

// Points defines model for Points.
type Points struct {
	PointsMonetaryValue *MoneyType `json:"PointsMonetaryValue,omitempty"`

	// PointsNumber The number of points.
	PointsNumber *int32 `json:"PointsNumber,omitempty"`
}

// Price defines model for Price.
type Price struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN *string `json:"ASIN,omitempty"`

	// Product An item.
	Product *Product `json:"Product,omitempty"`

	// SellerSKU The seller stock keeping unit (SKU) of the item.
	SellerSKU *string `json:"SellerSKU,omitempty"`

	// Status The status of the operation.
	Status string `json:"status"`
}

// PriceList defines model for PriceList.
type PriceList = []Price

// PriceType defines model for PriceType.
type PriceType struct {
	LandedPrice  *MoneyType `json:"LandedPrice,omitempty"`
	ListingPrice MoneyType  `json:"ListingPrice"`
	Points       *Points    `json:"Points,omitempty"`
	Shipping     *MoneyType `json:"Shipping,omitempty"`
}

// PrimeInformationType Amazon Prime information.
type PrimeInformationType struct {
	// IsNationalPrime Indicates whether the offer is an Amazon Prime offer throughout the entire marketplace where it is listed.
	IsNationalPrime bool `json:"IsNationalPrime"`

	// IsPrime Indicates whether the offer is an Amazon Prime offer.
	IsPrime bool `json:"IsPrime"`
}

// Product An item.
type Product struct {
	// AttributeSets A list of product attributes if they are applicable to the product that is returned.
	AttributeSets *AttributeSetList `json:"AttributeSets,omitempty"`

	// CompetitivePricing Competitive pricing information for the item.
	CompetitivePricing *CompetitivePricingType `json:"CompetitivePricing,omitempty"`

	// Identifiers Specifies the identifiers used to uniquely identify an item.
	Identifiers IdentifierType `json:"Identifiers"`

	// Offers A list of offers.
	Offers *OffersList `json:"Offers,omitempty"`

	// Relationships A list that contains product variation information, if applicable.
	Relationships *RelationshipList `json:"Relationships,omitempty"`

	// SalesRankings A list of sales rank information for the item, by category.
	SalesRankings *SalesRankList `json:"SalesRankings,omitempty"`
}

// QuantityDiscountPriceType Contains pricing information that includes special pricing when buying in bulk.
type QuantityDiscountPriceType struct {
	ListingPrice         MoneyType            `json:"listingPrice"`
	QuantityDiscountType QuantityDiscountType `json:"quantityDiscountType"`

	// QuantityTier Indicates at what quantity this price becomes active.
	QuantityTier int32 `json:"quantityTier"`
}

// QuantityDiscountType defines model for QuantityDiscountType.
type QuantityDiscountType string

// RelationshipList A list that contains product variation information, if applicable.
type RelationshipList = []map[string]interface{}

// SalesRankList A list of sales rank information for the item, by category.
type SalesRankList = []SalesRankType

// SalesRankType defines model for SalesRankType.
type SalesRankType struct {
	// ProductCategoryId  Identifies the item category from which the sales rank is taken.
	ProductCategoryId string `json:"ProductCategoryId"`

	// Rank The sales rank of the item within the item category.
	Rank int32 `json:"Rank"`
}

// SellerFeedbackType Information about the seller's feedback, including the percentage of positive feedback, and the total number of ratings received.
type SellerFeedbackType struct {
	// FeedbackCount The number of ratings received about the seller.
	FeedbackCount int64 `json:"FeedbackCount"`

	// SellerPositiveFeedbackRating The percentage of positive feedback for the seller in the past 365 days.
	SellerPositiveFeedbackRating *float64 `json:"SellerPositiveFeedbackRating,omitempty"`
}

// SellerSKUIdentifier defines model for SellerSKUIdentifier.
type SellerSKUIdentifier struct {
	// MarketplaceId A marketplace identifier.
	MarketplaceId string `json:"MarketplaceId"`

	// SellerId The seller identifier submitted for the operation.
	SellerId string `json:"SellerId"`

	// SellerSKU The seller stock keeping unit (SKU) of the item.
	SellerSKU string `json:"SellerSKU"`
}

// ShipsFromType The state and country from where the item is shipped.
type ShipsFromType struct {
	// Country The country from where the item is shipped.
	Country *string `json:"Country,omitempty"`

	// State The state from where the item is shipped.
	State *string `json:"State,omitempty"`
}

// Summary Contains price information about the product, including the LowestPrices and BuyBoxPrices, the ListPrice, the SuggestedLowerPricePlusShipping, and NumberOfOffers and NumberOfBuyBoxEligibleOffers.
type Summary struct {
	BuyBoxEligibleOffers      *BuyBoxEligibleOffers `json:"BuyBoxEligibleOffers,omitempty"`
	BuyBoxPrices              *BuyBoxPrices         `json:"BuyBoxPrices,omitempty"`
	CompetitivePriceThreshold *MoneyType            `json:"CompetitivePriceThreshold,omitempty"`
	ListPrice                 *MoneyType            `json:"ListPrice,omitempty"`
	LowestPrices              *LowestPrices         `json:"LowestPrices,omitempty"`
	NumberOfOffers            *NumberOfOffers       `json:"NumberOfOffers,omitempty"`

	// OffersAvailableTime When the status is ActiveButTooSoonForProcessing, this is the time when the offers will be available for processing.
	OffersAvailableTime *time.Time `json:"OffersAvailableTime,omitempty"`

	// SalesRankings A list of sales rank information for the item, by category.
	SalesRankings                   *SalesRankList `json:"SalesRankings,omitempty"`
	SuggestedLowerPricePlusShipping *MoneyType     `json:"SuggestedLowerPricePlusShipping,omitempty"`

	// TotalOfferCount The number of unique offers contained in NumberOfOffers.
	TotalOfferCount int32 `json:"TotalOfferCount"`
}

// GetCompetitivePricingParams defines parameters for GetCompetitivePricing.
type GetCompetitivePricingParams struct {
	// MarketplaceId A marketplace identifier. Specifies the marketplace for which prices are returned.
	MarketplaceId string `form:"MarketplaceId" json:"MarketplaceId"`

	// Asins A list of up to twenty Amazon Standard Identification Number (ASIN) values used to identify items in the given marketplace.
	Asins *[]string `form:"Asins,omitempty" json:"Asins,omitempty"`

	// Skus A list of up to twenty seller SKU values used to identify items in the given marketplace.
	Skus *[]string `form:"Skus,omitempty" json:"Skus,omitempty"`

	// ItemType Indicates whether ASIN values or seller SKU values are used to identify items. If you specify Asin, the information in the response will be dependent on the list of Asins you provide in the Asins parameter. If you specify Sku, the information in the response will be dependent on the list of Skus you provide in the Skus parameter. Possible values: Asin, Sku.
	ItemType GetCompetitivePricingParamsItemType `form:"ItemType" json:"ItemType"`

	// CustomerType Indicates whether to request pricing information from the point of view of Consumer or Business buyers. Default is Consumer.
	CustomerType *GetCompetitivePricingParamsCustomerType `form:"CustomerType,omitempty" json:"CustomerType,omitempty"`
}

// GetCompetitivePricingParamsItemType defines parameters for GetCompetitivePricing.
type GetCompetitivePricingParamsItemType string

// GetCompetitivePricingParamsCustomerType defines parameters for GetCompetitivePricing.
type GetCompetitivePricingParamsCustomerType string

// GetItemOffersParams defines parameters for GetItemOffers.
type GetItemOffersParams struct {
	// MarketplaceId A marketplace identifier. Specifies the marketplace for which prices are returned.
	MarketplaceId string `form:"MarketplaceId" json:"MarketplaceId"`

	// ItemCondition Filters the offer listings to be considered based on item condition. Possible values: New, Used, Collectible, Refurbished, Club.
	ItemCondition GetItemOffersParamsItemCondition `form:"ItemCondition" json:"ItemCondition"`

	// CustomerType Indicates whether to request Consumer or Business offers. Default is Consumer.
	CustomerType *GetItemOffersParamsCustomerType `form:"CustomerType,omitempty" json:"CustomerType,omitempty"`
}

// GetItemOffersParamsItemCondition defines parameters for GetItemOffers.
type GetItemOffersParamsItemCondition string

// GetItemOffersParamsCustomerType defines parameters for GetItemOffers.
type GetItemOffersParamsCustomerType string

// GetListingOffersParams defines parameters for GetListingOffers.
type GetListingOffersParams struct {
	// MarketplaceId A marketplace identifier. Specifies the marketplace for which prices are returned.
	MarketplaceId string `form:"MarketplaceId" json:"MarketplaceId"`

	// ItemCondition Filters the offer listings based on item condition. Possible values: New, Used, Collectible, Refurbished, Club.
	ItemCondition GetListingOffersParamsItemCondition `form:"ItemCondition" json:"ItemCondition"`

	// CustomerType Indicates whether to request Consumer or Business offers. Default is Consumer.
	CustomerType *GetListingOffersParamsCustomerType `form:"CustomerType,omitempty" json:"CustomerType,omitempty"`
}

// GetListingOffersParamsItemCondition defines parameters for GetListingOffers.
type GetListingOffersParamsItemCondition string

// GetListingOffersParamsCustomerType defines parameters for GetListingOffers.
type GetListingOffersParamsCustomerType string

// GetPricingParams defines parameters for GetPricing.
type GetPricingParams struct {
	// MarketplaceId A marketplace identifier. Specifies the marketplace for which prices are returned.
	MarketplaceId string `form:"MarketplaceId" json:"MarketplaceId"`

	// Asins A list of up to twenty Amazon Standard Identification Number (ASIN) values used to identify items in the given marketplace.
	Asins *[]string `form:"Asins,omitempty" json:"Asins,omitempty"`

	// Skus A list of up to twenty seller SKU values used to identify items in the given marketplace.
	Skus *[]string `form:"Skus,omitempty" json:"Skus,omitempty"`

	// ItemType Indicates whether ASIN values or seller SKU values are used to identify items. If you specify Asin, the information in the response will be dependent on the list of Asins you provide in the Asins parameter. If you specify Sku, the information in the response will be dependent on the list of Skus you provide in the Skus parameter.
	ItemType GetPricingParamsItemType `form:"ItemType" json:"ItemType"`

	// ItemCondition Filters the offer listings based on item condition. Possible values: New, Used, Collectible, Refurbished, Club.
	ItemCondition *GetPricingParamsItemCondition `form:"ItemCondition,omitempty" json:"ItemCondition,omitempty"`

	// OfferType Indicates whether to request pricing information for the seller's B2C or B2B offers. Default is B2C.
	OfferType *GetPricingParamsOfferType `form:"OfferType,omitempty" json:"OfferType,omitempty"`
}

// GetPricingParamsItemType defines parameters for GetPricing.
type GetPricingParamsItemType string

// GetPricingParamsItemCondition defines parameters for GetPricing.
type GetPricingParamsItemCondition string

// GetPricingParamsOfferType defines parameters for GetPricing.
type GetPricingParamsOfferType string

// GetItemOffersBatchJSONRequestBody defines body for GetItemOffersBatch for application/json ContentType.
type GetItemOffersBatchJSONRequestBody = GetItemOffersBatchRequest

// GetListingOffersBatchJSONRequestBody defines body for GetListingOffersBatch for application/json ContentType.
type GetListingOffersBatchJSONRequestBody = GetListingOffersBatchRequest

// Getter for additional properties for HttpResponseHeaders. Returns the specified
// element and whether it was found
func (a HttpResponseHeaders) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for HttpResponseHeaders
func (a *HttpResponseHeaders) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for HttpResponseHeaders to handle AdditionalProperties
func (a *HttpResponseHeaders) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := sonic.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Date"]; found {
		err = sonic.Unmarshal(raw, &a.Date)
		if err != nil {
			return fmt.Errorf("error reading 'Date': %w", err)
		}
		delete(object, "Date")
	}

	if raw, found := object["x-amzn-RequestId"]; found {
		err = sonic.Unmarshal(raw, &a.XAmznRequestId)
		if err != nil {
			return fmt.Errorf("error reading 'x-amzn-RequestId': %w", err)
		}
		delete(object, "x-amzn-RequestId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := sonic.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for HttpResponseHeaders to handle AdditionalProperties
func (a HttpResponseHeaders) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Date != nil {
		object["Date"], err = sonic.Marshal(a.Date)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'Date': %w", err)
		}
	}

	if a.XAmznRequestId != nil {
		object["x-amzn-RequestId"], err = sonic.Marshal(a.XAmznRequestId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'x-amzn-RequestId': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = sonic.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return sonic.Marshal(object)
}

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetItemOffersBatchWithBody request with any body
	GetItemOffersBatchWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	GetItemOffersBatch(ctx context.Context, body GetItemOffersBatchJSONRequestBody) (*http.Response, error)

	// GetListingOffersBatchWithBody request with any body
	GetListingOffersBatchWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	GetListingOffersBatch(ctx context.Context, body GetListingOffersBatchJSONRequestBody) (*http.Response, error)

	// GetCompetitivePricing request
	GetCompetitivePricing(ctx context.Context, params *GetCompetitivePricingParams) (*http.Response, error)

	// GetItemOffers request
	GetItemOffers(ctx context.Context, asin string, params *GetItemOffersParams) (*http.Response, error)

	// GetListingOffers request
	GetListingOffers(ctx context.Context, sellerSKU string, params *GetListingOffersParams) (*http.Response, error)

	// GetPricing request
	GetPricing(ctx context.Context, params *GetPricingParams) (*http.Response, error)
}

func (c *Client) GetItemOffersBatchWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetItemOffersBatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetItemOffersBatch(ctx context.Context, body GetItemOffersBatchJSONRequestBody) (*http.Response, error) {
	req, err := NewGetItemOffersBatchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetListingOffersBatchWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetListingOffersBatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetListingOffersBatch(ctx context.Context, body GetListingOffersBatchJSONRequestBody) (*http.Response, error) {
	req, err := NewGetListingOffersBatchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetCompetitivePricing(ctx context.Context, params *GetCompetitivePricingParams) (*http.Response, error) {
	req, err := NewGetCompetitivePricingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetItemOffers(ctx context.Context, asin string, params *GetItemOffersParams) (*http.Response, error) {
	req, err := NewGetItemOffersRequest(c.Server, asin, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetListingOffers(ctx context.Context, sellerSKU string, params *GetListingOffersParams) (*http.Response, error) {
	req, err := NewGetListingOffersRequest(c.Server, sellerSKU, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetPricing(ctx context.Context, params *GetPricingParams) (*http.Response, error) {
	req, err := NewGetPricingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewGetItemOffersBatchRequest calls the generic GetItemOffersBatch builder with application/json body
func NewGetItemOffersBatchRequest(server string, body GetItemOffersBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetItemOffersBatchRequestWithBody(server, "application/json", bodyReader)
}

// NewGetItemOffersBatchRequestWithBody generates requests for GetItemOffersBatch with any type of body
func NewGetItemOffersBatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/products/pricing/v0/itemOffers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetListingOffersBatchRequest calls the generic GetListingOffersBatch builder with application/json body
func NewGetListingOffersBatchRequest(server string, body GetListingOffersBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetListingOffersBatchRequestWithBody(server, "application/json", bodyReader)
}

// NewGetListingOffersBatchRequestWithBody generates requests for GetListingOffersBatch with any type of body
func NewGetListingOffersBatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/products/pricing/v0/listingOffers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCompetitivePricingRequest generates requests for GetCompetitivePricing
func NewGetCompetitivePricingRequest(server string, params *GetCompetitivePricingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/pricing/v0/competitivePrice")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.Asins != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Asins", runtime.ParamLocationQuery, *params.Asins); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Skus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Skus", runtime.ParamLocationQuery, *params.Skus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ItemType", runtime.ParamLocationQuery, params.ItemType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.CustomerType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "CustomerType", runtime.ParamLocationQuery, *params.CustomerType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemOffersRequest generates requests for GetItemOffers
func NewGetItemOffersRequest(server string, asin string, params *GetItemOffersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "Asin", runtime.ParamLocationPath, asin)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/pricing/v0/items/%s/offers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ItemCondition", runtime.ParamLocationQuery, params.ItemCondition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.CustomerType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "CustomerType", runtime.ParamLocationQuery, *params.CustomerType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListingOffersRequest generates requests for GetListingOffers
func NewGetListingOffersRequest(server string, sellerSKU string, params *GetListingOffersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "SellerSKU", runtime.ParamLocationPath, sellerSKU)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/pricing/v0/listings/%s/offers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ItemCondition", runtime.ParamLocationQuery, params.ItemCondition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.CustomerType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "CustomerType", runtime.ParamLocationQuery, *params.CustomerType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPricingRequest generates requests for GetPricing
func NewGetPricingRequest(server string, params *GetPricingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/pricing/v0/price")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.Asins != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Asins", runtime.ParamLocationQuery, *params.Asins); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Skus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Skus", runtime.ParamLocationQuery, *params.Skus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ItemType", runtime.ParamLocationQuery, params.ItemType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.ItemCondition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ItemCondition", runtime.ParamLocationQuery, *params.ItemCondition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.OfferType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "OfferType", runtime.ParamLocationQuery, *params.OfferType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetItemOffersBatchWithBodyWithResponse request with any body
	GetItemOffersBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetItemOffersBatchResp, error)

	GetItemOffersBatchWithResponse(ctx context.Context, body GetItemOffersBatchJSONRequestBody) (*GetItemOffersBatchResp, error)

	// GetListingOffersBatchWithBodyWithResponse request with any body
	GetListingOffersBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetListingOffersBatchResp, error)

	GetListingOffersBatchWithResponse(ctx context.Context, body GetListingOffersBatchJSONRequestBody) (*GetListingOffersBatchResp, error)

	// GetCompetitivePricingWithResponse request
	GetCompetitivePricingWithResponse(ctx context.Context, params *GetCompetitivePricingParams) (*GetCompetitivePricingResp, error)

	// GetItemOffersWithResponse request
	GetItemOffersWithResponse(ctx context.Context, asin string, params *GetItemOffersParams) (*GetItemOffersResp, error)

	// GetListingOffersWithResponse request
	GetListingOffersWithResponse(ctx context.Context, sellerSKU string, params *GetListingOffersParams) (*GetListingOffersResp, error)

	// GetPricingWithResponse request
	GetPricingWithResponse(ctx context.Context, params *GetPricingParams) (*GetPricingResp, error)
}

type GetItemOffersBatchResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetItemOffersBatchResponse
	JSON400      *Errors
	JSON401      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON429      *Errors
	JSON500      *Errors
	JSON503      *Errors
}

// Status returns HTTPResponse.Status
func (r GetItemOffersBatchResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemOffersBatchResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListingOffersBatchResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetListingOffersBatchResponse
	JSON400      *Errors
	JSON401      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON429      *Errors
	JSON500      *Errors
	JSON503      *Errors
}

// Status returns HTTPResponse.Status
func (r GetListingOffersBatchResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListingOffersBatchResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompetitivePricingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPricingResponse
	JSON400      *GetPricingResponse
	JSON401      *GetPricingResponse
	JSON403      *GetPricingResponse
	JSON404      *GetPricingResponse
	JSON429      *GetPricingResponse
	JSON500      *GetPricingResponse
	JSON503      *GetPricingResponse
}

// Status returns HTTPResponse.Status
func (r GetCompetitivePricingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompetitivePricingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemOffersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOffersResponse
	JSON400      *GetOffersResponse
	JSON401      *GetOffersResponse
	JSON403      *GetOffersResponse
	JSON404      *GetOffersResponse
	JSON429      *GetOffersResponse
	JSON500      *GetOffersResponse
	JSON503      *GetOffersResponse
}

// Status returns HTTPResponse.Status
func (r GetItemOffersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemOffersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListingOffersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOffersResponse
	JSON400      *GetOffersResponse
	JSON401      *GetOffersResponse
	JSON403      *GetOffersResponse
	JSON404      *GetOffersResponse
	JSON429      *GetOffersResponse
	JSON500      *GetOffersResponse
	JSON503      *GetOffersResponse
}

// Status returns HTTPResponse.Status
func (r GetListingOffersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListingOffersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPricingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPricingResponse
	JSON400      *GetPricingResponse
	JSON401      *GetPricingResponse
	JSON403      *GetPricingResponse
	JSON404      *GetPricingResponse
	JSON429      *GetPricingResponse
	JSON500      *GetPricingResponse
	JSON503      *GetPricingResponse
}

// Status returns HTTPResponse.Status
func (r GetPricingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPricingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetItemOffersBatchWithBodyWithResponse request with arbitrary body returning *GetItemOffersBatchResp
func (c *ClientWithResponses) GetItemOffersBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetItemOffersBatchResp, error) {
	rsp, err := c.GetItemOffersBatchWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetItemOffersBatchResp(rsp)
}

func (c *ClientWithResponses) GetItemOffersBatchWithResponse(ctx context.Context, body GetItemOffersBatchJSONRequestBody) (*GetItemOffersBatchResp, error) {
	rsp, err := c.GetItemOffersBatch(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseGetItemOffersBatchResp(rsp)
}

// GetListingOffersBatchWithBodyWithResponse request with arbitrary body returning *GetListingOffersBatchResp
func (c *ClientWithResponses) GetListingOffersBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetListingOffersBatchResp, error) {
	rsp, err := c.GetListingOffersBatchWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetListingOffersBatchResp(rsp)
}

func (c *ClientWithResponses) GetListingOffersBatchWithResponse(ctx context.Context, body GetListingOffersBatchJSONRequestBody) (*GetListingOffersBatchResp, error) {
	rsp, err := c.GetListingOffersBatch(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseGetListingOffersBatchResp(rsp)
}

// GetCompetitivePricingWithResponse request returning *GetCompetitivePricingResp
func (c *ClientWithResponses) GetCompetitivePricingWithResponse(ctx context.Context, params *GetCompetitivePricingParams) (*GetCompetitivePricingResp, error) {
	rsp, err := c.GetCompetitivePricing(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetCompetitivePricingResp(rsp)
}

// GetItemOffersWithResponse request returning *GetItemOffersResp
func (c *ClientWithResponses) GetItemOffersWithResponse(ctx context.Context, asin string, params *GetItemOffersParams) (*GetItemOffersResp, error) {
	rsp, err := c.GetItemOffers(ctx, asin, params)
	if err != nil {
		return nil, err
	}
	return ParseGetItemOffersResp(rsp)
}

// GetListingOffersWithResponse request returning *GetListingOffersResp
func (c *ClientWithResponses) GetListingOffersWithResponse(ctx context.Context, sellerSKU string, params *GetListingOffersParams) (*GetListingOffersResp, error) {
	rsp, err := c.GetListingOffers(ctx, sellerSKU, params)
	if err != nil {
		return nil, err
	}
	return ParseGetListingOffersResp(rsp)
}

// GetPricingWithResponse request returning *GetPricingResp
func (c *ClientWithResponses) GetPricingWithResponse(ctx context.Context, params *GetPricingParams) (*GetPricingResp, error) {
	rsp, err := c.GetPricing(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetPricingResp(rsp)
}

// ParseGetItemOffersBatchResp parses an HTTP response from a GetItemOffersBatchWithResponse call
func ParseGetItemOffersBatchResp(rsp *http.Response) (*GetItemOffersBatchResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemOffersBatchResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetItemOffersBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetListingOffersBatchResp parses an HTTP response from a GetListingOffersBatchWithResponse call
func ParseGetListingOffersBatchResp(rsp *http.Response) (*GetListingOffersBatchResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListingOffersBatchResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetListingOffersBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetCompetitivePricingResp parses an HTTP response from a GetCompetitivePricingWithResponse call
func ParseGetCompetitivePricingResp(rsp *http.Response) (*GetCompetitivePricingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompetitivePricingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetItemOffersResp parses an HTTP response from a GetItemOffersWithResponse call
func ParseGetItemOffersResp(rsp *http.Response) (*GetItemOffersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemOffersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetListingOffersResp parses an HTTP response from a GetListingOffersWithResponse call
func ParseGetListingOffersResp(rsp *http.Response) (*GetListingOffersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListingOffersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPricingResp parses an HTTP response from a GetPricingWithResponse call
func ParseGetPricingResp(rsp *http.Response) (*GetPricingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPricingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetPricingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
