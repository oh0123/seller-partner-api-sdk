// Package productFeesv0 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.4 DO NOT EDIT.
package productFeesv0

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for IdType.
const (
	ASIN      IdType = "ASIN"
	SellerSKU IdType = "SellerSKU"
)

// Defines values for OptionalFulfillmentProgram.
const (
	FBACORE OptionalFulfillmentProgram = "FBA_CORE"
	FBAEFN  OptionalFulfillmentProgram = "FBA_EFN"
	FBASNL  OptionalFulfillmentProgram = "FBA_SNL"
)

// Error defines model for Error.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional information that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// FeeDetail The type of fee, fee amount, and other details.
type FeeDetail struct {
	FeeAmount    MoneyType  `json:"FeeAmount"`
	FeePromotion *MoneyType `json:"FeePromotion,omitempty"`

	// FeeType The type of fee charged to a seller.
	FeeType  string    `json:"FeeType"`
	FinalFee MoneyType `json:"FinalFee"`

	// IncludedFeeDetailList A list of other fees that contribute to a given fee.
	IncludedFeeDetailList *IncludedFeeDetailList `json:"IncludedFeeDetailList,omitempty"`
	TaxAmount             *MoneyType             `json:"TaxAmount,omitempty"`
}

// FeeDetailList A list of other fees that contribute to a given fee.
type FeeDetailList = []FeeDetail

// FeesEstimate The total estimated fees for an item and a list of details.
type FeesEstimate struct {
	// FeeDetailList A list of other fees that contribute to a given fee.
	FeeDetailList *FeeDetailList `json:"FeeDetailList,omitempty"`

	// TimeOfFeesEstimation The time at which the fees were estimated. This defaults to the time the request is made.
	TimeOfFeesEstimation time.Time  `json:"TimeOfFeesEstimation"`
	TotalFeesEstimate    *MoneyType `json:"TotalFeesEstimate,omitempty"`
}

// FeesEstimateByIdRequest A product, marketplace, and proposed price used to request estimated fees.
type FeesEstimateByIdRequest struct {
	// FeesEstimateRequest A product, marketplace, and proposed price used to request estimated fees.
	FeesEstimateRequest *FeesEstimateRequest `json:"FeesEstimateRequest,omitempty"`

	// IdType The type of product identifier used in a `FeesEstimateByIdRequest`.
	IdType IdType `json:"IdType"`

	// IdValue The item identifier.
	IdValue string `json:"IdValue"`
}

// FeesEstimateError An unexpected error occurred during this operation.
type FeesEstimateError struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"Code"`

	// Detail Additional information that can help the caller understand or fix the issue.
	Detail FeesEstimateErrorDetail `json:"Detail"`

	// Message A message that describes the error condition.
	Message string `json:"Message"`

	// Type An error type, identifying either the receiver or the sender as the originator of the error.
	Type string `json:"Type"`
}

// FeesEstimateErrorDetail Additional information that can help the caller understand or fix the issue.
type FeesEstimateErrorDetail = []map[string]interface{}

// FeesEstimateIdentifier An item identifier, marketplace, time of request, and other details that identify an estimate.
type FeesEstimateIdentifier struct {
	// IdType The type of product identifier used in a `FeesEstimateByIdRequest`.
	IdType *IdType `json:"IdType,omitempty"`

	// IdValue The item identifier.
	IdValue *string `json:"IdValue,omitempty"`

	// IsAmazonFulfilled When true, the offer is fulfilled by Amazon.
	IsAmazonFulfilled *bool `json:"IsAmazonFulfilled,omitempty"`

	// MarketplaceId A marketplace identifier.
	MarketplaceId *string `json:"MarketplaceId,omitempty"`

	// OptionalFulfillmentProgram An optional enrollment program to return the estimated fees when the offer is fulfilled by Amazon (IsAmazonFulfilled is set to true).
	OptionalFulfillmentProgram *OptionalFulfillmentProgram `json:"OptionalFulfillmentProgram,omitempty"`

	// PriceToEstimateFees Price information for an item, used to estimate fees.
	PriceToEstimateFees *PriceToEstimateFees `json:"PriceToEstimateFees,omitempty"`

	// SellerId The seller identifier.
	SellerId *string `json:"SellerId,omitempty"`

	// SellerInputIdentifier A unique identifier provided by the caller to track this request.
	SellerInputIdentifier *string `json:"SellerInputIdentifier,omitempty"`
}

// FeesEstimateRequest A product, marketplace, and proposed price used to request estimated fees.
type FeesEstimateRequest struct {
	// Identifier A unique identifier provided by the caller to track this request.
	Identifier string `json:"Identifier"`

	// IsAmazonFulfilled When true, the offer is fulfilled by Amazon.
	IsAmazonFulfilled *bool `json:"IsAmazonFulfilled,omitempty"`

	// MarketplaceId A marketplace identifier.
	MarketplaceId string `json:"MarketplaceId"`

	// OptionalFulfillmentProgram An optional enrollment program to return the estimated fees when the offer is fulfilled by Amazon (IsAmazonFulfilled is set to true).
	OptionalFulfillmentProgram *OptionalFulfillmentProgram `json:"OptionalFulfillmentProgram,omitempty"`

	// PriceToEstimateFees Price information for an item, used to estimate fees.
	PriceToEstimateFees PriceToEstimateFees `json:"PriceToEstimateFees"`
}

// FeesEstimateResult An item identifier and the estimated fees for the item.
type FeesEstimateResult struct {
	// Error An unexpected error occurred during this operation.
	Error *FeesEstimateError `json:"Error,omitempty"`

	// FeesEstimate The total estimated fees for an item and a list of details.
	FeesEstimate *FeesEstimate `json:"FeesEstimate,omitempty"`

	// FeesEstimateIdentifier An item identifier, marketplace, time of request, and other details that identify an estimate.
	FeesEstimateIdentifier *FeesEstimateIdentifier `json:"FeesEstimateIdentifier,omitempty"`

	// Status The status of the fee request. Possible values: Success, ClientError, ServiceError.
	Status *string `json:"Status,omitempty"`
}

// GetMyFeesEstimateRequest Request schema.
type GetMyFeesEstimateRequest struct {
	// FeesEstimateRequest A product, marketplace, and proposed price used to request estimated fees.
	FeesEstimateRequest *FeesEstimateRequest `json:"FeesEstimateRequest,omitempty"`
}

// GetMyFeesEstimateResponse defines model for GetMyFeesEstimateResponse.
type GetMyFeesEstimateResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Response schema.
	Payload *GetMyFeesEstimateResult `json:"payload,omitempty"`
}

// GetMyFeesEstimateResult Response schema.
type GetMyFeesEstimateResult struct {
	// FeesEstimateResult An item identifier and the estimated fees for the item.
	FeesEstimateResult *FeesEstimateResult `json:"FeesEstimateResult,omitempty"`
}

// GetMyFeesEstimatesErrorList A list of error responses returned when a request is unsuccessful.
type GetMyFeesEstimatesErrorList struct {
	Errors []Error `json:"errors"`
}

// GetMyFeesEstimatesRequest Request for estimated fees for a list of products.
type GetMyFeesEstimatesRequest = []FeesEstimateByIdRequest

// GetMyFeesEstimatesResponse Estimated fees for a list of products.
type GetMyFeesEstimatesResponse = []FeesEstimateResult

// IdType The type of product identifier used in a `FeesEstimateByIdRequest`.
type IdType string

// IncludedFeeDetail The type of fee, fee amount, and other details.
type IncludedFeeDetail struct {
	FeeAmount    MoneyType  `json:"FeeAmount"`
	FeePromotion *MoneyType `json:"FeePromotion,omitempty"`

	// FeeType The type of fee charged to a seller.
	FeeType   string     `json:"FeeType"`
	FinalFee  MoneyType  `json:"FinalFee"`
	TaxAmount *MoneyType `json:"TaxAmount,omitempty"`
}

// IncludedFeeDetailList A list of other fees that contribute to a given fee.
type IncludedFeeDetailList = []IncludedFeeDetail

// MoneyType defines model for MoneyType.
type MoneyType struct {
	// Amount The monetary value.
	Amount *float32 `json:"Amount,omitempty"`

	// CurrencyCode The currency code in ISO 4217 format.
	CurrencyCode *string `json:"CurrencyCode,omitempty"`
}

// OptionalFulfillmentProgram An optional enrollment program to return the estimated fees when the offer is fulfilled by Amazon (IsAmazonFulfilled is set to true).
type OptionalFulfillmentProgram string

// Points defines model for Points.
type Points struct {
	PointsMonetaryValue *MoneyType `json:"PointsMonetaryValue,omitempty"`
	PointsNumber        *int32     `json:"PointsNumber,omitempty"`
}

// PriceToEstimateFees Price information for an item, used to estimate fees.
type PriceToEstimateFees struct {
	ListingPrice MoneyType  `json:"ListingPrice"`
	Points       *Points    `json:"Points,omitempty"`
	Shipping     *MoneyType `json:"Shipping,omitempty"`
}

// GetMyFeesEstimatesJSONRequestBody defines body for GetMyFeesEstimates for application/json ContentType.
type GetMyFeesEstimatesJSONRequestBody = GetMyFeesEstimatesRequest

// GetMyFeesEstimateForASINJSONRequestBody defines body for GetMyFeesEstimateForASIN for application/json ContentType.
type GetMyFeesEstimateForASINJSONRequestBody = GetMyFeesEstimateRequest

// GetMyFeesEstimateForSKUJSONRequestBody defines body for GetMyFeesEstimateForSKU for application/json ContentType.
type GetMyFeesEstimateForSKUJSONRequestBody = GetMyFeesEstimateRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetMyFeesEstimatesWithBody request with any body
	GetMyFeesEstimatesWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	GetMyFeesEstimates(ctx context.Context, body GetMyFeesEstimatesJSONRequestBody) (*http.Response, error)

	// GetMyFeesEstimateForASINWithBody request with any body
	GetMyFeesEstimateForASINWithBody(ctx context.Context, asin string, contentType string, body io.Reader) (*http.Response, error)

	GetMyFeesEstimateForASIN(ctx context.Context, asin string, body GetMyFeesEstimateForASINJSONRequestBody) (*http.Response, error)

	// GetMyFeesEstimateForSKUWithBody request with any body
	GetMyFeesEstimateForSKUWithBody(ctx context.Context, sellerSKU string, contentType string, body io.Reader) (*http.Response, error)

	GetMyFeesEstimateForSKU(ctx context.Context, sellerSKU string, body GetMyFeesEstimateForSKUJSONRequestBody) (*http.Response, error)
}

func (c *Client) GetMyFeesEstimatesWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetMyFeesEstimatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetMyFeesEstimates(ctx context.Context, body GetMyFeesEstimatesJSONRequestBody) (*http.Response, error) {
	req, err := NewGetMyFeesEstimatesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetMyFeesEstimateForASINWithBody(ctx context.Context, asin string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetMyFeesEstimateForASINRequestWithBody(c.Server, asin, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetMyFeesEstimateForASIN(ctx context.Context, asin string, body GetMyFeesEstimateForASINJSONRequestBody) (*http.Response, error) {
	req, err := NewGetMyFeesEstimateForASINRequest(c.Server, asin, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetMyFeesEstimateForSKUWithBody(ctx context.Context, sellerSKU string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetMyFeesEstimateForSKURequestWithBody(c.Server, sellerSKU, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetMyFeesEstimateForSKU(ctx context.Context, sellerSKU string, body GetMyFeesEstimateForSKUJSONRequestBody) (*http.Response, error) {
	req, err := NewGetMyFeesEstimateForSKURequest(c.Server, sellerSKU, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewGetMyFeesEstimatesRequest calls the generic GetMyFeesEstimates builder with application/json body
func NewGetMyFeesEstimatesRequest(server string, body GetMyFeesEstimatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMyFeesEstimatesRequestWithBody(server, "application/json", bodyReader)
}

// NewGetMyFeesEstimatesRequestWithBody generates requests for GetMyFeesEstimates with any type of body
func NewGetMyFeesEstimatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/fees/v0/feesEstimate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMyFeesEstimateForASINRequest calls the generic GetMyFeesEstimateForASIN builder with application/json body
func NewGetMyFeesEstimateForASINRequest(server string, asin string, body GetMyFeesEstimateForASINJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMyFeesEstimateForASINRequestWithBody(server, asin, "application/json", bodyReader)
}

// NewGetMyFeesEstimateForASINRequestWithBody generates requests for GetMyFeesEstimateForASIN with any type of body
func NewGetMyFeesEstimateForASINRequestWithBody(server string, asin string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "Asin", runtime.ParamLocationPath, asin)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/fees/v0/items/%s/feesEstimate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMyFeesEstimateForSKURequest calls the generic GetMyFeesEstimateForSKU builder with application/json body
func NewGetMyFeesEstimateForSKURequest(server string, sellerSKU string, body GetMyFeesEstimateForSKUJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMyFeesEstimateForSKURequestWithBody(server, sellerSKU, "application/json", bodyReader)
}

// NewGetMyFeesEstimateForSKURequestWithBody generates requests for GetMyFeesEstimateForSKU with any type of body
func NewGetMyFeesEstimateForSKURequestWithBody(server string, sellerSKU string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "SellerSKU", runtime.ParamLocationPath, sellerSKU)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/fees/v0/listings/%s/feesEstimate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetMyFeesEstimatesWithBodyWithResponse request with any body
	GetMyFeesEstimatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetMyFeesEstimatesResp, error)

	GetMyFeesEstimatesWithResponse(ctx context.Context, body GetMyFeesEstimatesJSONRequestBody) (*GetMyFeesEstimatesResp, error)

	// GetMyFeesEstimateForASINWithBodyWithResponse request with any body
	GetMyFeesEstimateForASINWithBodyWithResponse(ctx context.Context, asin string, contentType string, body io.Reader) (*GetMyFeesEstimateForASINResp, error)

	GetMyFeesEstimateForASINWithResponse(ctx context.Context, asin string, body GetMyFeesEstimateForASINJSONRequestBody) (*GetMyFeesEstimateForASINResp, error)

	// GetMyFeesEstimateForSKUWithBodyWithResponse request with any body
	GetMyFeesEstimateForSKUWithBodyWithResponse(ctx context.Context, sellerSKU string, contentType string, body io.Reader) (*GetMyFeesEstimateForSKUResp, error)

	GetMyFeesEstimateForSKUWithResponse(ctx context.Context, sellerSKU string, body GetMyFeesEstimateForSKUJSONRequestBody) (*GetMyFeesEstimateForSKUResp, error)
}

type GetMyFeesEstimatesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetMyFeesEstimatesResponse
	JSON400      *GetMyFeesEstimatesErrorList
	JSON401      *GetMyFeesEstimatesErrorList
	JSON403      *GetMyFeesEstimatesErrorList
	JSON404      *GetMyFeesEstimatesErrorList
	JSON429      *GetMyFeesEstimatesErrorList
	JSON500      *GetMyFeesEstimatesErrorList
	JSON503      *GetMyFeesEstimatesErrorList
}

// Status returns HTTPResponse.Status
func (r GetMyFeesEstimatesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMyFeesEstimatesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMyFeesEstimateForASINResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetMyFeesEstimateResponse
	JSON400      *GetMyFeesEstimateResponse
	JSON401      *GetMyFeesEstimateResponse
	JSON403      *GetMyFeesEstimateResponse
	JSON404      *GetMyFeesEstimateResponse
	JSON429      *GetMyFeesEstimateResponse
	JSON500      *GetMyFeesEstimateResponse
	JSON503      *GetMyFeesEstimateResponse
}

// Status returns HTTPResponse.Status
func (r GetMyFeesEstimateForASINResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMyFeesEstimateForASINResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMyFeesEstimateForSKUResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetMyFeesEstimateResponse
	JSON400      *GetMyFeesEstimateResponse
	JSON401      *GetMyFeesEstimateResponse
	JSON403      *GetMyFeesEstimateResponse
	JSON404      *GetMyFeesEstimateResponse
	JSON429      *GetMyFeesEstimateResponse
	JSON500      *GetMyFeesEstimateResponse
	JSON503      *GetMyFeesEstimateResponse
}

// Status returns HTTPResponse.Status
func (r GetMyFeesEstimateForSKUResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMyFeesEstimateForSKUResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetMyFeesEstimatesWithBodyWithResponse request with arbitrary body returning *GetMyFeesEstimatesResp
func (c *ClientWithResponses) GetMyFeesEstimatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetMyFeesEstimatesResp, error) {
	rsp, err := c.GetMyFeesEstimatesWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetMyFeesEstimatesResp(rsp)
}

func (c *ClientWithResponses) GetMyFeesEstimatesWithResponse(ctx context.Context, body GetMyFeesEstimatesJSONRequestBody) (*GetMyFeesEstimatesResp, error) {
	rsp, err := c.GetMyFeesEstimates(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseGetMyFeesEstimatesResp(rsp)
}

// GetMyFeesEstimateForASINWithBodyWithResponse request with arbitrary body returning *GetMyFeesEstimateForASINResp
func (c *ClientWithResponses) GetMyFeesEstimateForASINWithBodyWithResponse(ctx context.Context, asin string, contentType string, body io.Reader) (*GetMyFeesEstimateForASINResp, error) {
	rsp, err := c.GetMyFeesEstimateForASINWithBody(ctx, asin, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetMyFeesEstimateForASINResp(rsp)
}

func (c *ClientWithResponses) GetMyFeesEstimateForASINWithResponse(ctx context.Context, asin string, body GetMyFeesEstimateForASINJSONRequestBody) (*GetMyFeesEstimateForASINResp, error) {
	rsp, err := c.GetMyFeesEstimateForASIN(ctx, asin, body)
	if err != nil {
		return nil, err
	}
	return ParseGetMyFeesEstimateForASINResp(rsp)
}

// GetMyFeesEstimateForSKUWithBodyWithResponse request with arbitrary body returning *GetMyFeesEstimateForSKUResp
func (c *ClientWithResponses) GetMyFeesEstimateForSKUWithBodyWithResponse(ctx context.Context, sellerSKU string, contentType string, body io.Reader) (*GetMyFeesEstimateForSKUResp, error) {
	rsp, err := c.GetMyFeesEstimateForSKUWithBody(ctx, sellerSKU, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetMyFeesEstimateForSKUResp(rsp)
}

func (c *ClientWithResponses) GetMyFeesEstimateForSKUWithResponse(ctx context.Context, sellerSKU string, body GetMyFeesEstimateForSKUJSONRequestBody) (*GetMyFeesEstimateForSKUResp, error) {
	rsp, err := c.GetMyFeesEstimateForSKU(ctx, sellerSKU, body)
	if err != nil {
		return nil, err
	}
	return ParseGetMyFeesEstimateForSKUResp(rsp)
}

// ParseGetMyFeesEstimatesResp parses an HTTP response from a GetMyFeesEstimatesWithResponse call
func ParseGetMyFeesEstimatesResp(rsp *http.Response) (*GetMyFeesEstimatesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMyFeesEstimatesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetMyFeesEstimatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetMyFeesEstimatesErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetMyFeesEstimatesErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetMyFeesEstimatesErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetMyFeesEstimatesErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetMyFeesEstimatesErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetMyFeesEstimatesErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetMyFeesEstimatesErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetMyFeesEstimateForASINResp parses an HTTP response from a GetMyFeesEstimateForASINWithResponse call
func ParseGetMyFeesEstimateForASINResp(rsp *http.Response) (*GetMyFeesEstimateForASINResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMyFeesEstimateForASINResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetMyFeesEstimateForSKUResp parses an HTTP response from a GetMyFeesEstimateForSKUWithResponse call
func ParseGetMyFeesEstimateForSKUResp(rsp *http.Response) (*GetMyFeesEstimateForSKUResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMyFeesEstimateForSKUResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetMyFeesEstimateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
