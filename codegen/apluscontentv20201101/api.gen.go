// Package apluscontentv20201101 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package apluscontentv20201101

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/bytedance/sonic"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AsinBadge.
const (
	BRANDNOTELIGIBLE    AsinBadge = "BRAND_NOT_ELIGIBLE"
	CATALOGNOTFOUND     AsinBadge = "CATALOG_NOT_FOUND"
	CONTENTNOTPUBLISHED AsinBadge = "CONTENT_NOT_PUBLISHED"
	CONTENTPUBLISHED    AsinBadge = "CONTENT_PUBLISHED"
)

// Defines values for ColorType.
const (
	DARK  ColorType = "DARK"
	LIGHT ColorType = "LIGHT"
)

// Defines values for ContentBadge.
const (
	BULK      ContentBadge = "BULK"
	GENERATED ContentBadge = "GENERATED"
	LAUNCHPAD ContentBadge = "LAUNCHPAD"
	PREMIUM   ContentBadge = "PREMIUM"
	STANDARD  ContentBadge = "STANDARD"
)

// Defines values for ContentModuleType.
const (
	STANDARDCOMPANYLOGO            ContentModuleType = "STANDARD_COMPANY_LOGO"
	STANDARDCOMPARISONTABLE        ContentModuleType = "STANDARD_COMPARISON_TABLE"
	STANDARDFOURIMAGETEXT          ContentModuleType = "STANDARD_FOUR_IMAGE_TEXT"
	STANDARDFOURIMAGETEXTQUADRANT  ContentModuleType = "STANDARD_FOUR_IMAGE_TEXT_QUADRANT"
	STANDARDHEADERIMAGETEXT        ContentModuleType = "STANDARD_HEADER_IMAGE_TEXT"
	STANDARDIMAGESIDEBAR           ContentModuleType = "STANDARD_IMAGE_SIDEBAR"
	STANDARDIMAGETEXTOVERLAY       ContentModuleType = "STANDARD_IMAGE_TEXT_OVERLAY"
	STANDARDMULTIPLEIMAGETEXT      ContentModuleType = "STANDARD_MULTIPLE_IMAGE_TEXT"
	STANDARDPRODUCTDESCRIPTION     ContentModuleType = "STANDARD_PRODUCT_DESCRIPTION"
	STANDARDSINGLEIMAGEHIGHLIGHTS  ContentModuleType = "STANDARD_SINGLE_IMAGE_HIGHLIGHTS"
	STANDARDSINGLEIMAGESPECSDETAIL ContentModuleType = "STANDARD_SINGLE_IMAGE_SPECS_DETAIL"
	STANDARDSINGLESIDEIMAGE        ContentModuleType = "STANDARD_SINGLE_SIDE_IMAGE"
	STANDARDTECHSPECS              ContentModuleType = "STANDARD_TECH_SPECS"
	STANDARDTEXT                   ContentModuleType = "STANDARD_TEXT"
	STANDARDTHREEIMAGETEXT         ContentModuleType = "STANDARD_THREE_IMAGE_TEXT"
)

// Defines values for ContentStatus.
const (
	APPROVED  ContentStatus = "APPROVED"
	DRAFT     ContentStatus = "DRAFT"
	REJECTED  ContentStatus = "REJECTED"
	SUBMITTED ContentStatus = "SUBMITTED"
)

// Defines values for ContentType.
const (
	EBC ContentType = "EBC"
	EMC ContentType = "EMC"
)

// Defines values for DecoratorType.
const (
	LISTITEM       DecoratorType = "LIST_ITEM"
	LISTORDERED    DecoratorType = "LIST_ORDERED"
	LISTUNORDERED  DecoratorType = "LIST_UNORDERED"
	STYLEBOLD      DecoratorType = "STYLE_BOLD"
	STYLEITALIC    DecoratorType = "STYLE_ITALIC"
	STYLELINEBREAK DecoratorType = "STYLE_LINEBREAK"
	STYLEPARAGRAPH DecoratorType = "STYLE_PARAGRAPH"
	STYLEUNDERLINE DecoratorType = "STYLE_UNDERLINE"
)

// Defines values for PositionType.
const (
	LEFT  PositionType = "LEFT"
	RIGHT PositionType = "RIGHT"
)

// Defines values for GetContentDocumentParamsIncludedDataSet.
const (
	GetContentDocumentParamsIncludedDataSetCONTENTS GetContentDocumentParamsIncludedDataSet = "CONTENTS"
	GetContentDocumentParamsIncludedDataSetMETADATA GetContentDocumentParamsIncludedDataSet = "METADATA"
)

// Defines values for ListContentDocumentAsinRelationsParamsIncludedDataSet.
const (
	ListContentDocumentAsinRelationsParamsIncludedDataSetMETADATA ListContentDocumentAsinRelationsParamsIncludedDataSet = "METADATA"
)

// AplusPaginatedResponse defines model for AplusPaginatedResponse.
type AplusPaginatedResponse struct {
	// NextPageToken A page token that is returned when the results of the call exceed the page size. To get another page of results, call the operation again, passing in this value with the pageToken parameter.
	NextPageToken *PageToken `json:"nextPageToken,omitempty"`

	// Warnings A set of messages to the user, such as warnings or comments.
	Warnings *MessageSet `json:"warnings,omitempty"`
}

// AplusResponse The base response data for all A+ Content operations when a request is successful or partially successful. Individual operations may extend this with additional data.
type AplusResponse struct {
	// Warnings A set of messages to the user, such as warnings or comments.
	Warnings *MessageSet `json:"warnings,omitempty"`
}

// Asin The Amazon Standard Identification Number (ASIN).
type Asin = string

// AsinBadge A flag that provides additional information about an ASIN. This is contextual and may change depending on the request that generated it.
type AsinBadge string

// AsinBadgeSet The set of ASIN badges.
type AsinBadgeSet = []AsinBadge

// AsinMetadata The A+ Content ASIN with additional metadata for content management. If you don't include the `includedDataSet` parameter in a call to the listContentDocumentAsinRelations operation, the related ASINs are returned without metadata.
type AsinMetadata struct {
	// Asin The Amazon Standard Identification Number (ASIN).
	Asin Asin `json:"asin"`

	// BadgeSet The set of ASIN badges.
	BadgeSet *AsinBadgeSet `json:"badgeSet,omitempty"`

	// ContentReferenceKeySet A set of content reference keys.
	ContentReferenceKeySet *ContentReferenceKeySet `json:"contentReferenceKeySet,omitempty"`

	// ImageUrl The default image for the ASIN in the Amazon catalog.
	ImageUrl *string `json:"imageUrl,omitempty"`

	// Parent The Amazon Standard Identification Number (ASIN).
	Parent *Asin `json:"parent,omitempty"`

	// Title The title for the ASIN in the Amazon catalog.
	Title *string `json:"title,omitempty"`
}

// AsinMetadataSet The set of ASIN metadata.
type AsinMetadataSet = []AsinMetadata

// AsinSet The set of ASINs.
type AsinSet = []Asin

// ColorType The relative color scheme of content.
type ColorType string

// ContentBadge A flag that provides additional information about an A+ Content document.
type ContentBadge string

// ContentBadgeSet The set of content badges.
type ContentBadgeSet = []ContentBadge

// ContentDocument The A+ Content document. This is the enhanced content that is published to product detail pages.
type ContentDocument struct {
	// ContentModuleList A list of A+ Content modules.
	ContentModuleList ContentModuleList `json:"contentModuleList"`

	// ContentSubType The A+ Content document subtype. This represents a special-purpose type of an A+ Content document. Not every A+ Content document type will have a subtype, and subtypes may change at any time.
	ContentSubType *ContentSubType `json:"contentSubType,omitempty"`

	// ContentType The A+ Content document type.
	ContentType ContentType `json:"contentType"`

	// Locale The IETF language tag. This only supports the primary language subtag with one secondary language subtag. The secondary language subtag is almost always a regional designation. This does not support additional subtags beyond the primary and secondary subtags.
	// **Pattern:** ^[a-z]{2,}-[A-Z0-9]{2,}$
	Locale LanguageTag `json:"locale"`

	// Name The A+ Content document name.
	Name string `json:"name"`
}

// ContentMetadata The metadata of an A+ Content document.
type ContentMetadata struct {
	// BadgeSet The set of content badges.
	BadgeSet ContentBadgeSet `json:"badgeSet"`

	// MarketplaceId The identifier for the marketplace where the A+ Content is published.
	MarketplaceId MarketplaceId `json:"marketplaceId"`

	// Name The A+ Content document name.
	Name string `json:"name"`

	// Status The submission status of the content document.
	Status ContentStatus `json:"status"`

	// UpdateTime The approximate age of the A+ Content document and metadata.
	UpdateTime time.Time `json:"updateTime"`
}

// ContentMetadataRecord The metadata for an A+ Content document, with additional information for content management.
type ContentMetadataRecord struct {
	// ContentMetadata The metadata of an A+ Content document.
	ContentMetadata ContentMetadata `json:"contentMetadata"`

	// ContentReferenceKey A unique reference key for the A+ Content document. A content reference key cannot form a permalink and may change in the future. A content reference key is not guaranteed to match any A+ content identifier.
	ContentReferenceKey ContentReferenceKey `json:"contentReferenceKey"`
}

// ContentMetadataRecordList A list of A+ Content metadata records.
type ContentMetadataRecordList = []ContentMetadataRecord

// ContentModule An A+ Content module. An A+ Content document is composed of content modules. The contentModuleType property selects which content module types to use.
type ContentModule struct {
	// ContentModuleType The type of A+ Content module.
	ContentModuleType ContentModuleType `json:"contentModuleType"`

	// StandardCompanyLogo The standard company logo image.
	StandardCompanyLogo *StandardCompanyLogoModule `json:"standardCompanyLogo,omitempty"`

	// StandardComparisonTable The standard product comparison table.
	StandardComparisonTable *StandardComparisonTableModule `json:"standardComparisonTable,omitempty"`

	// StandardFourImageText Four standard images with text, presented across a single row.
	StandardFourImageText *StandardFourImageTextModule `json:"standardFourImageText,omitempty"`

	// StandardFourImageTextQuadrant Four standard images with text, presented on a grid of four quadrants.
	StandardFourImageTextQuadrant *StandardFourImageTextQuadrantModule `json:"standardFourImageTextQuadrant,omitempty"`

	// StandardHeaderImageText Standard headline text, an image, and body text.
	StandardHeaderImageText *StandardHeaderImageTextModule `json:"standardHeaderImageText,omitempty"`

	// StandardImageSidebar Two images, two paragraphs, and two bulleted lists. One image is smaller and displayed in the sidebar.
	StandardImageSidebar *StandardImageSidebarModule `json:"standardImageSidebar,omitempty"`

	// StandardImageTextOverlay A standard background image with a floating text box.
	StandardImageTextOverlay *StandardImageTextOverlayModule `json:"standardImageTextOverlay,omitempty"`

	// StandardMultipleImageText Standard images with text, presented one at a time. The user clicks on thumbnails to view each block.
	StandardMultipleImageText *StandardMultipleImageTextModule `json:"standardMultipleImageText,omitempty"`

	// StandardProductDescription Standard product description text.
	StandardProductDescription *StandardProductDescriptionModule `json:"standardProductDescription,omitempty"`

	// StandardSingleImageHighlights A standard image with several paragraphs and a bulleted list.
	StandardSingleImageHighlights *StandardSingleImageHighlightsModule `json:"standardSingleImageHighlights,omitempty"`

	// StandardSingleImageSpecsDetail A standard image with paragraphs and a bulleted list, and extra space for technical details.
	StandardSingleImageSpecsDetail *StandardSingleImageSpecsDetailModule `json:"standardSingleImageSpecsDetail,omitempty"`

	// StandardSingleSideImage A standard headline and body text with an image on the side.
	StandardSingleSideImage *StandardSingleSideImageModule `json:"standardSingleSideImage,omitempty"`

	// StandardTechSpecs The standard table of technical feature names and definitions.
	StandardTechSpecs *StandardTechSpecsModule `json:"standardTechSpecs,omitempty"`

	// StandardText A standard headline and body text.
	StandardText *StandardTextModule `json:"standardText,omitempty"`

	// StandardThreeImageText Three standard images with text, presented across a single row.
	StandardThreeImageText *StandardThreeImageTextModule `json:"standardThreeImageText,omitempty"`
}

// ContentModuleList A list of A+ Content modules.
type ContentModuleList = []ContentModule

// ContentModuleType The type of A+ Content module.
type ContentModuleType string

// ContentRecord A content document with additional information for content management.
type ContentRecord struct {
	// ContentDocument The A+ Content document. This is the enhanced content that is published to product detail pages.
	ContentDocument *ContentDocument `json:"contentDocument,omitempty"`

	// ContentMetadata The metadata of an A+ Content document.
	ContentMetadata *ContentMetadata `json:"contentMetadata,omitempty"`

	// ContentReferenceKey A unique reference key for the A+ Content document. A content reference key cannot form a permalink and may change in the future. A content reference key is not guaranteed to match any A+ content identifier.
	ContentReferenceKey ContentReferenceKey `json:"contentReferenceKey"`
}

// ContentReferenceKey A unique reference key for the A+ Content document. A content reference key cannot form a permalink and may change in the future. A content reference key is not guaranteed to match any A+ content identifier.
type ContentReferenceKey = string

// ContentReferenceKeySet A set of content reference keys.
type ContentReferenceKeySet = []ContentReferenceKey

// ContentStatus The submission status of the content document.
type ContentStatus string

// ContentSubType The A+ Content document subtype. This represents a special-purpose type of an A+ Content document. Not every A+ Content document type will have a subtype, and subtypes may change at any time.
type ContentSubType = string

// ContentType The A+ Content document type.
type ContentType string

// Decorator A decorator applied to a content string value in order to create rich text.
type Decorator struct {
	// Depth The relative intensity or variation of this decorator. Decorators such as bullet-points, for example, can have multiple indentation depths.
	Depth *int `json:"depth,omitempty"`

	// Length The number of content characters to alter with this decorator. Decorators such as line breaks can have zero length and fit between characters.
	Length *int `json:"length,omitempty"`

	// Offset The starting character of this decorator within the content string. Use zero for the first character.
	Offset *int `json:"offset,omitempty"`

	// Type The type of rich text decorator.
	Type *DecoratorType `json:"type,omitempty"`
}

// DecoratorSet A set of content decorators.
type DecoratorSet = []Decorator

// DecoratorType The type of rich text decorator.
type DecoratorType string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code The code that identifies the type of error condition.
	Code string `json:"code"`

	// Details Additional information, if available, to clarify the error condition.
	Details *string `json:"details,omitempty"`

	// Message A human readable description of the error condition.
	Message string `json:"message"`
}

// ErrorList The error response for when a request is unsuccessful.
type ErrorList struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors []Error `json:"errors"`
}

// GetContentDocumentResponse defines model for GetContentDocumentResponse.
type GetContentDocumentResponse struct {
	// ContentRecord A content document with additional information for content management.
	ContentRecord ContentRecord `json:"contentRecord"`

	// Warnings A set of messages to the user, such as warnings or comments.
	Warnings *MessageSet `json:"warnings,omitempty"`
}

// ImageComponent A reference to an image, hosted in the A+ Content media library.
type ImageComponent struct {
	// AltText The alternative text for the image.
	AltText string `json:"altText"`

	// ImageCropSpecification The instructions for optionally cropping an image. If no cropping is desired, set the dimensions to the original image size. If the image is cropped and no offset values are provided, then the coordinates of the top left corner of the cropped image, relative to the original image, are defaulted to (0,0).
	ImageCropSpecification ImageCropSpecification `json:"imageCropSpecification"`

	// UploadDestinationId This identifier is provided by the Selling Partner API for Uploads.
	UploadDestinationId string `json:"uploadDestinationId"`
}

// ImageCropSpecification The instructions for optionally cropping an image. If no cropping is desired, set the dimensions to the original image size. If the image is cropped and no offset values are provided, then the coordinates of the top left corner of the cropped image, relative to the original image, are defaulted to (0,0).
type ImageCropSpecification struct {
	// Offset The top left corner of the cropped image, specified in the original image's coordinate space.
	Offset *ImageOffsets `json:"offset,omitempty"`

	// Size The dimensions extending from the top left corner of the cropped image, or the top left corner of the original image if there is no cropping. Only `pixels` is allowed as the units value for ImageDimensions.
	Size ImageDimensions `json:"size"`
}

// ImageDimensions The dimensions extending from the top left corner of the cropped image, or the top left corner of the original image if there is no cropping. Only `pixels` is allowed as the units value for ImageDimensions.
type ImageDimensions struct {
	// Height A whole number dimension and its unit of measurement. For example, this can represent 100 pixels.
	Height IntegerWithUnits `json:"height"`

	// Width A whole number dimension and its unit of measurement. For example, this can represent 100 pixels.
	Width IntegerWithUnits `json:"width"`
}

// ImageOffsets The top left corner of the cropped image, specified in the original image's coordinate space.
type ImageOffsets struct {
	// X A whole number dimension and its unit of measurement. For example, this can represent 100 pixels.
	X IntegerWithUnits `json:"x"`

	// Y A whole number dimension and its unit of measurement. For example, this can represent 100 pixels.
	Y IntegerWithUnits `json:"y"`
}

// IntegerWithUnits A whole number dimension and its unit of measurement. For example, this can represent 100 pixels.
type IntegerWithUnits struct {
	// Units The unit of measurement.
	Units string `json:"units"`

	// Value The dimension value.
	Value int `json:"value"`
}

// LanguageTag The IETF language tag. This only supports the primary language subtag with one secondary language subtag. The secondary language subtag is almost always a regional designation. This does not support additional subtags beyond the primary and secondary subtags.
// **Pattern:** ^[a-z]{2,}-[A-Z0-9]{2,}$
type LanguageTag = string

// ListContentDocumentAsinRelationsResponse defines model for ListContentDocumentAsinRelationsResponse.
type ListContentDocumentAsinRelationsResponse struct {
	// AsinMetadataSet The set of ASIN metadata.
	AsinMetadataSet AsinMetadataSet `json:"asinMetadataSet"`

	// NextPageToken A page token that is returned when the results of the call exceed the page size. To get another page of results, call the operation again, passing in this value with the pageToken parameter.
	NextPageToken *PageToken `json:"nextPageToken,omitempty"`

	// Warnings A set of messages to the user, such as warnings or comments.
	Warnings *MessageSet `json:"warnings,omitempty"`
}

// MarketplaceId The identifier for the marketplace where the A+ Content is published.
type MarketplaceId = string

// MessageSet A set of messages to the user, such as warnings or comments.
type MessageSet = []Error

// PageToken A page token that is returned when the results of the call exceed the page size. To get another page of results, call the operation again, passing in this value with the pageToken parameter.
type PageToken = string

// ParagraphComponent A list of rich text content, usually presented in a text box.
type ParagraphComponent struct {
	TextList []TextComponent `json:"textList"`
}

// PlainTextItem Plain positional text, used in collections of brief labels and descriptors.
type PlainTextItem struct {
	// Position The rank or index of this text item within the collection. Different items cannot occupy the same position within a single collection.
	Position int `json:"position"`

	// Value The actual plain text.
	Value string `json:"value"`
}

// PositionType The relative positioning of content.
type PositionType string

// PostContentDocumentApprovalSubmissionResponse The base response data for all A+ Content operations when a request is successful or partially successful. Individual operations may extend this with additional data.
type PostContentDocumentApprovalSubmissionResponse = AplusResponse

// PostContentDocumentAsinRelationsRequest defines model for PostContentDocumentAsinRelationsRequest.
type PostContentDocumentAsinRelationsRequest struct {
	// AsinSet The set of ASINs.
	AsinSet AsinSet `json:"asinSet"`
}

// PostContentDocumentAsinRelationsResponse The base response data for all A+ Content operations when a request is successful or partially successful. Individual operations may extend this with additional data.
type PostContentDocumentAsinRelationsResponse = AplusResponse

// PostContentDocumentRequest defines model for PostContentDocumentRequest.
type PostContentDocumentRequest struct {
	// ContentDocument The A+ Content document. This is the enhanced content that is published to product detail pages.
	ContentDocument ContentDocument `json:"contentDocument"`
}

// PostContentDocumentResponse defines model for PostContentDocumentResponse.
type PostContentDocumentResponse struct {
	// ContentReferenceKey A unique reference key for the A+ Content document. A content reference key cannot form a permalink and may change in the future. A content reference key is not guaranteed to match any A+ content identifier.
	ContentReferenceKey ContentReferenceKey `json:"contentReferenceKey"`

	// Warnings A set of messages to the user, such as warnings or comments.
	Warnings *MessageSet `json:"warnings,omitempty"`
}

// PostContentDocumentSuspendSubmissionResponse The base response data for all A+ Content operations when a request is successful or partially successful. Individual operations may extend this with additional data.
type PostContentDocumentSuspendSubmissionResponse = AplusResponse

// PublishRecord The full context for an A+ Content publishing event.
type PublishRecord struct {
	// Asin The Amazon Standard Identification Number (ASIN).
	Asin Asin `json:"asin"`

	// ContentReferenceKey A unique reference key for the A+ Content document. A content reference key cannot form a permalink and may change in the future. A content reference key is not guaranteed to match any A+ content identifier.
	ContentReferenceKey ContentReferenceKey `json:"contentReferenceKey"`

	// ContentSubType The A+ Content document subtype. This represents a special-purpose type of an A+ Content document. Not every A+ Content document type will have a subtype, and subtypes may change at any time.
	ContentSubType *ContentSubType `json:"contentSubType,omitempty"`

	// ContentType The A+ Content document type.
	ContentType ContentType `json:"contentType"`

	// Locale The IETF language tag. This only supports the primary language subtag with one secondary language subtag. The secondary language subtag is almost always a regional designation. This does not support additional subtags beyond the primary and secondary subtags.
	// **Pattern:** ^[a-z]{2,}-[A-Z0-9]{2,}$
	Locale LanguageTag `json:"locale"`

	// MarketplaceId The identifier for the marketplace where the A+ Content is published.
	MarketplaceId MarketplaceId `json:"marketplaceId"`
}

// PublishRecordList A list of A+ Content publishing records.
type PublishRecordList = []PublishRecord

// SearchContentDocumentsResponse defines model for SearchContentDocumentsResponse.
type SearchContentDocumentsResponse struct {
	// ContentMetadataRecords A list of A+ Content metadata records.
	ContentMetadataRecords ContentMetadataRecordList `json:"contentMetadataRecords"`

	// NextPageToken A page token that is returned when the results of the call exceed the page size. To get another page of results, call the operation again, passing in this value with the pageToken parameter.
	NextPageToken *PageToken `json:"nextPageToken,omitempty"`

	// Warnings A set of messages to the user, such as warnings or comments.
	Warnings *MessageSet `json:"warnings,omitempty"`
}

// SearchContentPublishRecordsResponse defines model for SearchContentPublishRecordsResponse.
type SearchContentPublishRecordsResponse struct {
	// NextPageToken A page token that is returned when the results of the call exceed the page size. To get another page of results, call the operation again, passing in this value with the pageToken parameter.
	NextPageToken *PageToken `json:"nextPageToken,omitempty"`

	// PublishRecordList A list of A+ Content publishing records.
	PublishRecordList PublishRecordList `json:"publishRecordList"`

	// Warnings A set of messages to the user, such as warnings or comments.
	Warnings *MessageSet `json:"warnings,omitempty"`
}

// StandardCompanyLogoModule The standard company logo image.
type StandardCompanyLogoModule struct {
	// CompanyLogo A reference to an image, hosted in the A+ Content media library.
	CompanyLogo ImageComponent `json:"companyLogo"`
}

// StandardComparisonProductBlock The A+ Content standard comparison product block.
type StandardComparisonProductBlock struct {
	// Asin The Amazon Standard Identification Number (ASIN).
	Asin *Asin `json:"asin,omitempty"`

	// Highlight Determines whether this block of content is visually highlighted.
	Highlight *bool `json:"highlight,omitempty"`

	// Image A reference to an image, hosted in the A+ Content media library.
	Image *ImageComponent `json:"image,omitempty"`

	// Metrics Comparison metrics for the product.
	Metrics *[]PlainTextItem `json:"metrics,omitempty"`

	// Position The rank or index of this comparison product block within the module. Different blocks cannot occupy the same position within a single module.
	Position int `json:"position"`

	// Title The comparison product title.
	Title *string `json:"title,omitempty"`
}

// StandardComparisonTableModule The standard product comparison table.
type StandardComparisonTableModule struct {
	MetricRowLabels *[]PlainTextItem                  `json:"metricRowLabels,omitempty"`
	ProductColumns  *[]StandardComparisonProductBlock `json:"productColumns,omitempty"`
}

// StandardFourImageTextModule Four standard images with text, presented across a single row.
type StandardFourImageTextModule struct {
	// Block1 The A+ Content standard image and text box block.
	Block1 *StandardImageTextBlock `json:"block1,omitempty"`

	// Block2 The A+ Content standard image and text box block.
	Block2 *StandardImageTextBlock `json:"block2,omitempty"`

	// Block3 The A+ Content standard image and text box block.
	Block3 *StandardImageTextBlock `json:"block3,omitempty"`

	// Block4 The A+ Content standard image and text box block.
	Block4 *StandardImageTextBlock `json:"block4,omitempty"`

	// Headline Rich text content.
	Headline *TextComponent `json:"headline,omitempty"`
}

// StandardFourImageTextQuadrantModule Four standard images with text, presented on a grid of four quadrants.
type StandardFourImageTextQuadrantModule struct {
	// Block1 The A+ Content standard image and text box block.
	Block1 StandardImageTextBlock `json:"block1"`

	// Block2 The A+ Content standard image and text box block.
	Block2 StandardImageTextBlock `json:"block2"`

	// Block3 The A+ Content standard image and text box block.
	Block3 StandardImageTextBlock `json:"block3"`

	// Block4 The A+ Content standard image and text box block.
	Block4 StandardImageTextBlock `json:"block4"`
}

// StandardHeaderImageTextModule Standard headline text, an image, and body text.
type StandardHeaderImageTextModule struct {
	// Block The A+ Content standard image and text box block.
	Block *StandardImageTextBlock `json:"block,omitempty"`

	// Headline Rich text content.
	Headline *TextComponent `json:"headline,omitempty"`
}

// StandardHeaderTextListBlock The A+ standard fixed-length list of text, with a related headline.
type StandardHeaderTextListBlock struct {
	// Block The A+ Content standard fixed length list of text, usually presented as bullet points.
	Block *StandardTextListBlock `json:"block,omitempty"`

	// Headline Rich text content.
	Headline *TextComponent `json:"headline,omitempty"`
}

// StandardImageCaptionBlock The A+ Content standard image and caption block.
type StandardImageCaptionBlock struct {
	// Caption Rich text content.
	Caption *TextComponent `json:"caption,omitempty"`

	// Image A reference to an image, hosted in the A+ Content media library.
	Image *ImageComponent `json:"image,omitempty"`
}

// StandardImageSidebarModule Two images, two paragraphs, and two bulleted lists. One image is smaller and displayed in the sidebar.
type StandardImageSidebarModule struct {
	// DescriptionListBlock The A+ Content standard fixed length list of text, usually presented as bullet points.
	DescriptionListBlock *StandardTextListBlock `json:"descriptionListBlock,omitempty"`

	// DescriptionTextBlock The A+ Content standard text box block, comprised of a paragraph with a headline.
	DescriptionTextBlock *StandardTextBlock `json:"descriptionTextBlock,omitempty"`

	// Headline Rich text content.
	Headline *TextComponent `json:"headline,omitempty"`

	// ImageCaptionBlock The A+ Content standard image and caption block.
	ImageCaptionBlock *StandardImageCaptionBlock `json:"imageCaptionBlock,omitempty"`

	// SidebarImageTextBlock The A+ Content standard image and text box block.
	SidebarImageTextBlock *StandardImageTextBlock `json:"sidebarImageTextBlock,omitempty"`

	// SidebarListBlock The A+ Content standard fixed length list of text, usually presented as bullet points.
	SidebarListBlock *StandardTextListBlock `json:"sidebarListBlock,omitempty"`
}

// StandardImageTextBlock The A+ Content standard image and text box block.
type StandardImageTextBlock struct {
	// Body A list of rich text content, usually presented in a text box.
	Body *ParagraphComponent `json:"body,omitempty"`

	// Headline Rich text content.
	Headline *TextComponent `json:"headline,omitempty"`

	// Image A reference to an image, hosted in the A+ Content media library.
	Image *ImageComponent `json:"image,omitempty"`
}

// StandardImageTextCaptionBlock The A+ Content standard image and text block, with a related caption. The caption may not display on all devices.
type StandardImageTextCaptionBlock struct {
	// Block The A+ Content standard image and text box block.
	Block *StandardImageTextBlock `json:"block,omitempty"`

	// Caption Rich text content.
	Caption *TextComponent `json:"caption,omitempty"`
}

// StandardImageTextOverlayModule A standard background image with a floating text box.
type StandardImageTextOverlayModule struct {
	// Block The A+ Content standard image and text box block.
	Block *StandardImageTextBlock `json:"block,omitempty"`

	// OverlayColorType The relative color scheme of content.
	OverlayColorType ColorType `json:"overlayColorType"`
}

// StandardMultipleImageTextModule Standard images with text, presented one at a time. The user clicks on thumbnails to view each block.
type StandardMultipleImageTextModule struct {
	Blocks *[]StandardImageTextCaptionBlock `json:"blocks,omitempty"`
}

// StandardProductDescriptionModule Standard product description text.
type StandardProductDescriptionModule struct {
	// Body A list of rich text content, usually presented in a text box.
	Body ParagraphComponent `json:"body"`
}

// StandardSingleImageHighlightsModule A standard image with several paragraphs and a bulleted list.
type StandardSingleImageHighlightsModule struct {
	// BulletedListBlock The A+ standard fixed-length list of text, with a related headline.
	BulletedListBlock *StandardHeaderTextListBlock `json:"bulletedListBlock,omitempty"`

	// Headline Rich text content.
	Headline *TextComponent `json:"headline,omitempty"`

	// Image A reference to an image, hosted in the A+ Content media library.
	Image *ImageComponent `json:"image,omitempty"`

	// TextBlock1 The A+ Content standard text box block, comprised of a paragraph with a headline.
	TextBlock1 *StandardTextBlock `json:"textBlock1,omitempty"`

	// TextBlock2 The A+ Content standard text box block, comprised of a paragraph with a headline.
	TextBlock2 *StandardTextBlock `json:"textBlock2,omitempty"`

	// TextBlock3 The A+ Content standard text box block, comprised of a paragraph with a headline.
	TextBlock3 *StandardTextBlock `json:"textBlock3,omitempty"`
}

// StandardSingleImageSpecsDetailModule A standard image with paragraphs and a bulleted list, and extra space for technical details.
type StandardSingleImageSpecsDetailModule struct {
	// DescriptionBlock1 The A+ Content standard text box block, comprised of a paragraph with a headline.
	DescriptionBlock1 *StandardTextBlock `json:"descriptionBlock1,omitempty"`

	// DescriptionBlock2 The A+ Content standard text box block, comprised of a paragraph with a headline.
	DescriptionBlock2 *StandardTextBlock `json:"descriptionBlock2,omitempty"`

	// DescriptionHeadline Rich text content.
	DescriptionHeadline *TextComponent `json:"descriptionHeadline,omitempty"`

	// Headline Rich text content.
	Headline *TextComponent `json:"headline,omitempty"`

	// Image A reference to an image, hosted in the A+ Content media library.
	Image *ImageComponent `json:"image,omitempty"`

	// SpecificationHeadline Rich text content.
	SpecificationHeadline *TextComponent `json:"specificationHeadline,omitempty"`

	// SpecificationListBlock The A+ standard fixed-length list of text, with a related headline.
	SpecificationListBlock *StandardHeaderTextListBlock `json:"specificationListBlock,omitempty"`

	// SpecificationTextBlock The A+ Content standard text box block, comprised of a paragraph with a headline.
	SpecificationTextBlock *StandardTextBlock `json:"specificationTextBlock,omitempty"`
}

// StandardSingleSideImageModule A standard headline and body text with an image on the side.
type StandardSingleSideImageModule struct {
	// Block The A+ Content standard image and text box block.
	Block *StandardImageTextBlock `json:"block,omitempty"`

	// ImagePositionType The relative positioning of content.
	ImagePositionType PositionType `json:"imagePositionType"`
}

// StandardTechSpecsModule The standard table of technical feature names and definitions.
type StandardTechSpecsModule struct {
	// Headline Rich text content.
	Headline *TextComponent `json:"headline,omitempty"`

	// SpecificationList The specification list.
	SpecificationList []StandardTextPairBlock `json:"specificationList"`

	// TableCount The number of tables to present. Features are evenly divided between the tables.
	TableCount *int `json:"tableCount,omitempty"`
}

// StandardTextBlock The A+ Content standard text box block, comprised of a paragraph with a headline.
type StandardTextBlock struct {
	// Body A list of rich text content, usually presented in a text box.
	Body *ParagraphComponent `json:"body,omitempty"`

	// Headline Rich text content.
	Headline *TextComponent `json:"headline,omitempty"`
}

// StandardTextListBlock The A+ Content standard fixed length list of text, usually presented as bullet points.
type StandardTextListBlock struct {
	TextList []TextItem `json:"textList"`
}

// StandardTextModule A standard headline and body text.
type StandardTextModule struct {
	// Body A list of rich text content, usually presented in a text box.
	Body ParagraphComponent `json:"body"`

	// Headline Rich text content.
	Headline *TextComponent `json:"headline,omitempty"`
}

// StandardTextPairBlock The A+ Content standard label and description block, comprised of a pair of text components.
type StandardTextPairBlock struct {
	// Description Rich text content.
	Description *TextComponent `json:"description,omitempty"`

	// Label Rich text content.
	Label *TextComponent `json:"label,omitempty"`
}

// StandardThreeImageTextModule Three standard images with text, presented across a single row.
type StandardThreeImageTextModule struct {
	// Block1 The A+ Content standard image and text box block.
	Block1 *StandardImageTextBlock `json:"block1,omitempty"`

	// Block2 The A+ Content standard image and text box block.
	Block2 *StandardImageTextBlock `json:"block2,omitempty"`

	// Block3 The A+ Content standard image and text box block.
	Block3 *StandardImageTextBlock `json:"block3,omitempty"`

	// Headline Rich text content.
	Headline *TextComponent `json:"headline,omitempty"`
}

// TextComponent Rich text content.
type TextComponent struct {
	// DecoratorSet A set of content decorators.
	DecoratorSet *DecoratorSet `json:"decoratorSet,omitempty"`

	// Value The actual plain text.
	Value string `json:"value"`
}

// TextItem Rich positional text, usually presented as a collection of bullet points.
type TextItem struct {
	// Position The rank or index of this text item within the collection. Different items cannot occupy the same position within a single collection.
	Position int `json:"position"`

	// Text Rich text content.
	Text TextComponent `json:"text"`
}

// ValidateContentDocumentAsinRelationsResponse defines model for ValidateContentDocumentAsinRelationsResponse.
type ValidateContentDocumentAsinRelationsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors []Error `json:"errors"`

	// Warnings A set of messages to the user, such as warnings or comments.
	Warnings *MessageSet `json:"warnings,omitempty"`
}

// ValidateContentDocumentAsinRelationsParams defines parameters for ValidateContentDocumentAsinRelations.
type ValidateContentDocumentAsinRelationsParams struct {
	// MarketplaceId The identifier for the marketplace where the A+ Content is published.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`

	// AsinSet The set of ASINs.
	AsinSet *[]string `form:"asinSet,omitempty" json:"asinSet,omitempty"`
}

// SearchContentDocumentsParams defines parameters for SearchContentDocuments.
type SearchContentDocumentsParams struct {
	// MarketplaceId The identifier for the marketplace where the A+ Content is published.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`

	// PageToken A page token from the nextPageToken response element returned by your previous call to this operation. nextPageToken is returned when the results of a call exceed the page size. To get the next page of results, call the operation and include pageToken as the only parameter. Specifying pageToken with any other parameter will cause the request to fail. When no nextPageToken value is returned there are no more pages to return. A pageToken value is not usable across different operations.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateContentDocumentParams defines parameters for CreateContentDocument.
type CreateContentDocumentParams struct {
	// MarketplaceId The identifier for the marketplace where the A+ Content is published.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// GetContentDocumentParams defines parameters for GetContentDocument.
type GetContentDocumentParams struct {
	// MarketplaceId The identifier for the marketplace where the A+ Content is published.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`

	// IncludedDataSet The set of A+ Content data types to include in the response.
	IncludedDataSet []GetContentDocumentParamsIncludedDataSet `form:"includedDataSet" json:"includedDataSet"`
}

// GetContentDocumentParamsIncludedDataSet defines parameters for GetContentDocument.
type GetContentDocumentParamsIncludedDataSet string

// UpdateContentDocumentParams defines parameters for UpdateContentDocument.
type UpdateContentDocumentParams struct {
	// MarketplaceId The identifier for the marketplace where the A+ Content is published.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// PostContentDocumentApprovalSubmissionParams defines parameters for PostContentDocumentApprovalSubmission.
type PostContentDocumentApprovalSubmissionParams struct {
	// MarketplaceId The identifier for the marketplace where the A+ Content is published.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// ListContentDocumentAsinRelationsParams defines parameters for ListContentDocumentAsinRelations.
type ListContentDocumentAsinRelationsParams struct {
	// MarketplaceId The identifier for the marketplace where the A+ Content is published.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`

	// IncludedDataSet The set of A+ Content data types to include in the response. If you do not include this parameter, the operation returns the related ASINs without metadata.
	IncludedDataSet *[]ListContentDocumentAsinRelationsParamsIncludedDataSet `form:"includedDataSet,omitempty" json:"includedDataSet,omitempty"`

	// AsinSet The set of ASINs.
	AsinSet *[]string `form:"asinSet,omitempty" json:"asinSet,omitempty"`

	// PageToken A page token from the nextPageToken response element returned by your previous call to this operation. nextPageToken is returned when the results of a call exceed the page size. To get the next page of results, call the operation and include pageToken as the only parameter. Specifying pageToken with any other parameter will cause the request to fail. When no nextPageToken value is returned there are no more pages to return. A pageToken value is not usable across different operations.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListContentDocumentAsinRelationsParamsIncludedDataSet defines parameters for ListContentDocumentAsinRelations.
type ListContentDocumentAsinRelationsParamsIncludedDataSet string

// PostContentDocumentAsinRelationsParams defines parameters for PostContentDocumentAsinRelations.
type PostContentDocumentAsinRelationsParams struct {
	// MarketplaceId The identifier for the marketplace where the A+ Content is published.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// PostContentDocumentSuspendSubmissionParams defines parameters for PostContentDocumentSuspendSubmission.
type PostContentDocumentSuspendSubmissionParams struct {
	// MarketplaceId The identifier for the marketplace where the A+ Content is published.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// SearchContentPublishRecordsParams defines parameters for SearchContentPublishRecords.
type SearchContentPublishRecordsParams struct {
	// MarketplaceId The identifier for the marketplace where the A+ Content is published.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`

	// Asin The Amazon Standard Identification Number (ASIN).
	Asin string `form:"asin" json:"asin"`

	// PageToken A page token from the nextPageToken response element returned by your previous call to this operation. nextPageToken is returned when the results of a call exceed the page size. To get the next page of results, call the operation and include pageToken as the only parameter. Specifying pageToken with any other parameter will cause the request to fail. When no nextPageToken value is returned there are no more pages to return. A pageToken value is not usable across different operations.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ValidateContentDocumentAsinRelationsJSONRequestBody defines body for ValidateContentDocumentAsinRelations for application/json ContentType.
type ValidateContentDocumentAsinRelationsJSONRequestBody = PostContentDocumentRequest

// CreateContentDocumentJSONRequestBody defines body for CreateContentDocument for application/json ContentType.
type CreateContentDocumentJSONRequestBody = PostContentDocumentRequest

// UpdateContentDocumentJSONRequestBody defines body for UpdateContentDocument for application/json ContentType.
type UpdateContentDocumentJSONRequestBody = PostContentDocumentRequest

// PostContentDocumentAsinRelationsJSONRequestBody defines body for PostContentDocumentAsinRelations for application/json ContentType.
type PostContentDocumentAsinRelationsJSONRequestBody = PostContentDocumentAsinRelationsRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ValidateContentDocumentAsinRelationsWithBody request with any body
	ValidateContentDocumentAsinRelationsWithBody(ctx context.Context, params *ValidateContentDocumentAsinRelationsParams, contentType string, body io.Reader) (*http.Response, error)

	ValidateContentDocumentAsinRelations(ctx context.Context, params *ValidateContentDocumentAsinRelationsParams, body ValidateContentDocumentAsinRelationsJSONRequestBody) (*http.Response, error)

	// SearchContentDocuments request
	SearchContentDocuments(ctx context.Context, params *SearchContentDocumentsParams) (*http.Response, error)

	// CreateContentDocumentWithBody request with any body
	CreateContentDocumentWithBody(ctx context.Context, params *CreateContentDocumentParams, contentType string, body io.Reader) (*http.Response, error)

	CreateContentDocument(ctx context.Context, params *CreateContentDocumentParams, body CreateContentDocumentJSONRequestBody) (*http.Response, error)

	// GetContentDocument request
	GetContentDocument(ctx context.Context, contentReferenceKey string, params *GetContentDocumentParams) (*http.Response, error)

	// UpdateContentDocumentWithBody request with any body
	UpdateContentDocumentWithBody(ctx context.Context, contentReferenceKey string, params *UpdateContentDocumentParams, contentType string, body io.Reader) (*http.Response, error)

	UpdateContentDocument(ctx context.Context, contentReferenceKey string, params *UpdateContentDocumentParams, body UpdateContentDocumentJSONRequestBody) (*http.Response, error)

	// PostContentDocumentApprovalSubmission request
	PostContentDocumentApprovalSubmission(ctx context.Context, contentReferenceKey string, params *PostContentDocumentApprovalSubmissionParams) (*http.Response, error)

	// ListContentDocumentAsinRelations request
	ListContentDocumentAsinRelations(ctx context.Context, contentReferenceKey string, params *ListContentDocumentAsinRelationsParams) (*http.Response, error)

	// PostContentDocumentAsinRelationsWithBody request with any body
	PostContentDocumentAsinRelationsWithBody(ctx context.Context, contentReferenceKey string, params *PostContentDocumentAsinRelationsParams, contentType string, body io.Reader) (*http.Response, error)

	PostContentDocumentAsinRelations(ctx context.Context, contentReferenceKey string, params *PostContentDocumentAsinRelationsParams, body PostContentDocumentAsinRelationsJSONRequestBody) (*http.Response, error)

	// PostContentDocumentSuspendSubmission request
	PostContentDocumentSuspendSubmission(ctx context.Context, contentReferenceKey string, params *PostContentDocumentSuspendSubmissionParams) (*http.Response, error)

	// SearchContentPublishRecords request
	SearchContentPublishRecords(ctx context.Context, params *SearchContentPublishRecordsParams) (*http.Response, error)
}

func (c *Client) ValidateContentDocumentAsinRelationsWithBody(ctx context.Context, params *ValidateContentDocumentAsinRelationsParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewValidateContentDocumentAsinRelationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ValidateContentDocumentAsinRelations(ctx context.Context, params *ValidateContentDocumentAsinRelationsParams, body ValidateContentDocumentAsinRelationsJSONRequestBody) (*http.Response, error) {
	req, err := NewValidateContentDocumentAsinRelationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SearchContentDocuments(ctx context.Context, params *SearchContentDocumentsParams) (*http.Response, error) {
	req, err := NewSearchContentDocumentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateContentDocumentWithBody(ctx context.Context, params *CreateContentDocumentParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateContentDocumentRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateContentDocument(ctx context.Context, params *CreateContentDocumentParams, body CreateContentDocumentJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateContentDocumentRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetContentDocument(ctx context.Context, contentReferenceKey string, params *GetContentDocumentParams) (*http.Response, error) {
	req, err := NewGetContentDocumentRequest(c.Server, contentReferenceKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateContentDocumentWithBody(ctx context.Context, contentReferenceKey string, params *UpdateContentDocumentParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateContentDocumentRequestWithBody(c.Server, contentReferenceKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateContentDocument(ctx context.Context, contentReferenceKey string, params *UpdateContentDocumentParams, body UpdateContentDocumentJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateContentDocumentRequest(c.Server, contentReferenceKey, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PostContentDocumentApprovalSubmission(ctx context.Context, contentReferenceKey string, params *PostContentDocumentApprovalSubmissionParams) (*http.Response, error) {
	req, err := NewPostContentDocumentApprovalSubmissionRequest(c.Server, contentReferenceKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListContentDocumentAsinRelations(ctx context.Context, contentReferenceKey string, params *ListContentDocumentAsinRelationsParams) (*http.Response, error) {
	req, err := NewListContentDocumentAsinRelationsRequest(c.Server, contentReferenceKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PostContentDocumentAsinRelationsWithBody(ctx context.Context, contentReferenceKey string, params *PostContentDocumentAsinRelationsParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostContentDocumentAsinRelationsRequestWithBody(c.Server, contentReferenceKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PostContentDocumentAsinRelations(ctx context.Context, contentReferenceKey string, params *PostContentDocumentAsinRelationsParams, body PostContentDocumentAsinRelationsJSONRequestBody) (*http.Response, error) {
	req, err := NewPostContentDocumentAsinRelationsRequest(c.Server, contentReferenceKey, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PostContentDocumentSuspendSubmission(ctx context.Context, contentReferenceKey string, params *PostContentDocumentSuspendSubmissionParams) (*http.Response, error) {
	req, err := NewPostContentDocumentSuspendSubmissionRequest(c.Server, contentReferenceKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SearchContentPublishRecords(ctx context.Context, params *SearchContentPublishRecordsParams) (*http.Response, error) {
	req, err := NewSearchContentPublishRecordsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewValidateContentDocumentAsinRelationsRequest calls the generic ValidateContentDocumentAsinRelations builder with application/json body
func NewValidateContentDocumentAsinRelationsRequest(server string, params *ValidateContentDocumentAsinRelationsParams, body ValidateContentDocumentAsinRelationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateContentDocumentAsinRelationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewValidateContentDocumentAsinRelationsRequestWithBody generates requests for ValidateContentDocumentAsinRelations with any type of body
func NewValidateContentDocumentAsinRelationsRequestWithBody(server string, params *ValidateContentDocumentAsinRelationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aplus/2020-11-01/contentAsinValidations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.AsinSet != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asinSet", runtime.ParamLocationQuery, *params.AsinSet); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchContentDocumentsRequest generates requests for SearchContentDocuments
func NewSearchContentDocumentsRequest(server string, params *SearchContentDocumentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aplus/2020-11-01/contentDocuments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateContentDocumentRequest calls the generic CreateContentDocument builder with application/json body
func NewCreateContentDocumentRequest(server string, params *CreateContentDocumentParams, body CreateContentDocumentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateContentDocumentRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateContentDocumentRequestWithBody generates requests for CreateContentDocument with any type of body
func NewCreateContentDocumentRequestWithBody(server string, params *CreateContentDocumentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aplus/2020-11-01/contentDocuments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetContentDocumentRequest generates requests for GetContentDocument
func NewGetContentDocumentRequest(server string, contentReferenceKey string, params *GetContentDocumentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contentReferenceKey", runtime.ParamLocationPath, contentReferenceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aplus/2020-11-01/contentDocuments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedDataSet", runtime.ParamLocationQuery, params.IncludedDataSet); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateContentDocumentRequest calls the generic UpdateContentDocument builder with application/json body
func NewUpdateContentDocumentRequest(server string, contentReferenceKey string, params *UpdateContentDocumentParams, body UpdateContentDocumentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateContentDocumentRequestWithBody(server, contentReferenceKey, params, "application/json", bodyReader)
}

// NewUpdateContentDocumentRequestWithBody generates requests for UpdateContentDocument with any type of body
func NewUpdateContentDocumentRequestWithBody(server string, contentReferenceKey string, params *UpdateContentDocumentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contentReferenceKey", runtime.ParamLocationPath, contentReferenceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aplus/2020-11-01/contentDocuments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostContentDocumentApprovalSubmissionRequest generates requests for PostContentDocumentApprovalSubmission
func NewPostContentDocumentApprovalSubmissionRequest(server string, contentReferenceKey string, params *PostContentDocumentApprovalSubmissionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contentReferenceKey", runtime.ParamLocationPath, contentReferenceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aplus/2020-11-01/contentDocuments/%s/approvalSubmissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListContentDocumentAsinRelationsRequest generates requests for ListContentDocumentAsinRelations
func NewListContentDocumentAsinRelationsRequest(server string, contentReferenceKey string, params *ListContentDocumentAsinRelationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contentReferenceKey", runtime.ParamLocationPath, contentReferenceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aplus/2020-11-01/contentDocuments/%s/asins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IncludedDataSet != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedDataSet", runtime.ParamLocationQuery, *params.IncludedDataSet); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.AsinSet != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asinSet", runtime.ParamLocationQuery, *params.AsinSet); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostContentDocumentAsinRelationsRequest calls the generic PostContentDocumentAsinRelations builder with application/json body
func NewPostContentDocumentAsinRelationsRequest(server string, contentReferenceKey string, params *PostContentDocumentAsinRelationsParams, body PostContentDocumentAsinRelationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostContentDocumentAsinRelationsRequestWithBody(server, contentReferenceKey, params, "application/json", bodyReader)
}

// NewPostContentDocumentAsinRelationsRequestWithBody generates requests for PostContentDocumentAsinRelations with any type of body
func NewPostContentDocumentAsinRelationsRequestWithBody(server string, contentReferenceKey string, params *PostContentDocumentAsinRelationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contentReferenceKey", runtime.ParamLocationPath, contentReferenceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aplus/2020-11-01/contentDocuments/%s/asins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostContentDocumentSuspendSubmissionRequest generates requests for PostContentDocumentSuspendSubmission
func NewPostContentDocumentSuspendSubmissionRequest(server string, contentReferenceKey string, params *PostContentDocumentSuspendSubmissionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contentReferenceKey", runtime.ParamLocationPath, contentReferenceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aplus/2020-11-01/contentDocuments/%s/suspendSubmissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchContentPublishRecordsRequest generates requests for SearchContentPublishRecords
func NewSearchContentPublishRecordsRequest(server string, params *SearchContentPublishRecordsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aplus/2020-11-01/contentPublishRecords")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asin", runtime.ParamLocationQuery, params.Asin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ValidateContentDocumentAsinRelationsWithBodyWithResponse request with any body
	ValidateContentDocumentAsinRelationsWithBodyWithResponse(ctx context.Context, params *ValidateContentDocumentAsinRelationsParams, contentType string, body io.Reader) (*ValidateContentDocumentAsinRelationsResp, error)

	ValidateContentDocumentAsinRelationsWithResponse(ctx context.Context, params *ValidateContentDocumentAsinRelationsParams, body ValidateContentDocumentAsinRelationsJSONRequestBody) (*ValidateContentDocumentAsinRelationsResp, error)

	// SearchContentDocumentsWithResponse request
	SearchContentDocumentsWithResponse(ctx context.Context, params *SearchContentDocumentsParams) (*SearchContentDocumentsResp, error)

	// CreateContentDocumentWithBodyWithResponse request with any body
	CreateContentDocumentWithBodyWithResponse(ctx context.Context, params *CreateContentDocumentParams, contentType string, body io.Reader) (*CreateContentDocumentResp, error)

	CreateContentDocumentWithResponse(ctx context.Context, params *CreateContentDocumentParams, body CreateContentDocumentJSONRequestBody) (*CreateContentDocumentResp, error)

	// GetContentDocumentWithResponse request
	GetContentDocumentWithResponse(ctx context.Context, contentReferenceKey string, params *GetContentDocumentParams) (*GetContentDocumentResp, error)

	// UpdateContentDocumentWithBodyWithResponse request with any body
	UpdateContentDocumentWithBodyWithResponse(ctx context.Context, contentReferenceKey string, params *UpdateContentDocumentParams, contentType string, body io.Reader) (*UpdateContentDocumentResp, error)

	UpdateContentDocumentWithResponse(ctx context.Context, contentReferenceKey string, params *UpdateContentDocumentParams, body UpdateContentDocumentJSONRequestBody) (*UpdateContentDocumentResp, error)

	// PostContentDocumentApprovalSubmissionWithResponse request
	PostContentDocumentApprovalSubmissionWithResponse(ctx context.Context, contentReferenceKey string, params *PostContentDocumentApprovalSubmissionParams) (*PostContentDocumentApprovalSubmissionResp, error)

	// ListContentDocumentAsinRelationsWithResponse request
	ListContentDocumentAsinRelationsWithResponse(ctx context.Context, contentReferenceKey string, params *ListContentDocumentAsinRelationsParams) (*ListContentDocumentAsinRelationsResp, error)

	// PostContentDocumentAsinRelationsWithBodyWithResponse request with any body
	PostContentDocumentAsinRelationsWithBodyWithResponse(ctx context.Context, contentReferenceKey string, params *PostContentDocumentAsinRelationsParams, contentType string, body io.Reader) (*PostContentDocumentAsinRelationsResp, error)

	PostContentDocumentAsinRelationsWithResponse(ctx context.Context, contentReferenceKey string, params *PostContentDocumentAsinRelationsParams, body PostContentDocumentAsinRelationsJSONRequestBody) (*PostContentDocumentAsinRelationsResp, error)

	// PostContentDocumentSuspendSubmissionWithResponse request
	PostContentDocumentSuspendSubmissionWithResponse(ctx context.Context, contentReferenceKey string, params *PostContentDocumentSuspendSubmissionParams) (*PostContentDocumentSuspendSubmissionResp, error)

	// SearchContentPublishRecordsWithResponse request
	SearchContentPublishRecordsWithResponse(ctx context.Context, params *SearchContentPublishRecordsParams) (*SearchContentPublishRecordsResp, error)
}

type ValidateContentDocumentAsinRelationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidateContentDocumentAsinRelationsResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ValidateContentDocumentAsinRelationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateContentDocumentAsinRelationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchContentDocumentsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchContentDocumentsResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON410      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r SearchContentDocumentsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchContentDocumentsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateContentDocumentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostContentDocumentResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CreateContentDocumentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateContentDocumentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentDocumentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetContentDocumentResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON410      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetContentDocumentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentDocumentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateContentDocumentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostContentDocumentResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON410      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateContentDocumentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateContentDocumentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostContentDocumentApprovalSubmissionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostContentDocumentApprovalSubmissionResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON410      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r PostContentDocumentApprovalSubmissionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostContentDocumentApprovalSubmissionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContentDocumentAsinRelationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListContentDocumentAsinRelationsResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON410      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListContentDocumentAsinRelationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContentDocumentAsinRelationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostContentDocumentAsinRelationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostContentDocumentAsinRelationsResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON410      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r PostContentDocumentAsinRelationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostContentDocumentAsinRelationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostContentDocumentSuspendSubmissionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostContentDocumentSuspendSubmissionResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON410      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r PostContentDocumentSuspendSubmissionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostContentDocumentSuspendSubmissionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchContentPublishRecordsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchContentPublishRecordsResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r SearchContentPublishRecordsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchContentPublishRecordsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ValidateContentDocumentAsinRelationsWithBodyWithResponse request with arbitrary body returning *ValidateContentDocumentAsinRelationsResp
func (c *ClientWithResponses) ValidateContentDocumentAsinRelationsWithBodyWithResponse(ctx context.Context, params *ValidateContentDocumentAsinRelationsParams, contentType string, body io.Reader) (*ValidateContentDocumentAsinRelationsResp, error) {
	rsp, err := c.ValidateContentDocumentAsinRelationsWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseValidateContentDocumentAsinRelationsResp(rsp)
}

func (c *ClientWithResponses) ValidateContentDocumentAsinRelationsWithResponse(ctx context.Context, params *ValidateContentDocumentAsinRelationsParams, body ValidateContentDocumentAsinRelationsJSONRequestBody) (*ValidateContentDocumentAsinRelationsResp, error) {
	rsp, err := c.ValidateContentDocumentAsinRelations(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseValidateContentDocumentAsinRelationsResp(rsp)
}

// SearchContentDocumentsWithResponse request returning *SearchContentDocumentsResp
func (c *ClientWithResponses) SearchContentDocumentsWithResponse(ctx context.Context, params *SearchContentDocumentsParams) (*SearchContentDocumentsResp, error) {
	rsp, err := c.SearchContentDocuments(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseSearchContentDocumentsResp(rsp)
}

// CreateContentDocumentWithBodyWithResponse request with arbitrary body returning *CreateContentDocumentResp
func (c *ClientWithResponses) CreateContentDocumentWithBodyWithResponse(ctx context.Context, params *CreateContentDocumentParams, contentType string, body io.Reader) (*CreateContentDocumentResp, error) {
	rsp, err := c.CreateContentDocumentWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateContentDocumentResp(rsp)
}

func (c *ClientWithResponses) CreateContentDocumentWithResponse(ctx context.Context, params *CreateContentDocumentParams, body CreateContentDocumentJSONRequestBody) (*CreateContentDocumentResp, error) {
	rsp, err := c.CreateContentDocument(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateContentDocumentResp(rsp)
}

// GetContentDocumentWithResponse request returning *GetContentDocumentResp
func (c *ClientWithResponses) GetContentDocumentWithResponse(ctx context.Context, contentReferenceKey string, params *GetContentDocumentParams) (*GetContentDocumentResp, error) {
	rsp, err := c.GetContentDocument(ctx, contentReferenceKey, params)
	if err != nil {
		return nil, err
	}
	return ParseGetContentDocumentResp(rsp)
}

// UpdateContentDocumentWithBodyWithResponse request with arbitrary body returning *UpdateContentDocumentResp
func (c *ClientWithResponses) UpdateContentDocumentWithBodyWithResponse(ctx context.Context, contentReferenceKey string, params *UpdateContentDocumentParams, contentType string, body io.Reader) (*UpdateContentDocumentResp, error) {
	rsp, err := c.UpdateContentDocumentWithBody(ctx, contentReferenceKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContentDocumentResp(rsp)
}

func (c *ClientWithResponses) UpdateContentDocumentWithResponse(ctx context.Context, contentReferenceKey string, params *UpdateContentDocumentParams, body UpdateContentDocumentJSONRequestBody) (*UpdateContentDocumentResp, error) {
	rsp, err := c.UpdateContentDocument(ctx, contentReferenceKey, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContentDocumentResp(rsp)
}

// PostContentDocumentApprovalSubmissionWithResponse request returning *PostContentDocumentApprovalSubmissionResp
func (c *ClientWithResponses) PostContentDocumentApprovalSubmissionWithResponse(ctx context.Context, contentReferenceKey string, params *PostContentDocumentApprovalSubmissionParams) (*PostContentDocumentApprovalSubmissionResp, error) {
	rsp, err := c.PostContentDocumentApprovalSubmission(ctx, contentReferenceKey, params)
	if err != nil {
		return nil, err
	}
	return ParsePostContentDocumentApprovalSubmissionResp(rsp)
}

// ListContentDocumentAsinRelationsWithResponse request returning *ListContentDocumentAsinRelationsResp
func (c *ClientWithResponses) ListContentDocumentAsinRelationsWithResponse(ctx context.Context, contentReferenceKey string, params *ListContentDocumentAsinRelationsParams) (*ListContentDocumentAsinRelationsResp, error) {
	rsp, err := c.ListContentDocumentAsinRelations(ctx, contentReferenceKey, params)
	if err != nil {
		return nil, err
	}
	return ParseListContentDocumentAsinRelationsResp(rsp)
}

// PostContentDocumentAsinRelationsWithBodyWithResponse request with arbitrary body returning *PostContentDocumentAsinRelationsResp
func (c *ClientWithResponses) PostContentDocumentAsinRelationsWithBodyWithResponse(ctx context.Context, contentReferenceKey string, params *PostContentDocumentAsinRelationsParams, contentType string, body io.Reader) (*PostContentDocumentAsinRelationsResp, error) {
	rsp, err := c.PostContentDocumentAsinRelationsWithBody(ctx, contentReferenceKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostContentDocumentAsinRelationsResp(rsp)
}

func (c *ClientWithResponses) PostContentDocumentAsinRelationsWithResponse(ctx context.Context, contentReferenceKey string, params *PostContentDocumentAsinRelationsParams, body PostContentDocumentAsinRelationsJSONRequestBody) (*PostContentDocumentAsinRelationsResp, error) {
	rsp, err := c.PostContentDocumentAsinRelations(ctx, contentReferenceKey, params, body)
	if err != nil {
		return nil, err
	}
	return ParsePostContentDocumentAsinRelationsResp(rsp)
}

// PostContentDocumentSuspendSubmissionWithResponse request returning *PostContentDocumentSuspendSubmissionResp
func (c *ClientWithResponses) PostContentDocumentSuspendSubmissionWithResponse(ctx context.Context, contentReferenceKey string, params *PostContentDocumentSuspendSubmissionParams) (*PostContentDocumentSuspendSubmissionResp, error) {
	rsp, err := c.PostContentDocumentSuspendSubmission(ctx, contentReferenceKey, params)
	if err != nil {
		return nil, err
	}
	return ParsePostContentDocumentSuspendSubmissionResp(rsp)
}

// SearchContentPublishRecordsWithResponse request returning *SearchContentPublishRecordsResp
func (c *ClientWithResponses) SearchContentPublishRecordsWithResponse(ctx context.Context, params *SearchContentPublishRecordsParams) (*SearchContentPublishRecordsResp, error) {
	rsp, err := c.SearchContentPublishRecords(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseSearchContentPublishRecordsResp(rsp)
}

// ParseValidateContentDocumentAsinRelationsResp parses an HTTP response from a ValidateContentDocumentAsinRelationsWithResponse call
func ParseValidateContentDocumentAsinRelationsResp(rsp *http.Response) (*ValidateContentDocumentAsinRelationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateContentDocumentAsinRelationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidateContentDocumentAsinRelationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSearchContentDocumentsResp parses an HTTP response from a SearchContentDocumentsWithResponse call
func ParseSearchContentDocumentsResp(rsp *http.Response) (*SearchContentDocumentsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchContentDocumentsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchContentDocumentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateContentDocumentResp parses an HTTP response from a CreateContentDocumentWithResponse call
func ParseCreateContentDocumentResp(rsp *http.Response) (*CreateContentDocumentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateContentDocumentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostContentDocumentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetContentDocumentResp parses an HTTP response from a GetContentDocumentWithResponse call
func ParseGetContentDocumentResp(rsp *http.Response) (*GetContentDocumentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContentDocumentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetContentDocumentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateContentDocumentResp parses an HTTP response from a UpdateContentDocumentWithResponse call
func ParseUpdateContentDocumentResp(rsp *http.Response) (*UpdateContentDocumentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateContentDocumentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostContentDocumentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePostContentDocumentApprovalSubmissionResp parses an HTTP response from a PostContentDocumentApprovalSubmissionWithResponse call
func ParsePostContentDocumentApprovalSubmissionResp(rsp *http.Response) (*PostContentDocumentApprovalSubmissionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostContentDocumentApprovalSubmissionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostContentDocumentApprovalSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListContentDocumentAsinRelationsResp parses an HTTP response from a ListContentDocumentAsinRelationsWithResponse call
func ParseListContentDocumentAsinRelationsResp(rsp *http.Response) (*ListContentDocumentAsinRelationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContentDocumentAsinRelationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListContentDocumentAsinRelationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePostContentDocumentAsinRelationsResp parses an HTTP response from a PostContentDocumentAsinRelationsWithResponse call
func ParsePostContentDocumentAsinRelationsResp(rsp *http.Response) (*PostContentDocumentAsinRelationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostContentDocumentAsinRelationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostContentDocumentAsinRelationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePostContentDocumentSuspendSubmissionResp parses an HTTP response from a PostContentDocumentSuspendSubmissionWithResponse call
func ParsePostContentDocumentSuspendSubmissionResp(rsp *http.Response) (*PostContentDocumentSuspendSubmissionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostContentDocumentSuspendSubmissionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostContentDocumentSuspendSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSearchContentPublishRecordsResp parses an HTTP response from a SearchContentPublishRecordsWithResponse call
func ParseSearchContentPublishRecordsResp(rsp *http.Response) (*SearchContentPublishRecordsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchContentPublishRecordsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchContentPublishRecordsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
