// Package ordersv0 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package ordersv0

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/bytedance/sonic"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AddressAddressType.
const (
	Commercial  AddressAddressType = "Commercial"
	Residential AddressAddressType = "Residential"
)

// Defines values for AssociationType.
const (
	VALUEADDSERVICE AssociationType = "VALUE_ADD_SERVICE"
)

// Defines values for BusinessHoursDayOfWeek.
const (
	FRI BusinessHoursDayOfWeek = "FRI"
	MON BusinessHoursDayOfWeek = "MON"
	SAT BusinessHoursDayOfWeek = "SAT"
	SUN BusinessHoursDayOfWeek = "SUN"
	THU BusinessHoursDayOfWeek = "THU"
	TUE BusinessHoursDayOfWeek = "TUE"
	WED BusinessHoursDayOfWeek = "WED"
)

// Defines values for ConfirmShipmentRequestCodCollectionMethod.
const (
	DirectPayment ConfirmShipmentRequestCodCollectionMethod = "DirectPayment"
)

// Defines values for ConstraintType.
const (
	MANDATORY ConstraintType = "MANDATORY"
)

// Defines values for EasyShipShipmentStatus.
const (
	EasyShipShipmentStatusAtDestinationFC   EasyShipShipmentStatus = "AtDestinationFC"
	EasyShipShipmentStatusAtOriginFC        EasyShipShipmentStatus = "AtOriginFC"
	EasyShipShipmentStatusDamaged           EasyShipShipmentStatus = "Damaged"
	EasyShipShipmentStatusDelivered         EasyShipShipmentStatus = "Delivered"
	EasyShipShipmentStatusDroppedOff        EasyShipShipmentStatus = "DroppedOff"
	EasyShipShipmentStatusLabelCanceled     EasyShipShipmentStatus = "LabelCanceled"
	EasyShipShipmentStatusLost              EasyShipShipmentStatus = "Lost"
	EasyShipShipmentStatusOutForDelivery    EasyShipShipmentStatus = "OutForDelivery"
	EasyShipShipmentStatusPendingDropOff    EasyShipShipmentStatus = "PendingDropOff"
	EasyShipShipmentStatusPendingPickUp     EasyShipShipmentStatus = "PendingPickUp"
	EasyShipShipmentStatusPendingSchedule   EasyShipShipmentStatus = "PendingSchedule"
	EasyShipShipmentStatusPickedUp          EasyShipShipmentStatus = "PickedUp"
	EasyShipShipmentStatusRejectedByBuyer   EasyShipShipmentStatus = "RejectedByBuyer"
	EasyShipShipmentStatusReturnedToSeller  EasyShipShipmentStatus = "ReturnedToSeller"
	EasyShipShipmentStatusReturningToSeller EasyShipShipmentStatus = "ReturningToSeller"
	EasyShipShipmentStatusUndeliverable     EasyShipShipmentStatus = "Undeliverable"
)

// Defines values for ElectronicInvoiceStatus.
const (
	Accepted    ElectronicInvoiceStatus = "Accepted"
	Errored     ElectronicInvoiceStatus = "Errored"
	NotFound    ElectronicInvoiceStatus = "NotFound"
	NotRequired ElectronicInvoiceStatus = "NotRequired"
	Processing  ElectronicInvoiceStatus = "Processing"
)

// Defines values for MeasurementUnit.
const (
	CENTIMETERS       MeasurementUnit = "CENTIMETERS"
	COUNT             MeasurementUnit = "COUNT"
	CUBICCENTIMETERS  MeasurementUnit = "CUBIC_CENTIMETERS"
	CUBICFEET         MeasurementUnit = "CUBIC_FEET"
	CUBICINCHES       MeasurementUnit = "CUBIC_INCHES"
	CUBICMETERS       MeasurementUnit = "CUBIC_METERS"
	FEET              MeasurementUnit = "FEET"
	FLUIDOUNCES       MeasurementUnit = "FLUID_OUNCES"
	GALLONS           MeasurementUnit = "GALLONS"
	GRAMS             MeasurementUnit = "GRAMS"
	INCHES            MeasurementUnit = "INCHES"
	KILOGRAMS         MeasurementUnit = "KILOGRAMS"
	LITERS            MeasurementUnit = "LITERS"
	METERS            MeasurementUnit = "METERS"
	MILLIGRAMS        MeasurementUnit = "MILLIGRAMS"
	MILLIMETERS       MeasurementUnit = "MILLIMETERS"
	OUNCES            MeasurementUnit = "OUNCES"
	PINTS             MeasurementUnit = "PINTS"
	POUNDS            MeasurementUnit = "POUNDS"
	QUARTS            MeasurementUnit = "QUARTS"
	SQUARECENTIMETERS MeasurementUnit = "SQUARE_CENTIMETERS"
	SQUAREFEET        MeasurementUnit = "SQUARE_FEET"
	SQUAREINCHES      MeasurementUnit = "SQUARE_INCHES"
	SQUAREMETERS      MeasurementUnit = "SQUARE_METERS"
)

// Defines values for OrderBuyerInvoicePreference.
const (
	BUSINESS   OrderBuyerInvoicePreference = "BUSINESS"
	INDIVIDUAL OrderBuyerInvoicePreference = "INDIVIDUAL"
)

// Defines values for OrderFulfillmentChannel.
const (
	AFN OrderFulfillmentChannel = "AFN"
	MFN OrderFulfillmentChannel = "MFN"
)

// Defines values for OrderOrderStatus.
const (
	OrderOrderStatusCanceled            OrderOrderStatus = "Canceled"
	OrderOrderStatusInvoiceUnconfirmed  OrderOrderStatus = "InvoiceUnconfirmed"
	OrderOrderStatusPartiallyShipped    OrderOrderStatus = "PartiallyShipped"
	OrderOrderStatusPending             OrderOrderStatus = "Pending"
	OrderOrderStatusPendingAvailability OrderOrderStatus = "PendingAvailability"
	OrderOrderStatusShipped             OrderOrderStatus = "Shipped"
	OrderOrderStatusUnfulfillable       OrderOrderStatus = "Unfulfillable"
	OrderOrderStatusUnshipped           OrderOrderStatus = "Unshipped"
)

// Defines values for OrderOrderType.
const (
	BackOrder             OrderOrderType = "BackOrder"
	LongLeadTimeOrder     OrderOrderType = "LongLeadTimeOrder"
	Preorder              OrderOrderType = "Preorder"
	SourcingOnDemandOrder OrderOrderType = "SourcingOnDemandOrder"
	StandardOrder         OrderOrderType = "StandardOrder"
)

// Defines values for OrderPaymentMethod.
const (
	COD   OrderPaymentMethod = "COD"
	CVS   OrderPaymentMethod = "CVS"
	Other OrderPaymentMethod = "Other"
)

// Defines values for OrderItemDeemedResellerCategory.
const (
	IOSS OrderItemDeemedResellerCategory = "IOSS"
	UOSS OrderItemDeemedResellerCategory = "UOSS"
)

// Defines values for OtherDeliveryAttributes.
const (
	HASACCESSPOINT OtherDeliveryAttributes = "HAS_ACCESS_POINT"
	PALLETDISABLED OtherDeliveryAttributes = "PALLET_DISABLED"
	PALLETENABLED  OtherDeliveryAttributes = "PALLET_ENABLED"
)

// Defines values for RegulatedInformationFieldFieldType.
const (
	FileAttachment RegulatedInformationFieldFieldType = "FileAttachment"
	Text           RegulatedInformationFieldFieldType = "Text"
)

// Defines values for ShipmentStatus.
const (
	ShipmentStatusPickedUp       ShipmentStatus = "PickedUp"
	ShipmentStatusReadyForPickup ShipmentStatus = "ReadyForPickup"
	ShipmentStatusRefusedPickup  ShipmentStatus = "RefusedPickup"
)

// Defines values for SubstitutionPreferencesSubstitutionType.
const (
	AMAZONRECOMMENDED  SubstitutionPreferencesSubstitutionType = "AMAZON_RECOMMENDED"
	CUSTOMERPREFERENCE SubstitutionPreferencesSubstitutionType = "CUSTOMER_PREFERENCE"
	DONOTSUBSTITUTE    SubstitutionPreferencesSubstitutionType = "DO_NOT_SUBSTITUTE"
)

// Defines values for TaxCollectionModel.
const (
	MarketplaceFacilitator TaxCollectionModel = "MarketplaceFacilitator"
)

// Defines values for TaxCollectionResponsibleParty.
const (
	AmazonServicesInc TaxCollectionResponsibleParty = "Amazon Services, Inc."
)

// Defines values for VerificationStatus.
const (
	VerificationStatusApproved  VerificationStatus = "Approved"
	VerificationStatusCancelled VerificationStatus = "Cancelled"
	VerificationStatusExpired   VerificationStatus = "Expired"
	VerificationStatusPending   VerificationStatus = "Pending"
	VerificationStatusRejected  VerificationStatus = "Rejected"
)

// Address The shipping address for the order.
type Address struct {
	// AddressLine1 The street address.
	AddressLine1 *string `json:"AddressLine1,omitempty"`

	// AddressLine2 Additional street address information, if required.
	AddressLine2 *string `json:"AddressLine2,omitempty"`

	// AddressLine3 Additional street address information, if required.
	AddressLine3 *string `json:"AddressLine3,omitempty"`

	// AddressType The address type of the shipping address.
	AddressType *AddressAddressType `json:"AddressType,omitempty"`

	// City The city.
	City *string `json:"City,omitempty"`

	// CompanyName The company name of the recipient.
	//
	// **Note**: This attribute is only available for shipping address.
	CompanyName *string `json:"CompanyName,omitempty"`

	// CountryCode The country code. A two-character country code, in ISO 3166-1 alpha-2 format.
	CountryCode *string `json:"CountryCode,omitempty"`

	// County The county.
	County *string `json:"County,omitempty"`

	// District The district.
	District *string `json:"District,omitempty"`

	// ExtendedFields The container for address extended fields (such as `street name` and `street number`). Currently only available with Brazil shipping addresses.
	ExtendedFields *AddressExtendedFields `json:"ExtendedFields,omitempty"`

	// Municipality The municipality.
	Municipality *string `json:"Municipality,omitempty"`

	// Name The name.
	Name string `json:"Name"`

	// Phone The phone number of the buyer.
	//
	// **Note**:
	// 1. This attribute is only available for shipping address.
	// 2. In some cases, the buyer phone number is suppressed:
	// a. Phone is suppressed for all `AFN` (fulfilled by Amazon) orders.
	// b. Phone is suppressed for the shipped `MFN` (fulfilled by seller) order when the current date is past the Latest Delivery Date.
	Phone *string `json:"Phone,omitempty"`

	// PostalCode The postal code.
	PostalCode *string `json:"PostalCode,omitempty"`

	// StateOrRegion The state or region.
	StateOrRegion *string `json:"StateOrRegion,omitempty"`
}

// AddressAddressType The address type of the shipping address.
type AddressAddressType string

// AddressExtendedFields The container for address extended fields (such as `street name` and `street number`). Currently only available with Brazil shipping addresses.
type AddressExtendedFields struct {
	// Complement The floor number/unit number in the building/private house number.
	Complement *string `json:"Complement,omitempty"`

	// Neighborhood The neighborhood. This value is only used in some countries (such as Brazil).
	Neighborhood *string `json:"Neighborhood,omitempty"`

	// StreetName The street name.
	StreetName *string `json:"StreetName,omitempty"`

	// StreetNumber The house, building, or property number associated with the location's street address.
	StreetNumber *string `json:"StreetNumber,omitempty"`
}

// AmazonPrograms Contains the list of programs that are associated with an item.
//
// Possible programs are:
//   - **Subscribe and Save**: Offers recurring, scheduled deliveries to Amazon customers and Amazon Business customers for their frequently ordered products.
type AmazonPrograms struct {
	// Programs A list of the programs that are associated with the specified order item.
	//
	// **Possible values**: `SUBSCRIBE_AND_SAVE`
	Programs []string `json:"Programs"`
}

// AssociatedItem An item that is associated with an order item. For example, a tire installation service that is purchased with tires.
type AssociatedItem struct {
	// AssociationType The type of association an item has with an order item.
	AssociationType *AssociationType `json:"AssociationType,omitempty"`

	// OrderId The order item's order identifier, in 3-7-7 format.
	OrderId *string `json:"OrderId,omitempty"`

	// OrderItemId An Amazon-defined item identifier for the associated item.
	OrderItemId *string `json:"OrderItemId,omitempty"`
}

// AssociationType The type of association an item has with an order item.
type AssociationType string

// AutomatedShippingSettings Contains information regarding the Shipping Settings Automation program, such as whether the order's shipping settings were generated automatically, and what those settings are.
type AutomatedShippingSettings struct {
	// AutomatedCarrier Auto-generated carrier for SSA orders.
	AutomatedCarrier *string `json:"AutomatedCarrier,omitempty"`

	// AutomatedShipMethod Auto-generated ship method for SSA orders.
	AutomatedShipMethod *string `json:"AutomatedShipMethod,omitempty"`

	// HasAutomatedShippingSettings When true, this order has automated shipping settings generated by Amazon. This order could be identified as an SSA order.
	HasAutomatedShippingSettings *bool `json:"HasAutomatedShippingSettings,omitempty"`
}

// BusinessHours Business days and hours when the destination is open for deliveries.
type BusinessHours struct {
	// DayOfWeek Day of the week.
	DayOfWeek *BusinessHoursDayOfWeek `json:"DayOfWeek,omitempty"`

	// OpenIntervals Time window during the day when the business is open.
	OpenIntervals *[]OpenInterval `json:"OpenIntervals,omitempty"`
}

// BusinessHoursDayOfWeek Day of the week.
type BusinessHoursDayOfWeek string

// BuyerCustomizedInfoDetail Buyer information for custom orders from the Amazon Custom program.
type BuyerCustomizedInfoDetail struct {
	// CustomizedURL The location of a ZIP file containing Amazon Custom data.
	CustomizedURL *string `json:"CustomizedURL,omitempty"`
}

// BuyerInfo Buyer information.
type BuyerInfo struct {
	// BuyerCounty The county of the buyer.
	//
	// **Note**: This attribute is only available in the Brazil marketplace.
	BuyerCounty *string `json:"BuyerCounty,omitempty"`

	// BuyerEmail The anonymized email address of the buyer.
	BuyerEmail *string `json:"BuyerEmail,omitempty"`

	// BuyerName The buyer name or the recipient name.
	BuyerName *string `json:"BuyerName,omitempty"`

	// BuyerTaxInfo Tax information about the buyer.
	BuyerTaxInfo *BuyerTaxInfo `json:"BuyerTaxInfo,omitempty"`

	// PurchaseOrderNumber The purchase order (PO) number entered by the buyer at checkout. Only returned for orders where the buyer entered a PO number at checkout.
	PurchaseOrderNumber *string `json:"PurchaseOrderNumber,omitempty"`
}

// BuyerRequestedCancel Information about whether or not a buyer requested cancellation.
type BuyerRequestedCancel struct {
	// BuyerCancelReason The reason that the buyer requested cancellation.
	BuyerCancelReason *string `json:"BuyerCancelReason,omitempty"`

	// IsBuyerRequestedCancel Indicate whether the buyer has requested cancellation.
	//
	// **Possible Values**: `true`, `false`.
	IsBuyerRequestedCancel *string `json:"IsBuyerRequestedCancel,omitempty"`
}

// BuyerTaxInfo Tax information about the buyer.
type BuyerTaxInfo struct {
	// CompanyLegalName The legal name of the company.
	CompanyLegalName *string `json:"CompanyLegalName,omitempty"`

	// TaxClassifications A list of tax classifications that apply to the order.
	TaxClassifications *[]TaxClassification `json:"TaxClassifications,omitempty"`

	// TaxingRegion The country or region imposing the tax.
	TaxingRegion *string `json:"TaxingRegion,omitempty"`
}

// BuyerTaxInformation Contains the business invoice tax information. Available only in the TR marketplace.
type BuyerTaxInformation struct {
	// BuyerBusinessAddress Business buyer's address.
	BuyerBusinessAddress *string `json:"BuyerBusinessAddress,omitempty"`

	// BuyerLegalCompanyName Business buyer's company legal name.
	BuyerLegalCompanyName *string `json:"BuyerLegalCompanyName,omitempty"`

	// BuyerTaxOffice Business buyer's tax office.
	BuyerTaxOffice *string `json:"BuyerTaxOffice,omitempty"`

	// BuyerTaxRegistrationId Business buyer's tax registration ID.
	BuyerTaxRegistrationId *string `json:"BuyerTaxRegistrationId,omitempty"`
}

// ConfirmShipmentErrorResponse The error response schema for the `confirmShipment` operation.
type ConfirmShipmentErrorResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// ConfirmShipmentOrderItem A single order item.
type ConfirmShipmentOrderItem struct {
	// OrderItemId The order item's unique identifier.
	OrderItemId string `json:"orderItemId"`

	// Quantity The item's quantity.
	Quantity int `json:"quantity"`

	// TransparencyCodes A list of order items.
	TransparencyCodes *TransparencyCodeList `json:"transparencyCodes,omitempty"`
}

// ConfirmShipmentOrderItemsList A list of order items.
type ConfirmShipmentOrderItemsList = []ConfirmShipmentOrderItem

// ConfirmShipmentRequest The request schema for an shipment confirmation.
type ConfirmShipmentRequest struct {
	// CodCollectionMethod The COD collection method (only supported in the JP marketplace).
	CodCollectionMethod *ConfirmShipmentRequestCodCollectionMethod `json:"codCollectionMethod,omitempty"`

	// MarketplaceId The unobfuscated marketplace identifier.
	MarketplaceId MarketplaceId `json:"marketplaceId"`

	// PackageDetail Properties of packages
	PackageDetail PackageDetail `json:"packageDetail"`
}

// ConfirmShipmentRequestCodCollectionMethod The COD collection method (only supported in the JP marketplace).
type ConfirmShipmentRequestCodCollectionMethod string

// ConstraintType Details the importance of the constraint present on the item
type ConstraintType string

// DeliveryPreferences Contains all of the delivery instructions provided by the customer for the shipping address.
type DeliveryPreferences struct {
	// AddressInstructions Building instructions, nearby landmark or navigation instructions.
	AddressInstructions *string `json:"AddressInstructions,omitempty"`

	// DropOffLocation Drop-off location selected by the customer.
	DropOffLocation *string `json:"DropOffLocation,omitempty"`

	// OtherAttributes Enumerated list of miscellaneous delivery attributes associated with the shipping address.
	OtherAttributes *[]OtherDeliveryAttributes `json:"OtherAttributes,omitempty"`

	// PreferredDeliveryTime The time window when the delivery is preferred.
	PreferredDeliveryTime *PreferredDeliveryTime `json:"PreferredDeliveryTime,omitempty"`
}

// EasyShipShipmentStatus The status of the Amazon Easy Ship order. This property is only included for Amazon Easy Ship orders.
type EasyShipShipmentStatus string

// ElectronicInvoiceStatus The status of the electronic invoice. Only available for Easy Ship orders and orders in the BR marketplace.
type ElectronicInvoiceStatus string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// ExceptionDates Dates when the business is closed or open with a different time window.
type ExceptionDates struct {
	// ExceptionDate Date when the business is closed, in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> date format.
	ExceptionDate *string `json:"ExceptionDate,omitempty"`

	// IsOpen Boolean indicating if the business is closed or open on that date.
	IsOpen *bool `json:"IsOpen,omitempty"`

	// OpenIntervals Time window during the day when the business is open.
	OpenIntervals *[]OpenInterval `json:"OpenIntervals,omitempty"`
}

// FulfillmentInstruction Contains the instructions about the fulfillment, such as the location from where you want the order filled.
type FulfillmentInstruction struct {
	// FulfillmentSupplySourceId The `sourceId` of the location from where you want the order fulfilled.
	FulfillmentSupplySourceId *string `json:"FulfillmentSupplySourceId,omitempty"`
}

// GetOrderAddressResponse The response schema for the `getOrderAddress` operation.
type GetOrderAddressResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The shipping address for the order.
	Payload *OrderAddress `json:"payload,omitempty"`
}

// GetOrderBuyerInfoResponse The response schema for the `getOrderBuyerInfo` operation.
type GetOrderBuyerInfoResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Buyer information for an order.
	Payload *OrderBuyerInfo `json:"payload,omitempty"`
}

// GetOrderItemsBuyerInfoResponse The response schema for the `getOrderItemsBuyerInfo` operation.
type GetOrderItemsBuyerInfoResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload A single order item's buyer information list with the order ID.
	Payload *OrderItemsBuyerInfoList `json:"payload,omitempty"`
}

// GetOrderItemsResponse The response schema for the `getOrderItems` operation.
type GetOrderItemsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The order items list along with the order ID.
	Payload *OrderItemsList `json:"payload,omitempty"`
}

// GetOrderRegulatedInfoResponse The response schema for the `getOrderRegulatedInfo` operation.
type GetOrderRegulatedInfoResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The order's regulated information along with its verification status.
	Payload *OrderRegulatedInfo `json:"payload,omitempty"`
}

// GetOrderResponse The response schema for the `getOrder` operation.
type GetOrderResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Order information.
	Payload *Order `json:"payload,omitempty"`
}

// GetOrdersResponse The response schema for the `getOrders` operation.
type GetOrdersResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload A list of orders along with additional information to make subsequent API calls.
	Payload *OrdersList `json:"payload,omitempty"`
}

// ItemBuyerInfo A single item's buyer information.
type ItemBuyerInfo struct {
	// BuyerCustomizedInfo Buyer information for custom orders from the Amazon Custom program.
	BuyerCustomizedInfo *BuyerCustomizedInfoDetail `json:"BuyerCustomizedInfo,omitempty"`

	// GiftMessageText A gift message provided by the buyer.
	//
	// **Note**: This attribute is only available for MFN (fulfilled by seller) orders.
	GiftMessageText *string `json:"GiftMessageText,omitempty"`

	// GiftWrapLevel The gift wrap level specified by the buyer.
	GiftWrapLevel *string `json:"GiftWrapLevel,omitempty"`

	// GiftWrapPrice The monetary value of the order.
	GiftWrapPrice *Money `json:"GiftWrapPrice,omitempty"`

	// GiftWrapTax The monetary value of the order.
	GiftWrapTax *Money `json:"GiftWrapTax,omitempty"`
}

// MarketplaceId The unobfuscated marketplace identifier.
type MarketplaceId = string

// MarketplaceTaxInfo Tax information about the marketplace.
type MarketplaceTaxInfo struct {
	// TaxClassifications A list of tax classifications that apply to the order.
	TaxClassifications *[]TaxClassification `json:"TaxClassifications,omitempty"`
}

// Measurement Measurement information for an order item.
type Measurement struct {
	// Unit The unit of measure.
	Unit MeasurementUnit `json:"Unit"`

	// Value The measurement value.
	Value float32 `json:"Value"`
}

// MeasurementUnit The unit of measure.
type MeasurementUnit string

// Money The monetary value of the order.
type Money struct {
	// Amount The currency amount.
	Amount *string `json:"Amount,omitempty"`

	// CurrencyCode The three-digit currency code. In ISO 4217 format.
	CurrencyCode *string `json:"CurrencyCode,omitempty"`
}

// OpenInterval The time interval for which the business is open.
type OpenInterval struct {
	// EndTime The time when the business opens or closes.
	EndTime *OpenTimeInterval `json:"EndTime,omitempty"`

	// StartTime The time when the business opens or closes.
	StartTime *OpenTimeInterval `json:"StartTime,omitempty"`
}

// OpenTimeInterval The time when the business opens or closes.
type OpenTimeInterval struct {
	// Hour The hour when the business opens or closes.
	Hour *int `json:"Hour,omitempty"`

	// Minute The minute when the business opens or closes.
	Minute *int `json:"Minute,omitempty"`
}

// Order Order information.
type Order struct {
	// AmazonOrderId An Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderId string `json:"AmazonOrderId"`

	// AutomatedShippingSettings Contains information regarding the Shipping Settings Automation program, such as whether the order's shipping settings were generated automatically, and what those settings are.
	AutomatedShippingSettings *AutomatedShippingSettings `json:"AutomatedShippingSettings,omitempty"`

	// BuyerInfo Buyer information.
	BuyerInfo *BuyerInfo `json:"BuyerInfo,omitempty"`

	// BuyerInvoicePreference The buyer's invoicing preference. Sellers can use this data to issue electronic invoices for orders in Turkey.
	//
	// **Note**: This attribute is only available in the Turkey marketplace.
	BuyerInvoicePreference *OrderBuyerInvoicePreference `json:"BuyerInvoicePreference,omitempty"`

	// BuyerTaxInformation Contains the business invoice tax information. Available only in the TR marketplace.
	BuyerTaxInformation *BuyerTaxInformation `json:"BuyerTaxInformation,omitempty"`

	// CbaDisplayableShippingLabel Custom ship label for Checkout by Amazon (CBA).
	CbaDisplayableShippingLabel *string `json:"CbaDisplayableShippingLabel,omitempty"`

	// DefaultShipFromLocationAddress The shipping address for the order.
	DefaultShipFromLocationAddress *Address `json:"DefaultShipFromLocationAddress,omitempty"`

	// EarliestDeliveryDate The start of the time period within which you have committed to fulfill the order. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date time format. Only returned for seller-fulfilled orders.
	EarliestDeliveryDate *string `json:"EarliestDeliveryDate,omitempty"`

	// EarliestShipDate The start of the time period within which you have committed to ship the order. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date time format. Only returned for seller-fulfilled orders.
	//
	// __Note__: `EarliestShipDate` might not be returned for orders placed before February 1, 2013.
	EarliestShipDate *string `json:"EarliestShipDate,omitempty"`

	// EasyShipShipmentStatus The status of the Amazon Easy Ship order. This property is only included for Amazon Easy Ship orders.
	EasyShipShipmentStatus *EasyShipShipmentStatus `json:"EasyShipShipmentStatus,omitempty"`

	// ElectronicInvoiceStatus The status of the electronic invoice. Only available for Easy Ship orders and orders in the BR marketplace.
	ElectronicInvoiceStatus *ElectronicInvoiceStatus `json:"ElectronicInvoiceStatus,omitempty"`

	// FulfillmentChannel Whether the order was fulfilled by Amazon (`AFN`) or by the seller (`MFN`).
	FulfillmentChannel *OrderFulfillmentChannel `json:"FulfillmentChannel,omitempty"`

	// FulfillmentInstruction Contains the instructions about the fulfillment, such as the location from where you want the order filled.
	FulfillmentInstruction *FulfillmentInstruction `json:"FulfillmentInstruction,omitempty"`

	// HasRegulatedItems Whether the order contains regulated items which may require additional approval steps before being fulfilled.
	HasRegulatedItems *bool `json:"HasRegulatedItems,omitempty"`

	// IsAccessPointOrder When true, this order is marked to be delivered to an Access Point. The access location is chosen by the customer. Access Points include Amazon Hub Lockers, Amazon Hub Counters, and pickup points operated by carriers.
	IsAccessPointOrder *bool `json:"IsAccessPointOrder,omitempty"`

	// IsBusinessOrder When true, the order is an Amazon Business order. An Amazon Business order is an order where the buyer is a Verified Business Buyer.
	IsBusinessOrder *bool `json:"IsBusinessOrder,omitempty"`

	// IsEstimatedShipDateSet When true, the estimated ship date is set for the order. Only returned for Sourcing on Demand orders.
	IsEstimatedShipDateSet *bool `json:"IsEstimatedShipDateSet,omitempty"`

	// IsGlobalExpressEnabled When true, the order is a `GlobalExpress` order.
	IsGlobalExpressEnabled *bool `json:"IsGlobalExpressEnabled,omitempty"`

	// IsIBA When true, the item within this order was bought and re-sold by Amazon Business EU SARL (ABEU). By buying and instantly re-selling your items, ABEU becomes the seller of record, making your inventory available for sale to customers who would not otherwise purchase from a third-party seller.
	IsIBA *bool `json:"IsIBA,omitempty"`

	// IsISPU When true, this order is marked to be picked up from a store rather than delivered.
	IsISPU *bool `json:"IsISPU,omitempty"`

	// IsPremiumOrder When true, the order has a Premium Shipping Service Level Agreement. For more information about Premium Shipping orders, refer to "Premium Shipping Options" in the Seller Central Help for your marketplace.
	IsPremiumOrder *bool `json:"IsPremiumOrder,omitempty"`

	// IsPrime When true, the order is a seller-fulfilled Amazon Prime order.
	IsPrime *bool `json:"IsPrime,omitempty"`

	// IsReplacementOrder When true, this is a replacement order.
	IsReplacementOrder *string `json:"IsReplacementOrder,omitempty"`

	// IsSoldByAB When true, the item within this order was bought and re-sold by Amazon Business EU SARL (ABEU). By buying and instantly re-selling your items, ABEU becomes the seller of record, making your inventory available for sale to customers who would not otherwise purchase from a third-party seller.
	IsSoldByAB *bool `json:"IsSoldByAB,omitempty"`

	// LastUpdateDate The date when the order was last updated.
	//
	// __Note__: `LastUpdateDate` is returned with an incorrect date for orders that were last updated before 2009-04-01.
	LastUpdateDate string `json:"LastUpdateDate"`

	// LatestDeliveryDate The end of the time period within which you have committed to fulfill the order. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date time format. Only returned for seller-fulfilled orders that do not have a `PendingAvailability`, `Pending`, or `Canceled` status.
	LatestDeliveryDate *string `json:"LatestDeliveryDate,omitempty"`

	// LatestShipDate The end of the time period within which you have committed to ship the order. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date time format. Only returned for seller-fulfilled orders.
	//
	// __Note__: `LatestShipDate` might not be returned for orders placed before February 1, 2013.
	LatestShipDate *string `json:"LatestShipDate,omitempty"`

	// MarketplaceId The identifier for the marketplace where the order was placed.
	MarketplaceId *string `json:"MarketplaceId,omitempty"`

	// MarketplaceTaxInfo Tax information about the marketplace.
	MarketplaceTaxInfo *MarketplaceTaxInfo `json:"MarketplaceTaxInfo,omitempty"`

	// NumberOfItemsShipped The number of items shipped.
	NumberOfItemsShipped *int `json:"NumberOfItemsShipped,omitempty"`

	// NumberOfItemsUnshipped The number of items unshipped.
	NumberOfItemsUnshipped *int `json:"NumberOfItemsUnshipped,omitempty"`

	// OrderChannel The order channel for the first item in the order.
	OrderChannel *string `json:"OrderChannel,omitempty"`

	// OrderStatus The current order status.
	OrderStatus OrderOrderStatus `json:"OrderStatus"`

	// OrderTotal The monetary value of the order.
	OrderTotal *Money `json:"OrderTotal,omitempty"`

	// OrderType The order's type.
	OrderType *OrderOrderType `json:"OrderType,omitempty"`

	// PaymentExecutionDetail A list of payment execution detail items.
	PaymentExecutionDetail *PaymentExecutionDetailItemList `json:"PaymentExecutionDetail,omitempty"`

	// PaymentMethod The payment method for the order. This property is limited to COD and CVS payment methods. Unless you need the specific COD payment information provided by the `PaymentExecutionDetailItem` object, we recommend using the `PaymentMethodDetails` property to get payment method information.
	PaymentMethod *OrderPaymentMethod `json:"PaymentMethod,omitempty"`

	// PaymentMethodDetails A list of payment method detail items.
	PaymentMethodDetails *PaymentMethodDetailItemList `json:"PaymentMethodDetails,omitempty"`

	// PromiseResponseDueDate Indicates the date by which the seller must respond to the buyer with an estimated ship date. Only returned for Sourcing on Demand orders.
	PromiseResponseDueDate *string `json:"PromiseResponseDueDate,omitempty"`

	// PurchaseDate The date when the order was created.
	PurchaseDate string `json:"PurchaseDate"`

	// ReplacedOrderId The order ID value for the order that is being replaced. Returned only if IsReplacementOrder = true.
	ReplacedOrderId *string `json:"ReplacedOrderId,omitempty"`

	// SalesChannel The sales channel for the first item in the order.
	SalesChannel *string `json:"SalesChannel,omitempty"`

	// SellerDisplayName The sellerâ€™s friendly name registered in the marketplace where the sale took place. Sellers can use this data to issue electronic invoices for orders in Brazil.
	//
	// **Note**: This attribute is only available in the Brazil marketplace for the orders with `Pending` or `Unshipped` status.
	SellerDisplayName *string `json:"SellerDisplayName,omitempty"`

	// SellerOrderId A seller-defined order identifier.
	SellerOrderId *string `json:"SellerOrderId,omitempty"`

	// ShipServiceLevel The order's shipment service level.
	ShipServiceLevel *string `json:"ShipServiceLevel,omitempty"`

	// ShipmentServiceLevelCategory The shipment service level category for the order.
	//
	// **Possible values**: `Expedited`, `FreeEconomy`, `NextDay`, `Priority`, `SameDay`, `SecondDay`, `Scheduled`, and `Standard`.
	ShipmentServiceLevelCategory *string `json:"ShipmentServiceLevelCategory,omitempty"`

	// ShippingAddress The shipping address for the order.
	ShippingAddress *Address `json:"ShippingAddress,omitempty"`
}

// OrderBuyerInvoicePreference The buyer's invoicing preference. Sellers can use this data to issue electronic invoices for orders in Turkey.
//
// **Note**: This attribute is only available in the Turkey marketplace.
type OrderBuyerInvoicePreference string

// OrderFulfillmentChannel Whether the order was fulfilled by Amazon (`AFN`) or by the seller (`MFN`).
type OrderFulfillmentChannel string

// OrderOrderStatus The current order status.
type OrderOrderStatus string

// OrderOrderType The order's type.
type OrderOrderType string

// OrderPaymentMethod The payment method for the order. This property is limited to COD and CVS payment methods. Unless you need the specific COD payment information provided by the `PaymentExecutionDetailItem` object, we recommend using the `PaymentMethodDetails` property to get payment method information.
type OrderPaymentMethod string

// OrderAddress The shipping address for the order.
type OrderAddress struct {
	// AmazonOrderId An Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderId string `json:"AmazonOrderId"`

	// BuyerCompanyName The company name of the contact buyer. For IBA orders, the buyer company must be Amazon entities.
	BuyerCompanyName *string `json:"BuyerCompanyName,omitempty"`

	// DeliveryPreferences Contains all of the delivery instructions provided by the customer for the shipping address.
	DeliveryPreferences *DeliveryPreferences `json:"DeliveryPreferences,omitempty"`

	// ShippingAddress The shipping address for the order.
	ShippingAddress *Address `json:"ShippingAddress,omitempty"`
}

// OrderBuyerInfo Buyer information for an order.
type OrderBuyerInfo struct {
	// AmazonOrderId An Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderId string `json:"AmazonOrderId"`

	// BuyerCounty The county of the buyer.
	//
	// **Note**: This attribute is only available in the Brazil marketplace.
	BuyerCounty *string `json:"BuyerCounty,omitempty"`

	// BuyerEmail The anonymized email address of the buyer.
	BuyerEmail *string `json:"BuyerEmail,omitempty"`

	// BuyerName The buyer name or the recipient name.
	BuyerName *string `json:"BuyerName,omitempty"`

	// BuyerTaxInfo Tax information about the buyer.
	BuyerTaxInfo *BuyerTaxInfo `json:"BuyerTaxInfo,omitempty"`

	// PurchaseOrderNumber The purchase order (PO) number entered by the buyer at checkout. Only returned for orders where the buyer entered a PO number at checkout.
	PurchaseOrderNumber *string `json:"PurchaseOrderNumber,omitempty"`
}

// OrderItem A single order item.
type OrderItem struct {
	// ASIN The item's Amazon Standard Identification Number (ASIN).
	ASIN string `json:"ASIN"`

	// AmazonPrograms Contains the list of programs that are associated with an item.
	//
	// Possible programs are:
	//  - **Subscribe and Save**: Offers recurring, scheduled deliveries to Amazon customers and Amazon Business customers for their frequently ordered products.
	AmazonPrograms *AmazonPrograms `json:"AmazonPrograms,omitempty"`

	// AssociatedItems A list of associated items that a customer has purchased with a product. For example, a tire installation service purchased with tires.
	AssociatedItems *[]AssociatedItem `json:"AssociatedItems,omitempty"`

	// BuyerInfo A single item's buyer information.
	BuyerInfo *ItemBuyerInfo `json:"BuyerInfo,omitempty"`

	// BuyerRequestedCancel Information about whether or not a buyer requested cancellation.
	BuyerRequestedCancel *BuyerRequestedCancel `json:"BuyerRequestedCancel,omitempty"`

	// CODFee The monetary value of the order.
	CODFee *Money `json:"CODFee,omitempty"`

	// CODFeeDiscount The monetary value of the order.
	CODFeeDiscount *Money `json:"CODFeeDiscount,omitempty"`

	// ConditionId The condition of the item.
	//
	// **Possible values**: `New`, `Used`, `Collectible`, `Refurbished`, `Preorder`, and `Club`.
	ConditionId *string `json:"ConditionId,omitempty"`

	// ConditionNote The condition of the item, as described by the seller.
	ConditionNote *string `json:"ConditionNote,omitempty"`

	// ConditionSubtypeId The subcondition of the item.
	//
	// **Possible values**: `New`, `Mint`, `Very Good`, `Good`, `Acceptable`, `Poor`, `Club`, `OEM`, `Warranty`, `Refurbished Warranty`, `Refurbished`, `Open Box`, `Any`, and `Other`.
	ConditionSubtypeId *string `json:"ConditionSubtypeId,omitempty"`

	// DeemedResellerCategory The category of deemed reseller. This applies to selling partners that are not based in the EU and is used to help them meet the VAT Deemed Reseller tax laws in the EU and UK.
	DeemedResellerCategory *OrderItemDeemedResellerCategory `json:"DeemedResellerCategory,omitempty"`

	// IossNumber The IOSS number of the marketplace. Sellers shipping to the EU from outside the EU must provide this IOSS number to their carrier when Amazon has collected the VAT on the sale.
	IossNumber *string `json:"IossNumber,omitempty"`

	// IsGift Indicates whether the item is a gift.
	//
	// **Possible values**: `true` and `false`.
	IsGift *string `json:"IsGift,omitempty"`

	// IsTransparency When true, the ASIN is enrolled in Transparency. The Transparency serial number that you must submit is determined by:
	//
	// **1D or 2D Barcode:** This has a **T** logo. Submit either the 29-character alpha-numeric identifier beginning with **AZ** or **ZA**, or the 38-character Serialized Global Trade Item Number (SGTIN).
	// **2D Barcode SN:** Submit the 7- to 20-character serial number barcode, which likely has the prefix **SN**. The serial number is applied to the same side of the packaging as the GTIN (UPC/EAN/ISBN) barcode.
	// **QR code SN:** Submit the URL that the QR code generates.
	IsTransparency *bool `json:"IsTransparency,omitempty"`

	// ItemPrice The monetary value of the order.
	ItemPrice *Money `json:"ItemPrice,omitempty"`

	// ItemTax The monetary value of the order.
	ItemTax *Money `json:"ItemTax,omitempty"`

	// Measurement Measurement information for an order item.
	Measurement *Measurement `json:"Measurement,omitempty"`

	// OrderItemId An Amazon-defined order item identifier.
	OrderItemId string `json:"OrderItemId"`

	// PointsGranted The number of Amazon Points offered with the purchase of an item, and their monetary value.
	PointsGranted *PointsGrantedDetail `json:"PointsGranted,omitempty"`

	// PriceDesignation Indicates that the selling price is a special price that is only available for Amazon Business orders. For more information about the Amazon Business Seller Program, refer to the [Amazon Business website](https://www.amazon.com/b2b/info/amazon-business).
	//
	// **Possible values**: `BusinessPrice`
	PriceDesignation *string `json:"PriceDesignation,omitempty"`

	// ProductInfo Product information on the number of items.
	ProductInfo *ProductInfoDetail `json:"ProductInfo,omitempty"`

	// PromotionDiscount The monetary value of the order.
	PromotionDiscount *Money `json:"PromotionDiscount,omitempty"`

	// PromotionDiscountTax The monetary value of the order.
	PromotionDiscountTax *Money `json:"PromotionDiscountTax,omitempty"`

	// PromotionIds A list of promotion identifiers provided by the seller when the promotions were created.
	PromotionIds *PromotionIdList `json:"PromotionIds,omitempty"`

	// QuantityOrdered The number of items in the order.
	QuantityOrdered int `json:"QuantityOrdered"`

	// QuantityShipped The number of items shipped.
	QuantityShipped *int `json:"QuantityShipped,omitempty"`

	// ScheduledDeliveryEndDate The end date of the scheduled delivery window in the time zone for the order destination. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date time format.
	ScheduledDeliveryEndDate *string `json:"ScheduledDeliveryEndDate,omitempty"`

	// ScheduledDeliveryStartDate The start date of the scheduled delivery window in the time zone for the order destination. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date time format.
	ScheduledDeliveryStartDate *string `json:"ScheduledDeliveryStartDate,omitempty"`

	// SellerSKU The item's seller stock keeping unit (SKU).
	SellerSKU *string `json:"SellerSKU,omitempty"`

	// SerialNumberRequired When true, the product type for this item has a serial number.
	//
	//  Only returned for Amazon Easy Ship orders.
	SerialNumberRequired *bool `json:"SerialNumberRequired,omitempty"`

	// SerialNumbers A list of serial numbers for electronic products that are shipped to customers. Returned for FBA orders only.
	SerialNumbers *[]string `json:"SerialNumbers,omitempty"`

	// ShippingConstraints Delivery constraints applicable to this order.
	ShippingConstraints *ShippingConstraints `json:"ShippingConstraints,omitempty"`

	// ShippingDiscount The monetary value of the order.
	ShippingDiscount *Money `json:"ShippingDiscount,omitempty"`

	// ShippingDiscountTax The monetary value of the order.
	ShippingDiscountTax *Money `json:"ShippingDiscountTax,omitempty"`

	// ShippingPrice The monetary value of the order.
	ShippingPrice *Money `json:"ShippingPrice,omitempty"`

	// ShippingTax The monetary value of the order.
	ShippingTax *Money `json:"ShippingTax,omitempty"`

	// StoreChainStoreId The store chain store identifier. Linked to a specific store in a store chain.
	StoreChainStoreId *string `json:"StoreChainStoreId,omitempty"`

	// SubstitutionPreferences Substitution preferences for an order item.
	SubstitutionPreferences *SubstitutionPreferences `json:"SubstitutionPreferences,omitempty"`

	// TaxCollection Information about withheld taxes.
	TaxCollection *TaxCollection `json:"TaxCollection,omitempty"`

	// Title The item's name.
	Title *string `json:"Title,omitempty"`
}

// OrderItemDeemedResellerCategory The category of deemed reseller. This applies to selling partners that are not based in the EU and is used to help them meet the VAT Deemed Reseller tax laws in the EU and UK.
type OrderItemDeemedResellerCategory string

// OrderItemBuyerInfo A single order item's buyer information.
type OrderItemBuyerInfo struct {
	// BuyerCustomizedInfo Buyer information for custom orders from the Amazon Custom program.
	BuyerCustomizedInfo *BuyerCustomizedInfoDetail `json:"BuyerCustomizedInfo,omitempty"`

	// GiftMessageText A gift message provided by the buyer.
	//
	// **Note**: This attribute is only available for MFN (fulfilled by seller) orders.
	GiftMessageText *string `json:"GiftMessageText,omitempty"`

	// GiftWrapLevel The gift wrap level specified by the buyer.
	GiftWrapLevel *string `json:"GiftWrapLevel,omitempty"`

	// GiftWrapPrice The monetary value of the order.
	GiftWrapPrice *Money `json:"GiftWrapPrice,omitempty"`

	// GiftWrapTax The monetary value of the order.
	GiftWrapTax *Money `json:"GiftWrapTax,omitempty"`

	// OrderItemId An Amazon-defined order item identifier.
	OrderItemId string `json:"OrderItemId"`
}

// OrderItemBuyerInfoList A single order item's buyer information list.
type OrderItemBuyerInfoList = []OrderItemBuyerInfo

// OrderItemList A list of order items.
type OrderItemList = []OrderItem

// OrderItems For partial shipment status updates, the list of order items and quantities to be updated.
type OrderItems = []struct {
	// OrderItemId The order item's unique identifier.
	OrderItemId *string `json:"orderItemId,omitempty"`

	// Quantity The quantity for which to update the shipment status.
	Quantity *int `json:"quantity,omitempty"`
}

// OrderItemsBuyerInfoList A single order item's buyer information list with the order ID.
type OrderItemsBuyerInfoList struct {
	// AmazonOrderId An Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderId string `json:"AmazonOrderId"`

	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"NextToken,omitempty"`

	// OrderItems A single order item's buyer information list.
	OrderItems OrderItemBuyerInfoList `json:"OrderItems"`
}

// OrderItemsList The order items list along with the order ID.
type OrderItemsList struct {
	// AmazonOrderId An Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderId string `json:"AmazonOrderId"`

	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"NextToken,omitempty"`

	// OrderItems A list of order items.
	OrderItems OrderItemList `json:"OrderItems"`
}

// OrderList A list of orders.
type OrderList = []Order

// OrderRegulatedInfo The order's regulated information along with its verification status.
type OrderRegulatedInfo struct {
	// AmazonOrderId An Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderId string `json:"AmazonOrderId"`

	// RegulatedInformation The regulated information collected during purchase and used to verify the order.
	RegulatedInformation RegulatedInformation `json:"RegulatedInformation"`

	// RegulatedOrderVerificationStatus The verification status of the order, along with associated approval or rejection metadata.
	RegulatedOrderVerificationStatus RegulatedOrderVerificationStatus `json:"RegulatedOrderVerificationStatus"`

	// RequiresDosageLabel When true, the order requires attaching a dosage information label when shipped.
	RequiresDosageLabel bool `json:"RequiresDosageLabel"`
}

// OrdersList A list of orders along with additional information to make subsequent API calls.
type OrdersList struct {
	// CreatedBefore Use this date to select orders created before (or at) a specified time. Only orders placed before the specified time are returned. The date must be in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) format.
	CreatedBefore *string `json:"CreatedBefore,omitempty"`

	// LastUpdatedBefore Use this date to select orders that were last updated before (or at) a specified time. An update is defined as any change in order status, including the creation of a new order. Includes updates made by Amazon and by the seller. All dates must be in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) format.
	LastUpdatedBefore *string `json:"LastUpdatedBefore,omitempty"`

	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"NextToken,omitempty"`

	// Orders A list of orders.
	Orders OrderList `json:"Orders"`
}

// OtherDeliveryAttributes Miscellaneous delivery attributes associated with the shipping address.
type OtherDeliveryAttributes string

// PackageDetail Properties of packages
type PackageDetail struct {
	// CarrierCode Identifies the carrier that will deliver the package. This field is required for all marketplaces. For more information, refer to the [`CarrierCode` announcement](https://developer-docs.amazon.com/sp-api/changelog/carriercode-value-required-in-shipment-confirmations-for-br-mx-ca-sg-au-in-jp-marketplaces).
	CarrierCode string `json:"carrierCode"`

	// CarrierName Carrier Name that will deliver the package. Required when `carrierCode` is "Others"
	CarrierName *string `json:"carrierName,omitempty"`

	// OrderItems A list of order items.
	OrderItems ConfirmShipmentOrderItemsList `json:"orderItems"`

	// PackageReferenceId A seller-supplied identifier that uniquely identifies a package within the scope of an order. Only positive numeric values are supported.
	PackageReferenceId PackageReferenceId `json:"packageReferenceId"`

	// ShipDate The shipping date for the package. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> date/time format.
	ShipDate time.Time `json:"shipDate"`

	// ShipFromSupplySourceId The unique identifier for the supply source.
	ShipFromSupplySourceId *string `json:"shipFromSupplySourceId,omitempty"`

	// ShippingMethod Ship method to be used for shipping the order.
	ShippingMethod *string `json:"shippingMethod,omitempty"`

	// TrackingNumber The tracking number used to obtain tracking and delivery information.
	TrackingNumber string `json:"trackingNumber"`
}

// PackageReferenceId A seller-supplied identifier that uniquely identifies a package within the scope of an order. Only positive numeric values are supported.
type PackageReferenceId = string

// PaymentExecutionDetailItem Information about a sub-payment method used to pay for a COD order.
type PaymentExecutionDetailItem struct {
	// Payment The monetary value of the order.
	Payment Money `json:"Payment"`

	// PaymentMethod A sub-payment method for a COD order.
	//
	// **Possible values**:
	// * `COD`: Cash on delivery
	// * `GC`: Gift card
	// * `PointsAccount`: Amazon Points
	// * `Invoice`: Invoice
	PaymentMethod string `json:"PaymentMethod"`
}

// PaymentExecutionDetailItemList A list of payment execution detail items.
type PaymentExecutionDetailItemList = []PaymentExecutionDetailItem

// PaymentMethodDetailItemList A list of payment method detail items.
type PaymentMethodDetailItemList = []string

// PointsGrantedDetail The number of Amazon Points offered with the purchase of an item, and their monetary value.
type PointsGrantedDetail struct {
	// PointsMonetaryValue The monetary value of the order.
	PointsMonetaryValue *Money `json:"PointsMonetaryValue,omitempty"`

	// PointsNumber The number of Amazon Points granted with the purchase of an item.
	PointsNumber *int `json:"PointsNumber,omitempty"`
}

// PreferredDeliveryTime The time window when the delivery is preferred.
type PreferredDeliveryTime struct {
	// BusinessHours Business hours when the business is open for deliveries.
	BusinessHours *[]BusinessHours `json:"BusinessHours,omitempty"`

	// ExceptionDates Dates when the business is closed during the next 30 days.
	ExceptionDates *[]ExceptionDates `json:"ExceptionDates,omitempty"`
}

// PrescriptionDetail Information about the prescription that is used to verify a regulated product. This must be provided once per order and reflect the sellerâ€™s own records. Only approved orders can have prescriptions.
type PrescriptionDetail struct {
	// ClinicId The identifier for the clinic which provided the prescription used to verify the regulated product.
	ClinicId string `json:"clinicId"`

	// ExpirationDate The expiration date of the prescription used to verify the regulated product, in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date time format.
	ExpirationDate time.Time `json:"expirationDate"`

	// PrescriptionId The identifier for the prescription used to verify the regulated product.
	PrescriptionId string `json:"prescriptionId"`

	// RefillsRemaining The number of refills remaining for the prescription used to verify the regulated product. If a prescription originally had 10 total refills, this value must be `10` for the first order, `9` for the second order, and `0` for the eleventh order. If a prescription originally had no refills, this value must be 0.
	RefillsRemaining int `json:"refillsRemaining"`

	// TotalRefillsAuthorized The total number of refills written in the original prescription used to verify the regulated product. If a prescription originally had no refills, this value must be 0.
	TotalRefillsAuthorized int `json:"totalRefillsAuthorized"`

	// UsageInstructions The instructions for the prescription as provided by the approver of the regulated product.
	UsageInstructions string `json:"usageInstructions"`

	// WrittenQuantity The number of units in each fill as provided in the prescription.
	WrittenQuantity int `json:"writtenQuantity"`
}

// ProductInfoDetail Product information on the number of items.
type ProductInfoDetail struct {
	// NumberOfItems The total number of items that are included in the ASIN.
	NumberOfItems *string `json:"NumberOfItems,omitempty"`
}

// PromotionIdList A list of promotion identifiers provided by the seller when the promotions were created.
type PromotionIdList = []string

// RegulatedInformation The regulated information collected during purchase and used to verify the order.
type RegulatedInformation struct {
	// Fields A list of regulated information fields as collected from the regulatory form.
	Fields []RegulatedInformationField `json:"Fields"`
}

// RegulatedInformationField A field collected from the regulatory form.
type RegulatedInformationField struct {
	// FieldId The unique identifier of the field.
	FieldId string `json:"FieldId"`

	// FieldLabel The name of the field.
	FieldLabel string `json:"FieldLabel"`

	// FieldType The type of field.
	FieldType RegulatedInformationFieldFieldType `json:"FieldType"`

	// FieldValue The content of the field as collected in regulatory form. Note that `FileAttachment` type fields contain a URL where you can download the attachment.
	FieldValue string `json:"FieldValue"`
}

// RegulatedInformationFieldFieldType The type of field.
type RegulatedInformationFieldFieldType string

// RegulatedOrderVerificationStatus The verification status of the order, along with associated approval or rejection metadata.
type RegulatedOrderVerificationStatus struct {
	// ExternalReviewerId The identifier for the order's regulated information reviewer.
	ExternalReviewerId *string `json:"ExternalReviewerId,omitempty"`

	// RejectionReason The reason for rejecting the order's regulated information. This is only present if the order is rejected.
	RejectionReason *RejectionReason `json:"RejectionReason,omitempty"`

	// RequiresMerchantAction When true, the regulated information provided in the order requires a review by the merchant.
	RequiresMerchantAction bool `json:"RequiresMerchantAction"`

	// ReviewDate The date the order was reviewed. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date time format.
	ReviewDate *string `json:"ReviewDate,omitempty"`

	// Status The verification status of the order.
	Status VerificationStatus `json:"Status"`

	// ValidRejectionReasons A list of valid rejection reasons that may be used to reject the order's regulated information.
	ValidRejectionReasons []RejectionReason `json:"ValidRejectionReasons"`

	// ValidVerificationDetails A list of valid verification details that may be provided and the criteria required for when the verification detail can be provided.
	ValidVerificationDetails *[]ValidVerificationDetail `json:"ValidVerificationDetails,omitempty"`
}

// RejectionReason The reason for rejecting the order's regulated information. This is only present if the order is rejected.
type RejectionReason struct {
	// RejectionReasonDescription The description of this rejection reason.
	RejectionReasonDescription string `json:"RejectionReasonDescription"`

	// RejectionReasonId The unique identifier for the rejection reason.
	RejectionReasonId string `json:"RejectionReasonId"`
}

// ShipmentStatus The shipment status to apply.
type ShipmentStatus string

// ShippingConstraints Delivery constraints applicable to this order.
type ShippingConstraints struct {
	// PalletDelivery Details the importance of the constraint present on the item
	PalletDelivery *ConstraintType `json:"PalletDelivery,omitempty"`

	// RecipientAgeVerification Details the importance of the constraint present on the item
	RecipientAgeVerification *ConstraintType `json:"RecipientAgeVerification,omitempty"`

	// RecipientIdentityVerification Details the importance of the constraint present on the item
	RecipientIdentityVerification *ConstraintType `json:"RecipientIdentityVerification,omitempty"`

	// SignatureConfirmation Details the importance of the constraint present on the item
	SignatureConfirmation *ConstraintType `json:"SignatureConfirmation,omitempty"`
}

// SubstitutionOption Substitution options for an order item.
type SubstitutionOption struct {
	// ASIN The item's Amazon Standard Identification Number (ASIN).
	ASIN *string `json:"ASIN,omitempty"`

	// Measurement Measurement information for an order item.
	Measurement *Measurement `json:"Measurement,omitempty"`

	// QuantityOrdered The number of items to be picked for this substitution option.
	QuantityOrdered *int `json:"QuantityOrdered,omitempty"`

	// SellerSKU The item's seller stock keeping unit (SKU).
	SellerSKU *string `json:"SellerSKU,omitempty"`

	// Title The item's title.
	Title *string `json:"Title,omitempty"`
}

// SubstitutionOptionList A collection of substitution options.
type SubstitutionOptionList = []SubstitutionOption

// SubstitutionPreferences Substitution preferences for an order item.
type SubstitutionPreferences struct {
	// SubstitutionOptions A collection of substitution options.
	SubstitutionOptions *SubstitutionOptionList `json:"SubstitutionOptions,omitempty"`

	// SubstitutionType The type of substitution that these preferences represent.
	SubstitutionType SubstitutionPreferencesSubstitutionType `json:"SubstitutionType"`
}

// SubstitutionPreferencesSubstitutionType The type of substitution that these preferences represent.
type SubstitutionPreferencesSubstitutionType string

// TaxClassification The tax classification of the order.
type TaxClassification struct {
	// Name The type of tax.
	Name *string `json:"Name,omitempty"`

	// Value The buyer's tax identifier.
	Value *string `json:"Value,omitempty"`
}

// TaxCollection Information about withheld taxes.
type TaxCollection struct {
	// Model The tax collection model applied to the item.
	Model *TaxCollectionModel `json:"Model,omitempty"`

	// ResponsibleParty The party responsible for withholding the taxes and remitting them to the taxing authority.
	ResponsibleParty *TaxCollectionResponsibleParty `json:"ResponsibleParty,omitempty"`
}

// TaxCollectionModel The tax collection model applied to the item.
type TaxCollectionModel string

// TaxCollectionResponsibleParty The party responsible for withholding the taxes and remitting them to the taxing authority.
type TaxCollectionResponsibleParty string

// TransparencyCode The transparency code associated with the item.
type TransparencyCode = string

// TransparencyCodeList A list of order items.
type TransparencyCodeList = []TransparencyCode

// UpdateShipmentStatusErrorResponse The error response schema for the `UpdateShipmentStatus` operation.
type UpdateShipmentStatusErrorResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// UpdateShipmentStatusRequest The request body for the `updateShipmentStatus` operation.
type UpdateShipmentStatusRequest struct {
	// MarketplaceId The unobfuscated marketplace identifier.
	MarketplaceId MarketplaceId `json:"marketplaceId"`

	// OrderItems For partial shipment status updates, the list of order items and quantities to be updated.
	OrderItems *OrderItems `json:"orderItems,omitempty"`

	// ShipmentStatus The shipment status to apply.
	ShipmentStatus ShipmentStatus `json:"shipmentStatus"`
}

// UpdateVerificationStatusErrorResponse The error response schema for the `UpdateVerificationStatus` operation.
type UpdateVerificationStatusErrorResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// UpdateVerificationStatusRequest The request body for the `updateVerificationStatus` operation.
type UpdateVerificationStatusRequest struct {
	// RegulatedOrderVerificationStatus The updated values of the `VerificationStatus` field.
	RegulatedOrderVerificationStatus UpdateVerificationStatusRequestBody `json:"regulatedOrderVerificationStatus"`
}

// UpdateVerificationStatusRequestBody The updated values of the `VerificationStatus` field.
type UpdateVerificationStatusRequestBody struct {
	// ExternalReviewerId The identifier of the order's regulated information reviewer.
	ExternalReviewerId string `json:"externalReviewerId"`

	// RejectionReasonId The unique identifier of the rejection reason used for rejecting the order's regulated information. Only required if the new status is rejected.
	RejectionReasonId *string `json:"rejectionReasonId,omitempty"`

	// Status The verification status of the order.
	Status *VerificationStatus `json:"status,omitempty"`

	// VerificationDetails Additional information related to the verification of a regulated order.
	VerificationDetails *VerificationDetails `json:"verificationDetails,omitempty"`
}

// ValidVerificationDetail The types of verification details that may be provided for the order and the criteria required for when the type of verification detail can be provided. The types of verification details allowed depend on the type of regulated product and will not change order to order.
type ValidVerificationDetail struct {
	// ValidVerificationStatuses A list of valid verification statuses where the associated verification detail type may be provided. For example, if the value of this field is ["Approved"], calls to provide the associated verification detail will fail for orders with a `VerificationStatus` of `Pending`, `Rejected`, `Expired`, or `Cancelled`.
	ValidVerificationStatuses []VerificationStatus `json:"ValidVerificationStatuses"`

	// VerificationDetailType A supported type of verification detail. The type indicates which verification detail could be shared while updating the regulated order. Valid value: `prescriptionDetail`.
	VerificationDetailType string `json:"VerificationDetailType"`
}

// VerificationDetails Additional information related to the verification of a regulated order.
type VerificationDetails struct {
	// PrescriptionDetail Information about the prescription that is used to verify a regulated product. This must be provided once per order and reflect the sellerâ€™s own records. Only approved orders can have prescriptions.
	PrescriptionDetail *PrescriptionDetail `json:"prescriptionDetail,omitempty"`
}

// VerificationStatus The verification status of the order.
type VerificationStatus string

// GetOrdersParams defines parameters for GetOrders.
type GetOrdersParams struct {
	// CreatedAfter Use this date to select orders created after (or at) a specified time. Only orders placed after the specified time are returned. The date must be in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) format.
	//
	// **Note**: Either the `CreatedAfter` parameter or the `LastUpdatedAfter` parameter is required. Both cannot be empty. `LastUpdatedAfter` and `LastUpdatedBefore` cannot be set when `CreatedAfter` is set.
	CreatedAfter *string `form:"CreatedAfter,omitempty" json:"CreatedAfter,omitempty"`

	// CreatedBefore Use this date to select orders created before (or at) a specified time. Only orders placed before the specified time are returned. The date must be in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) format.
	//
	// **Note**: `CreatedBefore` is optional when `CreatedAfter` is set. If specified, `CreatedBefore` must be equal to or after the `CreatedAfter` date and at least two minutes before current time.
	CreatedBefore *string `form:"CreatedBefore,omitempty" json:"CreatedBefore,omitempty"`

	// LastUpdatedAfter Use this date to select orders that were last updated after (or at) a specified time. An update is defined as any change in order status, including the creation of a new order. Includes updates made by Amazon and by the seller. The date must be in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) format.
	//
	// **Note**: Either the `CreatedAfter` parameter or the `LastUpdatedAfter` parameter is required. Both cannot be empty. `CreatedAfter` or `CreatedBefore` cannot be set when `LastUpdatedAfter` is set.
	LastUpdatedAfter *string `form:"LastUpdatedAfter,omitempty" json:"LastUpdatedAfter,omitempty"`

	// LastUpdatedBefore Use this date to select orders that were last updated before (or at) a specified time. An update is defined as any change in order status, including the creation of a new order. Includes updates made by Amazon and by the seller. The date must be in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) format.
	//
	// **Note**: `LastUpdatedBefore` is optional when `LastUpdatedAfter` is set. But if specified, `LastUpdatedBefore` must be equal to or after the `LastUpdatedAfter` date and at least two minutes before current time.
	LastUpdatedBefore *string `form:"LastUpdatedBefore,omitempty" json:"LastUpdatedBefore,omitempty"`

	// OrderStatuses A list of `OrderStatus` values used to filter the results.
	//
	// **Possible values:**
	// - `PendingAvailability` (This status is available for pre-orders only. The order has been placed, payment has not been authorized, and the release date of the item is in the future.)
	// - `Pending` (The order has been placed but payment has not been authorized.)
	// - `Unshipped` (Payment has been authorized and the order is ready for shipment, but no items in the order have been shipped.)
	// - `PartiallyShipped` (One or more, but not all, items in the order have been shipped.)
	// - `Shipped` (All items in the order have been shipped.)
	// - `InvoiceUnconfirmed` (All items in the order have been shipped. The seller has not yet given confirmation to Amazon that the invoice has been shipped to the buyer.)
	// - `Canceled` (The order has been canceled.)
	// - `Unfulfillable` (The order cannot be fulfilled. This state applies only to Multi-Channel Fulfillment orders.)
	OrderStatuses *[]string `form:"OrderStatuses,omitempty" json:"OrderStatuses,omitempty"`

	// MarketplaceIds A list of `MarketplaceId` values. Used to select orders that were placed in the specified marketplaces.
	//
	// Refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids) for a complete list of `marketplaceId` values.
	MarketplaceIds []string `form:"MarketplaceIds" json:"MarketplaceIds"`

	// FulfillmentChannels A list that indicates how an order was fulfilled. Filters the results by fulfillment channel.
	//
	// **Possible values**: `AFN` (fulfilled by Amazon), `MFN` (fulfilled by seller).
	FulfillmentChannels *[]string `form:"FulfillmentChannels,omitempty" json:"FulfillmentChannels,omitempty"`

	// PaymentMethods A list of payment method values. Use this field to select orders that were paid with the specified payment methods.
	//
	// **Possible values**: `COD` (cash on delivery), `CVS` (convenience store), `Other` (Any payment method other than COD or CVS).
	PaymentMethods *[]string `form:"PaymentMethods,omitempty" json:"PaymentMethods,omitempty"`

	// BuyerEmail The email address of a buyer. Used to select orders that contain the specified email address.
	BuyerEmail *string `form:"BuyerEmail,omitempty" json:"BuyerEmail,omitempty"`

	// SellerOrderId An order identifier that is specified by the seller. Used to select only the orders that match the order identifier. If `SellerOrderId` is specified, then `FulfillmentChannels`, `OrderStatuses`, `PaymentMethod`, `LastUpdatedAfter`, LastUpdatedBefore, and `BuyerEmail` cannot be specified.
	SellerOrderId *string `form:"SellerOrderId,omitempty" json:"SellerOrderId,omitempty"`

	// MaxResultsPerPage A number that indicates the maximum number of orders that can be returned per page. Value must be 1 - 100. Default 100.
	MaxResultsPerPage *int `form:"MaxResultsPerPage,omitempty" json:"MaxResultsPerPage,omitempty"`

	// EasyShipShipmentStatuses A list of `EasyShipShipmentStatus` values. Used to select Easy Ship orders with statuses that match the specified values. If `EasyShipShipmentStatus` is specified, only Amazon Easy Ship orders are returned.
	//
	// **Possible values:**
	// - `PendingSchedule` (The package is awaiting the schedule for pick-up.)
	// - `PendingPickUp` (Amazon has not yet picked up the package from the seller.)
	// - `PendingDropOff` (The seller will deliver the package to the carrier.)
	// - `LabelCanceled` (The seller canceled the pickup.)
	// - `PickedUp` (Amazon has picked up the package from the seller.)
	// - `DroppedOff` (The package is delivered to the carrier by the seller.)
	// - `AtOriginFC` (The packaged is at the origin fulfillment center.)
	// - `AtDestinationFC` (The package is at the destination fulfillment center.)
	// - `Delivered` (The package has been delivered.)
	// - `RejectedByBuyer` (The package has been rejected by the buyer.)
	// - `Undeliverable` (The package cannot be delivered.)
	// - `ReturningToSeller` (The package was not delivered and is being returned to the seller.)
	// - `ReturnedToSeller` (The package was not delivered and was returned to the seller.)
	// - `Lost` (The package is lost.)
	// - `OutForDelivery` (The package is out for delivery.)
	// - `Damaged` (The package was damaged by the carrier.)
	EasyShipShipmentStatuses *[]string `form:"EasyShipShipmentStatuses,omitempty" json:"EasyShipShipmentStatuses,omitempty"`

	// ElectronicInvoiceStatuses A list of `ElectronicInvoiceStatus` values. Used to select orders with electronic invoice statuses that match the specified values.
	//
	// **Possible values:**
	// - `NotRequired` (Electronic invoice submission is not required for this order.)
	// - `NotFound` (The electronic invoice was not submitted for this order.)
	// - `Processing` (The electronic invoice is being processed for this order.)
	// - `Errored` (The last submitted electronic invoice was rejected for this order.)
	// - `Accepted` (The last submitted electronic invoice was submitted and accepted.)
	ElectronicInvoiceStatuses *[]string `form:"ElectronicInvoiceStatuses,omitempty" json:"ElectronicInvoiceStatuses,omitempty"`

	// NextToken A string token returned in the response of your previous request.
	NextToken *string `form:"NextToken,omitempty" json:"NextToken,omitempty"`

	// AmazonOrderIds A list of `AmazonOrderId` values. An `AmazonOrderId` is an Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderIds *[]string `form:"AmazonOrderIds,omitempty" json:"AmazonOrderIds,omitempty"`

	// ActualFulfillmentSupplySourceId The `sourceId` of the location from where you want the order fulfilled.
	ActualFulfillmentSupplySourceId *string `form:"ActualFulfillmentSupplySourceId,omitempty" json:"ActualFulfillmentSupplySourceId,omitempty"`

	// IsISPU When true, this order is marked to be picked up from a store rather than delivered.
	IsISPU *bool `form:"IsISPU,omitempty" json:"IsISPU,omitempty"`

	// StoreChainStoreId The store chain store identifier. Linked to a specific store in a store chain.
	StoreChainStoreId *string `form:"StoreChainStoreId,omitempty" json:"StoreChainStoreId,omitempty"`

	// EarliestDeliveryDateBefore Use this date to select orders with a earliest delivery date before (or at) a specified time. The date must be in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) format.
	EarliestDeliveryDateBefore *string `form:"EarliestDeliveryDateBefore,omitempty" json:"EarliestDeliveryDateBefore,omitempty"`

	// EarliestDeliveryDateAfter Use this date to select orders with a earliest delivery date after (or at) a specified time. The date must be in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) format.
	EarliestDeliveryDateAfter *string `form:"EarliestDeliveryDateAfter,omitempty" json:"EarliestDeliveryDateAfter,omitempty"`

	// LatestDeliveryDateBefore Use this date to select orders with a latest delivery date before (or at) a specified time. The date must be in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) format.
	LatestDeliveryDateBefore *string `form:"LatestDeliveryDateBefore,omitempty" json:"LatestDeliveryDateBefore,omitempty"`

	// LatestDeliveryDateAfter Use this date to select orders with a latest delivery date after (or at) a specified time. The date must be in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) format.
	LatestDeliveryDateAfter *string `form:"LatestDeliveryDateAfter,omitempty" json:"LatestDeliveryDateAfter,omitempty"`
}

// GetOrderItemsParams defines parameters for GetOrderItems.
type GetOrderItemsParams struct {
	// NextToken A string token returned in the response of your previous request.
	NextToken *string `form:"NextToken,omitempty" json:"NextToken,omitempty"`
}

// GetOrderItemsBuyerInfoParams defines parameters for GetOrderItemsBuyerInfo.
type GetOrderItemsBuyerInfoParams struct {
	// NextToken A string token returned in the response of your previous request.
	NextToken *string `form:"NextToken,omitempty" json:"NextToken,omitempty"`
}

// UpdateVerificationStatusJSONRequestBody defines body for UpdateVerificationStatus for application/json ContentType.
type UpdateVerificationStatusJSONRequestBody = UpdateVerificationStatusRequest

// UpdateShipmentStatusJSONRequestBody defines body for UpdateShipmentStatus for application/json ContentType.
type UpdateShipmentStatusJSONRequestBody = UpdateShipmentStatusRequest

// ConfirmShipmentJSONRequestBody defines body for ConfirmShipment for application/json ContentType.
type ConfirmShipmentJSONRequestBody = ConfirmShipmentRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetOrders request
	GetOrders(ctx context.Context, params *GetOrdersParams) (*http.Response, error)

	// GetOrder request
	GetOrder(ctx context.Context, orderId string) (*http.Response, error)

	// GetOrderAddress request
	GetOrderAddress(ctx context.Context, orderId string) (*http.Response, error)

	// GetOrderBuyerInfo request
	GetOrderBuyerInfo(ctx context.Context, orderId string) (*http.Response, error)

	// GetOrderItems request
	GetOrderItems(ctx context.Context, orderId string, params *GetOrderItemsParams) (*http.Response, error)

	// GetOrderItemsBuyerInfo request
	GetOrderItemsBuyerInfo(ctx context.Context, orderId string, params *GetOrderItemsBuyerInfoParams) (*http.Response, error)

	// GetOrderRegulatedInfo request
	GetOrderRegulatedInfo(ctx context.Context, orderId string) (*http.Response, error)

	// UpdateVerificationStatusWithBody request with any body
	UpdateVerificationStatusWithBody(ctx context.Context, orderId string, contentType string, body io.Reader) (*http.Response, error)

	UpdateVerificationStatus(ctx context.Context, orderId string, body UpdateVerificationStatusJSONRequestBody) (*http.Response, error)

	// UpdateShipmentStatusWithBody request with any body
	UpdateShipmentStatusWithBody(ctx context.Context, orderId string, contentType string, body io.Reader) (*http.Response, error)

	UpdateShipmentStatus(ctx context.Context, orderId string, body UpdateShipmentStatusJSONRequestBody) (*http.Response, error)

	// ConfirmShipmentWithBody request with any body
	ConfirmShipmentWithBody(ctx context.Context, orderId string, contentType string, body io.Reader) (*http.Response, error)

	ConfirmShipment(ctx context.Context, orderId string, body ConfirmShipmentJSONRequestBody) (*http.Response, error)
}

func (c *Client) GetOrders(ctx context.Context, params *GetOrdersParams) (*http.Response, error) {
	req, err := NewGetOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetOrder(ctx context.Context, orderId string) (*http.Response, error) {
	req, err := NewGetOrderRequest(c.Server, orderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetOrderAddress(ctx context.Context, orderId string) (*http.Response, error) {
	req, err := NewGetOrderAddressRequest(c.Server, orderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetOrderBuyerInfo(ctx context.Context, orderId string) (*http.Response, error) {
	req, err := NewGetOrderBuyerInfoRequest(c.Server, orderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetOrderItems(ctx context.Context, orderId string, params *GetOrderItemsParams) (*http.Response, error) {
	req, err := NewGetOrderItemsRequest(c.Server, orderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetOrderItemsBuyerInfo(ctx context.Context, orderId string, params *GetOrderItemsBuyerInfoParams) (*http.Response, error) {
	req, err := NewGetOrderItemsBuyerInfoRequest(c.Server, orderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetOrderRegulatedInfo(ctx context.Context, orderId string) (*http.Response, error) {
	req, err := NewGetOrderRegulatedInfoRequest(c.Server, orderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateVerificationStatusWithBody(ctx context.Context, orderId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateVerificationStatusRequestWithBody(c.Server, orderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateVerificationStatus(ctx context.Context, orderId string, body UpdateVerificationStatusJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateVerificationStatusRequest(c.Server, orderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateShipmentStatusWithBody(ctx context.Context, orderId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateShipmentStatusRequestWithBody(c.Server, orderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateShipmentStatus(ctx context.Context, orderId string, body UpdateShipmentStatusJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateShipmentStatusRequest(c.Server, orderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ConfirmShipmentWithBody(ctx context.Context, orderId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewConfirmShipmentRequestWithBody(c.Server, orderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ConfirmShipment(ctx context.Context, orderId string, body ConfirmShipmentJSONRequestBody) (*http.Response, error) {
	req, err := NewConfirmShipmentRequest(c.Server, orderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewGetOrdersRequest generates requests for GetOrders
func NewGetOrdersRequest(server string, params *GetOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "CreatedAfter", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "CreatedBefore", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LastUpdatedAfter", runtime.ParamLocationQuery, *params.LastUpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LastUpdatedBefore", runtime.ParamLocationQuery, *params.LastUpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.OrderStatuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "OrderStatuses", runtime.ParamLocationQuery, *params.OrderStatuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.FulfillmentChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "FulfillmentChannels", runtime.ParamLocationQuery, *params.FulfillmentChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaymentMethods != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "PaymentMethods", runtime.ParamLocationQuery, *params.PaymentMethods); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.BuyerEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "BuyerEmail", runtime.ParamLocationQuery, *params.BuyerEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SellerOrderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SellerOrderId", runtime.ParamLocationQuery, *params.SellerOrderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.MaxResultsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MaxResultsPerPage", runtime.ParamLocationQuery, *params.MaxResultsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.EasyShipShipmentStatuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "EasyShipShipmentStatuses", runtime.ParamLocationQuery, *params.EasyShipShipmentStatuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ElectronicInvoiceStatuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ElectronicInvoiceStatuses", runtime.ParamLocationQuery, *params.ElectronicInvoiceStatuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.AmazonOrderIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "AmazonOrderIds", runtime.ParamLocationQuery, *params.AmazonOrderIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ActualFulfillmentSupplySourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ActualFulfillmentSupplySourceId", runtime.ParamLocationQuery, *params.ActualFulfillmentSupplySourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IsISPU != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "IsISPU", runtime.ParamLocationQuery, *params.IsISPU); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.StoreChainStoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "StoreChainStoreId", runtime.ParamLocationQuery, *params.StoreChainStoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.EarliestDeliveryDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "EarliestDeliveryDateBefore", runtime.ParamLocationQuery, *params.EarliestDeliveryDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.EarliestDeliveryDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "EarliestDeliveryDateAfter", runtime.ParamLocationQuery, *params.EarliestDeliveryDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LatestDeliveryDateBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LatestDeliveryDateBefore", runtime.ParamLocationQuery, *params.LatestDeliveryDateBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LatestDeliveryDateAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LatestDeliveryDateAfter", runtime.ParamLocationQuery, *params.LatestDeliveryDateAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderRequest generates requests for GetOrder
func NewGetOrderRequest(server string, orderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderAddressRequest generates requests for GetOrderAddress
func NewGetOrderAddressRequest(server string, orderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/address", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderBuyerInfoRequest generates requests for GetOrderBuyerInfo
func NewGetOrderBuyerInfoRequest(server string, orderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/buyerInfo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderItemsRequest generates requests for GetOrderItems
func NewGetOrderItemsRequest(server string, orderId string, params *GetOrderItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/orderItems", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderItemsBuyerInfoRequest generates requests for GetOrderItemsBuyerInfo
func NewGetOrderItemsBuyerInfoRequest(server string, orderId string, params *GetOrderItemsBuyerInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/orderItems/buyerInfo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderRegulatedInfoRequest generates requests for GetOrderRegulatedInfo
func NewGetOrderRegulatedInfoRequest(server string, orderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/regulatedInfo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVerificationStatusRequest calls the generic UpdateVerificationStatus builder with application/json body
func NewUpdateVerificationStatusRequest(server string, orderId string, body UpdateVerificationStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVerificationStatusRequestWithBody(server, orderId, "application/json", bodyReader)
}

// NewUpdateVerificationStatusRequestWithBody generates requests for UpdateVerificationStatus with any type of body
func NewUpdateVerificationStatusRequestWithBody(server string, orderId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/regulatedInfo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateShipmentStatusRequest calls the generic UpdateShipmentStatus builder with application/json body
func NewUpdateShipmentStatusRequest(server string, orderId string, body UpdateShipmentStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShipmentStatusRequestWithBody(server, orderId, "application/json", bodyReader)
}

// NewUpdateShipmentStatusRequestWithBody generates requests for UpdateShipmentStatus with any type of body
func NewUpdateShipmentStatusRequestWithBody(server string, orderId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/shipment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConfirmShipmentRequest calls the generic ConfirmShipment builder with application/json body
func NewConfirmShipmentRequest(server string, orderId string, body ConfirmShipmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfirmShipmentRequestWithBody(server, orderId, "application/json", bodyReader)
}

// NewConfirmShipmentRequestWithBody generates requests for ConfirmShipment with any type of body
func NewConfirmShipmentRequestWithBody(server string, orderId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/shipmentConfirmation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetOrdersWithResponse request
	GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams) (*GetOrdersResp, error)

	// GetOrderWithResponse request
	GetOrderWithResponse(ctx context.Context, orderId string) (*GetOrderResp, error)

	// GetOrderAddressWithResponse request
	GetOrderAddressWithResponse(ctx context.Context, orderId string) (*GetOrderAddressResp, error)

	// GetOrderBuyerInfoWithResponse request
	GetOrderBuyerInfoWithResponse(ctx context.Context, orderId string) (*GetOrderBuyerInfoResp, error)

	// GetOrderItemsWithResponse request
	GetOrderItemsWithResponse(ctx context.Context, orderId string, params *GetOrderItemsParams) (*GetOrderItemsResp, error)

	// GetOrderItemsBuyerInfoWithResponse request
	GetOrderItemsBuyerInfoWithResponse(ctx context.Context, orderId string, params *GetOrderItemsBuyerInfoParams) (*GetOrderItemsBuyerInfoResp, error)

	// GetOrderRegulatedInfoWithResponse request
	GetOrderRegulatedInfoWithResponse(ctx context.Context, orderId string) (*GetOrderRegulatedInfoResp, error)

	// UpdateVerificationStatusWithBodyWithResponse request with any body
	UpdateVerificationStatusWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader) (*UpdateVerificationStatusResp, error)

	UpdateVerificationStatusWithResponse(ctx context.Context, orderId string, body UpdateVerificationStatusJSONRequestBody) (*UpdateVerificationStatusResp, error)

	// UpdateShipmentStatusWithBodyWithResponse request with any body
	UpdateShipmentStatusWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader) (*UpdateShipmentStatusResp, error)

	UpdateShipmentStatusWithResponse(ctx context.Context, orderId string, body UpdateShipmentStatusJSONRequestBody) (*UpdateShipmentStatusResp, error)

	// ConfirmShipmentWithBodyWithResponse request with any body
	ConfirmShipmentWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader) (*ConfirmShipmentResp, error)

	ConfirmShipmentWithResponse(ctx context.Context, orderId string, body ConfirmShipmentJSONRequestBody) (*ConfirmShipmentResp, error)
}

type GetOrdersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrdersResponse
	JSON400      *GetOrdersResponse
	JSON403      *GetOrdersResponse
	JSON404      *GetOrdersResponse
	JSON429      *GetOrdersResponse
	JSON500      *GetOrdersResponse
	JSON503      *GetOrdersResponse
}

// Status returns HTTPResponse.Status
func (r GetOrdersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderResponse
	JSON400      *GetOrderResponse
	JSON403      *GetOrderResponse
	JSON404      *GetOrderResponse
	JSON429      *GetOrderResponse
	JSON500      *GetOrderResponse
	JSON503      *GetOrderResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderAddressResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderAddressResponse
	JSON400      *GetOrderAddressResponse
	JSON403      *GetOrderAddressResponse
	JSON404      *GetOrderAddressResponse
	JSON429      *GetOrderAddressResponse
	JSON500      *GetOrderAddressResponse
	JSON503      *GetOrderAddressResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderAddressResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderAddressResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderBuyerInfoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderBuyerInfoResponse
	JSON400      *GetOrderBuyerInfoResponse
	JSON403      *GetOrderBuyerInfoResponse
	JSON404      *GetOrderBuyerInfoResponse
	JSON429      *GetOrderBuyerInfoResponse
	JSON500      *GetOrderBuyerInfoResponse
	JSON503      *GetOrderBuyerInfoResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderBuyerInfoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderBuyerInfoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderItemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderItemsResponse
	JSON400      *GetOrderItemsResponse
	JSON403      *GetOrderItemsResponse
	JSON404      *GetOrderItemsResponse
	JSON429      *GetOrderItemsResponse
	JSON500      *GetOrderItemsResponse
	JSON503      *GetOrderItemsResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderItemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderItemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderItemsBuyerInfoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderItemsBuyerInfoResponse
	JSON400      *GetOrderItemsBuyerInfoResponse
	JSON403      *GetOrderItemsBuyerInfoResponse
	JSON404      *GetOrderItemsBuyerInfoResponse
	JSON429      *GetOrderItemsBuyerInfoResponse
	JSON500      *GetOrderItemsBuyerInfoResponse
	JSON503      *GetOrderItemsBuyerInfoResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderItemsBuyerInfoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderItemsBuyerInfoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderRegulatedInfoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderRegulatedInfoResponse
	JSON400      *GetOrderRegulatedInfoResponse
	JSON403      *GetOrderRegulatedInfoResponse
	JSON404      *GetOrderRegulatedInfoResponse
	JSON429      *GetOrderRegulatedInfoResponse
	JSON500      *GetOrderRegulatedInfoResponse
	JSON503      *GetOrderRegulatedInfoResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderRegulatedInfoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderRegulatedInfoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVerificationStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *UpdateVerificationStatusErrorResponse
	JSON403      *UpdateVerificationStatusErrorResponse
	JSON404      *UpdateVerificationStatusErrorResponse
	JSON413      *UpdateVerificationStatusErrorResponse
	JSON415      *UpdateVerificationStatusErrorResponse
	JSON429      *UpdateVerificationStatusErrorResponse
	JSON500      *UpdateVerificationStatusErrorResponse
	JSON503      *UpdateVerificationStatusErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateVerificationStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVerificationStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShipmentStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *UpdateShipmentStatusErrorResponse
	JSON403      *UpdateShipmentStatusErrorResponse
	JSON404      *UpdateShipmentStatusErrorResponse
	JSON413      *UpdateShipmentStatusErrorResponse
	JSON415      *UpdateShipmentStatusErrorResponse
	JSON429      *UpdateShipmentStatusErrorResponse
	JSON500      *UpdateShipmentStatusErrorResponse
	JSON503      *UpdateShipmentStatusErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateShipmentStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShipmentStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmShipmentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ConfirmShipmentErrorResponse
	JSON401      *ConfirmShipmentErrorResponse
	JSON403      *ConfirmShipmentErrorResponse
	JSON404      *ConfirmShipmentErrorResponse
	JSON429      *ConfirmShipmentErrorResponse
	JSON500      *ConfirmShipmentErrorResponse
	JSON503      *ConfirmShipmentErrorResponse
}

// Status returns HTTPResponse.Status
func (r ConfirmShipmentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmShipmentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetOrdersWithResponse request returning *GetOrdersResp
func (c *ClientWithResponses) GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams) (*GetOrdersResp, error) {
	rsp, err := c.GetOrders(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersResp(rsp)
}

// GetOrderWithResponse request returning *GetOrderResp
func (c *ClientWithResponses) GetOrderWithResponse(ctx context.Context, orderId string) (*GetOrderResp, error) {
	rsp, err := c.GetOrder(ctx, orderId)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderResp(rsp)
}

// GetOrderAddressWithResponse request returning *GetOrderAddressResp
func (c *ClientWithResponses) GetOrderAddressWithResponse(ctx context.Context, orderId string) (*GetOrderAddressResp, error) {
	rsp, err := c.GetOrderAddress(ctx, orderId)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderAddressResp(rsp)
}

// GetOrderBuyerInfoWithResponse request returning *GetOrderBuyerInfoResp
func (c *ClientWithResponses) GetOrderBuyerInfoWithResponse(ctx context.Context, orderId string) (*GetOrderBuyerInfoResp, error) {
	rsp, err := c.GetOrderBuyerInfo(ctx, orderId)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderBuyerInfoResp(rsp)
}

// GetOrderItemsWithResponse request returning *GetOrderItemsResp
func (c *ClientWithResponses) GetOrderItemsWithResponse(ctx context.Context, orderId string, params *GetOrderItemsParams) (*GetOrderItemsResp, error) {
	rsp, err := c.GetOrderItems(ctx, orderId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderItemsResp(rsp)
}

// GetOrderItemsBuyerInfoWithResponse request returning *GetOrderItemsBuyerInfoResp
func (c *ClientWithResponses) GetOrderItemsBuyerInfoWithResponse(ctx context.Context, orderId string, params *GetOrderItemsBuyerInfoParams) (*GetOrderItemsBuyerInfoResp, error) {
	rsp, err := c.GetOrderItemsBuyerInfo(ctx, orderId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderItemsBuyerInfoResp(rsp)
}

// GetOrderRegulatedInfoWithResponse request returning *GetOrderRegulatedInfoResp
func (c *ClientWithResponses) GetOrderRegulatedInfoWithResponse(ctx context.Context, orderId string) (*GetOrderRegulatedInfoResp, error) {
	rsp, err := c.GetOrderRegulatedInfo(ctx, orderId)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderRegulatedInfoResp(rsp)
}

// UpdateVerificationStatusWithBodyWithResponse request with arbitrary body returning *UpdateVerificationStatusResp
func (c *ClientWithResponses) UpdateVerificationStatusWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader) (*UpdateVerificationStatusResp, error) {
	rsp, err := c.UpdateVerificationStatusWithBody(ctx, orderId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVerificationStatusResp(rsp)
}

func (c *ClientWithResponses) UpdateVerificationStatusWithResponse(ctx context.Context, orderId string, body UpdateVerificationStatusJSONRequestBody) (*UpdateVerificationStatusResp, error) {
	rsp, err := c.UpdateVerificationStatus(ctx, orderId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVerificationStatusResp(rsp)
}

// UpdateShipmentStatusWithBodyWithResponse request with arbitrary body returning *UpdateShipmentStatusResp
func (c *ClientWithResponses) UpdateShipmentStatusWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader) (*UpdateShipmentStatusResp, error) {
	rsp, err := c.UpdateShipmentStatusWithBody(ctx, orderId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentStatusResp(rsp)
}

func (c *ClientWithResponses) UpdateShipmentStatusWithResponse(ctx context.Context, orderId string, body UpdateShipmentStatusJSONRequestBody) (*UpdateShipmentStatusResp, error) {
	rsp, err := c.UpdateShipmentStatus(ctx, orderId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentStatusResp(rsp)
}

// ConfirmShipmentWithBodyWithResponse request with arbitrary body returning *ConfirmShipmentResp
func (c *ClientWithResponses) ConfirmShipmentWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader) (*ConfirmShipmentResp, error) {
	rsp, err := c.ConfirmShipmentWithBody(ctx, orderId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseConfirmShipmentResp(rsp)
}

func (c *ClientWithResponses) ConfirmShipmentWithResponse(ctx context.Context, orderId string, body ConfirmShipmentJSONRequestBody) (*ConfirmShipmentResp, error) {
	rsp, err := c.ConfirmShipment(ctx, orderId, body)
	if err != nil {
		return nil, err
	}
	return ParseConfirmShipmentResp(rsp)
}

// ParseGetOrdersResp parses an HTTP response from a GetOrdersWithResponse call
func ParseGetOrdersResp(rsp *http.Response) (*GetOrdersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderResp parses an HTTP response from a GetOrderWithResponse call
func ParseGetOrderResp(rsp *http.Response) (*GetOrderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderAddressResp parses an HTTP response from a GetOrderAddressWithResponse call
func ParseGetOrderAddressResp(rsp *http.Response) (*GetOrderAddressResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderAddressResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderBuyerInfoResp parses an HTTP response from a GetOrderBuyerInfoWithResponse call
func ParseGetOrderBuyerInfoResp(rsp *http.Response) (*GetOrderBuyerInfoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderBuyerInfoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderItemsResp parses an HTTP response from a GetOrderItemsWithResponse call
func ParseGetOrderItemsResp(rsp *http.Response) (*GetOrderItemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderItemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderItemsBuyerInfoResp parses an HTTP response from a GetOrderItemsBuyerInfoWithResponse call
func ParseGetOrderItemsBuyerInfoResp(rsp *http.Response) (*GetOrderItemsBuyerInfoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderItemsBuyerInfoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderRegulatedInfoResp parses an HTTP response from a GetOrderRegulatedInfoWithResponse call
func ParseGetOrderRegulatedInfoResp(rsp *http.Response) (*GetOrderRegulatedInfoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderRegulatedInfoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateVerificationStatusResp parses an HTTP response from a UpdateVerificationStatusWithResponse call
func ParseUpdateVerificationStatusResp(rsp *http.Response) (*UpdateVerificationStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVerificationStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateShipmentStatusResp parses an HTTP response from a UpdateShipmentStatusWithResponse call
func ParseUpdateShipmentStatusResp(rsp *http.Response) (*UpdateShipmentStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShipmentStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConfirmShipmentResp parses an HTTP response from a ConfirmShipmentWithResponse call
func ParseConfirmShipmentResp(rsp *http.Response) (*ConfirmShipmentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmShipmentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
