// Package ordersv0 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.3 DO NOT EDIT.
package ordersv0

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for AddressAddressType.
const (
	Commercial  AddressAddressType = "Commercial"
	Residential AddressAddressType = "Residential"
)

// Defines values for BusinessHoursDayOfWeek.
const (
	FRI BusinessHoursDayOfWeek = "FRI"
	MON BusinessHoursDayOfWeek = "MON"
	SAT BusinessHoursDayOfWeek = "SAT"
	SUN BusinessHoursDayOfWeek = "SUN"
	THU BusinessHoursDayOfWeek = "THU"
	TUE BusinessHoursDayOfWeek = "TUE"
	WED BusinessHoursDayOfWeek = "WED"
)

// Defines values for ConfirmShipmentRequestCodCollectionMethod.
const (
	DirectPayment ConfirmShipmentRequestCodCollectionMethod = "DirectPayment"
)

// Defines values for EasyShipShipmentStatus.
const (
	EasyShipShipmentStatusAtDestinationFC   EasyShipShipmentStatus = "AtDestinationFC"
	EasyShipShipmentStatusAtOriginFC        EasyShipShipmentStatus = "AtOriginFC"
	EasyShipShipmentStatusDamaged           EasyShipShipmentStatus = "Damaged"
	EasyShipShipmentStatusDelivered         EasyShipShipmentStatus = "Delivered"
	EasyShipShipmentStatusDroppedOff        EasyShipShipmentStatus = "DroppedOff"
	EasyShipShipmentStatusLabelCanceled     EasyShipShipmentStatus = "LabelCanceled"
	EasyShipShipmentStatusLost              EasyShipShipmentStatus = "Lost"
	EasyShipShipmentStatusOutForDelivery    EasyShipShipmentStatus = "OutForDelivery"
	EasyShipShipmentStatusPendingDropOff    EasyShipShipmentStatus = "PendingDropOff"
	EasyShipShipmentStatusPendingPickUp     EasyShipShipmentStatus = "PendingPickUp"
	EasyShipShipmentStatusPendingSchedule   EasyShipShipmentStatus = "PendingSchedule"
	EasyShipShipmentStatusPickedUp          EasyShipShipmentStatus = "PickedUp"
	EasyShipShipmentStatusRejectedByBuyer   EasyShipShipmentStatus = "RejectedByBuyer"
	EasyShipShipmentStatusReturnedToSeller  EasyShipShipmentStatus = "ReturnedToSeller"
	EasyShipShipmentStatusReturningToSeller EasyShipShipmentStatus = "ReturningToSeller"
	EasyShipShipmentStatusUndeliverable     EasyShipShipmentStatus = "Undeliverable"
)

// Defines values for ElectronicInvoiceStatus.
const (
	Accepted    ElectronicInvoiceStatus = "Accepted"
	Errored     ElectronicInvoiceStatus = "Errored"
	NotFound    ElectronicInvoiceStatus = "NotFound"
	NotRequired ElectronicInvoiceStatus = "NotRequired"
	Processing  ElectronicInvoiceStatus = "Processing"
)

// Defines values for OrderBuyerInvoicePreference.
const (
	BUSINESS   OrderBuyerInvoicePreference = "BUSINESS"
	INDIVIDUAL OrderBuyerInvoicePreference = "INDIVIDUAL"
)

// Defines values for OrderFulfillmentChannel.
const (
	AFN OrderFulfillmentChannel = "AFN"
	MFN OrderFulfillmentChannel = "MFN"
)

// Defines values for OrderOrderStatus.
const (
	OrderOrderStatusCanceled            OrderOrderStatus = "Canceled"
	OrderOrderStatusInvoiceUnconfirmed  OrderOrderStatus = "InvoiceUnconfirmed"
	OrderOrderStatusPartiallyShipped    OrderOrderStatus = "PartiallyShipped"
	OrderOrderStatusPending             OrderOrderStatus = "Pending"
	OrderOrderStatusPendingAvailability OrderOrderStatus = "PendingAvailability"
	OrderOrderStatusShipped             OrderOrderStatus = "Shipped"
	OrderOrderStatusUnfulfillable       OrderOrderStatus = "Unfulfillable"
	OrderOrderStatusUnshipped           OrderOrderStatus = "Unshipped"
)

// Defines values for OrderOrderType.
const (
	BackOrder             OrderOrderType = "BackOrder"
	LongLeadTimeOrder     OrderOrderType = "LongLeadTimeOrder"
	Preorder              OrderOrderType = "Preorder"
	SourcingOnDemandOrder OrderOrderType = "SourcingOnDemandOrder"
	StandardOrder         OrderOrderType = "StandardOrder"
)

// Defines values for OrderPaymentMethod.
const (
	COD   OrderPaymentMethod = "COD"
	CVS   OrderPaymentMethod = "CVS"
	Other OrderPaymentMethod = "Other"
)

// Defines values for OrderItemDeemedResellerCategory.
const (
	IOSS OrderItemDeemedResellerCategory = "IOSS"
	UOSS OrderItemDeemedResellerCategory = "UOSS"
)

// Defines values for OtherDeliveryAttributes.
const (
	HASACCESSPOINT OtherDeliveryAttributes = "HAS_ACCESS_POINT"
	PALLETDISABLED OtherDeliveryAttributes = "PALLET_DISABLED"
	PALLETENABLED  OtherDeliveryAttributes = "PALLET_ENABLED"
)

// Defines values for RegulatedInformationFieldFieldType.
const (
	FileAttachment RegulatedInformationFieldFieldType = "FileAttachment"
	Text           RegulatedInformationFieldFieldType = "Text"
)

// Defines values for ShipmentStatus.
const (
	ShipmentStatusPickedUp       ShipmentStatus = "PickedUp"
	ShipmentStatusReadyForPickup ShipmentStatus = "ReadyForPickup"
	ShipmentStatusRefusedPickup  ShipmentStatus = "RefusedPickup"
)

// Defines values for TaxCollectionModel.
const (
	MarketplaceFacilitator TaxCollectionModel = "MarketplaceFacilitator"
)

// Defines values for TaxCollectionResponsibleParty.
const (
	AmazonServicesInc TaxCollectionResponsibleParty = "Amazon Services, Inc."
)

// Defines values for VerificationStatus.
const (
	VerificationStatusApproved  VerificationStatus = "Approved"
	VerificationStatusCancelled VerificationStatus = "Cancelled"
	VerificationStatusExpired   VerificationStatus = "Expired"
	VerificationStatusPending   VerificationStatus = "Pending"
	VerificationStatusRejected  VerificationStatus = "Rejected"
)

// Address The shipping address for the order.
type Address struct {
	// AddressLine1 The street address.
	AddressLine1 *string `json:"AddressLine1,omitempty"`

	// AddressLine2 Additional street address information, if required.
	AddressLine2 *string `json:"AddressLine2,omitempty"`

	// AddressLine3 Additional street address information, if required.
	AddressLine3 *string `json:"AddressLine3,omitempty"`

	// AddressType The address type of the shipping address.
	AddressType *AddressAddressType `json:"AddressType,omitempty"`

	// City The city
	City *string `json:"City,omitempty"`

	// CountryCode The country code. A two-character country code, in ISO 3166-1 alpha-2 format.
	CountryCode *string `json:"CountryCode,omitempty"`

	// County The county.
	County *string `json:"County,omitempty"`

	// District The district.
	District *string `json:"District,omitempty"`

	// Municipality The municipality.
	Municipality *string `json:"Municipality,omitempty"`

	// Name The name.
	Name string `json:"Name"`

	// Phone The phone number. Not returned for Fulfillment by Amazon (FBA) orders.
	Phone *string `json:"Phone,omitempty"`

	// PostalCode The postal code.
	PostalCode *string `json:"PostalCode,omitempty"`

	// StateOrRegion The state or region.
	StateOrRegion *string `json:"StateOrRegion,omitempty"`
}

// AddressAddressType The address type of the shipping address.
type AddressAddressType string

// AutomatedShippingSettings Contains information regarding the Shipping Settings Automation program, such as whether the order's shipping settings were generated automatically, and what those settings are.
type AutomatedShippingSettings struct {
	// AutomatedCarrier Auto-generated carrier for SSA orders.
	AutomatedCarrier *string `json:"AutomatedCarrier,omitempty"`

	// AutomatedShipMethod Auto-generated ship method for SSA orders.
	AutomatedShipMethod *string `json:"AutomatedShipMethod,omitempty"`

	// HasAutomatedShippingSettings When true, this order has automated shipping settings generated by Amazon. This order could be identified as an SSA order.
	HasAutomatedShippingSettings *bool `json:"HasAutomatedShippingSettings,omitempty"`
}

// BusinessHours Business days and hours when the destination is open for deliveries.
type BusinessHours struct {
	// DayOfWeek Day of the week.
	DayOfWeek *BusinessHoursDayOfWeek `json:"DayOfWeek,omitempty"`

	// OpenIntervals Time window during the day when the business is open.
	OpenIntervals *[]OpenInterval `json:"OpenIntervals,omitempty"`
}

// BusinessHoursDayOfWeek Day of the week.
type BusinessHoursDayOfWeek string

// BuyerCustomizedInfoDetail Buyer information for custom orders from the Amazon Custom program.
type BuyerCustomizedInfoDetail struct {
	// CustomizedURL The location of a zip file containing Amazon Custom data.
	CustomizedURL *string `json:"CustomizedURL,omitempty"`
}

// BuyerInfo Buyer information.
type BuyerInfo struct {
	// BuyerCounty The county of the buyer.
	BuyerCounty *string `json:"BuyerCounty,omitempty"`

	// BuyerEmail The anonymized email address of the buyer.
	BuyerEmail *string `json:"BuyerEmail,omitempty"`

	// BuyerName The buyer name or the recipient name.
	BuyerName *string `json:"BuyerName,omitempty"`

	// BuyerTaxInfo Tax information about the buyer.
	BuyerTaxInfo *BuyerTaxInfo `json:"BuyerTaxInfo,omitempty"`

	// PurchaseOrderNumber The purchase order (PO) number entered by the buyer at checkout. Returned only for orders where the buyer entered a PO number at checkout.
	PurchaseOrderNumber *string `json:"PurchaseOrderNumber,omitempty"`
}

// BuyerRequestedCancel Information about whether or not a buyer requested cancellation.
type BuyerRequestedCancel struct {
	// BuyerCancelReason The reason that the buyer requested cancellation.
	BuyerCancelReason *string `json:"BuyerCancelReason,omitempty"`

	// IsBuyerRequestedCancel When true, the buyer has requested cancellation.
	IsBuyerRequestedCancel *bool `json:"IsBuyerRequestedCancel,omitempty"`
}

// BuyerTaxInfo Tax information about the buyer.
type BuyerTaxInfo struct {
	// CompanyLegalName The legal name of the company.
	CompanyLegalName *string `json:"CompanyLegalName,omitempty"`

	// TaxClassifications A list of tax classifications that apply to the order.
	TaxClassifications *[]TaxClassification `json:"TaxClassifications,omitempty"`

	// TaxingRegion The country or region imposing the tax.
	TaxingRegion *string `json:"TaxingRegion,omitempty"`
}

// BuyerTaxInformation Contains the business invoice tax information. Available only in the TR marketplace.
type BuyerTaxInformation struct {
	// BuyerBusinessAddress Business buyer's address.
	BuyerBusinessAddress *string `json:"BuyerBusinessAddress,omitempty"`

	// BuyerLegalCompanyName Business buyer's company legal name.
	BuyerLegalCompanyName *string `json:"BuyerLegalCompanyName,omitempty"`

	// BuyerTaxOffice Business buyer's tax office.
	BuyerTaxOffice *string `json:"BuyerTaxOffice,omitempty"`

	// BuyerTaxRegistrationId Business buyer's tax registration ID.
	BuyerTaxRegistrationId *string `json:"BuyerTaxRegistrationId,omitempty"`
}

// ConfirmShipmentErrorResponse The error response schema for an shipment confirmation.
type ConfirmShipmentErrorResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// ConfirmShipmentOrderItem A single order item.
type ConfirmShipmentOrderItem struct {
	// OrderItemId The unique identifier of the order item.
	OrderItemId string `json:"orderItemId"`

	// Quantity The quantity of the item.
	Quantity int `json:"quantity"`

	// TransparencyCodes A list of order items.
	TransparencyCodes *TransparencyCodeList `json:"transparencyCodes,omitempty"`
}

// ConfirmShipmentOrderItemsList A list of order items.
type ConfirmShipmentOrderItemsList = []ConfirmShipmentOrderItem

// ConfirmShipmentRequest The request schema for an shipment confirmation.
type ConfirmShipmentRequest struct {
	// CodCollectionMethod The cod collection method, support in JP only.
	CodCollectionMethod *ConfirmShipmentRequestCodCollectionMethod `json:"codCollectionMethod,omitempty"`

	// MarketplaceId The unobfuscated marketplace identifier.
	MarketplaceId MarketplaceId `json:"marketplaceId"`

	// PackageDetail Properties of packages
	PackageDetail PackageDetail `json:"packageDetail"`
}

// ConfirmShipmentRequestCodCollectionMethod The cod collection method, support in JP only.
type ConfirmShipmentRequestCodCollectionMethod string

// DeliveryPreferences Contains all of the delivery instructions provided by the customer for the shipping address.
type DeliveryPreferences struct {
	// AddressInstructions Building instructions, nearby landmark or navigation instructions.
	AddressInstructions *string `json:"AddressInstructions,omitempty"`

	// DropOffLocation Drop-off location selected by the customer.
	DropOffLocation *string `json:"DropOffLocation,omitempty"`

	// OtherAttributes Enumerated list of miscellaneous delivery attributes associated with the shipping address.
	OtherAttributes *[]OtherDeliveryAttributes `json:"OtherAttributes,omitempty"`

	// PreferredDeliveryTime The time window when the delivery is preferred.
	PreferredDeliveryTime *PreferredDeliveryTime `json:"PreferredDeliveryTime,omitempty"`
}

// EasyShipShipmentStatus The status of the Amazon Easy Ship order. This property is included only for Amazon Easy Ship orders.
type EasyShipShipmentStatus string

// ElectronicInvoiceStatus The status of the electronic invoice.
type ElectronicInvoiceStatus string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// ExceptionDates Dates when the business is closed or open with a different time window.
type ExceptionDates struct {
	// ExceptionDate Date when the business is closed, in ISO-8601 date format.
	ExceptionDate *string `json:"ExceptionDate,omitempty"`

	// IsOpen Boolean indicating if the business is closed or open on that date.
	IsOpen *bool `json:"IsOpen,omitempty"`

	// OpenIntervals Time window during the day when the business is open.
	OpenIntervals *[]OpenInterval `json:"OpenIntervals,omitempty"`
}

// FulfillmentInstruction Contains the instructions about the fulfillment like where should it be fulfilled from.
type FulfillmentInstruction struct {
	// FulfillmentSupplySourceId Denotes the recommended sourceId where the order should be fulfilled from.
	FulfillmentSupplySourceId *string `json:"FulfillmentSupplySourceId,omitempty"`
}

// GetOrderAddressResponse The response schema for the getOrderAddress operation.
type GetOrderAddressResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The shipping address for the order.
	Payload *OrderAddress `json:"payload,omitempty"`
}

// GetOrderBuyerInfoResponse The response schema for the getOrderBuyerInfo operation.
type GetOrderBuyerInfoResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Buyer information for an order.
	Payload *OrderBuyerInfo `json:"payload,omitempty"`
}

// GetOrderItemsBuyerInfoResponse The response schema for the getOrderItemsBuyerInfo operation.
type GetOrderItemsBuyerInfoResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload A single order item's buyer information list with the order ID.
	Payload *OrderItemsBuyerInfoList `json:"payload,omitempty"`
}

// GetOrderItemsResponse The response schema for the getOrderItems operation.
type GetOrderItemsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The order items list along with the order ID.
	Payload *OrderItemsList `json:"payload,omitempty"`
}

// GetOrderRegulatedInfoResponse The response schema for the getOrderRegulatedInfo operation.
type GetOrderRegulatedInfoResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The order's regulated information along with its verification status.
	Payload *OrderRegulatedInfo `json:"payload,omitempty"`
}

// GetOrderResponse The response schema for the getOrder operation.
type GetOrderResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Order information.
	Payload *Order `json:"payload,omitempty"`
}

// GetOrdersResponse The response schema for the getOrders operation.
type GetOrdersResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload A list of orders along with additional information to make subsequent API calls.
	Payload *OrdersList `json:"payload,omitempty"`
}

// ItemBuyerInfo A single item's buyer information.
type ItemBuyerInfo struct {
	// BuyerCustomizedInfo Buyer information for custom orders from the Amazon Custom program.
	BuyerCustomizedInfo *BuyerCustomizedInfoDetail `json:"BuyerCustomizedInfo,omitempty"`

	// GiftMessageText A gift message provided by the buyer.
	GiftMessageText *string `json:"GiftMessageText,omitempty"`

	// GiftWrapLevel The gift wrap level specified by the buyer.
	GiftWrapLevel *string `json:"GiftWrapLevel,omitempty"`

	// GiftWrapPrice The monetary value of the order.
	GiftWrapPrice *Money `json:"GiftWrapPrice,omitempty"`

	// GiftWrapTax The monetary value of the order.
	GiftWrapTax *Money `json:"GiftWrapTax,omitempty"`
}

// MarketplaceId The unobfuscated marketplace identifier.
type MarketplaceId = string

// MarketplaceTaxInfo Tax information about the marketplace.
type MarketplaceTaxInfo struct {
	// TaxClassifications A list of tax classifications that apply to the order.
	TaxClassifications *[]TaxClassification `json:"TaxClassifications,omitempty"`
}

// Money The monetary value of the order.
type Money struct {
	// Amount The currency amount.
	Amount *string `json:"Amount,omitempty"`

	// CurrencyCode The three-digit currency code. In ISO 4217 format.
	CurrencyCode *string `json:"CurrencyCode,omitempty"`
}

// OpenInterval The time interval for which the business is open.
type OpenInterval struct {
	// EndTime The time when the business opens or closes.
	EndTime *OpenTimeInterval `json:"EndTime,omitempty"`

	// StartTime The time when the business opens or closes.
	StartTime *OpenTimeInterval `json:"StartTime,omitempty"`
}

// OpenTimeInterval The time when the business opens or closes.
type OpenTimeInterval struct {
	// Hour The hour when the business opens or closes.
	Hour *int `json:"Hour,omitempty"`

	// Minute The minute when the business opens or closes.
	Minute *int `json:"Minute,omitempty"`
}

// Order Order information.
type Order struct {
	// AmazonOrderId An Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderId string `json:"AmazonOrderId"`

	// AutomatedShippingSettings Contains information regarding the Shipping Settings Automation program, such as whether the order's shipping settings were generated automatically, and what those settings are.
	AutomatedShippingSettings *AutomatedShippingSettings `json:"AutomatedShippingSettings,omitempty"`

	// BuyerInfo Buyer information.
	BuyerInfo *BuyerInfo `json:"BuyerInfo,omitempty"`

	// BuyerInvoicePreference The buyer's invoicing preference. Available only in the TR marketplace.
	BuyerInvoicePreference *OrderBuyerInvoicePreference `json:"BuyerInvoicePreference,omitempty"`

	// BuyerTaxInformation Contains the business invoice tax information. Available only in the TR marketplace.
	BuyerTaxInformation *BuyerTaxInformation `json:"BuyerTaxInformation,omitempty"`

	// CbaDisplayableShippingLabel Custom ship label for Checkout by Amazon (CBA).
	CbaDisplayableShippingLabel *string `json:"CbaDisplayableShippingLabel,omitempty"`

	// DefaultShipFromLocationAddress The shipping address for the order.
	DefaultShipFromLocationAddress *Address `json:"DefaultShipFromLocationAddress,omitempty"`

	// EarliestDeliveryDate The start of the time period within which you have committed to fulfill the order. In ISO 8601 date time format. Returned only for seller-fulfilled orders.
	EarliestDeliveryDate *string `json:"EarliestDeliveryDate,omitempty"`

	// EarliestShipDate The start of the time period within which you have committed to ship the order. In ISO 8601 date time format. Returned only for seller-fulfilled orders.
	//
	// __Note__: EarliestShipDate might not be returned for orders placed before February 1, 2013.
	EarliestShipDate *string `json:"EarliestShipDate,omitempty"`

	// EasyShipShipmentStatus The status of the Amazon Easy Ship order. This property is included only for Amazon Easy Ship orders.
	EasyShipShipmentStatus *EasyShipShipmentStatus `json:"EasyShipShipmentStatus,omitempty"`

	// ElectronicInvoiceStatus The status of the electronic invoice.
	ElectronicInvoiceStatus *ElectronicInvoiceStatus `json:"ElectronicInvoiceStatus,omitempty"`

	// FulfillmentChannel Whether the order was fulfilled by Amazon (AFN) or by the seller (MFN).
	FulfillmentChannel *OrderFulfillmentChannel `json:"FulfillmentChannel,omitempty"`

	// FulfillmentInstruction Contains the instructions about the fulfillment like where should it be fulfilled from.
	FulfillmentInstruction *FulfillmentInstruction `json:"FulfillmentInstruction,omitempty"`

	// HasRegulatedItems Whether the order contains regulated items which may require additional approval steps before being fulfilled.
	HasRegulatedItems *bool `json:"HasRegulatedItems,omitempty"`

	// IsAccessPointOrder When true, this order is marked to be delivered to an Access Point. The access location is chosen by the customer. Access Points include Amazon Hub Lockers, Amazon Hub Counters, and pickup points operated by carriers.
	IsAccessPointOrder *bool `json:"IsAccessPointOrder,omitempty"`

	// IsBusinessOrder When true, the order is an Amazon Business order. An Amazon Business order is an order where the buyer is a Verified Business Buyer.
	IsBusinessOrder *bool `json:"IsBusinessOrder,omitempty"`

	// IsEstimatedShipDateSet When true, the estimated ship date is set for the order. Returned only for Sourcing on Demand orders.
	IsEstimatedShipDateSet *bool `json:"IsEstimatedShipDateSet,omitempty"`

	// IsGlobalExpressEnabled When true, the order is a GlobalExpress order.
	IsGlobalExpressEnabled *bool `json:"IsGlobalExpressEnabled,omitempty"`

	// IsIBA When true, the item within this order was bought and re-sold by Amazon Business EU SARL (ABEU). By buying and instantly re-selling your items, ABEU becomes the seller of record, making your inventory available for sale to customers who would not otherwise purchase from a third-party seller.
	IsIBA *bool `json:"IsIBA,omitempty"`

	// IsISPU When true, this order is marked to be picked up from a store rather than delivered.
	IsISPU *bool `json:"IsISPU,omitempty"`

	// IsPremiumOrder When true, the order has a Premium Shipping Service Level Agreement. For more information about Premium Shipping orders, see "Premium Shipping Options" in the Seller Central Help for your marketplace.
	IsPremiumOrder *bool `json:"IsPremiumOrder,omitempty"`

	// IsPrime When true, the order is a seller-fulfilled Amazon Prime order.
	IsPrime *bool `json:"IsPrime,omitempty"`

	// IsReplacementOrder When true, this is a replacement order.
	IsReplacementOrder *bool `json:"IsReplacementOrder,omitempty"`

	// IsSoldByAB When true, the item within this order was bought and re-sold by Amazon Business EU SARL (ABEU). By buying and instantly re-selling your items, ABEU becomes the seller of record, making your inventory available for sale to customers who would not otherwise purchase from a third-party seller.
	IsSoldByAB *bool `json:"IsSoldByAB,omitempty"`

	// LastUpdateDate The date when the order was last updated.
	//
	// __Note__: LastUpdateDate is returned with an incorrect date for orders that were last updated before 2009-04-01.
	LastUpdateDate string `json:"LastUpdateDate"`

	// LatestDeliveryDate The end of the time period within which you have committed to fulfill the order. In ISO 8601 date time format. Returned only for seller-fulfilled orders that do not have a PendingAvailability, Pending, or Canceled status.
	LatestDeliveryDate *string `json:"LatestDeliveryDate,omitempty"`

	// LatestShipDate The end of the time period within which you have committed to ship the order. In ISO 8601 date time format. Returned only for seller-fulfilled orders.
	//
	// __Note__: LatestShipDate might not be returned for orders placed before February 1, 2013.
	LatestShipDate *string `json:"LatestShipDate,omitempty"`

	// MarketplaceId The identifier for the marketplace where the order was placed.
	MarketplaceId *string `json:"MarketplaceId,omitempty"`

	// MarketplaceTaxInfo Tax information about the marketplace.
	MarketplaceTaxInfo *MarketplaceTaxInfo `json:"MarketplaceTaxInfo,omitempty"`

	// NumberOfItemsShipped The number of items shipped.
	NumberOfItemsShipped *int `json:"NumberOfItemsShipped,omitempty"`

	// NumberOfItemsUnshipped The number of items unshipped.
	NumberOfItemsUnshipped *int `json:"NumberOfItemsUnshipped,omitempty"`

	// OrderChannel The order channel of the first item in the order.
	OrderChannel *string `json:"OrderChannel,omitempty"`

	// OrderStatus The current order status.
	OrderStatus OrderOrderStatus `json:"OrderStatus"`

	// OrderTotal The monetary value of the order.
	OrderTotal *Money `json:"OrderTotal,omitempty"`

	// OrderType The type of the order.
	OrderType *OrderOrderType `json:"OrderType,omitempty"`

	// PaymentExecutionDetail A list of payment execution detail items.
	PaymentExecutionDetail *PaymentExecutionDetailItemList `json:"PaymentExecutionDetail,omitempty"`

	// PaymentMethod The payment method for the order. This property is limited to Cash On Delivery (COD) and Convenience Store (CVS) payment methods. Unless you need the specific COD payment information provided by the PaymentExecutionDetailItem object, we recommend using the PaymentMethodDetails property to get payment method information.
	PaymentMethod *OrderPaymentMethod `json:"PaymentMethod,omitempty"`

	// PaymentMethodDetails A list of payment method detail items.
	PaymentMethodDetails *PaymentMethodDetailItemList `json:"PaymentMethodDetails,omitempty"`

	// PromiseResponseDueDate Indicates the date by which the seller must respond to the buyer with an estimated ship date. Returned only for Sourcing on Demand orders.
	PromiseResponseDueDate *string `json:"PromiseResponseDueDate,omitempty"`

	// PurchaseDate The date when the order was created.
	PurchaseDate string `json:"PurchaseDate"`

	// ReplacedOrderId The order ID value for the order that is being replaced. Returned only if IsReplacementOrder = true.
	ReplacedOrderId *string `json:"ReplacedOrderId,omitempty"`

	// SalesChannel The sales channel of the first item in the order.
	SalesChannel *string `json:"SalesChannel,omitempty"`

	// SellerDisplayName The sellerâ€™s friendly name registered in the marketplace.
	SellerDisplayName *string `json:"SellerDisplayName,omitempty"`

	// SellerOrderId A seller-defined order identifier.
	SellerOrderId *string `json:"SellerOrderId,omitempty"`

	// ShipServiceLevel The shipment service level of the order.
	ShipServiceLevel *string `json:"ShipServiceLevel,omitempty"`

	// ShipmentServiceLevelCategory The shipment service level category of the order.
	//
	// Possible values: Expedited, FreeEconomy, NextDay, SameDay, SecondDay, Scheduled, Standard.
	ShipmentServiceLevelCategory *string `json:"ShipmentServiceLevelCategory,omitempty"`

	// ShippingAddress The shipping address for the order.
	ShippingAddress *Address `json:"ShippingAddress,omitempty"`
}

// OrderBuyerInvoicePreference The buyer's invoicing preference. Available only in the TR marketplace.
type OrderBuyerInvoicePreference string

// OrderFulfillmentChannel Whether the order was fulfilled by Amazon (AFN) or by the seller (MFN).
type OrderFulfillmentChannel string

// OrderOrderStatus The current order status.
type OrderOrderStatus string

// OrderOrderType The type of the order.
type OrderOrderType string

// OrderPaymentMethod The payment method for the order. This property is limited to Cash On Delivery (COD) and Convenience Store (CVS) payment methods. Unless you need the specific COD payment information provided by the PaymentExecutionDetailItem object, we recommend using the PaymentMethodDetails property to get payment method information.
type OrderPaymentMethod string

// OrderAddress The shipping address for the order.
type OrderAddress struct {
	// AmazonOrderId An Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderId string `json:"AmazonOrderId"`

	// BuyerCompanyName Company name of the destination address.
	BuyerCompanyName *string `json:"BuyerCompanyName,omitempty"`

	// DeliveryPreferences Contains all of the delivery instructions provided by the customer for the shipping address.
	DeliveryPreferences *DeliveryPreferences `json:"DeliveryPreferences,omitempty"`

	// ShippingAddress The shipping address for the order.
	ShippingAddress *Address `json:"ShippingAddress,omitempty"`
}

// OrderBuyerInfo Buyer information for an order.
type OrderBuyerInfo struct {
	// AmazonOrderId An Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderId string `json:"AmazonOrderId"`

	// BuyerCounty The county of the buyer.
	BuyerCounty *string `json:"BuyerCounty,omitempty"`

	// BuyerEmail The anonymized email address of the buyer.
	BuyerEmail *string `json:"BuyerEmail,omitempty"`

	// BuyerName The buyer name or the recipient name.
	BuyerName *string `json:"BuyerName,omitempty"`

	// BuyerTaxInfo Tax information about the buyer.
	BuyerTaxInfo *BuyerTaxInfo `json:"BuyerTaxInfo,omitempty"`

	// PurchaseOrderNumber The purchase order (PO) number entered by the buyer at checkout. Returned only for orders where the buyer entered a PO number at checkout.
	PurchaseOrderNumber *string `json:"PurchaseOrderNumber,omitempty"`
}

// OrderItem A single order item.
type OrderItem struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN string `json:"ASIN"`

	// BuyerInfo A single item's buyer information.
	BuyerInfo *ItemBuyerInfo `json:"BuyerInfo,omitempty"`

	// BuyerRequestedCancel Information about whether or not a buyer requested cancellation.
	BuyerRequestedCancel *BuyerRequestedCancel `json:"BuyerRequestedCancel,omitempty"`

	// CODFee The monetary value of the order.
	CODFee *Money `json:"CODFee,omitempty"`

	// CODFeeDiscount The monetary value of the order.
	CODFeeDiscount *Money `json:"CODFeeDiscount,omitempty"`

	// ConditionId The condition of the item.
	//
	// Possible values: New, Used, Collectible, Refurbished, Preorder, Club.
	ConditionId *string `json:"ConditionId,omitempty"`

	// ConditionNote The condition of the item as described by the seller.
	ConditionNote *string `json:"ConditionNote,omitempty"`

	// ConditionSubtypeId The subcondition of the item.
	//
	// Possible values: New, Mint, Very Good, Good, Acceptable, Poor, Club, OEM, Warranty, Refurbished Warranty, Refurbished, Open Box, Any, Other.
	ConditionSubtypeId *string `json:"ConditionSubtypeId,omitempty"`

	// DeemedResellerCategory The category of deemed reseller. This applies to selling partners that are not based in the EU and is used to help them meet the VAT Deemed Reseller tax laws in the EU and UK.
	DeemedResellerCategory *OrderItemDeemedResellerCategory `json:"DeemedResellerCategory,omitempty"`

	// IossNumber The IOSS number for the marketplace. Sellers shipping to the European Union (EU) from outside of the EU must provide this IOSS number to their carrier when Amazon has collected the VAT on the sale.
	IossNumber *string `json:"IossNumber,omitempty"`

	// IsGift When true, the item is a gift.
	IsGift *bool `json:"IsGift,omitempty"`

	// IsTransparency When true, transparency codes are required.
	IsTransparency *bool `json:"IsTransparency,omitempty"`

	// ItemPrice The monetary value of the order.
	ItemPrice *Money `json:"ItemPrice,omitempty"`

	// ItemTax The monetary value of the order.
	ItemTax *Money `json:"ItemTax,omitempty"`

	// OrderItemId An Amazon-defined order item identifier.
	OrderItemId string `json:"OrderItemId"`

	// PointsGranted The number of Amazon Points offered with the purchase of an item, and their monetary value.
	PointsGranted *PointsGrantedDetail `json:"PointsGranted,omitempty"`

	// PriceDesignation Indicates that the selling price is a special price that is available only for Amazon Business orders. For more information about the Amazon Business Seller Program, see the [Amazon Business website](https://www.amazon.com/b2b/info/amazon-business).
	//
	// Possible values: BusinessPrice - A special price that is available only for Amazon Business orders.
	PriceDesignation *string `json:"PriceDesignation,omitempty"`

	// ProductInfo Product information on the number of items.
	ProductInfo *ProductInfoDetail `json:"ProductInfo,omitempty"`

	// PromotionDiscount The monetary value of the order.
	PromotionDiscount *Money `json:"PromotionDiscount,omitempty"`

	// PromotionDiscountTax The monetary value of the order.
	PromotionDiscountTax *Money `json:"PromotionDiscountTax,omitempty"`

	// PromotionIds A list of promotion identifiers provided by the seller when the promotions were created.
	PromotionIds *PromotionIdList `json:"PromotionIds,omitempty"`

	// QuantityOrdered The number of items in the order.
	QuantityOrdered int `json:"QuantityOrdered"`

	// QuantityShipped The number of items shipped.
	QuantityShipped *int `json:"QuantityShipped,omitempty"`

	// ScheduledDeliveryEndDate The end date of the scheduled delivery window in the time zone of the order destination. In ISO 8601 date time format.
	ScheduledDeliveryEndDate *string `json:"ScheduledDeliveryEndDate,omitempty"`

	// ScheduledDeliveryStartDate The start date of the scheduled delivery window in the time zone of the order destination. In ISO 8601 date time format.
	ScheduledDeliveryStartDate *string `json:"ScheduledDeliveryStartDate,omitempty"`

	// SellerSKU The seller stock keeping unit (SKU) of the item.
	SellerSKU *string `json:"SellerSKU,omitempty"`

	// SerialNumberRequired When true, the product type for this item has a serial number.
	//
	// Returned only for Amazon Easy Ship orders.
	SerialNumberRequired *bool `json:"SerialNumberRequired,omitempty"`

	// SerialNumbers A list of serial numbers for electronic products that are shipped to customers. Returned for FBA orders only.
	SerialNumbers *[]string `json:"SerialNumbers,omitempty"`

	// ShippingDiscount The monetary value of the order.
	ShippingDiscount *Money `json:"ShippingDiscount,omitempty"`

	// ShippingDiscountTax The monetary value of the order.
	ShippingDiscountTax *Money `json:"ShippingDiscountTax,omitempty"`

	// ShippingPrice The monetary value of the order.
	ShippingPrice *Money `json:"ShippingPrice,omitempty"`

	// ShippingTax The monetary value of the order.
	ShippingTax *Money `json:"ShippingTax,omitempty"`

	// StoreChainStoreId The store chain store identifier. Linked to a specific store in a store chain.
	StoreChainStoreId *string `json:"StoreChainStoreId,omitempty"`

	// TaxCollection Information about withheld taxes.
	TaxCollection *TaxCollection `json:"TaxCollection,omitempty"`

	// Title The name of the item.
	Title *string `json:"Title,omitempty"`
}

// OrderItemDeemedResellerCategory The category of deemed reseller. This applies to selling partners that are not based in the EU and is used to help them meet the VAT Deemed Reseller tax laws in the EU and UK.
type OrderItemDeemedResellerCategory string

// OrderItemBuyerInfo A single order item's buyer information.
type OrderItemBuyerInfo struct {
	// BuyerCustomizedInfo Buyer information for custom orders from the Amazon Custom program.
	BuyerCustomizedInfo *BuyerCustomizedInfoDetail `json:"BuyerCustomizedInfo,omitempty"`

	// GiftMessageText A gift message provided by the buyer.
	GiftMessageText *string `json:"GiftMessageText,omitempty"`

	// GiftWrapLevel The gift wrap level specified by the buyer.
	GiftWrapLevel *string `json:"GiftWrapLevel,omitempty"`

	// GiftWrapPrice The monetary value of the order.
	GiftWrapPrice *Money `json:"GiftWrapPrice,omitempty"`

	// GiftWrapTax The monetary value of the order.
	GiftWrapTax *Money `json:"GiftWrapTax,omitempty"`

	// OrderItemId An Amazon-defined order item identifier.
	OrderItemId string `json:"OrderItemId"`
}

// OrderItemBuyerInfoList A single order item's buyer information list.
type OrderItemBuyerInfoList = []OrderItemBuyerInfo

// OrderItemList A list of order items.
type OrderItemList = []OrderItem

// OrderItems For partial shipment status updates, the list of order items and quantities to be updated.
type OrderItems = []struct {
	// OrderItemId The unique identifier of the order item.
	OrderItemId *string `json:"orderItemId,omitempty"`

	// Quantity The quantity for which to update the shipment status.
	Quantity *int `json:"quantity,omitempty"`
}

// OrderItemsBuyerInfoList A single order item's buyer information list with the order ID.
type OrderItemsBuyerInfoList struct {
	// AmazonOrderId An Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderId string `json:"AmazonOrderId"`

	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"NextToken,omitempty"`

	// OrderItems A single order item's buyer information list.
	OrderItems OrderItemBuyerInfoList `json:"OrderItems"`
}

// OrderItemsList The order items list along with the order ID.
type OrderItemsList struct {
	// AmazonOrderId An Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderId string `json:"AmazonOrderId"`

	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"NextToken,omitempty"`

	// OrderItems A list of order items.
	OrderItems OrderItemList `json:"OrderItems"`
}

// OrderList A list of orders.
type OrderList = []Order

// OrderRegulatedInfo The order's regulated information along with its verification status.
type OrderRegulatedInfo struct {
	// AmazonOrderId An Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderId string `json:"AmazonOrderId"`

	// RegulatedInformation The regulated information collected during purchase and used to verify the order.
	RegulatedInformation RegulatedInformation `json:"RegulatedInformation"`

	// RegulatedOrderVerificationStatus The verification status of the order along with associated approval or rejection metadata.
	RegulatedOrderVerificationStatus RegulatedOrderVerificationStatus `json:"RegulatedOrderVerificationStatus"`

	// RequiresDosageLabel When true, the order requires attaching a dosage information label when shipped.
	RequiresDosageLabel bool `json:"RequiresDosageLabel"`
}

// OrdersList A list of orders along with additional information to make subsequent API calls.
type OrdersList struct {
	// CreatedBefore A date used for selecting orders created before (or at) a specified time. Only orders placed before the specified time are returned. The date must be in ISO 8601 format.
	CreatedBefore *string `json:"CreatedBefore,omitempty"`

	// LastUpdatedBefore A date used for selecting orders that were last updated before (or at) a specified time. An update is defined as any change in order status, including the creation of a new order. Includes updates made by Amazon and by the seller. All dates must be in ISO 8601 format.
	LastUpdatedBefore *string `json:"LastUpdatedBefore,omitempty"`

	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"NextToken,omitempty"`

	// Orders A list of orders.
	Orders OrderList `json:"Orders"`
}

// OtherDeliveryAttributes Miscellaneous delivery attributes associated with the shipping address.
type OtherDeliveryAttributes string

// PackageDetail Properties of packages
type PackageDetail struct {
	// CarrierCode Identifies the carrier that will deliver the package. This field is required for all marketplaces, see [reference](https://developer-docs.amazon.com/sp-api/changelog/carriercode-value-required-in-shipment-confirmations-for-br-mx-ca-sg-au-in-jp-marketplaces).
	CarrierCode string `json:"carrierCode"`

	// CarrierName Carrier Name that will deliver the package. Required when carrierCode is "Others"
	CarrierName *string `json:"carrierName,omitempty"`

	// OrderItems A list of order items.
	OrderItems ConfirmShipmentOrderItemsList `json:"orderItems"`

	// PackageReferenceId A seller-supplied identifier that uniquely identifies a package within the scope of an order. Only positive numeric values are supported.
	PackageReferenceId PackageReferenceId `json:"packageReferenceId"`

	// ShipDate The shipping date for the package. Must be in ISO-8601 date/time format.
	ShipDate time.Time `json:"shipDate"`

	// ShipFromSupplySourceId The unique identifier of the supply source.
	ShipFromSupplySourceId *string `json:"shipFromSupplySourceId,omitempty"`

	// ShippingMethod Ship method to be used for shipping the order.
	ShippingMethod *string `json:"shippingMethod,omitempty"`

	// TrackingNumber The tracking number used to obtain tracking and delivery information.
	TrackingNumber string `json:"trackingNumber"`
}

// PackageReferenceId A seller-supplied identifier that uniquely identifies a package within the scope of an order. Only positive numeric values are supported.
type PackageReferenceId = string

// PaymentExecutionDetailItem Information about a sub-payment method used to pay for a COD order.
type PaymentExecutionDetailItem struct {
	// Payment The monetary value of the order.
	Payment Money `json:"Payment"`

	// PaymentMethod A sub-payment method for a COD order.
	//
	// Possible values:
	//
	// * COD - Cash On Delivery.
	//
	// * GC - Gift Card.
	//
	// * PointsAccount - Amazon Points.
	PaymentMethod string `json:"PaymentMethod"`
}

// PaymentExecutionDetailItemList A list of payment execution detail items.
type PaymentExecutionDetailItemList = []PaymentExecutionDetailItem

// PaymentMethodDetailItemList A list of payment method detail items.
type PaymentMethodDetailItemList = []string

// PointsGrantedDetail The number of Amazon Points offered with the purchase of an item, and their monetary value.
type PointsGrantedDetail struct {
	// PointsMonetaryValue The monetary value of the order.
	PointsMonetaryValue *Money `json:"PointsMonetaryValue,omitempty"`

	// PointsNumber The number of Amazon Points granted with the purchase of an item.
	PointsNumber *int `json:"PointsNumber,omitempty"`
}

// PreferredDeliveryTime The time window when the delivery is preferred.
type PreferredDeliveryTime struct {
	// BusinessHours Business hours when the business is open for deliveries.
	BusinessHours *[]BusinessHours `json:"BusinessHours,omitempty"`

	// ExceptionDates Dates when the business is closed in the next 30 days.
	ExceptionDates *[]ExceptionDates `json:"ExceptionDates,omitempty"`
}

// ProductInfoDetail Product information on the number of items.
type ProductInfoDetail struct {
	// NumberOfItems The total number of items that are included in the ASIN.
	NumberOfItems *int `json:"NumberOfItems,omitempty"`
}

// PromotionIdList A list of promotion identifiers provided by the seller when the promotions were created.
type PromotionIdList = []string

// RegulatedInformation The regulated information collected during purchase and used to verify the order.
type RegulatedInformation struct {
	// Fields A list of regulated information fields as collected from the regulatory form.
	Fields []RegulatedInformationField `json:"Fields"`
}

// RegulatedInformationField A field collected from the regulatory form.
type RegulatedInformationField struct {
	// FieldId The unique identifier for the field.
	FieldId string `json:"FieldId"`

	// FieldLabel The name for the field.
	FieldLabel string `json:"FieldLabel"`

	// FieldType The type of field.
	FieldType RegulatedInformationFieldFieldType `json:"FieldType"`

	// FieldValue The content of the field as collected in regulatory form. Note that FileAttachment type fields will contain a URL to download the attachment here.
	FieldValue string `json:"FieldValue"`
}

// RegulatedInformationFieldFieldType The type of field.
type RegulatedInformationFieldFieldType string

// RegulatedOrderVerificationStatus The verification status of the order along with associated approval or rejection metadata.
type RegulatedOrderVerificationStatus struct {
	// ExternalReviewerId The identifier for the order's regulated information reviewer.
	ExternalReviewerId *string `json:"ExternalReviewerId,omitempty"`

	// RejectionReason The reason for rejecting the order's regulated information. Not present if the order isn't rejected.
	RejectionReason *RejectionReason `json:"RejectionReason,omitempty"`

	// RequiresMerchantAction When true, the regulated information provided in the order requires a review by the merchant.
	RequiresMerchantAction bool `json:"RequiresMerchantAction"`

	// ReviewDate The date the order was reviewed. In ISO 8601 date time format.
	ReviewDate *string `json:"ReviewDate,omitempty"`

	// Status The verification status of the order.
	Status VerificationStatus `json:"Status"`

	// ValidRejectionReasons A list of valid rejection reasons that may be used to reject the order's regulated information.
	ValidRejectionReasons []RejectionReason `json:"ValidRejectionReasons"`
}

// RejectionReason The reason for rejecting the order's regulated information. Not present if the order isn't rejected.
type RejectionReason struct {
	// RejectionReasonDescription The description of this rejection reason.
	RejectionReasonDescription string `json:"RejectionReasonDescription"`

	// RejectionReasonId The unique identifier for the rejection reason.
	RejectionReasonId string `json:"RejectionReasonId"`
}

// ShipmentStatus The shipment status to apply.
type ShipmentStatus string

// TaxClassification The tax classification for the order.
type TaxClassification struct {
	// Name The type of tax.
	Name *string `json:"Name,omitempty"`

	// Value The buyer's tax identifier.
	Value *string `json:"Value,omitempty"`
}

// TaxCollection Information about withheld taxes.
type TaxCollection struct {
	// Model The tax collection model applied to the item.
	Model *TaxCollectionModel `json:"Model,omitempty"`

	// ResponsibleParty The party responsible for withholding the taxes and remitting them to the taxing authority.
	ResponsibleParty *TaxCollectionResponsibleParty `json:"ResponsibleParty,omitempty"`
}

// TaxCollectionModel The tax collection model applied to the item.
type TaxCollectionModel string

// TaxCollectionResponsibleParty The party responsible for withholding the taxes and remitting them to the taxing authority.
type TaxCollectionResponsibleParty string

// TransparencyCode The Transparency code associated with the item.
type TransparencyCode = string

// TransparencyCodeList A list of order items.
type TransparencyCodeList = []TransparencyCode

// UpdateShipmentStatusErrorResponse The error response schema for the UpdateShipmentStatus operation.
type UpdateShipmentStatusErrorResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// UpdateShipmentStatusRequest The request body for the updateShipmentStatus operation.
type UpdateShipmentStatusRequest struct {
	// MarketplaceId The unobfuscated marketplace identifier.
	MarketplaceId MarketplaceId `json:"marketplaceId"`

	// OrderItems For partial shipment status updates, the list of order items and quantities to be updated.
	OrderItems *OrderItems `json:"orderItems,omitempty"`

	// ShipmentStatus The shipment status to apply.
	ShipmentStatus ShipmentStatus `json:"shipmentStatus"`
}

// UpdateVerificationStatusErrorResponse The error response schema for the UpdateVerificationStatus operation.
type UpdateVerificationStatusErrorResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// UpdateVerificationStatusRequest The request body for the updateVerificationStatus operation.
type UpdateVerificationStatusRequest struct {
	// RegulatedOrderVerificationStatus The updated values of the VerificationStatus field.
	RegulatedOrderVerificationStatus UpdateVerificationStatusRequestBody `json:"regulatedOrderVerificationStatus"`
}

// UpdateVerificationStatusRequestBody The updated values of the VerificationStatus field.
type UpdateVerificationStatusRequestBody struct {
	// ExternalReviewerId The identifier for the order's regulated information reviewer.
	ExternalReviewerId string `json:"externalReviewerId"`

	// RejectionReasonId The unique identifier for the rejection reason used for rejecting the order's regulated information. Only required if the new status is rejected.
	RejectionReasonId *string `json:"rejectionReasonId,omitempty"`

	// Status The verification status of the order.
	Status VerificationStatus `json:"status"`
}

// VerificationStatus The verification status of the order.
type VerificationStatus string

// GetOrdersParams defines parameters for GetOrders.
type GetOrdersParams struct {
	// CreatedAfter A date used for selecting orders created after (or at) a specified time. Only orders placed after the specified time are returned. Either the CreatedAfter parameter or the LastUpdatedAfter parameter is required. Both cannot be empty. The date must be in ISO 8601 format.
	CreatedAfter *string `form:"CreatedAfter,omitempty" json:"CreatedAfter,omitempty"`

	// CreatedBefore A date used for selecting orders created before (or at) a specified time. Only orders placed before the specified time are returned. The date must be in ISO 8601 format.
	CreatedBefore *string `form:"CreatedBefore,omitempty" json:"CreatedBefore,omitempty"`

	// LastUpdatedAfter A date used for selecting orders that were last updated after (or at) a specified time. An update is defined as any change in order status, including the creation of a new order. Includes updates made by Amazon and by the seller. The date must be in ISO 8601 format.
	LastUpdatedAfter *string `form:"LastUpdatedAfter,omitempty" json:"LastUpdatedAfter,omitempty"`

	// LastUpdatedBefore A date used for selecting orders that were last updated before (or at) a specified time. An update is defined as any change in order status, including the creation of a new order. Includes updates made by Amazon and by the seller. The date must be in ISO 8601 format.
	LastUpdatedBefore *string `form:"LastUpdatedBefore,omitempty" json:"LastUpdatedBefore,omitempty"`

	// OrderStatuses A list of `OrderStatus` values used to filter the results.
	//
	// **Possible values:**
	// - `PendingAvailability` (This status is available for pre-orders only. The order has been placed, payment has not been authorized, and the release date of the item is in the future.)
	// - `Pending` (The order has been placed but payment has not been authorized.)
	// - `Unshipped` (Payment has been authorized and the order is ready for shipment, but no items in the order have been shipped.)
	// - `PartiallyShipped` (One or more, but not all, items in the order have been shipped.)
	// - `Shipped` (All items in the order have been shipped.)
	// - `InvoiceUnconfirmed` (All items in the order have been shipped. The seller has not yet given confirmation to Amazon that the invoice has been shipped to the buyer.)
	// - `Canceled` (The order has been canceled.)
	// - `Unfulfillable` (The order cannot be fulfilled. This state applies only to Multi-Channel Fulfillment orders.)
	OrderStatuses *[]string `form:"OrderStatuses,omitempty" json:"OrderStatuses,omitempty"`

	// MarketplaceIds A list of MarketplaceId values. Used to select orders that were placed in the specified marketplaces.
	//
	// See the [Selling Partner API Developer Guide](doc:marketplace-ids) for a complete list of marketplaceId values.
	MarketplaceIds []string `form:"MarketplaceIds" json:"MarketplaceIds"`

	// FulfillmentChannels A list that indicates how an order was fulfilled. Filters the results by fulfillment channel. Possible values: AFN (Fulfillment by Amazon); MFN (Fulfilled by the seller).
	FulfillmentChannels *[]string `form:"FulfillmentChannels,omitempty" json:"FulfillmentChannels,omitempty"`

	// PaymentMethods A list of payment method values. Used to select orders paid using the specified payment methods. Possible values: COD (Cash on delivery); CVS (Convenience store payment); Other (Any payment method other than COD or CVS).
	PaymentMethods *[]string `form:"PaymentMethods,omitempty" json:"PaymentMethods,omitempty"`

	// BuyerEmail The email address of a buyer. Used to select orders that contain the specified email address.
	BuyerEmail *string `form:"BuyerEmail,omitempty" json:"BuyerEmail,omitempty"`

	// SellerOrderId An order identifier that is specified by the seller. Used to select only the orders that match the order identifier. If SellerOrderId is specified, then FulfillmentChannels, OrderStatuses, PaymentMethod, LastUpdatedAfter, LastUpdatedBefore, and BuyerEmail cannot be specified.
	SellerOrderId *string `form:"SellerOrderId,omitempty" json:"SellerOrderId,omitempty"`

	// MaxResultsPerPage A number that indicates the maximum number of orders that can be returned per page. Value must be 1 - 100. Default 100.
	MaxResultsPerPage *int `form:"MaxResultsPerPage,omitempty" json:"MaxResultsPerPage,omitempty"`

	// EasyShipShipmentStatuses A list of `EasyShipShipmentStatus` values. Used to select Easy Ship orders with statuses that match the specified values. If `EasyShipShipmentStatus` is specified, only Amazon Easy Ship orders are returned.
	//
	// **Possible values:**
	// - `PendingSchedule` (The package is awaiting the schedule for pick-up.)
	// - `PendingPickUp` (Amazon has not yet picked up the package from the seller.)
	// - `PendingDropOff` (The seller will deliver the package to the carrier.)
	// - `LabelCanceled` (The seller canceled the pickup.)
	// - `PickedUp` (Amazon has picked up the package from the seller.)
	// - `DroppedOff` (The package is delivered to the carrier by the seller.)
	// - `AtOriginFC` (The packaged is at the origin fulfillment center.)
	// - `AtDestinationFC` (The package is at the destination fulfillment center.)
	// - `Delivered` (The package has been delivered.)
	// - `RejectedByBuyer` (The package has been rejected by the buyer.)
	// - `Undeliverable` (The package cannot be delivered.)
	// - `ReturningToSeller` (The package was not delivered and is being returned to the seller.)
	// - `ReturnedToSeller` (The package was not delivered and was returned to the seller.)
	// - `Lost` (The package is lost.)
	// - `OutForDelivery` (The package is out for delivery.)
	// - `Damaged` (The package was damaged by the carrier.)
	EasyShipShipmentStatuses *[]string `form:"EasyShipShipmentStatuses,omitempty" json:"EasyShipShipmentStatuses,omitempty"`

	// ElectronicInvoiceStatuses A list of `ElectronicInvoiceStatus` values. Used to select orders with electronic invoice statuses that match the specified values.
	//
	// **Possible values:**
	// - `NotRequired` (Electronic invoice submission is not required for this order.)
	// - `NotFound` (The electronic invoice was not submitted for this order.)
	// - `Processing` (The electronic invoice is being processed for this order.)
	// - `Errored` (The last submitted electronic invoice was rejected for this order.)
	// - `Accepted` (The last submitted electronic invoice was submitted and accepted.)
	ElectronicInvoiceStatuses *[]string `form:"ElectronicInvoiceStatuses,omitempty" json:"ElectronicInvoiceStatuses,omitempty"`

	// NextToken A string token returned in the response of your previous request.
	NextToken *string `form:"NextToken,omitempty" json:"NextToken,omitempty"`

	// AmazonOrderIds A list of AmazonOrderId values. An AmazonOrderId is an Amazon-defined order identifier, in 3-7-7 format.
	AmazonOrderIds *[]string `form:"AmazonOrderIds,omitempty" json:"AmazonOrderIds,omitempty"`

	// ActualFulfillmentSupplySourceId Denotes the recommended sourceId where the order should be fulfilled from.
	ActualFulfillmentSupplySourceId *string `form:"ActualFulfillmentSupplySourceId,omitempty" json:"ActualFulfillmentSupplySourceId,omitempty"`

	// IsISPU When true, this order is marked to be picked up from a store rather than delivered.
	IsISPU *bool `form:"IsISPU,omitempty" json:"IsISPU,omitempty"`

	// StoreChainStoreId The store chain store identifier. Linked to a specific store in a store chain.
	StoreChainStoreId *string `form:"StoreChainStoreId,omitempty" json:"StoreChainStoreId,omitempty"`
}

// GetOrderItemsParams defines parameters for GetOrderItems.
type GetOrderItemsParams struct {
	// NextToken A string token returned in the response of your previous request.
	NextToken *string `form:"NextToken,omitempty" json:"NextToken,omitempty"`
}

// GetOrderItemsBuyerInfoParams defines parameters for GetOrderItemsBuyerInfo.
type GetOrderItemsBuyerInfoParams struct {
	// NextToken A string token returned in the response of your previous request.
	NextToken *string `form:"NextToken,omitempty" json:"NextToken,omitempty"`
}

// UpdateVerificationStatusJSONRequestBody defines body for UpdateVerificationStatus for application/json ContentType.
type UpdateVerificationStatusJSONRequestBody = UpdateVerificationStatusRequest

// UpdateShipmentStatusJSONRequestBody defines body for UpdateShipmentStatus for application/json ContentType.
type UpdateShipmentStatusJSONRequestBody = UpdateShipmentStatusRequest

// ConfirmShipmentJSONRequestBody defines body for ConfirmShipment for application/json ContentType.
type ConfirmShipmentJSONRequestBody = ConfirmShipmentRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetOrders request
	GetOrders(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrder request
	GetOrder(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderAddress request
	GetOrderAddress(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderBuyerInfo request
	GetOrderBuyerInfo(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderItems request
	GetOrderItems(ctx context.Context, orderId string, params *GetOrderItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderItemsBuyerInfo request
	GetOrderItemsBuyerInfo(ctx context.Context, orderId string, params *GetOrderItemsBuyerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderRegulatedInfo request
	GetOrderRegulatedInfo(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVerificationStatusWithBody request with any body
	UpdateVerificationStatusWithBody(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVerificationStatus(ctx context.Context, orderId string, body UpdateVerificationStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateShipmentStatusWithBody request with any body
	UpdateShipmentStatusWithBody(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateShipmentStatus(ctx context.Context, orderId string, body UpdateShipmentStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmShipmentWithBody request with any body
	ConfirmShipmentWithBody(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfirmShipment(ctx context.Context, orderId string, body ConfirmShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetOrders(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrder(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderRequest(c.Server, orderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderAddress(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderAddressRequest(c.Server, orderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderBuyerInfo(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderBuyerInfoRequest(c.Server, orderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderItems(ctx context.Context, orderId string, params *GetOrderItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderItemsRequest(c.Server, orderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderItemsBuyerInfo(ctx context.Context, orderId string, params *GetOrderItemsBuyerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderItemsBuyerInfoRequest(c.Server, orderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderRegulatedInfo(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderRegulatedInfoRequest(c.Server, orderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVerificationStatusWithBody(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVerificationStatusRequestWithBody(c.Server, orderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVerificationStatus(ctx context.Context, orderId string, body UpdateVerificationStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVerificationStatusRequest(c.Server, orderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShipmentStatusWithBody(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShipmentStatusRequestWithBody(c.Server, orderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShipmentStatus(ctx context.Context, orderId string, body UpdateShipmentStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShipmentStatusRequest(c.Server, orderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmShipmentWithBody(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmShipmentRequestWithBody(c.Server, orderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmShipment(ctx context.Context, orderId string, body ConfirmShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmShipmentRequest(c.Server, orderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetOrdersRequest generates requests for GetOrders
func NewGetOrdersRequest(server string, params *GetOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "CreatedAfter", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "CreatedBefore", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LastUpdatedAfter", runtime.ParamLocationQuery, *params.LastUpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LastUpdatedBefore", runtime.ParamLocationQuery, *params.LastUpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.OrderStatuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "OrderStatuses", runtime.ParamLocationQuery, *params.OrderStatuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.FulfillmentChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "FulfillmentChannels", runtime.ParamLocationQuery, *params.FulfillmentChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaymentMethods != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "PaymentMethods", runtime.ParamLocationQuery, *params.PaymentMethods); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.BuyerEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "BuyerEmail", runtime.ParamLocationQuery, *params.BuyerEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SellerOrderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SellerOrderId", runtime.ParamLocationQuery, *params.SellerOrderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.MaxResultsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MaxResultsPerPage", runtime.ParamLocationQuery, *params.MaxResultsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.EasyShipShipmentStatuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "EasyShipShipmentStatuses", runtime.ParamLocationQuery, *params.EasyShipShipmentStatuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ElectronicInvoiceStatuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ElectronicInvoiceStatuses", runtime.ParamLocationQuery, *params.ElectronicInvoiceStatuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.AmazonOrderIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "AmazonOrderIds", runtime.ParamLocationQuery, *params.AmazonOrderIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ActualFulfillmentSupplySourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ActualFulfillmentSupplySourceId", runtime.ParamLocationQuery, *params.ActualFulfillmentSupplySourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IsISPU != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "IsISPU", runtime.ParamLocationQuery, *params.IsISPU); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.StoreChainStoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "StoreChainStoreId", runtime.ParamLocationQuery, *params.StoreChainStoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderRequest generates requests for GetOrder
func NewGetOrderRequest(server string, orderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderAddressRequest generates requests for GetOrderAddress
func NewGetOrderAddressRequest(server string, orderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/address", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderBuyerInfoRequest generates requests for GetOrderBuyerInfo
func NewGetOrderBuyerInfoRequest(server string, orderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/buyerInfo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderItemsRequest generates requests for GetOrderItems
func NewGetOrderItemsRequest(server string, orderId string, params *GetOrderItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/orderItems", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderItemsBuyerInfoRequest generates requests for GetOrderItemsBuyerInfo
func NewGetOrderItemsBuyerInfoRequest(server string, orderId string, params *GetOrderItemsBuyerInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/orderItems/buyerInfo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderRegulatedInfoRequest generates requests for GetOrderRegulatedInfo
func NewGetOrderRegulatedInfoRequest(server string, orderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/regulatedInfo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVerificationStatusRequest calls the generic UpdateVerificationStatus builder with application/json body
func NewUpdateVerificationStatusRequest(server string, orderId string, body UpdateVerificationStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVerificationStatusRequestWithBody(server, orderId, "application/json", bodyReader)
}

// NewUpdateVerificationStatusRequestWithBody generates requests for UpdateVerificationStatus with any type of body
func NewUpdateVerificationStatusRequestWithBody(server string, orderId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/regulatedInfo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateShipmentStatusRequest calls the generic UpdateShipmentStatus builder with application/json body
func NewUpdateShipmentStatusRequest(server string, orderId string, body UpdateShipmentStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShipmentStatusRequestWithBody(server, orderId, "application/json", bodyReader)
}

// NewUpdateShipmentStatusRequestWithBody generates requests for UpdateShipmentStatus with any type of body
func NewUpdateShipmentStatusRequestWithBody(server string, orderId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/shipment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConfirmShipmentRequest calls the generic ConfirmShipment builder with application/json body
func NewConfirmShipmentRequest(server string, orderId string, body ConfirmShipmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfirmShipmentRequestWithBody(server, orderId, "application/json", bodyReader)
}

// NewConfirmShipmentRequestWithBody generates requests for ConfirmShipment with any type of body
func NewConfirmShipmentRequestWithBody(server string, orderId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/v0/orders/%s/shipmentConfirmation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetOrdersWithResponse request
	GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*GetOrdersResp, error)

	// GetOrderWithResponse request
	GetOrderWithResponse(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*GetOrderResp, error)

	// GetOrderAddressWithResponse request
	GetOrderAddressWithResponse(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*GetOrderAddressResp, error)

	// GetOrderBuyerInfoWithResponse request
	GetOrderBuyerInfoWithResponse(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*GetOrderBuyerInfoResp, error)

	// GetOrderItemsWithResponse request
	GetOrderItemsWithResponse(ctx context.Context, orderId string, params *GetOrderItemsParams, reqEditors ...RequestEditorFn) (*GetOrderItemsResp, error)

	// GetOrderItemsBuyerInfoWithResponse request
	GetOrderItemsBuyerInfoWithResponse(ctx context.Context, orderId string, params *GetOrderItemsBuyerInfoParams, reqEditors ...RequestEditorFn) (*GetOrderItemsBuyerInfoResp, error)

	// GetOrderRegulatedInfoWithResponse request
	GetOrderRegulatedInfoWithResponse(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*GetOrderRegulatedInfoResp, error)

	// UpdateVerificationStatusWithBodyWithResponse request with any body
	UpdateVerificationStatusWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVerificationStatusResp, error)

	UpdateVerificationStatusWithResponse(ctx context.Context, orderId string, body UpdateVerificationStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVerificationStatusResp, error)

	// UpdateShipmentStatusWithBodyWithResponse request with any body
	UpdateShipmentStatusWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShipmentStatusResp, error)

	UpdateShipmentStatusWithResponse(ctx context.Context, orderId string, body UpdateShipmentStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShipmentStatusResp, error)

	// ConfirmShipmentWithBodyWithResponse request with any body
	ConfirmShipmentWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmShipmentResp, error)

	ConfirmShipmentWithResponse(ctx context.Context, orderId string, body ConfirmShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmShipmentResp, error)
}

type GetOrdersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrdersResponse
	JSON400      *GetOrdersResponse
	JSON403      *GetOrdersResponse
	JSON404      *GetOrdersResponse
	JSON429      *GetOrdersResponse
	JSON500      *GetOrdersResponse
	JSON503      *GetOrdersResponse
}

// Status returns HTTPResponse.Status
func (r GetOrdersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderResponse
	JSON400      *GetOrderResponse
	JSON403      *GetOrderResponse
	JSON404      *GetOrderResponse
	JSON429      *GetOrderResponse
	JSON500      *GetOrderResponse
	JSON503      *GetOrderResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderAddressResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderAddressResponse
	JSON400      *GetOrderAddressResponse
	JSON403      *GetOrderAddressResponse
	JSON404      *GetOrderAddressResponse
	JSON429      *GetOrderAddressResponse
	JSON500      *GetOrderAddressResponse
	JSON503      *GetOrderAddressResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderAddressResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderAddressResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderBuyerInfoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderBuyerInfoResponse
	JSON400      *GetOrderBuyerInfoResponse
	JSON403      *GetOrderBuyerInfoResponse
	JSON404      *GetOrderBuyerInfoResponse
	JSON429      *GetOrderBuyerInfoResponse
	JSON500      *GetOrderBuyerInfoResponse
	JSON503      *GetOrderBuyerInfoResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderBuyerInfoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderBuyerInfoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderItemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderItemsResponse
	JSON400      *GetOrderItemsResponse
	JSON403      *GetOrderItemsResponse
	JSON404      *GetOrderItemsResponse
	JSON429      *GetOrderItemsResponse
	JSON500      *GetOrderItemsResponse
	JSON503      *GetOrderItemsResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderItemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderItemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderItemsBuyerInfoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderItemsBuyerInfoResponse
	JSON400      *GetOrderItemsBuyerInfoResponse
	JSON403      *GetOrderItemsBuyerInfoResponse
	JSON404      *GetOrderItemsBuyerInfoResponse
	JSON429      *GetOrderItemsBuyerInfoResponse
	JSON500      *GetOrderItemsBuyerInfoResponse
	JSON503      *GetOrderItemsBuyerInfoResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderItemsBuyerInfoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderItemsBuyerInfoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderRegulatedInfoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderRegulatedInfoResponse
	JSON400      *GetOrderRegulatedInfoResponse
	JSON403      *GetOrderRegulatedInfoResponse
	JSON404      *GetOrderRegulatedInfoResponse
	JSON429      *GetOrderRegulatedInfoResponse
	JSON500      *GetOrderRegulatedInfoResponse
	JSON503      *GetOrderRegulatedInfoResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderRegulatedInfoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderRegulatedInfoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVerificationStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *UpdateVerificationStatusErrorResponse
	JSON403      *UpdateVerificationStatusErrorResponse
	JSON404      *UpdateVerificationStatusErrorResponse
	JSON413      *UpdateVerificationStatusErrorResponse
	JSON415      *UpdateVerificationStatusErrorResponse
	JSON429      *UpdateVerificationStatusErrorResponse
	JSON500      *UpdateVerificationStatusErrorResponse
	JSON503      *UpdateVerificationStatusErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateVerificationStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVerificationStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShipmentStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *UpdateShipmentStatusErrorResponse
	JSON403      *UpdateShipmentStatusErrorResponse
	JSON404      *UpdateShipmentStatusErrorResponse
	JSON413      *UpdateShipmentStatusErrorResponse
	JSON415      *UpdateShipmentStatusErrorResponse
	JSON429      *UpdateShipmentStatusErrorResponse
	JSON500      *UpdateShipmentStatusErrorResponse
	JSON503      *UpdateShipmentStatusErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateShipmentStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShipmentStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmShipmentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ConfirmShipmentErrorResponse
	JSON401      *ConfirmShipmentErrorResponse
	JSON403      *ConfirmShipmentErrorResponse
	JSON404      *ConfirmShipmentErrorResponse
	JSON429      *ConfirmShipmentErrorResponse
	JSON500      *ConfirmShipmentErrorResponse
	JSON503      *ConfirmShipmentErrorResponse
}

// Status returns HTTPResponse.Status
func (r ConfirmShipmentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmShipmentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetOrdersWithResponse request returning *GetOrdersResp
func (c *ClientWithResponses) GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*GetOrdersResp, error) {
	rsp, err := c.GetOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersResp(rsp)
}

// GetOrderWithResponse request returning *GetOrderResp
func (c *ClientWithResponses) GetOrderWithResponse(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*GetOrderResp, error) {
	rsp, err := c.GetOrder(ctx, orderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderResp(rsp)
}

// GetOrderAddressWithResponse request returning *GetOrderAddressResp
func (c *ClientWithResponses) GetOrderAddressWithResponse(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*GetOrderAddressResp, error) {
	rsp, err := c.GetOrderAddress(ctx, orderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderAddressResp(rsp)
}

// GetOrderBuyerInfoWithResponse request returning *GetOrderBuyerInfoResp
func (c *ClientWithResponses) GetOrderBuyerInfoWithResponse(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*GetOrderBuyerInfoResp, error) {
	rsp, err := c.GetOrderBuyerInfo(ctx, orderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderBuyerInfoResp(rsp)
}

// GetOrderItemsWithResponse request returning *GetOrderItemsResp
func (c *ClientWithResponses) GetOrderItemsWithResponse(ctx context.Context, orderId string, params *GetOrderItemsParams, reqEditors ...RequestEditorFn) (*GetOrderItemsResp, error) {
	rsp, err := c.GetOrderItems(ctx, orderId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderItemsResp(rsp)
}

// GetOrderItemsBuyerInfoWithResponse request returning *GetOrderItemsBuyerInfoResp
func (c *ClientWithResponses) GetOrderItemsBuyerInfoWithResponse(ctx context.Context, orderId string, params *GetOrderItemsBuyerInfoParams, reqEditors ...RequestEditorFn) (*GetOrderItemsBuyerInfoResp, error) {
	rsp, err := c.GetOrderItemsBuyerInfo(ctx, orderId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderItemsBuyerInfoResp(rsp)
}

// GetOrderRegulatedInfoWithResponse request returning *GetOrderRegulatedInfoResp
func (c *ClientWithResponses) GetOrderRegulatedInfoWithResponse(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*GetOrderRegulatedInfoResp, error) {
	rsp, err := c.GetOrderRegulatedInfo(ctx, orderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderRegulatedInfoResp(rsp)
}

// UpdateVerificationStatusWithBodyWithResponse request with arbitrary body returning *UpdateVerificationStatusResp
func (c *ClientWithResponses) UpdateVerificationStatusWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVerificationStatusResp, error) {
	rsp, err := c.UpdateVerificationStatusWithBody(ctx, orderId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVerificationStatusResp(rsp)
}

func (c *ClientWithResponses) UpdateVerificationStatusWithResponse(ctx context.Context, orderId string, body UpdateVerificationStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVerificationStatusResp, error) {
	rsp, err := c.UpdateVerificationStatus(ctx, orderId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVerificationStatusResp(rsp)
}

// UpdateShipmentStatusWithBodyWithResponse request with arbitrary body returning *UpdateShipmentStatusResp
func (c *ClientWithResponses) UpdateShipmentStatusWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShipmentStatusResp, error) {
	rsp, err := c.UpdateShipmentStatusWithBody(ctx, orderId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentStatusResp(rsp)
}

func (c *ClientWithResponses) UpdateShipmentStatusWithResponse(ctx context.Context, orderId string, body UpdateShipmentStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShipmentStatusResp, error) {
	rsp, err := c.UpdateShipmentStatus(ctx, orderId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentStatusResp(rsp)
}

// ConfirmShipmentWithBodyWithResponse request with arbitrary body returning *ConfirmShipmentResp
func (c *ClientWithResponses) ConfirmShipmentWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmShipmentResp, error) {
	rsp, err := c.ConfirmShipmentWithBody(ctx, orderId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmShipmentResp(rsp)
}

func (c *ClientWithResponses) ConfirmShipmentWithResponse(ctx context.Context, orderId string, body ConfirmShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmShipmentResp, error) {
	rsp, err := c.ConfirmShipment(ctx, orderId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmShipmentResp(rsp)
}

// ParseGetOrdersResp parses an HTTP response from a GetOrdersWithResponse call
func ParseGetOrdersResp(rsp *http.Response) (*GetOrdersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderResp parses an HTTP response from a GetOrderWithResponse call
func ParseGetOrderResp(rsp *http.Response) (*GetOrderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderAddressResp parses an HTTP response from a GetOrderAddressWithResponse call
func ParseGetOrderAddressResp(rsp *http.Response) (*GetOrderAddressResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderAddressResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderBuyerInfoResp parses an HTTP response from a GetOrderBuyerInfoWithResponse call
func ParseGetOrderBuyerInfoResp(rsp *http.Response) (*GetOrderBuyerInfoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderBuyerInfoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderItemsResp parses an HTTP response from a GetOrderItemsWithResponse call
func ParseGetOrderItemsResp(rsp *http.Response) (*GetOrderItemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderItemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderItemsBuyerInfoResp parses an HTTP response from a GetOrderItemsBuyerInfoWithResponse call
func ParseGetOrderItemsBuyerInfoResp(rsp *http.Response) (*GetOrderItemsBuyerInfoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderItemsBuyerInfoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderItemsBuyerInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderRegulatedInfoResp parses an HTTP response from a GetOrderRegulatedInfoWithResponse call
func ParseGetOrderRegulatedInfoResp(rsp *http.Response) (*GetOrderRegulatedInfoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderRegulatedInfoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderRegulatedInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateVerificationStatusResp parses an HTTP response from a UpdateVerificationStatusWithResponse call
func ParseUpdateVerificationStatusResp(rsp *http.Response) (*UpdateVerificationStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVerificationStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest UpdateVerificationStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateShipmentStatusResp parses an HTTP response from a UpdateShipmentStatusWithResponse call
func ParseUpdateShipmentStatusResp(rsp *http.Response) (*UpdateShipmentStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShipmentStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest UpdateShipmentStatusErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConfirmShipmentResp parses an HTTP response from a ConfirmShipmentWithResponse call
func ParseConfirmShipmentResp(rsp *http.Response) (*ConfirmShipmentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmShipmentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ConfirmShipmentErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
