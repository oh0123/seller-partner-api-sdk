// Package sellerwalletv20240301 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package sellerwalletv20240301

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for BalanceType.
const (
	AVAILABLE BalanceType = "AVAILABLE"
	LOCKEDIN  BalanceType = "LOCKED_IN"
	LOCKEDOUT BalanceType = "LOCKED_OUT"
	TOTAL     BalanceType = "TOTAL"
)

// Defines values for BankAccountHolderStatus.
const (
	ACTIVE             BankAccountHolderStatus = "ACTIVE"
	INACTIVE           BankAccountHolderStatus = "INACTIVE"
	UNDERREVIEW        BankAccountHolderStatus = "UNDER_REVIEW"
	VERIFICATIONFAILED BankAccountHolderStatus = "VERIFICATION_FAILED"
)

// Defines values for BankAccountNumberFormat.
const (
	BBAN BankAccountNumberFormat = "BBAN"
	IBAN BankAccountNumberFormat = "IBAN"
)

// Defines values for BankAccountOwnershipType.
const (
	GOVERNMENT BankAccountOwnershipType = "GOVERNMENT"
	SELF       BankAccountOwnershipType = "SELF"
	THIRDPARTY BankAccountOwnershipType = "THIRD_PARTY"
)

// Defines values for BankNumberFormat.
const (
	BASIC BankNumberFormat = "BASIC"
	BIC   BankNumberFormat = "BIC"
)

// Defines values for FeeType.
const (
	MISCELLANEOUSFEE FeeType = "MISCELLANEOUS_FEE"
	TAX              FeeType = "TAX"
	TRANSACTIONFEE   FeeType = "TRANSACTION_FEE"
)

// Defines values for PaymentPreferencePaymentType.
const (
	AMOUNT     PaymentPreferencePaymentType = "AMOUNT"
	PERCENTAGE PaymentPreferencePaymentType = "PERCENTAGE"
)

// Defines values for RateDirection.
const (
	BUY  RateDirection = "BUY"
	SELL RateDirection = "SELL"
)

// Defines values for RecurringFrequency.
const (
	BIWEEKLY RecurringFrequency = "BIWEEKLY"
	DAILY    RecurringFrequency = "DAILY"
	MONTHLY  RecurringFrequency = "MONTHLY"
	WEEKLY   RecurringFrequency = "WEEKLY"
)

// Defines values for ScheduleExpressionType.
const (
	ONETIME   ScheduleExpressionType = "ONE_TIME"
	RECURRING ScheduleExpressionType = "RECURRING"
)

// Defines values for ScheduleTransferType.
const (
	TIMEBASED ScheduleTransferType = "TIME_BASED"
)

// Defines values for TransactionStatus.
const (
	FAILED               TransactionStatus = "FAILED"
	FAILEDCREDITSAPPLIED TransactionStatus = "FAILED_CREDITS_APPLIED"
	INITIATED            TransactionStatus = "INITIATED"
	INPROGRESS           TransactionStatus = "IN_PROGRESS"
	PAYEEUNDERREVIEW     TransactionStatus = "PAYEE_UNDER_REVIEW"
	SUCCESSFUL           TransactionStatus = "SUCCESSFUL"
)

// Defines values for TransactionType.
const (
	CREDIT TransactionType = "CREDIT"
	DEBIT  TransactionType = "DEBIT"
)

// Defines values for TransferScheduleStatus.
const (
	DELETED  TransferScheduleStatus = "DELETED"
	DISABLED TransferScheduleStatus = "DISABLED"
	ENABLED  TransferScheduleStatus = "ENABLED"
	EXPIRED  TransferScheduleStatus = "EXPIRED"
)

// AccountHolderAddress The Address used to verify the bank account of the payee. This can be a person or business mailing address.
type AccountHolderAddress struct {
	// AddressLine1 Address Line 1 of the public address.
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Address Line 2 of the public address.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// City City name of the public address.
	City string `json:"city"`

	// Country Country name of the public address.
	Country *string `json:"country,omitempty"`

	// CountryCode The two digit country code, in ISO 3166 format.
	CountryCode string `json:"countryCode"`

	// PostalCode Postal code of the public address.
	PostalCode string `json:"postalCode"`

	// State State name of the public address. This will be state or region for CN (China) based addresses.
	State string `json:"state"`
}

// Balance The balance amount in the Amazon Seller Wallet bank account.
type Balance struct {
	// AccountId The unique identifier provided by Amazon to identify the account.
	AccountId string `json:"accountId"`

	// BalanceAmount A decimal number, such as an amount or FX rate.
	BalanceAmount BigDecimal `json:"balanceAmount"`

	// BalanceCurrency The Amazon Seller Wallet bank account currency code in ISO 4217 format.
	BalanceCurrency string `json:"balanceCurrency"`

	// BalanceType The type of bank account balance.
	BalanceType *BalanceType `json:"balanceType,omitempty"`

	// LastUpdateDate The date of the most recent account balance update.
	LastUpdateDate time.Time `json:"lastUpdateDate"`
}

// BalanceListing A list of balances in the seller account.
type BalanceListing struct {
	// Balances A list of balances in the seller account.
	Balances *[]Balance `json:"balances,omitempty"`
}

// BalanceType The type of bank account balance.
type BalanceType string

// BankAccount Details of an Amazon Seller Wallet bank account. This account is used to hold the money that a Seller Wallet customer earns by selling items.
type BankAccount struct {
	// AccountCountryCode The two-digit country code in ISO 3166 format.
	AccountCountryCode string `json:"accountCountryCode"`

	// AccountCurrency Bank account currency code in ISO 4217 format.
	AccountCurrency string `json:"accountCurrency"`

	// AccountHolderName The bank account holder's name (expected to be an Amazon customer).
	AccountHolderName string `json:"accountHolderName"`

	// AccountId The unique identifier provided by Amazon to identify the account.
	AccountId *string `json:"accountId,omitempty"`

	// BankAccountHolderStatus The status of the Amazon Seller Wallet account holder.
	BankAccountHolderStatus *BankAccountHolderStatus `json:"bankAccountHolderStatus,omitempty"`

	// BankAccountNumberFormat The bank account's format type.
	BankAccountNumberFormat BankAccountNumberFormat `json:"bankAccountNumberFormat"`

	// BankAccountNumberTail The last 3 digit of the bank account number. This value is three consecutive zeros for Amazon Seller Wallet accounts.
	BankAccountNumberTail string `json:"bankAccountNumberTail"`

	// BankAccountOwnershipType The destination bank account's ownership type.
	BankAccountOwnershipType BankAccountOwnershipType `json:"bankAccountOwnershipType"`

	// BankName The name of the bank. This value is Amazon Seller Wallet for Amazon Seller Wallet accounts.
	BankName *string `json:"bankName,omitempty"`

	// BankNumberFormat The format of the bank number. Also known as the routing number type.
	BankNumberFormat BankNumberFormat `json:"bankNumberFormat"`

	// RoutingNumber Routing number for automated clearing house transfers. This value is nine consecutive zeros for Amazon Seller Wallet accounts.
	RoutingNumber string `json:"routingNumber"`
}

// BankAccountHolderStatus The status of the Amazon Seller Wallet account holder.
type BankAccountHolderStatus string

// BankAccountListing A list of bank accounts.
type BankAccountListing struct {
	// Accounts A list of bank accounts.
	Accounts []BankAccount `json:"accounts"`
}

// BankAccountNumberFormat The bank account's format type.
type BankAccountNumberFormat string

// BankAccountOwnershipType The destination bank account's ownership type.
type BankAccountOwnershipType string

// BankNumberFormat The format of the bank number. Also known as the routing number type.
type BankNumberFormat string

// BigDecimal A decimal number, such as an amount or FX rate.
type BigDecimal = float32

// Currency A currency type and amount.
type Currency struct {
	// CurrencyAmount A decimal number, such as an amount or FX rate.
	CurrencyAmount *BigDecimal `json:"currencyAmount,omitempty"`

	// CurrencyCode The three-digit currency code in ISO 4217 format.
	CurrencyCode *string `json:"currencyCode,omitempty"`
}

// DeleteTransferSchedule The response returned when the schedule transfer's delete request is successful.
type DeleteTransferSchedule struct {
	// Code A success code that specifies that the delete operation was successful. For example, HTTP 200.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand the operation execution.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the success condition of the delete schedule transaction.
	Message string `json:"message"`
}

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	// Errors List of errors
	Errors []Error `json:"errors"`
}

// Fee Details of the fee.
type Fee struct {
	// FeeAmount A currency type and amount.
	FeeAmount Currency `json:"feeAmount"`

	// FeeId The unique identifier assigned to the fee.
	FeeId string `json:"feeId"`

	// FeeRateValue A decimal number, such as an amount or FX rate.
	FeeRateValue BigDecimal `json:"feeRateValue"`

	// FeeType The type of fee on the transaction.
	FeeType FeeType `json:"feeType"`
}

// FeeType The type of fee on the transaction.
type FeeType string

// FxRateDetails Foreign exchange rate details.
type FxRateDetails struct {
	// BaseRate A decimal number, such as an amount or FX rate.
	BaseRate BigDecimal `json:"baseRate"`

	// EffectiveFxRate A decimal number, such as an amount or FX rate.
	EffectiveFxRate BigDecimal `json:"effectiveFxRate"`

	// FxRateId The unique identifier assigned to the fees / foreign exchange rate of a transaction.
	FxRateId string `json:"fxRateId"`

	// RateDirection Whether the customer is buying or selling the source currency.
	RateDirection RateDirection `json:"rateDirection"`
}

// PaymentPreference The type of payment preference in which the transfer is being scheduled.
type PaymentPreference struct {
	// PaymentPreferencePaymentType The type of payment preference.
	PaymentPreferencePaymentType PaymentPreferencePaymentType `json:"paymentPreferencePaymentType"`

	// Value A decimal number, such as an amount or FX rate.
	Value BigDecimal `json:"value"`
}

// PaymentPreferencePaymentType The type of payment preference.
type PaymentPreferencePaymentType string

// RateDirection Whether the customer is buying or selling the source currency.
type RateDirection string

// RecurringFrequency The frequency at which the transaction is repeated.
type RecurringFrequency string

// ScheduleExpression The configuration of the schedule.
type ScheduleExpression struct {
	// RecurringFrequency The frequency at which the transaction is repeated.
	RecurringFrequency *RecurringFrequency `json:"recurringFrequency,omitempty"`

	// ScheduleExpressionType The type of scheduled transfer expression.
	ScheduleExpressionType ScheduleExpressionType `json:"scheduleExpressionType"`
}

// ScheduleExpressionType The type of scheduled transfer expression.
type ScheduleExpressionType string

// ScheduleTransferType The type of schedule the transfer is on. Schedules based on time patterns use EventBridge.
type ScheduleTransferType string

// Transaction The current transaction status and historical details related to it.
type Transaction struct {
	// ExpectedCompletionDate The expected completion date of the transaction.
	ExpectedCompletionDate *time.Time `json:"expectedCompletionDate,omitempty"`

	// LastUpdateDate The date of the most recent account balance update.
	LastUpdateDate time.Time `json:"lastUpdateDate"`

	// RequesterName The Amazon Seller Wallet customer who requested the transaction.
	RequesterName *string `json:"requesterName,omitempty"`

	// TransactionActualCompletionDate The transaction's completion date.
	TransactionActualCompletionDate *time.Time `json:"transactionActualCompletionDate,omitempty"`

	// TransactionDescription The description provided by the requester in the transaction request at time of transaction initiation.
	TransactionDescription string `json:"transactionDescription"`

	// TransactionDestinationAccount Details of the bank account involved in transaction.
	TransactionDestinationAccount TransactionAccount `json:"transactionDestinationAccount"`

	// TransactionFailureReason The reason the transaction failed, if applicable.
	TransactionFailureReason *string `json:"transactionFailureReason,omitempty"`

	// TransactionFinalAmount A currency type and amount.
	TransactionFinalAmount *Currency `json:"transactionFinalAmount,omitempty"`

	// TransactionId The unique identifier provided by Amazon to the transaction.
	TransactionId string `json:"transactionId"`

	// TransactionRequestAmount A currency type and amount.
	TransactionRequestAmount Currency `json:"transactionRequestAmount"`

	// TransactionRequestDate The date on which the transaction was initiated.
	TransactionRequestDate time.Time `json:"transactionRequestDate"`

	// TransactionRequesterSource The transaction initiation source. This value could be the Amazon portal or PISP name that the customer used to start the transaction.
	TransactionRequesterSource string `json:"transactionRequesterSource"`

	// TransactionSourceAccount Details of the bank account involved in transaction.
	TransactionSourceAccount TransactionAccount `json:"transactionSourceAccount"`

	// TransactionStatus The current status of the transaction.
	TransactionStatus TransactionStatus `json:"transactionStatus"`

	// TransactionType The type of transaction.
	TransactionType TransactionType `json:"transactionType"`

	// TransferRateDetails The fees and foreign exchange rates applied to the transaction.
	//
	// If the fees are in terms of the `baseAmount` (source account) currency, then the effective rate is equal to **1 - (fees * `baseRate` / `baseAmount`)**.
	//
	// If the fees are in terms of the `transferAmount` (destination account) currency, then the effective rate is equal to **`baseRate` - (fees / `baseAmount`)**.
	//
	// In the preceding expressions, **fees** is equal to the sum of all `feeAmount.currencyAmount` values in the `fees` array.
	TransferRateDetails TransferRatePreview `json:"transferRateDetails"`
}

// TransactionAccount Details of the bank account involved in transaction.
type TransactionAccount struct {
	// AccountId The unique identifier provided by Amazon to identify the account.
	AccountId *string `json:"accountId,omitempty"`

	// BankAccountCountryCode The two-digit country code, in ISO 3166 format. This field is optional for `transactionSourceAccount`, but is mandatory for `transactionDestinationAccount`.
	BankAccountCountryCode *string `json:"bankAccountCountryCode,omitempty"`

	// BankAccountCurrency The currency code in ISO 4217 format.
	BankAccountCurrency string `json:"bankAccountCurrency"`

	// BankAccountHolderName The account holder's name.
	BankAccountHolderName string `json:"bankAccountHolderName"`

	// BankAccountNumberFormat The bank account's format type.
	BankAccountNumberFormat BankAccountNumberFormat `json:"bankAccountNumberFormat"`

	// BankAccountNumberTail The last three digits of the bank account number.
	BankAccountNumberTail *string `json:"bankAccountNumberTail,omitempty"`

	// BankName The name of the bank.
	BankName string `json:"bankName"`
}

// TransactionInitiationRequest Request body to initiate a transaction from a Seller Wallet bank account to another customer-defined bank account.
type TransactionInitiationRequest struct {
	// Description A description of the transaction.
	Description string `json:"description"`

	// DestinationAccountHolderAddress The Address used to verify the bank account of the payee. This can be a person or business mailing address.
	DestinationAccountHolderAddress *AccountHolderAddress `json:"destinationAccountHolderAddress,omitempty"`

	// DestinationAccountId The unique identifier of the destination bank account where the money is deposited.
	DestinationAccountId *string `json:"destinationAccountId,omitempty"`

	// DestinationTransactionInstrument Details of the destination bank account in the transaction request.
	DestinationTransactionInstrument TransactionInstrumentDetails `json:"destinationTransactionInstrument"`

	// RequestTime The time at which the transaction was initiated in [ISO 8601 date time format](https://developer-docs.amazon.com/sp-api/docs/iso-8601).
	RequestTime time.Time `json:"requestTime"`

	// SourceAccountId The unique identifier of the source Amazon Seller Wallet bank account from which the money is debited.
	SourceAccountId string `json:"sourceAccountId"`

	// SourceAmount A currency type and amount.
	SourceAmount Currency `json:"sourceAmount"`

	// TransferRateDetails The fees and foreign exchange rates applied to the transaction.
	//
	// If the fees are in terms of the `baseAmount` (source account) currency, then the effective rate is equal to **1 - (fees * `baseRate` / `baseAmount`)**.
	//
	// If the fees are in terms of the `transferAmount` (destination account) currency, then the effective rate is equal to **`baseRate` - (fees / `baseAmount`)**.
	//
	// In the preceding expressions, **fees** is equal to the sum of all `feeAmount.currencyAmount` values in the `fees` array.
	TransferRateDetails *TransferRatePreview `json:"transferRateDetails,omitempty"`
}

// TransactionInstrumentDetails Details of the destination bank account in the transaction request.
type TransactionInstrumentDetails struct {
	// BankAccount Details of an Amazon Seller Wallet bank account. This account is used to hold the money that a Seller Wallet customer earns by selling items.
	BankAccount BankAccount `json:"bankAccount"`

	// BankAccountNumber The bank account number of the destination payment method.
	//
	// **Note:** This field is encrypted before Amazon receives it, so should not be used to generate `destAccountDigitalSignature`, and should not be included in the request signature.
	BankAccountNumber string `json:"bankAccountNumber"`
}

// TransactionListing A list of transactions.
type TransactionListing struct {
	// NextPageToken A token that you use to retrieve the next page of results. The response includes `nextPageToken` when the number of results exceeds 100. To get the next page of results, call the operation with this token and include the same arguments as the call that produced the token. To get a complete list, call this operation until `nextPageToken` is null. Note that this operation can return empty pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// Transactions A list of transactions.
	Transactions []Transaction `json:"transactions"`
}

// TransactionStatus The current status of the transaction.
type TransactionStatus string

// TransactionType The type of transaction.
type TransactionType string

// TransferRatePreview The fees and foreign exchange rates applied to the transaction.
//
// If the fees are in terms of the `baseAmount` (source account) currency, then the effective rate is equal to **1 - (fees * `baseRate` / `baseAmount`)**.
//
// If the fees are in terms of the `transferAmount` (destination account) currency, then the effective rate is equal to **`baseRate` - (fees / `baseAmount`)**.
//
// In the preceding expressions, **fees** is equal to the sum of all `feeAmount.currencyAmount` values in the `fees` array.
type TransferRatePreview struct {
	// BaseAmount A currency type and amount.
	BaseAmount Currency `json:"baseAmount"`

	// Fees A list of fees.
	Fees []Fee `json:"fees"`

	// FxRateDetails Foreign exchange rate details.
	FxRateDetails FxRateDetails `json:"fxRateDetails"`

	// TransferAmount A currency type and amount.
	TransferAmount Currency `json:"transferAmount"`
}

// TransferSchedule Transfer schedule details and historical details related to it.
type TransferSchedule struct {
	// PaymentPreference The type of payment preference in which the transfer is being scheduled.
	PaymentPreference *PaymentPreference `json:"paymentPreference,omitempty"`

	// TransactionDestinationAccount Details of the bank account involved in transaction.
	TransactionDestinationAccount TransactionAccount `json:"transactionDestinationAccount"`

	// TransactionSourceAccount Details of the bank account involved in transaction.
	TransactionSourceAccount *TransactionAccount `json:"transactionSourceAccount,omitempty"`

	// TransactionType The type of transaction.
	TransactionType TransactionType `json:"transactionType"`

	// TransferScheduleFailures A list of transfer schedule failures.
	TransferScheduleFailures []TransferScheduleFailures `json:"transferScheduleFailures"`

	// TransferScheduleId The unique identifier provided by Amazon to the scheduled transfer.
	TransferScheduleId string `json:"transferScheduleId"`

	// TransferScheduleInformation Mandatory information for initiating a schedule transfer.
	TransferScheduleInformation TransferScheduleInformation `json:"transferScheduleInformation"`

	// TransferScheduleStatus The schedule status of the transfer.
	TransferScheduleStatus TransferScheduleStatus `json:"transferScheduleStatus"`
}

// TransferScheduleFailures The time of and reason for the transfer schedule failure.
type TransferScheduleFailures struct {
	// TransferScheduleFailureDate The transfer schedule failure date.
	TransferScheduleFailureDate time.Time `json:"transferScheduleFailureDate"`

	// TransferScheduleFailureReason The reason listed for the failure of the transfer schedule.
	TransferScheduleFailureReason string `json:"transferScheduleFailureReason"`
}

// TransferScheduleInformation Mandatory information for initiating a schedule transfer.
type TransferScheduleInformation struct {
	// ScheduleEndDate The end date of the scheduled transfer.
	ScheduleEndDate *time.Time `json:"scheduleEndDate,omitempty"`

	// ScheduleExpression The configuration of the schedule.
	ScheduleExpression *ScheduleExpression `json:"scheduleExpression,omitempty"`

	// ScheduleStartDate The start date of the scheduled transfer.
	ScheduleStartDate *time.Time `json:"scheduleStartDate,omitempty"`

	// ScheduleType The type of schedule the transfer is on. Schedules based on time patterns use EventBridge.
	ScheduleType *ScheduleTransferType `json:"scheduleType,omitempty"`
}

// TransferScheduleListing A list of transfer schedules.
type TransferScheduleListing struct {
	// NextPageToken A token that you use to retrieve the next page of results. The response includes `nextPageToken` when the number of results exceeds 100. To get the next page of results, call the operation with this token and include the same arguments as the call that produced the token. To get a complete list, call this operation until `nextPageToken` is null. Note that this operation can return empty pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TransferSchedules A list of transfer schedules.
	TransferSchedules []TransferSchedule `json:"transferSchedules"`
}

// TransferScheduleRequest Request body to initiate a scheduled transfer from a Seller Wallet bank account to another customer-defined bank account.
type TransferScheduleRequest struct {
	// DestinationAccountId The unique identifier of the destination bank account where the money is deposited.
	DestinationAccountId string `json:"destinationAccountId"`

	// DestinationTransactionInstrument Details of the destination bank account in the transaction request.
	DestinationTransactionInstrument TransactionInstrumentDetails `json:"destinationTransactionInstrument"`

	// PaymentPreference The type of payment preference in which the transfer is being scheduled.
	PaymentPreference PaymentPreference `json:"paymentPreference"`

	// SourceAccountId The unique identifier of the source Amazon Seller Wallet bank account from which money is debited.
	SourceAccountId string `json:"sourceAccountId"`

	// SourceCurrencyCode The three-letter currency code of the source payment method country, in ISO 4217 format.
	SourceCurrencyCode string `json:"sourceCurrencyCode"`

	// TransactionType The type of transaction.
	TransactionType TransactionType `json:"transactionType"`

	// TransferScheduleInformation Mandatory information for initiating a schedule transfer.
	TransferScheduleInformation TransferScheduleInformation `json:"transferScheduleInformation"`

	// TransferScheduleStatus The schedule status of the transfer.
	TransferScheduleStatus *TransferScheduleStatus `json:"transferScheduleStatus,omitempty"`
}

// TransferScheduleStatus The schedule status of the transfer.
type TransferScheduleStatus string

// ListAccountsParams defines parameters for ListAccounts.
type ListAccountsParams struct {
	// MarketplaceId The marketplace for which items are returned. The marketplace ID is the globally unique identifier of a marketplace. To find the ID for your marketplace, refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids).
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// ListAccountTransactionsParams defines parameters for ListAccountTransactions.
type ListAccountTransactionsParams struct {
	// AccountId The ID of the Amazon Seller Wallet account.
	AccountId string `form:"accountId" json:"accountId"`

	// NextPageToken A token that you use to retrieve the next page of results. The response includes `nextPageToken` when the number of results exceeds 100. To get the next page of results, call the operation with this token and include the same arguments as the call that produced the token. To get a complete list, call this operation until `nextPageToken` is null. Note that this operation can return empty pages.
	NextPageToken *string `form:"nextPageToken,omitempty" json:"nextPageToken,omitempty"`
}

// CreateTransactionParams defines parameters for CreateTransaction.
type CreateTransactionParams struct {
	// DestAccountDigitalSignature Digital signature for the destination bank account details.
	DestAccountDigitalSignature string `json:"destAccountDigitalSignature"`

	// AmountDigitalSignature Digital signature for the source currency transaction amount.
	AmountDigitalSignature string `json:"amountDigitalSignature"`
}

// GetTransferPreviewParams defines parameters for GetTransferPreview.
type GetTransferPreviewParams struct {
	// SourceCountryCode Country code of the source transaction account in ISO 3166 format.
	SourceCountryCode string `form:"sourceCountryCode" json:"sourceCountryCode"`

	// SourceCurrencyCode Currency code of the source transaction country in ISO 4217 format.
	SourceCurrencyCode string `form:"sourceCurrencyCode" json:"sourceCurrencyCode"`

	// DestinationCountryCode Country code of the destination transaction account in ISO 3166 format.
	DestinationCountryCode string `form:"destinationCountryCode" json:"destinationCountryCode"`

	// DestinationCurrencyCode Currency code of the destination transaction country in ISO 4217 format.
	DestinationCurrencyCode string `form:"destinationCurrencyCode" json:"destinationCurrencyCode"`

	// BaseAmount The base transaction amount without any markup fees.
	BaseAmount float32 `form:"baseAmount" json:"baseAmount"`
}

// ListTransferSchedulesParams defines parameters for ListTransferSchedules.
type ListTransferSchedulesParams struct {
	// AccountId The ID of the Amazon Seller Wallet account.
	AccountId string `form:"accountId" json:"accountId"`

	// NextPageToken A token that you use to retrieve the next page of results. The response includes `nextPageToken` when the number of results exceeds the specified `pageSize` value. To get the next page of results, call the operation with this token and include the same arguments as the call that produced the token. To get a complete list, call this operation until `nextPageToken` is null. Note that this operation can return empty pages.
	NextPageToken *string `form:"nextPageToken,omitempty" json:"nextPageToken,omitempty"`
}

// CreateTransferScheduleParams defines parameters for CreateTransferSchedule.
type CreateTransferScheduleParams struct {
	// DestAccountDigitalSignature Digital signature for the destination bank account details.
	DestAccountDigitalSignature string `json:"destAccountDigitalSignature"`

	// AmountDigitalSignature Digital signature for the source currency transaction amount.
	AmountDigitalSignature string `json:"amountDigitalSignature"`
}

// UpdateTransferScheduleParams defines parameters for UpdateTransferSchedule.
type UpdateTransferScheduleParams struct {
	// DestAccountDigitalSignature Digital signature for the destination bank account details.
	DestAccountDigitalSignature string `json:"destAccountDigitalSignature"`

	// AmountDigitalSignature Digital signature for the source currency transaction amount.
	AmountDigitalSignature string `json:"amountDigitalSignature"`
}

// CreateTransactionJSONRequestBody defines body for CreateTransaction for application/json ContentType.
type CreateTransactionJSONRequestBody = TransactionInitiationRequest

// CreateTransferScheduleJSONRequestBody defines body for CreateTransferSchedule for application/json ContentType.
type CreateTransferScheduleJSONRequestBody = TransferScheduleRequest

// UpdateTransferScheduleJSONRequestBody defines body for UpdateTransferSchedule for application/json ContentType.
type UpdateTransferScheduleJSONRequestBody = TransferSchedule

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAccounts request
	ListAccounts(ctx context.Context, params *ListAccountsParams) (*http.Response, error)

	// GetAccount request
	GetAccount(ctx context.Context, accountId string) (*http.Response, error)

	// ListAccountBalances request
	ListAccountBalances(ctx context.Context, accountId string) (*http.Response, error)

	// ListAccountTransactions request
	ListAccountTransactions(ctx context.Context, params *ListAccountTransactionsParams) (*http.Response, error)

	// CreateTransactionWithBody request with any body
	CreateTransactionWithBody(ctx context.Context, params *CreateTransactionParams, contentType string, body io.Reader) (*http.Response, error)

	CreateTransaction(ctx context.Context, params *CreateTransactionParams, body CreateTransactionJSONRequestBody) (*http.Response, error)

	// GetTransaction request
	GetTransaction(ctx context.Context, transactionId string) (*http.Response, error)

	// GetTransferPreview request
	GetTransferPreview(ctx context.Context, params *GetTransferPreviewParams) (*http.Response, error)

	// ListTransferSchedules request
	ListTransferSchedules(ctx context.Context, params *ListTransferSchedulesParams) (*http.Response, error)

	// CreateTransferScheduleWithBody request with any body
	CreateTransferScheduleWithBody(ctx context.Context, params *CreateTransferScheduleParams, contentType string, body io.Reader) (*http.Response, error)

	CreateTransferSchedule(ctx context.Context, params *CreateTransferScheduleParams, body CreateTransferScheduleJSONRequestBody) (*http.Response, error)

	// UpdateTransferScheduleWithBody request with any body
	UpdateTransferScheduleWithBody(ctx context.Context, params *UpdateTransferScheduleParams, contentType string, body io.Reader) (*http.Response, error)

	UpdateTransferSchedule(ctx context.Context, params *UpdateTransferScheduleParams, body UpdateTransferScheduleJSONRequestBody) (*http.Response, error)

	// DeleteScheduleTransaction request
	DeleteScheduleTransaction(ctx context.Context, transferScheduleId string) (*http.Response, error)

	// GetTransferSchedule request
	GetTransferSchedule(ctx context.Context, transferScheduleId string) (*http.Response, error)
}

func (c *Client) ListAccounts(ctx context.Context, params *ListAccountsParams) (*http.Response, error) {
	req, err := NewListAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetAccount(ctx context.Context, accountId string) (*http.Response, error) {
	req, err := NewGetAccountRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListAccountBalances(ctx context.Context, accountId string) (*http.Response, error) {
	req, err := NewListAccountBalancesRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListAccountTransactions(ctx context.Context, params *ListAccountTransactionsParams) (*http.Response, error) {
	req, err := NewListAccountTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateTransactionWithBody(ctx context.Context, params *CreateTransactionParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateTransactionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateTransaction(ctx context.Context, params *CreateTransactionParams, body CreateTransactionJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateTransactionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetTransaction(ctx context.Context, transactionId string) (*http.Response, error) {
	req, err := NewGetTransactionRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetTransferPreview(ctx context.Context, params *GetTransferPreviewParams) (*http.Response, error) {
	req, err := NewGetTransferPreviewRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListTransferSchedules(ctx context.Context, params *ListTransferSchedulesParams) (*http.Response, error) {
	req, err := NewListTransferSchedulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateTransferScheduleWithBody(ctx context.Context, params *CreateTransferScheduleParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateTransferScheduleRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateTransferSchedule(ctx context.Context, params *CreateTransferScheduleParams, body CreateTransferScheduleJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateTransferScheduleRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateTransferScheduleWithBody(ctx context.Context, params *UpdateTransferScheduleParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateTransferScheduleRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateTransferSchedule(ctx context.Context, params *UpdateTransferScheduleParams, body UpdateTransferScheduleJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateTransferScheduleRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) DeleteScheduleTransaction(ctx context.Context, transferScheduleId string) (*http.Response, error) {
	req, err := NewDeleteScheduleTransactionRequest(c.Server, transferScheduleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetTransferSchedule(ctx context.Context, transferScheduleId string) (*http.Response, error) {
	req, err := NewGetTransferScheduleRequest(c.Server, transferScheduleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewListAccountsRequest generates requests for ListAccounts
func NewListAccountsRequest(server string, params *ListAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/transfers/wallet/2024-03-01/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountRequest generates requests for GetAccount
func NewGetAccountRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/transfers/wallet/2024-03-01/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAccountBalancesRequest generates requests for ListAccountBalances
func NewListAccountBalancesRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/transfers/wallet/2024-03-01/accounts/%s/balance", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAccountTransactionsRequest generates requests for ListAccountTransactions
func NewListAccountTransactionsRequest(server string, params *ListAccountTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/transfers/wallet/2024-03-01/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.NextPageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextPageToken", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTransactionRequest calls the generic CreateTransaction builder with application/json body
func NewCreateTransactionRequest(server string, params *CreateTransactionParams, body CreateTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTransactionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateTransactionRequestWithBody generates requests for CreateTransaction with any type of body
func NewCreateTransactionRequestWithBody(server string, params *CreateTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/transfers/wallet/2024-03-01/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "destAccountDigitalSignature", runtime.ParamLocationHeader, params.DestAccountDigitalSignature)
		if err != nil {
			return nil, err
		}

		req.Header.Set("destAccountDigitalSignature", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "amountDigitalSignature", runtime.ParamLocationHeader, params.AmountDigitalSignature)
		if err != nil {
			return nil, err
		}

		req.Header.Set("amountDigitalSignature", headerParam1)

	}

	return req, nil
}

// NewGetTransactionRequest generates requests for GetTransaction
func NewGetTransactionRequest(server string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transactionId", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/transfers/wallet/2024-03-01/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransferPreviewRequest generates requests for GetTransferPreview
func NewGetTransferPreviewRequest(server string, params *GetTransferPreviewParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/transfers/wallet/2024-03-01/transferPreview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceCountryCode", runtime.ParamLocationQuery, params.SourceCountryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceCurrencyCode", runtime.ParamLocationQuery, params.SourceCurrencyCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destinationCountryCode", runtime.ParamLocationQuery, params.DestinationCountryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destinationCurrencyCode", runtime.ParamLocationQuery, params.DestinationCurrencyCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "baseAmount", runtime.ParamLocationQuery, params.BaseAmount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTransferSchedulesRequest generates requests for ListTransferSchedules
func NewListTransferSchedulesRequest(server string, params *ListTransferSchedulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/transfers/wallet/2024-03-01/transferSchedules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.NextPageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextPageToken", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTransferScheduleRequest calls the generic CreateTransferSchedule builder with application/json body
func NewCreateTransferScheduleRequest(server string, params *CreateTransferScheduleParams, body CreateTransferScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTransferScheduleRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateTransferScheduleRequestWithBody generates requests for CreateTransferSchedule with any type of body
func NewCreateTransferScheduleRequestWithBody(server string, params *CreateTransferScheduleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/transfers/wallet/2024-03-01/transferSchedules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "destAccountDigitalSignature", runtime.ParamLocationHeader, params.DestAccountDigitalSignature)
		if err != nil {
			return nil, err
		}

		req.Header.Set("destAccountDigitalSignature", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "amountDigitalSignature", runtime.ParamLocationHeader, params.AmountDigitalSignature)
		if err != nil {
			return nil, err
		}

		req.Header.Set("amountDigitalSignature", headerParam1)

	}

	return req, nil
}

// NewUpdateTransferScheduleRequest calls the generic UpdateTransferSchedule builder with application/json body
func NewUpdateTransferScheduleRequest(server string, params *UpdateTransferScheduleParams, body UpdateTransferScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTransferScheduleRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateTransferScheduleRequestWithBody generates requests for UpdateTransferSchedule with any type of body
func NewUpdateTransferScheduleRequestWithBody(server string, params *UpdateTransferScheduleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/transfers/wallet/2024-03-01/transferSchedules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "destAccountDigitalSignature", runtime.ParamLocationHeader, params.DestAccountDigitalSignature)
		if err != nil {
			return nil, err
		}

		req.Header.Set("destAccountDigitalSignature", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "amountDigitalSignature", runtime.ParamLocationHeader, params.AmountDigitalSignature)
		if err != nil {
			return nil, err
		}

		req.Header.Set("amountDigitalSignature", headerParam1)

	}

	return req, nil
}

// NewDeleteScheduleTransactionRequest generates requests for DeleteScheduleTransaction
func NewDeleteScheduleTransactionRequest(server string, transferScheduleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transferScheduleId", runtime.ParamLocationPath, transferScheduleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/transfers/wallet/2024-03-01/transferSchedules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransferScheduleRequest generates requests for GetTransferSchedule
func NewGetTransferScheduleRequest(server string, transferScheduleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transferScheduleId", runtime.ParamLocationPath, transferScheduleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/transfers/wallet/2024-03-01/transferSchedules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAccountsWithResponse request
	ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams) (*ListAccountsResp, error)

	// GetAccountWithResponse request
	GetAccountWithResponse(ctx context.Context, accountId string) (*GetAccountResp, error)

	// ListAccountBalancesWithResponse request
	ListAccountBalancesWithResponse(ctx context.Context, accountId string) (*ListAccountBalancesResp, error)

	// ListAccountTransactionsWithResponse request
	ListAccountTransactionsWithResponse(ctx context.Context, params *ListAccountTransactionsParams) (*ListAccountTransactionsResp, error)

	// CreateTransactionWithBodyWithResponse request with any body
	CreateTransactionWithBodyWithResponse(ctx context.Context, params *CreateTransactionParams, contentType string, body io.Reader) (*CreateTransactionResp, error)

	CreateTransactionWithResponse(ctx context.Context, params *CreateTransactionParams, body CreateTransactionJSONRequestBody) (*CreateTransactionResp, error)

	// GetTransactionWithResponse request
	GetTransactionWithResponse(ctx context.Context, transactionId string) (*GetTransactionResp, error)

	// GetTransferPreviewWithResponse request
	GetTransferPreviewWithResponse(ctx context.Context, params *GetTransferPreviewParams) (*GetTransferPreviewResp, error)

	// ListTransferSchedulesWithResponse request
	ListTransferSchedulesWithResponse(ctx context.Context, params *ListTransferSchedulesParams) (*ListTransferSchedulesResp, error)

	// CreateTransferScheduleWithBodyWithResponse request with any body
	CreateTransferScheduleWithBodyWithResponse(ctx context.Context, params *CreateTransferScheduleParams, contentType string, body io.Reader) (*CreateTransferScheduleResp, error)

	CreateTransferScheduleWithResponse(ctx context.Context, params *CreateTransferScheduleParams, body CreateTransferScheduleJSONRequestBody) (*CreateTransferScheduleResp, error)

	// UpdateTransferScheduleWithBodyWithResponse request with any body
	UpdateTransferScheduleWithBodyWithResponse(ctx context.Context, params *UpdateTransferScheduleParams, contentType string, body io.Reader) (*UpdateTransferScheduleResp, error)

	UpdateTransferScheduleWithResponse(ctx context.Context, params *UpdateTransferScheduleParams, body UpdateTransferScheduleJSONRequestBody) (*UpdateTransferScheduleResp, error)

	// DeleteScheduleTransactionWithResponse request
	DeleteScheduleTransactionWithResponse(ctx context.Context, transferScheduleId string) (*DeleteScheduleTransactionResp, error)

	// GetTransferScheduleWithResponse request
	GetTransferScheduleWithResponse(ctx context.Context, transferScheduleId string) (*GetTransferScheduleResp, error)
}

type ListAccountsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BankAccountListing
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON408      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListAccountsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BankAccount
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON408      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetAccountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAccountBalancesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BalanceListing
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON408      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListAccountBalancesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountBalancesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAccountTransactionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionListing
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON408      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListAccountTransactionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountTransactionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTransactionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON408      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON422      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CreateTransactionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTransactionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON408      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetTransactionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransferPreviewResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransferRatePreview
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON408      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetTransferPreviewResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransferPreviewResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransferSchedulesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransferScheduleListing
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON408      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListTransferSchedulesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransferSchedulesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTransferScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransferSchedule
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON408      *ErrorList
	JSON409      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CreateTransferScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTransferScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTransferScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransferSchedule
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON408      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateTransferScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTransferScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScheduleTransactionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteTransferSchedule
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON408      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r DeleteScheduleTransactionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScheduleTransactionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransferScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransferSchedule
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON408      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetTransferScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransferScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAccountsWithResponse request returning *ListAccountsResp
func (c *ClientWithResponses) ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams) (*ListAccountsResp, error) {
	rsp, err := c.ListAccounts(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListAccountsResp(rsp)
}

// GetAccountWithResponse request returning *GetAccountResp
func (c *ClientWithResponses) GetAccountWithResponse(ctx context.Context, accountId string) (*GetAccountResp, error) {
	rsp, err := c.GetAccount(ctx, accountId)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountResp(rsp)
}

// ListAccountBalancesWithResponse request returning *ListAccountBalancesResp
func (c *ClientWithResponses) ListAccountBalancesWithResponse(ctx context.Context, accountId string) (*ListAccountBalancesResp, error) {
	rsp, err := c.ListAccountBalances(ctx, accountId)
	if err != nil {
		return nil, err
	}
	return ParseListAccountBalancesResp(rsp)
}

// ListAccountTransactionsWithResponse request returning *ListAccountTransactionsResp
func (c *ClientWithResponses) ListAccountTransactionsWithResponse(ctx context.Context, params *ListAccountTransactionsParams) (*ListAccountTransactionsResp, error) {
	rsp, err := c.ListAccountTransactions(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListAccountTransactionsResp(rsp)
}

// CreateTransactionWithBodyWithResponse request with arbitrary body returning *CreateTransactionResp
func (c *ClientWithResponses) CreateTransactionWithBodyWithResponse(ctx context.Context, params *CreateTransactionParams, contentType string, body io.Reader) (*CreateTransactionResp, error) {
	rsp, err := c.CreateTransactionWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateTransactionResp(rsp)
}

func (c *ClientWithResponses) CreateTransactionWithResponse(ctx context.Context, params *CreateTransactionParams, body CreateTransactionJSONRequestBody) (*CreateTransactionResp, error) {
	rsp, err := c.CreateTransaction(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateTransactionResp(rsp)
}

// GetTransactionWithResponse request returning *GetTransactionResp
func (c *ClientWithResponses) GetTransactionWithResponse(ctx context.Context, transactionId string) (*GetTransactionResp, error) {
	rsp, err := c.GetTransaction(ctx, transactionId)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionResp(rsp)
}

// GetTransferPreviewWithResponse request returning *GetTransferPreviewResp
func (c *ClientWithResponses) GetTransferPreviewWithResponse(ctx context.Context, params *GetTransferPreviewParams) (*GetTransferPreviewResp, error) {
	rsp, err := c.GetTransferPreview(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetTransferPreviewResp(rsp)
}

// ListTransferSchedulesWithResponse request returning *ListTransferSchedulesResp
func (c *ClientWithResponses) ListTransferSchedulesWithResponse(ctx context.Context, params *ListTransferSchedulesParams) (*ListTransferSchedulesResp, error) {
	rsp, err := c.ListTransferSchedules(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListTransferSchedulesResp(rsp)
}

// CreateTransferScheduleWithBodyWithResponse request with arbitrary body returning *CreateTransferScheduleResp
func (c *ClientWithResponses) CreateTransferScheduleWithBodyWithResponse(ctx context.Context, params *CreateTransferScheduleParams, contentType string, body io.Reader) (*CreateTransferScheduleResp, error) {
	rsp, err := c.CreateTransferScheduleWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateTransferScheduleResp(rsp)
}

func (c *ClientWithResponses) CreateTransferScheduleWithResponse(ctx context.Context, params *CreateTransferScheduleParams, body CreateTransferScheduleJSONRequestBody) (*CreateTransferScheduleResp, error) {
	rsp, err := c.CreateTransferSchedule(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateTransferScheduleResp(rsp)
}

// UpdateTransferScheduleWithBodyWithResponse request with arbitrary body returning *UpdateTransferScheduleResp
func (c *ClientWithResponses) UpdateTransferScheduleWithBodyWithResponse(ctx context.Context, params *UpdateTransferScheduleParams, contentType string, body io.Reader) (*UpdateTransferScheduleResp, error) {
	rsp, err := c.UpdateTransferScheduleWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransferScheduleResp(rsp)
}

func (c *ClientWithResponses) UpdateTransferScheduleWithResponse(ctx context.Context, params *UpdateTransferScheduleParams, body UpdateTransferScheduleJSONRequestBody) (*UpdateTransferScheduleResp, error) {
	rsp, err := c.UpdateTransferSchedule(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransferScheduleResp(rsp)
}

// DeleteScheduleTransactionWithResponse request returning *DeleteScheduleTransactionResp
func (c *ClientWithResponses) DeleteScheduleTransactionWithResponse(ctx context.Context, transferScheduleId string) (*DeleteScheduleTransactionResp, error) {
	rsp, err := c.DeleteScheduleTransaction(ctx, transferScheduleId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScheduleTransactionResp(rsp)
}

// GetTransferScheduleWithResponse request returning *GetTransferScheduleResp
func (c *ClientWithResponses) GetTransferScheduleWithResponse(ctx context.Context, transferScheduleId string) (*GetTransferScheduleResp, error) {
	rsp, err := c.GetTransferSchedule(ctx, transferScheduleId)
	if err != nil {
		return nil, err
	}
	return ParseGetTransferScheduleResp(rsp)
}

// ParseListAccountsResp parses an HTTP response from a ListAccountsWithResponse call
func ParseListAccountsResp(rsp *http.Response) (*ListAccountsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BankAccountListing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetAccountResp parses an HTTP response from a GetAccountWithResponse call
func ParseGetAccountResp(rsp *http.Response) (*GetAccountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BankAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListAccountBalancesResp parses an HTTP response from a ListAccountBalancesWithResponse call
func ParseListAccountBalancesResp(rsp *http.Response) (*ListAccountBalancesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountBalancesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BalanceListing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListAccountTransactionsResp parses an HTTP response from a ListAccountTransactionsWithResponse call
func ParseListAccountTransactionsResp(rsp *http.Response) (*ListAccountTransactionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountTransactionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionListing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateTransactionResp parses an HTTP response from a CreateTransactionWithResponse call
func ParseCreateTransactionResp(rsp *http.Response) (*CreateTransactionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTransactionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetTransactionResp parses an HTTP response from a GetTransactionWithResponse call
func ParseGetTransactionResp(rsp *http.Response) (*GetTransactionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetTransferPreviewResp parses an HTTP response from a GetTransferPreviewWithResponse call
func ParseGetTransferPreviewResp(rsp *http.Response) (*GetTransferPreviewResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransferPreviewResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransferRatePreview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListTransferSchedulesResp parses an HTTP response from a ListTransferSchedulesWithResponse call
func ParseListTransferSchedulesResp(rsp *http.Response) (*ListTransferSchedulesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransferSchedulesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransferScheduleListing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateTransferScheduleResp parses an HTTP response from a CreateTransferScheduleWithResponse call
func ParseCreateTransferScheduleResp(rsp *http.Response) (*CreateTransferScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTransferScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransferSchedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateTransferScheduleResp parses an HTTP response from a UpdateTransferScheduleWithResponse call
func ParseUpdateTransferScheduleResp(rsp *http.Response) (*UpdateTransferScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTransferScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransferSchedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteScheduleTransactionResp parses an HTTP response from a DeleteScheduleTransactionWithResponse call
func ParseDeleteScheduleTransactionResp(rsp *http.Response) (*DeleteScheduleTransactionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScheduleTransactionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteTransferSchedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetTransferScheduleResp parses an HTTP response from a GetTransferScheduleWithResponse call
func ParseGetTransferScheduleResp(rsp *http.Response) (*GetTransferScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransferScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransferSchedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
