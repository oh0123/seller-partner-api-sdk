// Package servicesv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.4 DO NOT EDIT.
package servicesv1

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for AppointmentAppointmentStatus.
const (
	AppointmentAppointmentStatusACTIVE    AppointmentAppointmentStatus = "ACTIVE"
	AppointmentAppointmentStatusCANCELLED AppointmentAppointmentStatus = "CANCELLED"
	AppointmentAppointmentStatusCOMPLETED AppointmentAppointmentStatus = "COMPLETED"
)

// Defines values for AppointmentSlotReportSchedulingType.
const (
	NONREALTIMESCHEDULING AppointmentSlotReportSchedulingType = "NON_REAL_TIME_SCHEDULING"
	REALTIMESCHEDULING    AppointmentSlotReportSchedulingType = "REAL_TIME_SCHEDULING"
)

// Defines values for AssociatedItemItemStatus.
const (
	AssociatedItemItemStatusACTIVE    AssociatedItemItemStatus = "ACTIVE"
	AssociatedItemItemStatusCANCELLED AssociatedItemItemStatus = "CANCELLED"
	AssociatedItemItemStatusDELIVERED AssociatedItemItemStatus = "DELIVERED"
	AssociatedItemItemStatusSHIPPED   AssociatedItemItemStatus = "SHIPPED"
)

// Defines values for CapacityType.
const (
	AVAILABLECAPACITY  CapacityType = "AVAILABLE_CAPACITY"
	ENCUMBEREDCAPACITY CapacityType = "ENCUMBERED_CAPACITY"
	RESERVEDCAPACITY   CapacityType = "RESERVED_CAPACITY"
	SCHEDULEDCAPACITY  CapacityType = "SCHEDULED_CAPACITY"
)

// Defines values for DayOfWeek.
const (
	FRIDAY    DayOfWeek = "FRIDAY"
	MONDAY    DayOfWeek = "MONDAY"
	SATURDAY  DayOfWeek = "SATURDAY"
	SUNDAY    DayOfWeek = "SUNDAY"
	THURSDAY  DayOfWeek = "THURSDAY"
	TUESDAY   DayOfWeek = "TUESDAY"
	WEDNESDAY DayOfWeek = "WEDNESDAY"
)

// Defines values for EncryptionDetailsStandard.
const (
	AES EncryptionDetailsStandard = "AES"
)

// Defines values for ErrorErrorLevel.
const (
	ERROR   ErrorErrorLevel = "ERROR"
	WARNING ErrorErrorLevel = "WARNING"
)

// Defines values for PoaPoaType.
const (
	CUSTOMERSIGNATURE   PoaPoaType = "CUSTOMER_SIGNATURE"
	DUMMYRECEIPT        PoaPoaType = "DUMMY_RECEIPT"
	NOSIGNATUREDUMMYPOS PoaPoaType = "NO_SIGNATURE_DUMMY_POS"
	POARECEIPT          PoaPoaType = "POA_RECEIPT"
)

// Defines values for ReservationType.
const (
	APPOINTMENT ReservationType = "APPOINTMENT"
	BREAK       ReservationType = "BREAK"
	TRAINING    ReservationType = "TRAINING"
	TRAVEL      ReservationType = "TRAVEL"
	VACATION    ReservationType = "VACATION"
)

// Defines values for ServiceJobServiceJobStatus.
const (
	ServiceJobServiceJobStatusCANCELLED       ServiceJobServiceJobStatus = "CANCELLED"
	ServiceJobServiceJobStatusCOMPLETED       ServiceJobServiceJobStatus = "COMPLETED"
	ServiceJobServiceJobStatusHOLD            ServiceJobServiceJobStatus = "HOLD"
	ServiceJobServiceJobStatusNOTFULFILLABLE  ServiceJobServiceJobStatus = "NOT_FULFILLABLE"
	ServiceJobServiceJobStatusNOTSERVICED     ServiceJobServiceJobStatus = "NOT_SERVICED"
	ServiceJobServiceJobStatusPAYMENTDECLINED ServiceJobServiceJobStatus = "PAYMENT_DECLINED"
	ServiceJobServiceJobStatusPENDINGSCHEDULE ServiceJobServiceJobStatus = "PENDING_SCHEDULE"
)

// Defines values for ServiceLocationServiceLocationType.
const (
	INHOME  ServiceLocationServiceLocationType = "IN_HOME"
	INSTORE ServiceLocationServiceLocationType = "IN_STORE"
	ONLINE  ServiceLocationServiceLocationType = "ONLINE"
)

// Defines values for ServiceUploadDocumentContentType.
const (
	GIF  ServiceUploadDocumentContentType = "GIF"
	JPEG ServiceUploadDocumentContentType = "JPEG"
	JPG  ServiceUploadDocumentContentType = "JPG"
	PDF  ServiceUploadDocumentContentType = "PDF"
	PNG  ServiceUploadDocumentContentType = "PNG"
	TIFF ServiceUploadDocumentContentType = "TIFF"
)

// Defines values for GetServiceJobsParamsServiceJobStatus.
const (
	GetServiceJobsParamsServiceJobStatusCANCELLED       GetServiceJobsParamsServiceJobStatus = "CANCELLED"
	GetServiceJobsParamsServiceJobStatusCOMPLETED       GetServiceJobsParamsServiceJobStatus = "COMPLETED"
	GetServiceJobsParamsServiceJobStatusHOLD            GetServiceJobsParamsServiceJobStatus = "HOLD"
	GetServiceJobsParamsServiceJobStatusNOTFULFILLABLE  GetServiceJobsParamsServiceJobStatus = "NOT_FULFILLABLE"
	GetServiceJobsParamsServiceJobStatusNOTSERVICED     GetServiceJobsParamsServiceJobStatus = "NOT_SERVICED"
	GetServiceJobsParamsServiceJobStatusPAYMENTDECLINED GetServiceJobsParamsServiceJobStatus = "PAYMENT_DECLINED"
	GetServiceJobsParamsServiceJobStatusPENDINGSCHEDULE GetServiceJobsParamsServiceJobStatus = "PENDING_SCHEDULE"
)

// Defines values for GetServiceJobsParamsSortField.
const (
	JOBDATE   GetServiceJobsParamsSortField = "JOB_DATE"
	JOBSTATUS GetServiceJobsParamsSortField = "JOB_STATUS"
)

// Defines values for GetServiceJobsParamsSortOrder.
const (
	ASC  GetServiceJobsParamsSortOrder = "ASC"
	DESC GetServiceJobsParamsSortOrder = "DESC"
)

// AddAppointmentRequest Input for add appointment operation.
type AddAppointmentRequest struct {
	// AppointmentTime The input appointment time details.
	AppointmentTime AppointmentTimeInput `json:"appointmentTime"`
}

// Address The shipping address for the service job.
type Address struct {
	// AddressLine1 The first line of the address.
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Additional address information, if required.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 Additional address information, if required.
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// City The city.
	City *string `json:"city,omitempty"`

	// CountryCode The two digit country code, in ISO 3166-1 alpha-2 format.
	CountryCode *string `json:"countryCode,omitempty"`

	// County The county.
	County *string `json:"county,omitempty"`

	// District The district.
	District *string `json:"district,omitempty"`

	// Name The name of the person, business, or institution.
	Name string `json:"name"`

	// Phone The phone number.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The postal code. This can contain letters, digits, spaces, and/or punctuation.
	PostalCode *string `json:"postalCode,omitempty"`

	// StateOrRegion The state or region.
	StateOrRegion *string `json:"stateOrRegion,omitempty"`
}

// Appointment The details of an appointment.
type Appointment struct {
	// AppointmentId The appointment identifier.
	AppointmentId *AppointmentId `json:"appointmentId,omitempty"`

	// AppointmentStatus The status of the appointment.
	AppointmentStatus *AppointmentAppointmentStatus `json:"appointmentStatus,omitempty"`

	// AppointmentTime The time of the appointment window.
	AppointmentTime *AppointmentTime `json:"appointmentTime,omitempty"`

	// AssignedTechnicians A list of technicians assigned to the service job.
	AssignedTechnicians *[]Technician `json:"assignedTechnicians,omitempty"`

	// Poa Proof of Appointment (POA) details.
	Poa *Poa `json:"poa,omitempty"`

	// RescheduledAppointmentId The appointment identifier.
	RescheduledAppointmentId *AppointmentId `json:"rescheduledAppointmentId,omitempty"`
}

// AppointmentAppointmentStatus The status of the appointment.
type AppointmentAppointmentStatus string

// AppointmentId The appointment identifier.
type AppointmentId = string

// AppointmentResource The resource that performs or performed appointment fulfillment.
type AppointmentResource struct {
	// ResourceId The resource identifier.
	ResourceId *string `json:"resourceId,omitempty"`
}

// AppointmentResources List of resources that performs or performed job appointment fulfillment.
type AppointmentResources = []AppointmentResource

// AppointmentSlot A time window along with associated capacity in which the service can be performed.
type AppointmentSlot struct {
	// Capacity Number of resources for which a slot can be reserved.
	Capacity *int `json:"capacity,omitempty"`

	// EndTime Time window end time in ISO 8601 format.
	EndTime *time.Time `json:"endTime,omitempty"`

	// StartTime Time window start time in ISO 8601 format.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// AppointmentSlotReport Availability information as per the service context queried.
type AppointmentSlotReport struct {
	// AppointmentSlots A list of time windows along with associated capacity in which the service can be performed.
	AppointmentSlots *[]AppointmentSlot `json:"appointmentSlots,omitempty"`

	// EndTime End Time up to which the appointment slots are generated in ISO 8601 format.
	EndTime *time.Time `json:"endTime,omitempty"`

	// SchedulingType Defines the type of slots.
	SchedulingType *AppointmentSlotReportSchedulingType `json:"schedulingType,omitempty"`

	// StartTime Start Time from which the appointment slots are generated in ISO 8601 format.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// AppointmentSlotReportSchedulingType Defines the type of slots.
type AppointmentSlotReportSchedulingType string

// AppointmentTime The time of the appointment window.
type AppointmentTime struct {
	// DurationInMinutes The duration of the appointment window, in minutes.
	DurationInMinutes int `json:"durationInMinutes"`

	// StartTime The date and time of the start of the appointment window in ISO 8601 format.
	StartTime time.Time `json:"startTime"`
}

// AppointmentTimeInput The input appointment time details.
type AppointmentTimeInput struct {
	// DurationInMinutes The duration of an appointment in minutes.
	DurationInMinutes *int `json:"durationInMinutes,omitempty"`

	// StartTime The date, time in UTC for the start time of an appointment in ISO 8601 format.
	StartTime time.Time `json:"startTime"`
}

// AssignAppointmentResourcesRequest Request schema for the `assignAppointmentResources` operation.
type AssignAppointmentResourcesRequest struct {
	// Resources List of resources that performs or performed job appointment fulfillment.
	Resources AppointmentResources `json:"resources"`
}

// AssignAppointmentResourcesResponse Response schema for the `assignAppointmentResources` operation.
type AssignAppointmentResourcesResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The payload for the `assignAppointmentResource` operation.
	Payload *struct {
		// Warnings A list of warnings returned in the sucessful execution response of an API request.
		Warnings *WarningList `json:"warnings,omitempty"`
	} `json:"payload,omitempty"`
}

// AssociatedItem Information about an item associated with the service job.
type AssociatedItem struct {
	// Asin The Amazon Standard Identification Number (ASIN) of the item.
	Asin *string `json:"asin,omitempty"`

	// BrandName The brand name of the item.
	BrandName *string `json:"brandName,omitempty"`

	// ItemDelivery Delivery information for the item.
	ItemDelivery *ItemDelivery `json:"itemDelivery,omitempty"`

	// ItemStatus The status of the item.
	ItemStatus *AssociatedItemItemStatus `json:"itemStatus,omitempty"`

	// OrderId The Amazon-defined identifier for an order placed by the buyer, in 3-7-7 format.
	OrderId *OrderId `json:"orderId,omitempty"`

	// Quantity The total number of items included in the order.
	Quantity *int `json:"quantity,omitempty"`

	// Title The title of the item.
	Title *string `json:"title,omitempty"`
}

// AssociatedItemItemStatus The status of the item.
type AssociatedItemItemStatus string

// AvailabilityRecord `AvailabilityRecord` to represent the capacity of a resource over a time range.
type AvailabilityRecord struct {
	// Capacity Signifies the capacity of a resource which is available.
	Capacity *int `json:"capacity,omitempty"`

	// EndTime Denotes the time till when the resource is available in a day in ISO-8601 format.
	EndTime time.Time `json:"endTime"`

	// Recurrence Repeated occurrence of an event in a time range.
	Recurrence *Recurrence `json:"recurrence,omitempty"`

	// StartTime Denotes the time from when the resource is available in a day in ISO-8601 format.
	StartTime time.Time `json:"startTime"`
}

// AvailabilityRecords List of `AvailabilityRecord`s to represent the capacity of a resource over a time range.
type AvailabilityRecords = []AvailabilityRecord

// Buyer Information about the buyer.
type Buyer struct {
	// BuyerId The identifier of the buyer.
	BuyerId *string `json:"buyerId,omitempty"`

	// IsPrimeMember When true, the service is for an Amazon Prime buyer.
	IsPrimeMember *bool `json:"isPrimeMember,omitempty"`

	// Name The name of the buyer.
	Name *string `json:"name,omitempty"`

	// Phone The phone number of the buyer.
	Phone *string `json:"phone,omitempty"`
}

// CancelReservationResponse Response schema for the `cancelReservation` operation.
type CancelReservationResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// CancelServiceJobByServiceJobIdResponse Response schema for the `cancelServiceJobByServiceJobId` operation.
type CancelServiceJobByServiceJobIdResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// CapacityType Type of capacity
type CapacityType string

// CompleteServiceJobByServiceJobIdResponse Response schema for the `completeServiceJobByServiceJobId` operation.
type CompleteServiceJobByServiceJobIdResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// CreateReservationRecord `CreateReservationRecord` entity contains the `Reservation` if there is an error/warning while performing the requested operation on it, otherwise it will contain the new `reservationId`.
type CreateReservationRecord struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Reservation Reservation object reduces the capacity of a resource.
	Reservation *Reservation `json:"reservation,omitempty"`

	// Warnings A list of warnings returned in the sucessful execution response of an API request.
	Warnings *WarningList `json:"warnings,omitempty"`
}

// CreateReservationRequest Request schema for the `createReservation` operation.
type CreateReservationRequest struct {
	// Reservation Reservation object reduces the capacity of a resource.
	Reservation Reservation `json:"reservation"`

	// ResourceId Resource (store) identifier.
	ResourceId string `json:"resourceId"`
}

// CreateReservationResponse Response schema for the `createReservation` operation.
type CreateReservationResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload `CreateReservationRecord` entity contains the `Reservation` if there is an error/warning while performing the requested operation on it, otherwise it will contain the new `reservationId`.
	Payload *CreateReservationRecord `json:"payload,omitempty"`
}

// CreateServiceDocumentUploadDestination The response schema for the `createServiceDocumentUploadDestination` operation.
type CreateServiceDocumentUploadDestination struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Information about an upload destination.
	Payload *ServiceDocumentUploadDestination `json:"payload,omitempty"`
}

// DayOfWeek The day of the week.
type DayOfWeek string

// EncryptionDetails Encryption details for required client-side encryption and decryption of document contents.
type EncryptionDetails struct {
	// InitializationVector The vector to encrypt or decrypt the document contents using Cipher Block Chaining (CBC).
	InitializationVector string `json:"initializationVector"`

	// Key The encryption key used to encrypt or decrypt the document contents.
	Key string `json:"key"`

	// Standard The encryption standard required to encrypt or decrypt the document contents.
	Standard EncryptionDetailsStandard `json:"standard"`
}

// EncryptionDetailsStandard The encryption standard required to encrypt or decrypt the document contents.
type EncryptionDetailsStandard string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// ErrorLevel The type of error.
	ErrorLevel *ErrorErrorLevel `json:"errorLevel,omitempty"`

	// Message A message that describes the error condition in a human-readable form.
	Message string `json:"message"`
}

// ErrorErrorLevel The type of error.
type ErrorErrorLevel string

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// FixedSlot In this slot format each slot only has the requested capacity types. This slot size is as specified by slot duration.
type FixedSlot struct {
	// AvailableCapacity Available capacity corresponding to the slot. This capacity represents the capacity available for allocation to reservations.
	AvailableCapacity *int32 `json:"availableCapacity,omitempty"`

	// EncumberedCapacity Encumbered capacity corresponding to the slot. This capacity represents the capacity allocated for Amazon Jobs/Appointments/Orders.
	EncumberedCapacity *int32 `json:"encumberedCapacity,omitempty"`

	// ReservedCapacity Reserved capacity corresponding to the slot. This capacity represents the capacity made unavailable due to events like Breaks/Leaves/Lunch.
	ReservedCapacity *int32 `json:"reservedCapacity,omitempty"`

	// ScheduledCapacity Scheduled capacity corresponding to the slot. This capacity represents the originally allocated capacity as per resource schedule.
	ScheduledCapacity *int32 `json:"scheduledCapacity,omitempty"`

	// StartDateTime Start date time of slot in ISO 8601 format with precision of seconds.
	StartDateTime *time.Time `json:"startDateTime,omitempty"`
}

// FixedSlotCapacity Response schema for the `getFixedSlotCapacity` operation.
type FixedSlotCapacity struct {
	// Capacities Array of capacity slots in fixed slot format.
	Capacities *[]FixedSlot `json:"capacities,omitempty"`

	// NextPageToken Next page token, if there are more pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// ResourceId Resource Identifier.
	ResourceId *string `json:"resourceId,omitempty"`

	// SlotDuration The duration of each slot which is returned. This value will be a multiple of 5 and fall in the following range: 5 <= `slotDuration` <= 360.
	SlotDuration *int32 `json:"slotDuration,omitempty"`
}

// FixedSlotCapacityErrors The error response schema for the `getFixedSlotCapacity` operation.
type FixedSlotCapacityErrors struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// FixedSlotCapacityQuery Request schema for the `getFixedSlotCapacity` operation. This schema is used to define the time range, capacity types and slot duration which are being queried.
type FixedSlotCapacityQuery struct {
	// CapacityTypes An array of capacity types which are being requested. Default value is `[SCHEDULED_CAPACITY]`.
	CapacityTypes *[]CapacityType `json:"capacityTypes,omitempty"`

	// EndDateTime End date time up to which the capacity slots are being requested in ISO 8601 format.
	EndDateTime time.Time `json:"endDateTime"`

	// SlotDuration Size in which slots are being requested. This value should be a multiple of 5 and fall in the range: 5 <= `slotDuration` <= 360.
	SlotDuration *int32 `json:"slotDuration,omitempty"`

	// StartDateTime Start date time from which the capacity slots are being requested in ISO 8601 format.
	StartDateTime time.Time `json:"startDateTime"`
}

// FulfillmentDocument Document that captured during service appointment fulfillment that portrays proof of completion
type FulfillmentDocument struct {
	// ContentSha256 Sha256 hash of the file content. This value is used to determine if the file has been corrupted or tampered with during transit.
	ContentSha256 *string `json:"contentSha256,omitempty"`

	// UploadDestinationId The identifier of the upload destination. Get this value by calling the `createServiceDocumentUploadDestination` operation of the Services API.
	UploadDestinationId *string `json:"uploadDestinationId,omitempty"`
}

// FulfillmentDocuments List of documents captured during service appointment fulfillment.
type FulfillmentDocuments = []FulfillmentDocument

// FulfillmentTime Input for fulfillment time details
type FulfillmentTime struct {
	// EndTime The date, time in UTC of the fulfillment end time in ISO 8601 format.
	EndTime *time.Time `json:"endTime,omitempty"`

	// StartTime The date, time in UTC of the fulfillment start time in ISO 8601 format.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// GetAppointmentSlotsResponse The response of fetching appointment slots based on service context.
type GetAppointmentSlotsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Availability information as per the service context queried.
	Payload *AppointmentSlotReport `json:"payload,omitempty"`
}

// GetServiceJobByServiceJobIdResponse The response schema for the `getServiceJobByServiceJobId` operation.
type GetServiceJobByServiceJobIdResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The job details of a service.
	Payload *ServiceJob `json:"payload,omitempty"`
}

// GetServiceJobsResponse Response schema for the `getServiceJobs` operation.
type GetServiceJobsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The payload for the `getServiceJobs` operation.
	Payload *JobListing `json:"payload,omitempty"`
}

// ItemDelivery Delivery information for the item.
type ItemDelivery struct {
	// EstimatedDeliveryDate The date and time of the latest Estimated Delivery Date (EDD) of all the items with an EDD. In ISO 8601 format.
	EstimatedDeliveryDate *time.Time `json:"estimatedDeliveryDate,omitempty"`

	// ItemDeliveryPromise Promised delivery information for the item.
	ItemDeliveryPromise *ItemDeliveryPromise `json:"itemDeliveryPromise,omitempty"`
}

// ItemDeliveryPromise Promised delivery information for the item.
type ItemDeliveryPromise struct {
	// EndTime The date and time of the end of the promised delivery window in ISO 8601 format.
	EndTime *time.Time `json:"endTime,omitempty"`

	// StartTime The date and time of the start of the promised delivery window in ISO 8601 format.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// JobListing The payload for the `getServiceJobs` operation.
type JobListing struct {
	// Jobs List of job details for the given input.
	Jobs *[]ServiceJob `json:"jobs,omitempty"`

	// NextPageToken A generated string used to pass information to your next request. If `nextPageToken` is returned, pass the value of `nextPageToken` to the `pageToken` to get next results.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// PreviousPageToken A generated string used to pass information to your next request. If `previousPageToken` is returned, pass the value of `previousPageToken` to the `pageToken` to get previous page results.
	PreviousPageToken *string `json:"previousPageToken,omitempty"`

	// TotalResultSize Total result size of the query result.
	TotalResultSize *int `json:"totalResultSize,omitempty"`
}

// OrderId The Amazon-defined identifier for an order placed by the buyer, in 3-7-7 format.
type OrderId = string

// Poa Proof of Appointment (POA) details.
type Poa struct {
	// AppointmentTime The time of the appointment window.
	AppointmentTime *AppointmentTime `json:"appointmentTime,omitempty"`

	// PoaType The type of POA uploaded.
	PoaType *PoaPoaType `json:"poaType,omitempty"`

	// Technicians A list of technicians.
	Technicians *[]Technician `json:"technicians,omitempty"`

	// UploadTime The date and time when the POA was uploaded in ISO 8601 format.
	UploadTime *time.Time `json:"uploadTime,omitempty"`

	// UploadingTechnician The identifier of the technician who uploaded the POA.
	UploadingTechnician *string `json:"uploadingTechnician,omitempty"`
}

// PoaPoaType The type of POA uploaded.
type PoaPoaType string

// RangeCapacity Range capacity entity where each entry has a capacity type and corresponding slots.
type RangeCapacity struct {
	// CapacityType Type of capacity
	CapacityType *CapacityType `json:"capacityType,omitempty"`

	// Slots Array of capacity slots in range slot format.
	Slots *[]RangeSlot `json:"slots,omitempty"`
}

// RangeSlot Capacity slots represented in a format similar to availability rules.
type RangeSlot struct {
	// Capacity Capacity of the slot.
	Capacity *int32 `json:"capacity,omitempty"`

	// EndDateTime End date time of slot in ISO 8601 format with precision of seconds.
	EndDateTime *time.Time `json:"endDateTime,omitempty"`

	// StartDateTime Start date time of slot in ISO 8601 format with precision of seconds.
	StartDateTime *time.Time `json:"startDateTime,omitempty"`
}

// RangeSlotCapacity Response schema for the `getRangeSlotCapacity` operation.
type RangeSlotCapacity struct {
	// Capacities Array of range capacities where each entry is for a specific capacity type.
	Capacities *[]RangeCapacity `json:"capacities,omitempty"`

	// NextPageToken Next page token, if there are more pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// ResourceId Resource Identifier.
	ResourceId *string `json:"resourceId,omitempty"`
}

// RangeSlotCapacityErrors The error response schema for the `getRangeSlotCapacity` operation.
type RangeSlotCapacityErrors struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// RangeSlotCapacityQuery Request schema for the `getRangeSlotCapacity` operation. This schema is used to define the time range and capacity types that are being queried.
type RangeSlotCapacityQuery struct {
	// CapacityTypes An array of capacity types which are being requested. Default value is `[SCHEDULED_CAPACITY]`.
	CapacityTypes *[]CapacityType `json:"capacityTypes,omitempty"`

	// EndDateTime End date time up to which the capacity slots are being requested in ISO 8601 format.
	EndDateTime time.Time `json:"endDateTime"`

	// StartDateTime Start date time from which the capacity slots are being requested in ISO 8601 format.
	StartDateTime time.Time `json:"startDateTime"`
}

// Recurrence Repeated occurrence of an event in a time range.
type Recurrence struct {
	// DaysOfMonth Days of the month when recurrence is valid.
	DaysOfMonth *[]int `json:"daysOfMonth,omitempty"`

	// DaysOfWeek Days of the week when recurrence is valid. If the schedule is valid every Monday, input will only contain `MONDAY` in the list.
	DaysOfWeek *[]DayOfWeek `json:"daysOfWeek,omitempty"`

	// EndTime End time of the recurrence.
	EndTime time.Time `json:"endTime"`
}

// RescheduleAppointmentRequest Input for rescheduled appointment operation.
type RescheduleAppointmentRequest struct {
	// AppointmentTime The input appointment time details.
	AppointmentTime AppointmentTimeInput `json:"appointmentTime"`

	// RescheduleReasonCode The appointment reschedule reason code.
	RescheduleReasonCode RescheduleReasonCode `json:"rescheduleReasonCode"`
}

// RescheduleReasonCode The appointment reschedule reason code.
type RescheduleReasonCode = string

// Reservation Reservation object reduces the capacity of a resource.
type Reservation struct {
	// Availability `AvailabilityRecord` to represent the capacity of a resource over a time range.
	Availability AvailabilityRecord `json:"availability"`

	// ReservationId Unique identifier for a reservation. If present, it is treated as an update reservation request and will update the corresponding reservation. Otherwise, it is treated as a new create reservation request.
	ReservationId *string `json:"reservationId,omitempty"`

	// Type Type of reservation.
	Type ReservationType `json:"type"`
}

// ReservationType Type of reservation.
type ReservationType string

// ScopeOfWork The scope of work for the order.
type ScopeOfWork struct {
	// Asin The Amazon Standard Identification Number (ASIN) of the service job.
	Asin *string `json:"asin,omitempty"`

	// Quantity The number of service jobs.
	Quantity *int `json:"quantity,omitempty"`

	// RequiredSkills A list of skills required to perform the job.
	RequiredSkills *[]string `json:"requiredSkills,omitempty"`

	// Title The title of the service job.
	Title *string `json:"title,omitempty"`
}

// Seller Information about the seller of the service job.
type Seller struct {
	// SellerId The identifier of the seller of the service job.
	SellerId *string `json:"sellerId,omitempty"`
}

// ServiceDocumentUploadDestination Information about an upload destination.
type ServiceDocumentUploadDestination struct {
	// EncryptionDetails Encryption details for required client-side encryption and decryption of document contents.
	EncryptionDetails EncryptionDetails `json:"encryptionDetails"`

	// Headers The headers to include in the upload request.
	Headers *map[string]interface{} `json:"headers,omitempty"`

	// UploadDestinationId The unique identifier to be used by APIs that reference the upload destination.
	UploadDestinationId string `json:"uploadDestinationId"`

	// Url The URL to which to upload the file.
	Url string `json:"url"`
}

// ServiceJob The job details of a service.
type ServiceJob struct {
	// Appointments A list of appointments.
	Appointments *[]Appointment `json:"appointments,omitempty"`

	// AssociatedItems A list of items associated with the service job.
	AssociatedItems *[]AssociatedItem `json:"associatedItems,omitempty"`

	// Buyer Information about the buyer.
	Buyer *Buyer `json:"buyer,omitempty"`

	// CreateTime The date and time of the creation of the job in ISO 8601 format.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// MarketplaceId The marketplace identifier.
	MarketplaceId *string `json:"marketplaceId,omitempty"`

	// PreferredAppointmentTimes A list of appointment windows preferred by the buyer. Included only if the buyer selected appointment windows when creating the order.
	PreferredAppointmentTimes *[]AppointmentTime `json:"preferredAppointmentTimes,omitempty"`

	// ScopeOfWork The scope of work for the order.
	ScopeOfWork *ScopeOfWork `json:"scopeOfWork,omitempty"`

	// Seller Information about the seller of the service job.
	Seller *Seller `json:"seller,omitempty"`

	// ServiceJobId Amazon identifier for the service job.
	ServiceJobId *ServiceJobId `json:"serviceJobId,omitempty"`

	// ServiceJobProvider Information about the service job provider.
	ServiceJobProvider *ServiceJobProvider `json:"serviceJobProvider,omitempty"`

	// ServiceJobStatus The status of the service job.
	ServiceJobStatus *ServiceJobServiceJobStatus `json:"serviceJobStatus,omitempty"`

	// ServiceLocation Information about the location of the service job.
	ServiceLocation *ServiceLocation `json:"serviceLocation,omitempty"`

	// ServiceOrderId The Amazon-defined identifier for an order placed by the buyer, in 3-7-7 format.
	ServiceOrderId *OrderId `json:"serviceOrderId,omitempty"`

	// StoreId The Amazon-defined identifier for the region scope.
	StoreId *string `json:"storeId,omitempty"`
}

// ServiceJobServiceJobStatus The status of the service job.
type ServiceJobServiceJobStatus string

// ServiceJobId Amazon identifier for the service job.
type ServiceJobId = string

// ServiceJobProvider Information about the service job provider.
type ServiceJobProvider struct {
	// ServiceJobProviderId The identifier of the service job provider.
	ServiceJobProviderId *string `json:"serviceJobProviderId,omitempty"`
}

// ServiceLocation Information about the location of the service job.
type ServiceLocation struct {
	// Address The shipping address for the service job.
	Address *Address `json:"address,omitempty"`

	// ServiceLocationType The location of the service job.
	ServiceLocationType *ServiceLocationServiceLocationType `json:"serviceLocationType,omitempty"`
}

// ServiceLocationServiceLocationType The location of the service job.
type ServiceLocationServiceLocationType string

// ServiceUploadDocument Input for to be uploaded document.
type ServiceUploadDocument struct {
	// ContentLength The content length of the to-be-uploaded file
	ContentLength int64 `json:"contentLength"`

	// ContentMD5 An MD5 hash of the content to be submitted to the upload destination. This value is used to determine if the data has been corrupted or tampered with during transit.
	ContentMD5 *string `json:"contentMD5,omitempty"`

	// ContentType The content type of the to-be-uploaded file
	ContentType ServiceUploadDocumentContentType `json:"contentType"`
}

// ServiceUploadDocumentContentType The content type of the to-be-uploaded file
type ServiceUploadDocumentContentType string

// SetAppointmentFulfillmentDataRequest Input for set appointment fulfillment data operation.
type SetAppointmentFulfillmentDataRequest struct {
	// AppointmentResources List of resources that performs or performed job appointment fulfillment.
	AppointmentResources *AppointmentResources `json:"appointmentResources,omitempty"`

	// FulfillmentDocuments List of documents captured during service appointment fulfillment.
	FulfillmentDocuments *FulfillmentDocuments `json:"fulfillmentDocuments,omitempty"`

	// FulfillmentTime Input for fulfillment time details
	FulfillmentTime *FulfillmentTime `json:"fulfillmentTime,omitempty"`
}

// SetAppointmentResponse Response schema for the `addAppointmentForServiceJobByServiceJobId` and `rescheduleAppointmentForServiceJobByServiceJobId` operations.
type SetAppointmentResponse struct {
	// AppointmentId The appointment identifier.
	AppointmentId *AppointmentId `json:"appointmentId,omitempty"`

	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Warnings A list of warnings returned in the sucessful execution response of an API request.
	Warnings *WarningList `json:"warnings,omitempty"`
}

// Technician A technician who is assigned to perform the service job in part or in full.
type Technician struct {
	// Name The name of the technician.
	Name *string `json:"name,omitempty"`

	// TechnicianId The technician identifier.
	TechnicianId *string `json:"technicianId,omitempty"`
}

// UpdateReservationRecord `UpdateReservationRecord` entity contains the `Reservation` if there is an error/warning while performing the requested operation on it, otherwise it will contain the new `reservationId`.
type UpdateReservationRecord struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Reservation Reservation object reduces the capacity of a resource.
	Reservation *Reservation `json:"reservation,omitempty"`

	// Warnings A list of warnings returned in the sucessful execution response of an API request.
	Warnings *WarningList `json:"warnings,omitempty"`
}

// UpdateReservationRequest Request schema for the `updateReservation` operation.
type UpdateReservationRequest struct {
	// Reservation Reservation object reduces the capacity of a resource.
	Reservation Reservation `json:"reservation"`

	// ResourceId Resource (store) identifier.
	ResourceId string `json:"resourceId"`
}

// UpdateReservationResponse Response schema for the `updateReservation` operation.
type UpdateReservationResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload `UpdateReservationRecord` entity contains the `Reservation` if there is an error/warning while performing the requested operation on it, otherwise it will contain the new `reservationId`.
	Payload *UpdateReservationRecord `json:"payload,omitempty"`
}

// UpdateScheduleRecord `UpdateScheduleRecord` entity contains the `AvailabilityRecord` if there is an error/warning while performing the requested operation on it.
type UpdateScheduleRecord struct {
	// Availability `AvailabilityRecord` to represent the capacity of a resource over a time range.
	Availability *AvailabilityRecord `json:"availability,omitempty"`

	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Warnings A list of warnings returned in the sucessful execution response of an API request.
	Warnings *WarningList `json:"warnings,omitempty"`
}

// UpdateScheduleRequest Request schema for the `updateSchedule` operation.
type UpdateScheduleRequest struct {
	// Schedules List of `AvailabilityRecord`s to represent the capacity of a resource over a time range.
	Schedules AvailabilityRecords `json:"schedules"`
}

// UpdateScheduleResponse Response schema for the `updateSchedule` operation.
type UpdateScheduleResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Contains the `UpdateScheduleRecords` for which the error/warning has occurred.
	Payload *[]UpdateScheduleRecord `json:"payload,omitempty"`
}

// Warning Warning returned when the request is successful, but there are important callouts based on which API clients should take defined actions.
type Warning struct {
	// Code An warning code that identifies the type of warning that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or address the warning.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the warning condition in a human-readable form.
	Message string `json:"message"`
}

// WarningList A list of warnings returned in the sucessful execution response of an API request.
type WarningList = []Warning

// GetAppointmentSlotsParams defines parameters for GetAppointmentSlots.
type GetAppointmentSlotsParams struct {
	// Asin ASIN associated with the service.
	Asin string `form:"asin" json:"asin"`

	// StoreId Store identifier defining the region scope to retrive appointment slots.
	StoreId string `form:"storeId" json:"storeId"`

	// MarketplaceIds An identifier for the marketplace for which appointment slots are queried
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// StartTime A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.
	StartTime *string `form:"startTime,omitempty" json:"startTime,omitempty"`

	// EndTime A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.
	EndTime *string `form:"endTime,omitempty" json:"endTime,omitempty"`
}

// CreateReservationParams defines parameters for CreateReservation.
type CreateReservationParams struct {
	// MarketplaceIds An identifier for the marketplace in which the resource operates.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`
}

// CancelReservationParams defines parameters for CancelReservation.
type CancelReservationParams struct {
	// MarketplaceIds An identifier for the marketplace in which the resource operates.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`
}

// UpdateReservationParams defines parameters for UpdateReservation.
type UpdateReservationParams struct {
	// MarketplaceIds An identifier for the marketplace in which the resource operates.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`
}

// GetServiceJobsParams defines parameters for GetServiceJobs.
type GetServiceJobsParams struct {
	// ServiceOrderIds List of service order ids for the query you want to perform.Max values supported 20.
	ServiceOrderIds *[]string `form:"serviceOrderIds,omitempty" json:"serviceOrderIds,omitempty"`

	// ServiceJobStatus A list of one or more job status by which to filter the list of jobs.
	ServiceJobStatus *[]GetServiceJobsParamsServiceJobStatus `form:"serviceJobStatus,omitempty" json:"serviceJobStatus,omitempty"`

	// PageToken String returned in the response of your previous request.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// PageSize A non-negative integer that indicates the maximum number of jobs to return in the list, Value must be 1 - 20. Default 20.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// SortField Sort fields on which you want to sort the output.
	SortField *GetServiceJobsParamsSortField `form:"sortField,omitempty" json:"sortField,omitempty"`

	// SortOrder Sort order for the query you want to perform.
	SortOrder *GetServiceJobsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// CreatedAfter A date used for selecting jobs created at or after a specified time. Must be in ISO 8601 format. Required if `LastUpdatedAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.
	CreatedAfter *string `form:"createdAfter,omitempty" json:"createdAfter,omitempty"`

	// CreatedBefore A date used for selecting jobs created at or before a specified time. Must be in ISO 8601 format.
	CreatedBefore *string `form:"createdBefore,omitempty" json:"createdBefore,omitempty"`

	// LastUpdatedAfter A date used for selecting jobs updated at or after a specified time. Must be in ISO 8601 format. Required if `createdAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.
	LastUpdatedAfter *string `form:"lastUpdatedAfter,omitempty" json:"lastUpdatedAfter,omitempty"`

	// LastUpdatedBefore A date used for selecting jobs updated at or before a specified time. Must be in ISO 8601 format.
	LastUpdatedBefore *string `form:"lastUpdatedBefore,omitempty" json:"lastUpdatedBefore,omitempty"`

	// ScheduleStartDate A date used for filtering jobs schedules at or after a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.
	ScheduleStartDate *string `form:"scheduleStartDate,omitempty" json:"scheduleStartDate,omitempty"`

	// ScheduleEndDate A date used for filtering jobs schedules at or before a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.
	ScheduleEndDate *string `form:"scheduleEndDate,omitempty" json:"scheduleEndDate,omitempty"`

	// MarketplaceIds Used to select jobs that were placed in the specified marketplaces.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// Asins List of Amazon Standard Identification Numbers (ASIN) of the items. Max values supported is 20.
	Asins *[]string `form:"asins,omitempty" json:"asins,omitempty"`

	// RequiredSkills A defined set of related knowledge, skills, experience, tools, materials, and work processes common to service delivery for a set of products and/or service scenarios. Max values supported is 20.
	RequiredSkills *[]string `form:"requiredSkills,omitempty" json:"requiredSkills,omitempty"`

	// StoreIds List of Amazon-defined identifiers for the region scope. Max values supported is 50.
	StoreIds *[]string `form:"storeIds,omitempty" json:"storeIds,omitempty"`
}

// GetServiceJobsParamsServiceJobStatus defines parameters for GetServiceJobs.
type GetServiceJobsParamsServiceJobStatus string

// GetServiceJobsParamsSortField defines parameters for GetServiceJobs.
type GetServiceJobsParamsSortField string

// GetServiceJobsParamsSortOrder defines parameters for GetServiceJobs.
type GetServiceJobsParamsSortOrder string

// GetAppointmmentSlotsByJobIdParams defines parameters for GetAppointmmentSlotsByJobId.
type GetAppointmmentSlotsByJobIdParams struct {
	// MarketplaceIds An identifier for the marketplace in which the resource operates.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// StartTime A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.
	StartTime *string `form:"startTime,omitempty" json:"startTime,omitempty"`

	// EndTime A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.
	EndTime *string `form:"endTime,omitempty" json:"endTime,omitempty"`
}

// CancelServiceJobByServiceJobIdParams defines parameters for CancelServiceJobByServiceJobId.
type CancelServiceJobByServiceJobIdParams struct {
	// CancellationReasonCode A cancel reason code that specifies the reason for cancelling a service job.
	CancellationReasonCode string `form:"cancellationReasonCode" json:"cancellationReasonCode"`
}

// GetFixedSlotCapacityParams defines parameters for GetFixedSlotCapacity.
type GetFixedSlotCapacityParams struct {
	// MarketplaceIds An identifier for the marketplace in which the resource operates.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// NextPageToken Next page token returned in the response of your previous request.
	NextPageToken *string `form:"nextPageToken,omitempty" json:"nextPageToken,omitempty"`
}

// GetRangeSlotCapacityParams defines parameters for GetRangeSlotCapacity.
type GetRangeSlotCapacityParams struct {
	// MarketplaceIds An identifier for the marketplace in which the resource operates.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// NextPageToken Next page token returned in the response of your previous request.
	NextPageToken *string `form:"nextPageToken,omitempty" json:"nextPageToken,omitempty"`
}

// UpdateScheduleParams defines parameters for UpdateSchedule.
type UpdateScheduleParams struct {
	// MarketplaceIds An identifier for the marketplace in which the resource operates.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`
}

// CreateServiceDocumentUploadDestinationJSONRequestBody defines body for CreateServiceDocumentUploadDestination for application/json ContentType.
type CreateServiceDocumentUploadDestinationJSONRequestBody = ServiceUploadDocument

// CreateReservationJSONRequestBody defines body for CreateReservation for application/json ContentType.
type CreateReservationJSONRequestBody = CreateReservationRequest

// UpdateReservationJSONRequestBody defines body for UpdateReservation for application/json ContentType.
type UpdateReservationJSONRequestBody = UpdateReservationRequest

// AddAppointmentForServiceJobByServiceJobIdJSONRequestBody defines body for AddAppointmentForServiceJobByServiceJobId for application/json ContentType.
type AddAppointmentForServiceJobByServiceJobIdJSONRequestBody = AddAppointmentRequest

// RescheduleAppointmentForServiceJobByServiceJobIdJSONRequestBody defines body for RescheduleAppointmentForServiceJobByServiceJobId for application/json ContentType.
type RescheduleAppointmentForServiceJobByServiceJobIdJSONRequestBody = RescheduleAppointmentRequest

// SetAppointmentFulfillmentDataJSONRequestBody defines body for SetAppointmentFulfillmentData for application/json ContentType.
type SetAppointmentFulfillmentDataJSONRequestBody = SetAppointmentFulfillmentDataRequest

// AssignAppointmentResourcesJSONRequestBody defines body for AssignAppointmentResources for application/json ContentType.
type AssignAppointmentResourcesJSONRequestBody = AssignAppointmentResourcesRequest

// GetFixedSlotCapacityJSONRequestBody defines body for GetFixedSlotCapacity for application/json ContentType.
type GetFixedSlotCapacityJSONRequestBody = FixedSlotCapacityQuery

// GetRangeSlotCapacityJSONRequestBody defines body for GetRangeSlotCapacity for application/json ContentType.
type GetRangeSlotCapacityJSONRequestBody = RangeSlotCapacityQuery

// UpdateScheduleJSONRequestBody defines body for UpdateSchedule for application/json ContentType.
type UpdateScheduleJSONRequestBody = UpdateScheduleRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAppointmentSlots request
	GetAppointmentSlots(ctx context.Context, params *GetAppointmentSlotsParams) (*http.Response, error)

	// CreateServiceDocumentUploadDestinationWithBody request with any body
	CreateServiceDocumentUploadDestinationWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateServiceDocumentUploadDestination(ctx context.Context, body CreateServiceDocumentUploadDestinationJSONRequestBody) (*http.Response, error)

	// CreateReservationWithBody request with any body
	CreateReservationWithBody(ctx context.Context, params *CreateReservationParams, contentType string, body io.Reader) (*http.Response, error)

	CreateReservation(ctx context.Context, params *CreateReservationParams, body CreateReservationJSONRequestBody) (*http.Response, error)

	// CancelReservation request
	CancelReservation(ctx context.Context, reservationId string, params *CancelReservationParams) (*http.Response, error)

	// UpdateReservationWithBody request with any body
	UpdateReservationWithBody(ctx context.Context, reservationId string, params *UpdateReservationParams, contentType string, body io.Reader) (*http.Response, error)

	UpdateReservation(ctx context.Context, reservationId string, params *UpdateReservationParams, body UpdateReservationJSONRequestBody) (*http.Response, error)

	// GetServiceJobs request
	GetServiceJobs(ctx context.Context, params *GetServiceJobsParams) (*http.Response, error)

	// GetServiceJobByServiceJobId request
	GetServiceJobByServiceJobId(ctx context.Context, serviceJobId string) (*http.Response, error)

	// GetAppointmmentSlotsByJobId request
	GetAppointmmentSlotsByJobId(ctx context.Context, serviceJobId string, params *GetAppointmmentSlotsByJobIdParams) (*http.Response, error)

	// AddAppointmentForServiceJobByServiceJobIdWithBody request with any body
	AddAppointmentForServiceJobByServiceJobIdWithBody(ctx context.Context, serviceJobId string, contentType string, body io.Reader) (*http.Response, error)

	AddAppointmentForServiceJobByServiceJobId(ctx context.Context, serviceJobId string, body AddAppointmentForServiceJobByServiceJobIdJSONRequestBody) (*http.Response, error)

	// RescheduleAppointmentForServiceJobByServiceJobIdWithBody request with any body
	RescheduleAppointmentForServiceJobByServiceJobIdWithBody(ctx context.Context, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*http.Response, error)

	RescheduleAppointmentForServiceJobByServiceJobId(ctx context.Context, serviceJobId string, appointmentId string, body RescheduleAppointmentForServiceJobByServiceJobIdJSONRequestBody) (*http.Response, error)

	// SetAppointmentFulfillmentDataWithBody request with any body
	SetAppointmentFulfillmentDataWithBody(ctx context.Context, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*http.Response, error)

	SetAppointmentFulfillmentData(ctx context.Context, serviceJobId string, appointmentId string, body SetAppointmentFulfillmentDataJSONRequestBody) (*http.Response, error)

	// AssignAppointmentResourcesWithBody request with any body
	AssignAppointmentResourcesWithBody(ctx context.Context, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*http.Response, error)

	AssignAppointmentResources(ctx context.Context, serviceJobId string, appointmentId string, body AssignAppointmentResourcesJSONRequestBody) (*http.Response, error)

	// CancelServiceJobByServiceJobId request
	CancelServiceJobByServiceJobId(ctx context.Context, serviceJobId string, params *CancelServiceJobByServiceJobIdParams) (*http.Response, error)

	// CompleteServiceJobByServiceJobId request
	CompleteServiceJobByServiceJobId(ctx context.Context, serviceJobId string) (*http.Response, error)

	// GetFixedSlotCapacityWithBody request with any body
	GetFixedSlotCapacityWithBody(ctx context.Context, resourceId string, params *GetFixedSlotCapacityParams, contentType string, body io.Reader) (*http.Response, error)

	GetFixedSlotCapacity(ctx context.Context, resourceId string, params *GetFixedSlotCapacityParams, body GetFixedSlotCapacityJSONRequestBody) (*http.Response, error)

	// GetRangeSlotCapacityWithBody request with any body
	GetRangeSlotCapacityWithBody(ctx context.Context, resourceId string, params *GetRangeSlotCapacityParams, contentType string, body io.Reader) (*http.Response, error)

	GetRangeSlotCapacity(ctx context.Context, resourceId string, params *GetRangeSlotCapacityParams, body GetRangeSlotCapacityJSONRequestBody) (*http.Response, error)

	// UpdateScheduleWithBody request with any body
	UpdateScheduleWithBody(ctx context.Context, resourceId string, params *UpdateScheduleParams, contentType string, body io.Reader) (*http.Response, error)

	UpdateSchedule(ctx context.Context, resourceId string, params *UpdateScheduleParams, body UpdateScheduleJSONRequestBody) (*http.Response, error)
}

func (c *Client) GetAppointmentSlots(ctx context.Context, params *GetAppointmentSlotsParams) (*http.Response, error) {
	req, err := NewGetAppointmentSlotsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateServiceDocumentUploadDestinationWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateServiceDocumentUploadDestinationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateServiceDocumentUploadDestination(ctx context.Context, body CreateServiceDocumentUploadDestinationJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateServiceDocumentUploadDestinationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateReservationWithBody(ctx context.Context, params *CreateReservationParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateReservationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateReservation(ctx context.Context, params *CreateReservationParams, body CreateReservationJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateReservationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CancelReservation(ctx context.Context, reservationId string, params *CancelReservationParams) (*http.Response, error) {
	req, err := NewCancelReservationRequest(c.Server, reservationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateReservationWithBody(ctx context.Context, reservationId string, params *UpdateReservationParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateReservationRequestWithBody(c.Server, reservationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateReservation(ctx context.Context, reservationId string, params *UpdateReservationParams, body UpdateReservationJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateReservationRequest(c.Server, reservationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetServiceJobs(ctx context.Context, params *GetServiceJobsParams) (*http.Response, error) {
	req, err := NewGetServiceJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetServiceJobByServiceJobId(ctx context.Context, serviceJobId string) (*http.Response, error) {
	req, err := NewGetServiceJobByServiceJobIdRequest(c.Server, serviceJobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetAppointmmentSlotsByJobId(ctx context.Context, serviceJobId string, params *GetAppointmmentSlotsByJobIdParams) (*http.Response, error) {
	req, err := NewGetAppointmmentSlotsByJobIdRequest(c.Server, serviceJobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) AddAppointmentForServiceJobByServiceJobIdWithBody(ctx context.Context, serviceJobId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAddAppointmentForServiceJobByServiceJobIdRequestWithBody(c.Server, serviceJobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) AddAppointmentForServiceJobByServiceJobId(ctx context.Context, serviceJobId string, body AddAppointmentForServiceJobByServiceJobIdJSONRequestBody) (*http.Response, error) {
	req, err := NewAddAppointmentForServiceJobByServiceJobIdRequest(c.Server, serviceJobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) RescheduleAppointmentForServiceJobByServiceJobIdWithBody(ctx context.Context, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewRescheduleAppointmentForServiceJobByServiceJobIdRequestWithBody(c.Server, serviceJobId, appointmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) RescheduleAppointmentForServiceJobByServiceJobId(ctx context.Context, serviceJobId string, appointmentId string, body RescheduleAppointmentForServiceJobByServiceJobIdJSONRequestBody) (*http.Response, error) {
	req, err := NewRescheduleAppointmentForServiceJobByServiceJobIdRequest(c.Server, serviceJobId, appointmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SetAppointmentFulfillmentDataWithBody(ctx context.Context, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSetAppointmentFulfillmentDataRequestWithBody(c.Server, serviceJobId, appointmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SetAppointmentFulfillmentData(ctx context.Context, serviceJobId string, appointmentId string, body SetAppointmentFulfillmentDataJSONRequestBody) (*http.Response, error) {
	req, err := NewSetAppointmentFulfillmentDataRequest(c.Server, serviceJobId, appointmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) AssignAppointmentResourcesWithBody(ctx context.Context, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAssignAppointmentResourcesRequestWithBody(c.Server, serviceJobId, appointmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) AssignAppointmentResources(ctx context.Context, serviceJobId string, appointmentId string, body AssignAppointmentResourcesJSONRequestBody) (*http.Response, error) {
	req, err := NewAssignAppointmentResourcesRequest(c.Server, serviceJobId, appointmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CancelServiceJobByServiceJobId(ctx context.Context, serviceJobId string, params *CancelServiceJobByServiceJobIdParams) (*http.Response, error) {
	req, err := NewCancelServiceJobByServiceJobIdRequest(c.Server, serviceJobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CompleteServiceJobByServiceJobId(ctx context.Context, serviceJobId string) (*http.Response, error) {
	req, err := NewCompleteServiceJobByServiceJobIdRequest(c.Server, serviceJobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetFixedSlotCapacityWithBody(ctx context.Context, resourceId string, params *GetFixedSlotCapacityParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetFixedSlotCapacityRequestWithBody(c.Server, resourceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetFixedSlotCapacity(ctx context.Context, resourceId string, params *GetFixedSlotCapacityParams, body GetFixedSlotCapacityJSONRequestBody) (*http.Response, error) {
	req, err := NewGetFixedSlotCapacityRequest(c.Server, resourceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetRangeSlotCapacityWithBody(ctx context.Context, resourceId string, params *GetRangeSlotCapacityParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetRangeSlotCapacityRequestWithBody(c.Server, resourceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetRangeSlotCapacity(ctx context.Context, resourceId string, params *GetRangeSlotCapacityParams, body GetRangeSlotCapacityJSONRequestBody) (*http.Response, error) {
	req, err := NewGetRangeSlotCapacityRequest(c.Server, resourceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateScheduleWithBody(ctx context.Context, resourceId string, params *UpdateScheduleParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateScheduleRequestWithBody(c.Server, resourceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateSchedule(ctx context.Context, resourceId string, params *UpdateScheduleParams, body UpdateScheduleJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateScheduleRequest(c.Server, resourceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewGetAppointmentSlotsRequest generates requests for GetAppointmentSlots
func NewGetAppointmentSlotsRequest(server string, params *GetAppointmentSlotsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/appointmentSlots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asin", runtime.ParamLocationQuery, params.Asin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, params.StoreId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endTime", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceDocumentUploadDestinationRequest calls the generic CreateServiceDocumentUploadDestination builder with application/json body
func NewCreateServiceDocumentUploadDestinationRequest(server string, body CreateServiceDocumentUploadDestinationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceDocumentUploadDestinationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateServiceDocumentUploadDestinationRequestWithBody generates requests for CreateServiceDocumentUploadDestination with any type of body
func NewCreateServiceDocumentUploadDestinationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/documents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateReservationRequest calls the generic CreateReservation builder with application/json body
func NewCreateReservationRequest(server string, params *CreateReservationParams, body CreateReservationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReservationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateReservationRequestWithBody generates requests for CreateReservation with any type of body
func NewCreateReservationRequestWithBody(server string, params *CreateReservationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/reservation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelReservationRequest generates requests for CancelReservation
func NewCancelReservationRequest(server string, reservationId string, params *CancelReservationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservationId", runtime.ParamLocationPath, reservationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateReservationRequest calls the generic UpdateReservation builder with application/json body
func NewUpdateReservationRequest(server string, reservationId string, params *UpdateReservationParams, body UpdateReservationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateReservationRequestWithBody(server, reservationId, params, "application/json", bodyReader)
}

// NewUpdateReservationRequestWithBody generates requests for UpdateReservation with any type of body
func NewUpdateReservationRequestWithBody(server string, reservationId string, params *UpdateReservationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservationId", runtime.ParamLocationPath, reservationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServiceJobsRequest generates requests for GetServiceJobs
func NewGetServiceJobsRequest(server string, params *GetServiceJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/serviceJobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceOrderIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceOrderIds", runtime.ParamLocationQuery, *params.ServiceOrderIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ServiceJobStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceJobStatus", runtime.ParamLocationQuery, *params.ServiceJobStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortField", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBefore", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastUpdatedAfter", runtime.ParamLocationQuery, *params.LastUpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastUpdatedBefore", runtime.ParamLocationQuery, *params.LastUpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ScheduleStartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduleStartDate", runtime.ParamLocationQuery, *params.ScheduleStartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ScheduleEndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduleEndDate", runtime.ParamLocationQuery, *params.ScheduleEndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.Asins != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asins", runtime.ParamLocationQuery, *params.Asins); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.RequiredSkills != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requiredSkills", runtime.ParamLocationQuery, *params.RequiredSkills); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.StoreIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeIds", runtime.ParamLocationQuery, *params.StoreIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceJobByServiceJobIdRequest generates requests for GetServiceJobByServiceJobId
func NewGetServiceJobByServiceJobIdRequest(server string, serviceJobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceJobId", runtime.ParamLocationPath, serviceJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/serviceJobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppointmmentSlotsByJobIdRequest generates requests for GetAppointmmentSlotsByJobId
func NewGetAppointmmentSlotsByJobIdRequest(server string, serviceJobId string, params *GetAppointmmentSlotsByJobIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceJobId", runtime.ParamLocationPath, serviceJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/serviceJobs/%s/appointmentSlots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endTime", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddAppointmentForServiceJobByServiceJobIdRequest calls the generic AddAppointmentForServiceJobByServiceJobId builder with application/json body
func NewAddAppointmentForServiceJobByServiceJobIdRequest(server string, serviceJobId string, body AddAppointmentForServiceJobByServiceJobIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAppointmentForServiceJobByServiceJobIdRequestWithBody(server, serviceJobId, "application/json", bodyReader)
}

// NewAddAppointmentForServiceJobByServiceJobIdRequestWithBody generates requests for AddAppointmentForServiceJobByServiceJobId with any type of body
func NewAddAppointmentForServiceJobByServiceJobIdRequestWithBody(server string, serviceJobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceJobId", runtime.ParamLocationPath, serviceJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/serviceJobs/%s/appointments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRescheduleAppointmentForServiceJobByServiceJobIdRequest calls the generic RescheduleAppointmentForServiceJobByServiceJobId builder with application/json body
func NewRescheduleAppointmentForServiceJobByServiceJobIdRequest(server string, serviceJobId string, appointmentId string, body RescheduleAppointmentForServiceJobByServiceJobIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRescheduleAppointmentForServiceJobByServiceJobIdRequestWithBody(server, serviceJobId, appointmentId, "application/json", bodyReader)
}

// NewRescheduleAppointmentForServiceJobByServiceJobIdRequestWithBody generates requests for RescheduleAppointmentForServiceJobByServiceJobId with any type of body
func NewRescheduleAppointmentForServiceJobByServiceJobIdRequestWithBody(server string, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceJobId", runtime.ParamLocationPath, serviceJobId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "appointmentId", runtime.ParamLocationPath, appointmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/serviceJobs/%s/appointments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetAppointmentFulfillmentDataRequest calls the generic SetAppointmentFulfillmentData builder with application/json body
func NewSetAppointmentFulfillmentDataRequest(server string, serviceJobId string, appointmentId string, body SetAppointmentFulfillmentDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAppointmentFulfillmentDataRequestWithBody(server, serviceJobId, appointmentId, "application/json", bodyReader)
}

// NewSetAppointmentFulfillmentDataRequestWithBody generates requests for SetAppointmentFulfillmentData with any type of body
func NewSetAppointmentFulfillmentDataRequestWithBody(server string, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceJobId", runtime.ParamLocationPath, serviceJobId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "appointmentId", runtime.ParamLocationPath, appointmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/serviceJobs/%s/appointments/%s/fulfillment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssignAppointmentResourcesRequest calls the generic AssignAppointmentResources builder with application/json body
func NewAssignAppointmentResourcesRequest(server string, serviceJobId string, appointmentId string, body AssignAppointmentResourcesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignAppointmentResourcesRequestWithBody(server, serviceJobId, appointmentId, "application/json", bodyReader)
}

// NewAssignAppointmentResourcesRequestWithBody generates requests for AssignAppointmentResources with any type of body
func NewAssignAppointmentResourcesRequestWithBody(server string, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceJobId", runtime.ParamLocationPath, serviceJobId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "appointmentId", runtime.ParamLocationPath, appointmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/serviceJobs/%s/appointments/%s/resources", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelServiceJobByServiceJobIdRequest generates requests for CancelServiceJobByServiceJobId
func NewCancelServiceJobByServiceJobIdRequest(server string, serviceJobId string, params *CancelServiceJobByServiceJobIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceJobId", runtime.ParamLocationPath, serviceJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/serviceJobs/%s/cancellations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cancellationReasonCode", runtime.ParamLocationQuery, params.CancellationReasonCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompleteServiceJobByServiceJobIdRequest generates requests for CompleteServiceJobByServiceJobId
func NewCompleteServiceJobByServiceJobIdRequest(server string, serviceJobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceJobId", runtime.ParamLocationPath, serviceJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/serviceJobs/%s/completions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFixedSlotCapacityRequest calls the generic GetFixedSlotCapacity builder with application/json body
func NewGetFixedSlotCapacityRequest(server string, resourceId string, params *GetFixedSlotCapacityParams, body GetFixedSlotCapacityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetFixedSlotCapacityRequestWithBody(server, resourceId, params, "application/json", bodyReader)
}

// NewGetFixedSlotCapacityRequestWithBody generates requests for GetFixedSlotCapacity with any type of body
func NewGetFixedSlotCapacityRequestWithBody(server string, resourceId string, params *GetFixedSlotCapacityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/serviceResources/%s/capacity/fixed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.NextPageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextPageToken", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRangeSlotCapacityRequest calls the generic GetRangeSlotCapacity builder with application/json body
func NewGetRangeSlotCapacityRequest(server string, resourceId string, params *GetRangeSlotCapacityParams, body GetRangeSlotCapacityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetRangeSlotCapacityRequestWithBody(server, resourceId, params, "application/json", bodyReader)
}

// NewGetRangeSlotCapacityRequestWithBody generates requests for GetRangeSlotCapacity with any type of body
func NewGetRangeSlotCapacityRequestWithBody(server string, resourceId string, params *GetRangeSlotCapacityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/serviceResources/%s/capacity/range", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.NextPageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextPageToken", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateScheduleRequest calls the generic UpdateSchedule builder with application/json body
func NewUpdateScheduleRequest(server string, resourceId string, params *UpdateScheduleParams, body UpdateScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateScheduleRequestWithBody(server, resourceId, params, "application/json", bodyReader)
}

// NewUpdateScheduleRequestWithBody generates requests for UpdateSchedule with any type of body
func NewUpdateScheduleRequestWithBody(server string, resourceId string, params *UpdateScheduleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/v1/serviceResources/%s/schedules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAppointmentSlotsWithResponse request
	GetAppointmentSlotsWithResponse(ctx context.Context, params *GetAppointmentSlotsParams) (*GetAppointmentSlotsResp, error)

	// CreateServiceDocumentUploadDestinationWithBodyWithResponse request with any body
	CreateServiceDocumentUploadDestinationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateServiceDocumentUploadDestinationResp, error)

	CreateServiceDocumentUploadDestinationWithResponse(ctx context.Context, body CreateServiceDocumentUploadDestinationJSONRequestBody) (*CreateServiceDocumentUploadDestinationResp, error)

	// CreateReservationWithBodyWithResponse request with any body
	CreateReservationWithBodyWithResponse(ctx context.Context, params *CreateReservationParams, contentType string, body io.Reader) (*CreateReservationResp, error)

	CreateReservationWithResponse(ctx context.Context, params *CreateReservationParams, body CreateReservationJSONRequestBody) (*CreateReservationResp, error)

	// CancelReservationWithResponse request
	CancelReservationWithResponse(ctx context.Context, reservationId string, params *CancelReservationParams) (*CancelReservationResp, error)

	// UpdateReservationWithBodyWithResponse request with any body
	UpdateReservationWithBodyWithResponse(ctx context.Context, reservationId string, params *UpdateReservationParams, contentType string, body io.Reader) (*UpdateReservationResp, error)

	UpdateReservationWithResponse(ctx context.Context, reservationId string, params *UpdateReservationParams, body UpdateReservationJSONRequestBody) (*UpdateReservationResp, error)

	// GetServiceJobsWithResponse request
	GetServiceJobsWithResponse(ctx context.Context, params *GetServiceJobsParams) (*GetServiceJobsResp, error)

	// GetServiceJobByServiceJobIdWithResponse request
	GetServiceJobByServiceJobIdWithResponse(ctx context.Context, serviceJobId string) (*GetServiceJobByServiceJobIdResp, error)

	// GetAppointmmentSlotsByJobIdWithResponse request
	GetAppointmmentSlotsByJobIdWithResponse(ctx context.Context, serviceJobId string, params *GetAppointmmentSlotsByJobIdParams) (*GetAppointmmentSlotsByJobIdResp, error)

	// AddAppointmentForServiceJobByServiceJobIdWithBodyWithResponse request with any body
	AddAppointmentForServiceJobByServiceJobIdWithBodyWithResponse(ctx context.Context, serviceJobId string, contentType string, body io.Reader) (*AddAppointmentForServiceJobByServiceJobIdResp, error)

	AddAppointmentForServiceJobByServiceJobIdWithResponse(ctx context.Context, serviceJobId string, body AddAppointmentForServiceJobByServiceJobIdJSONRequestBody) (*AddAppointmentForServiceJobByServiceJobIdResp, error)

	// RescheduleAppointmentForServiceJobByServiceJobIdWithBodyWithResponse request with any body
	RescheduleAppointmentForServiceJobByServiceJobIdWithBodyWithResponse(ctx context.Context, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*RescheduleAppointmentForServiceJobByServiceJobIdResp, error)

	RescheduleAppointmentForServiceJobByServiceJobIdWithResponse(ctx context.Context, serviceJobId string, appointmentId string, body RescheduleAppointmentForServiceJobByServiceJobIdJSONRequestBody) (*RescheduleAppointmentForServiceJobByServiceJobIdResp, error)

	// SetAppointmentFulfillmentDataWithBodyWithResponse request with any body
	SetAppointmentFulfillmentDataWithBodyWithResponse(ctx context.Context, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*SetAppointmentFulfillmentDataResp, error)

	SetAppointmentFulfillmentDataWithResponse(ctx context.Context, serviceJobId string, appointmentId string, body SetAppointmentFulfillmentDataJSONRequestBody) (*SetAppointmentFulfillmentDataResp, error)

	// AssignAppointmentResourcesWithBodyWithResponse request with any body
	AssignAppointmentResourcesWithBodyWithResponse(ctx context.Context, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*AssignAppointmentResourcesResp, error)

	AssignAppointmentResourcesWithResponse(ctx context.Context, serviceJobId string, appointmentId string, body AssignAppointmentResourcesJSONRequestBody) (*AssignAppointmentResourcesResp, error)

	// CancelServiceJobByServiceJobIdWithResponse request
	CancelServiceJobByServiceJobIdWithResponse(ctx context.Context, serviceJobId string, params *CancelServiceJobByServiceJobIdParams) (*CancelServiceJobByServiceJobIdResp, error)

	// CompleteServiceJobByServiceJobIdWithResponse request
	CompleteServiceJobByServiceJobIdWithResponse(ctx context.Context, serviceJobId string) (*CompleteServiceJobByServiceJobIdResp, error)

	// GetFixedSlotCapacityWithBodyWithResponse request with any body
	GetFixedSlotCapacityWithBodyWithResponse(ctx context.Context, resourceId string, params *GetFixedSlotCapacityParams, contentType string, body io.Reader) (*GetFixedSlotCapacityResp, error)

	GetFixedSlotCapacityWithResponse(ctx context.Context, resourceId string, params *GetFixedSlotCapacityParams, body GetFixedSlotCapacityJSONRequestBody) (*GetFixedSlotCapacityResp, error)

	// GetRangeSlotCapacityWithBodyWithResponse request with any body
	GetRangeSlotCapacityWithBodyWithResponse(ctx context.Context, resourceId string, params *GetRangeSlotCapacityParams, contentType string, body io.Reader) (*GetRangeSlotCapacityResp, error)

	GetRangeSlotCapacityWithResponse(ctx context.Context, resourceId string, params *GetRangeSlotCapacityParams, body GetRangeSlotCapacityJSONRequestBody) (*GetRangeSlotCapacityResp, error)

	// UpdateScheduleWithBodyWithResponse request with any body
	UpdateScheduleWithBodyWithResponse(ctx context.Context, resourceId string, params *UpdateScheduleParams, contentType string, body io.Reader) (*UpdateScheduleResp, error)

	UpdateScheduleWithResponse(ctx context.Context, resourceId string, params *UpdateScheduleParams, body UpdateScheduleJSONRequestBody) (*UpdateScheduleResp, error)
}

type GetAppointmentSlotsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAppointmentSlotsResponse
	JSON400      *GetAppointmentSlotsResponse
	JSON403      *GetAppointmentSlotsResponse
	JSON404      *GetAppointmentSlotsResponse
	JSON415      *GetAppointmentSlotsResponse
	JSON422      *GetAppointmentSlotsResponse
	JSON429      *GetAppointmentSlotsResponse
	JSON500      *GetAppointmentSlotsResponse
	JSON503      *GetAppointmentSlotsResponse
}

// Status returns HTTPResponse.Status
func (r GetAppointmentSlotsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppointmentSlotsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceDocumentUploadDestinationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateServiceDocumentUploadDestination
	JSON400      *CreateServiceDocumentUploadDestination
	JSON403      *CreateServiceDocumentUploadDestination
	JSON404      *CreateServiceDocumentUploadDestination
	JSON413      *CreateServiceDocumentUploadDestination
	JSON415      *CreateServiceDocumentUploadDestination
	JSON422      *CreateServiceDocumentUploadDestination
	JSON429      *CreateServiceDocumentUploadDestination
	JSON500      *CreateServiceDocumentUploadDestination
	JSON503      *CreateServiceDocumentUploadDestination
}

// Status returns HTTPResponse.Status
func (r CreateServiceDocumentUploadDestinationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceDocumentUploadDestinationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReservationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateReservationResponse
	JSON400      *CreateReservationResponse
	JSON403      *CreateReservationResponse
	JSON404      *CreateReservationResponse
	JSON413      *CreateReservationResponse
	JSON415      *CreateReservationResponse
	JSON429      *CreateReservationResponse
	JSON500      *CreateReservationResponse
	JSON503      *CreateReservationResponse
}

// Status returns HTTPResponse.Status
func (r CreateReservationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReservationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelReservationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *CancelReservationResponse
	JSON400      *CancelReservationResponse
	JSON403      *CancelReservationResponse
	JSON404      *CancelReservationResponse
	JSON413      *CancelReservationResponse
	JSON415      *CancelReservationResponse
	JSON429      *CancelReservationResponse
	JSON500      *CancelReservationResponse
	JSON503      *CancelReservationResponse
}

// Status returns HTTPResponse.Status
func (r CancelReservationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelReservationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateReservationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateReservationResponse
	JSON400      *UpdateReservationResponse
	JSON403      *UpdateReservationResponse
	JSON404      *UpdateReservationResponse
	JSON413      *UpdateReservationResponse
	JSON415      *UpdateReservationResponse
	JSON429      *UpdateReservationResponse
	JSON500      *UpdateReservationResponse
	JSON503      *UpdateReservationResponse
}

// Status returns HTTPResponse.Status
func (r UpdateReservationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateReservationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceJobsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetServiceJobsResponse
	JSON400      *GetServiceJobsResponse
	JSON403      *GetServiceJobsResponse
	JSON404      *GetServiceJobsResponse
	JSON413      *GetServiceJobsResponse
	JSON415      *GetServiceJobsResponse
	JSON429      *GetServiceJobsResponse
	JSON500      *GetServiceJobsResponse
	JSON503      *GetServiceJobsResponse
}

// Status returns HTTPResponse.Status
func (r GetServiceJobsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceJobsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceJobByServiceJobIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetServiceJobByServiceJobIdResponse
	JSON400      *GetServiceJobByServiceJobIdResponse
	JSON403      *GetServiceJobByServiceJobIdResponse
	JSON404      *GetServiceJobByServiceJobIdResponse
	JSON413      *GetServiceJobByServiceJobIdResponse
	JSON415      *GetServiceJobByServiceJobIdResponse
	JSON422      *GetServiceJobByServiceJobIdResponse
	JSON429      *GetServiceJobByServiceJobIdResponse
	JSON500      *GetServiceJobByServiceJobIdResponse
	JSON503      *GetServiceJobByServiceJobIdResponse
}

// Status returns HTTPResponse.Status
func (r GetServiceJobByServiceJobIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceJobByServiceJobIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppointmmentSlotsByJobIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAppointmentSlotsResponse
	JSON400      *GetAppointmentSlotsResponse
	JSON403      *GetAppointmentSlotsResponse
	JSON404      *GetAppointmentSlotsResponse
	JSON415      *GetAppointmentSlotsResponse
	JSON422      *GetAppointmentSlotsResponse
	JSON429      *GetAppointmentSlotsResponse
	JSON500      *GetAppointmentSlotsResponse
	JSON503      *GetAppointmentSlotsResponse
}

// Status returns HTTPResponse.Status
func (r GetAppointmmentSlotsByJobIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppointmmentSlotsByJobIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAppointmentForServiceJobByServiceJobIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SetAppointmentResponse
	JSON400      *SetAppointmentResponse
	JSON403      *SetAppointmentResponse
	JSON404      *SetAppointmentResponse
	JSON413      *SetAppointmentResponse
	JSON415      *SetAppointmentResponse
	JSON422      *SetAppointmentResponse
	JSON429      *SetAppointmentResponse
	JSON500      *SetAppointmentResponse
	JSON503      *SetAppointmentResponse
}

// Status returns HTTPResponse.Status
func (r AddAppointmentForServiceJobByServiceJobIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAppointmentForServiceJobByServiceJobIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RescheduleAppointmentForServiceJobByServiceJobIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SetAppointmentResponse
	JSON400      *SetAppointmentResponse
	JSON403      *SetAppointmentResponse
	JSON404      *SetAppointmentResponse
	JSON413      *SetAppointmentResponse
	JSON415      *SetAppointmentResponse
	JSON422      *SetAppointmentResponse
	JSON429      *SetAppointmentResponse
	JSON500      *SetAppointmentResponse
	JSON503      *SetAppointmentResponse
}

// Status returns HTTPResponse.Status
func (r RescheduleAppointmentForServiceJobByServiceJobIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RescheduleAppointmentForServiceJobByServiceJobIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAppointmentFulfillmentDataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *string
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON422      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r SetAppointmentFulfillmentDataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAppointmentFulfillmentDataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignAppointmentResourcesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssignAppointmentResourcesResponse
	JSON400      *AssignAppointmentResourcesResponse
	JSON403      *AssignAppointmentResourcesResponse
	JSON404      *AssignAppointmentResourcesResponse
	JSON413      *AssignAppointmentResourcesResponse
	JSON415      *AssignAppointmentResourcesResponse
	JSON422      *AssignAppointmentResourcesResponse
	JSON429      *AssignAppointmentResourcesResponse
	JSON500      *AssignAppointmentResourcesResponse
	JSON503      *AssignAppointmentResourcesResponse
}

// Status returns HTTPResponse.Status
func (r AssignAppointmentResourcesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignAppointmentResourcesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelServiceJobByServiceJobIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelServiceJobByServiceJobIdResponse
	JSON400      *CancelServiceJobByServiceJobIdResponse
	JSON403      *CancelServiceJobByServiceJobIdResponse
	JSON404      *CancelServiceJobByServiceJobIdResponse
	JSON413      *CancelServiceJobByServiceJobIdResponse
	JSON415      *CancelServiceJobByServiceJobIdResponse
	JSON422      *CancelServiceJobByServiceJobIdResponse
	JSON429      *CancelServiceJobByServiceJobIdResponse
	JSON500      *CancelServiceJobByServiceJobIdResponse
	JSON503      *CancelServiceJobByServiceJobIdResponse
}

// Status returns HTTPResponse.Status
func (r CancelServiceJobByServiceJobIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelServiceJobByServiceJobIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteServiceJobByServiceJobIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompleteServiceJobByServiceJobIdResponse
	JSON400      *CompleteServiceJobByServiceJobIdResponse
	JSON403      *CompleteServiceJobByServiceJobIdResponse
	JSON404      *CompleteServiceJobByServiceJobIdResponse
	JSON413      *CompleteServiceJobByServiceJobIdResponse
	JSON415      *CompleteServiceJobByServiceJobIdResponse
	JSON422      *CompleteServiceJobByServiceJobIdResponse
	JSON429      *CompleteServiceJobByServiceJobIdResponse
	JSON500      *CompleteServiceJobByServiceJobIdResponse
	JSON503      *CompleteServiceJobByServiceJobIdResponse
}

// Status returns HTTPResponse.Status
func (r CompleteServiceJobByServiceJobIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteServiceJobByServiceJobIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFixedSlotCapacityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FixedSlotCapacity
	JSON400      *FixedSlotCapacityErrors
	JSON401      *FixedSlotCapacityErrors
	JSON403      *FixedSlotCapacityErrors
	JSON404      *FixedSlotCapacityErrors
	JSON413      *FixedSlotCapacityErrors
	JSON415      *FixedSlotCapacityErrors
	JSON429      *FixedSlotCapacityErrors
	JSON500      *FixedSlotCapacityErrors
	JSON503      *FixedSlotCapacityErrors
}

// Status returns HTTPResponse.Status
func (r GetFixedSlotCapacityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFixedSlotCapacityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRangeSlotCapacityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RangeSlotCapacity
	JSON400      *RangeSlotCapacityErrors
	JSON401      *RangeSlotCapacityErrors
	JSON403      *RangeSlotCapacityErrors
	JSON404      *RangeSlotCapacityErrors
	JSON413      *RangeSlotCapacityErrors
	JSON415      *RangeSlotCapacityErrors
	JSON429      *RangeSlotCapacityErrors
	JSON500      *RangeSlotCapacityErrors
	JSON503      *RangeSlotCapacityErrors
}

// Status returns HTTPResponse.Status
func (r GetRangeSlotCapacityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRangeSlotCapacityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateScheduleResponse
	JSON400      *UpdateScheduleResponse
	JSON403      *UpdateScheduleResponse
	JSON404      *UpdateScheduleResponse
	JSON413      *UpdateScheduleResponse
	JSON415      *UpdateScheduleResponse
	JSON429      *UpdateScheduleResponse
	JSON500      *UpdateScheduleResponse
	JSON503      *UpdateScheduleResponse
}

// Status returns HTTPResponse.Status
func (r UpdateScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAppointmentSlotsWithResponse request returning *GetAppointmentSlotsResp
func (c *ClientWithResponses) GetAppointmentSlotsWithResponse(ctx context.Context, params *GetAppointmentSlotsParams) (*GetAppointmentSlotsResp, error) {
	rsp, err := c.GetAppointmentSlots(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetAppointmentSlotsResp(rsp)
}

// CreateServiceDocumentUploadDestinationWithBodyWithResponse request with arbitrary body returning *CreateServiceDocumentUploadDestinationResp
func (c *ClientWithResponses) CreateServiceDocumentUploadDestinationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateServiceDocumentUploadDestinationResp, error) {
	rsp, err := c.CreateServiceDocumentUploadDestinationWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceDocumentUploadDestinationResp(rsp)
}

func (c *ClientWithResponses) CreateServiceDocumentUploadDestinationWithResponse(ctx context.Context, body CreateServiceDocumentUploadDestinationJSONRequestBody) (*CreateServiceDocumentUploadDestinationResp, error) {
	rsp, err := c.CreateServiceDocumentUploadDestination(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceDocumentUploadDestinationResp(rsp)
}

// CreateReservationWithBodyWithResponse request with arbitrary body returning *CreateReservationResp
func (c *ClientWithResponses) CreateReservationWithBodyWithResponse(ctx context.Context, params *CreateReservationParams, contentType string, body io.Reader) (*CreateReservationResp, error) {
	rsp, err := c.CreateReservationWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateReservationResp(rsp)
}

func (c *ClientWithResponses) CreateReservationWithResponse(ctx context.Context, params *CreateReservationParams, body CreateReservationJSONRequestBody) (*CreateReservationResp, error) {
	rsp, err := c.CreateReservation(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateReservationResp(rsp)
}

// CancelReservationWithResponse request returning *CancelReservationResp
func (c *ClientWithResponses) CancelReservationWithResponse(ctx context.Context, reservationId string, params *CancelReservationParams) (*CancelReservationResp, error) {
	rsp, err := c.CancelReservation(ctx, reservationId, params)
	if err != nil {
		return nil, err
	}
	return ParseCancelReservationResp(rsp)
}

// UpdateReservationWithBodyWithResponse request with arbitrary body returning *UpdateReservationResp
func (c *ClientWithResponses) UpdateReservationWithBodyWithResponse(ctx context.Context, reservationId string, params *UpdateReservationParams, contentType string, body io.Reader) (*UpdateReservationResp, error) {
	rsp, err := c.UpdateReservationWithBody(ctx, reservationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReservationResp(rsp)
}

func (c *ClientWithResponses) UpdateReservationWithResponse(ctx context.Context, reservationId string, params *UpdateReservationParams, body UpdateReservationJSONRequestBody) (*UpdateReservationResp, error) {
	rsp, err := c.UpdateReservation(ctx, reservationId, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReservationResp(rsp)
}

// GetServiceJobsWithResponse request returning *GetServiceJobsResp
func (c *ClientWithResponses) GetServiceJobsWithResponse(ctx context.Context, params *GetServiceJobsParams) (*GetServiceJobsResp, error) {
	rsp, err := c.GetServiceJobs(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceJobsResp(rsp)
}

// GetServiceJobByServiceJobIdWithResponse request returning *GetServiceJobByServiceJobIdResp
func (c *ClientWithResponses) GetServiceJobByServiceJobIdWithResponse(ctx context.Context, serviceJobId string) (*GetServiceJobByServiceJobIdResp, error) {
	rsp, err := c.GetServiceJobByServiceJobId(ctx, serviceJobId)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceJobByServiceJobIdResp(rsp)
}

// GetAppointmmentSlotsByJobIdWithResponse request returning *GetAppointmmentSlotsByJobIdResp
func (c *ClientWithResponses) GetAppointmmentSlotsByJobIdWithResponse(ctx context.Context, serviceJobId string, params *GetAppointmmentSlotsByJobIdParams) (*GetAppointmmentSlotsByJobIdResp, error) {
	rsp, err := c.GetAppointmmentSlotsByJobId(ctx, serviceJobId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetAppointmmentSlotsByJobIdResp(rsp)
}

// AddAppointmentForServiceJobByServiceJobIdWithBodyWithResponse request with arbitrary body returning *AddAppointmentForServiceJobByServiceJobIdResp
func (c *ClientWithResponses) AddAppointmentForServiceJobByServiceJobIdWithBodyWithResponse(ctx context.Context, serviceJobId string, contentType string, body io.Reader) (*AddAppointmentForServiceJobByServiceJobIdResp, error) {
	rsp, err := c.AddAppointmentForServiceJobByServiceJobIdWithBody(ctx, serviceJobId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAddAppointmentForServiceJobByServiceJobIdResp(rsp)
}

func (c *ClientWithResponses) AddAppointmentForServiceJobByServiceJobIdWithResponse(ctx context.Context, serviceJobId string, body AddAppointmentForServiceJobByServiceJobIdJSONRequestBody) (*AddAppointmentForServiceJobByServiceJobIdResp, error) {
	rsp, err := c.AddAppointmentForServiceJobByServiceJobId(ctx, serviceJobId, body)
	if err != nil {
		return nil, err
	}
	return ParseAddAppointmentForServiceJobByServiceJobIdResp(rsp)
}

// RescheduleAppointmentForServiceJobByServiceJobIdWithBodyWithResponse request with arbitrary body returning *RescheduleAppointmentForServiceJobByServiceJobIdResp
func (c *ClientWithResponses) RescheduleAppointmentForServiceJobByServiceJobIdWithBodyWithResponse(ctx context.Context, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*RescheduleAppointmentForServiceJobByServiceJobIdResp, error) {
	rsp, err := c.RescheduleAppointmentForServiceJobByServiceJobIdWithBody(ctx, serviceJobId, appointmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseRescheduleAppointmentForServiceJobByServiceJobIdResp(rsp)
}

func (c *ClientWithResponses) RescheduleAppointmentForServiceJobByServiceJobIdWithResponse(ctx context.Context, serviceJobId string, appointmentId string, body RescheduleAppointmentForServiceJobByServiceJobIdJSONRequestBody) (*RescheduleAppointmentForServiceJobByServiceJobIdResp, error) {
	rsp, err := c.RescheduleAppointmentForServiceJobByServiceJobId(ctx, serviceJobId, appointmentId, body)
	if err != nil {
		return nil, err
	}
	return ParseRescheduleAppointmentForServiceJobByServiceJobIdResp(rsp)
}

// SetAppointmentFulfillmentDataWithBodyWithResponse request with arbitrary body returning *SetAppointmentFulfillmentDataResp
func (c *ClientWithResponses) SetAppointmentFulfillmentDataWithBodyWithResponse(ctx context.Context, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*SetAppointmentFulfillmentDataResp, error) {
	rsp, err := c.SetAppointmentFulfillmentDataWithBody(ctx, serviceJobId, appointmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSetAppointmentFulfillmentDataResp(rsp)
}

func (c *ClientWithResponses) SetAppointmentFulfillmentDataWithResponse(ctx context.Context, serviceJobId string, appointmentId string, body SetAppointmentFulfillmentDataJSONRequestBody) (*SetAppointmentFulfillmentDataResp, error) {
	rsp, err := c.SetAppointmentFulfillmentData(ctx, serviceJobId, appointmentId, body)
	if err != nil {
		return nil, err
	}
	return ParseSetAppointmentFulfillmentDataResp(rsp)
}

// AssignAppointmentResourcesWithBodyWithResponse request with arbitrary body returning *AssignAppointmentResourcesResp
func (c *ClientWithResponses) AssignAppointmentResourcesWithBodyWithResponse(ctx context.Context, serviceJobId string, appointmentId string, contentType string, body io.Reader) (*AssignAppointmentResourcesResp, error) {
	rsp, err := c.AssignAppointmentResourcesWithBody(ctx, serviceJobId, appointmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAssignAppointmentResourcesResp(rsp)
}

func (c *ClientWithResponses) AssignAppointmentResourcesWithResponse(ctx context.Context, serviceJobId string, appointmentId string, body AssignAppointmentResourcesJSONRequestBody) (*AssignAppointmentResourcesResp, error) {
	rsp, err := c.AssignAppointmentResources(ctx, serviceJobId, appointmentId, body)
	if err != nil {
		return nil, err
	}
	return ParseAssignAppointmentResourcesResp(rsp)
}

// CancelServiceJobByServiceJobIdWithResponse request returning *CancelServiceJobByServiceJobIdResp
func (c *ClientWithResponses) CancelServiceJobByServiceJobIdWithResponse(ctx context.Context, serviceJobId string, params *CancelServiceJobByServiceJobIdParams) (*CancelServiceJobByServiceJobIdResp, error) {
	rsp, err := c.CancelServiceJobByServiceJobId(ctx, serviceJobId, params)
	if err != nil {
		return nil, err
	}
	return ParseCancelServiceJobByServiceJobIdResp(rsp)
}

// CompleteServiceJobByServiceJobIdWithResponse request returning *CompleteServiceJobByServiceJobIdResp
func (c *ClientWithResponses) CompleteServiceJobByServiceJobIdWithResponse(ctx context.Context, serviceJobId string) (*CompleteServiceJobByServiceJobIdResp, error) {
	rsp, err := c.CompleteServiceJobByServiceJobId(ctx, serviceJobId)
	if err != nil {
		return nil, err
	}
	return ParseCompleteServiceJobByServiceJobIdResp(rsp)
}

// GetFixedSlotCapacityWithBodyWithResponse request with arbitrary body returning *GetFixedSlotCapacityResp
func (c *ClientWithResponses) GetFixedSlotCapacityWithBodyWithResponse(ctx context.Context, resourceId string, params *GetFixedSlotCapacityParams, contentType string, body io.Reader) (*GetFixedSlotCapacityResp, error) {
	rsp, err := c.GetFixedSlotCapacityWithBody(ctx, resourceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetFixedSlotCapacityResp(rsp)
}

func (c *ClientWithResponses) GetFixedSlotCapacityWithResponse(ctx context.Context, resourceId string, params *GetFixedSlotCapacityParams, body GetFixedSlotCapacityJSONRequestBody) (*GetFixedSlotCapacityResp, error) {
	rsp, err := c.GetFixedSlotCapacity(ctx, resourceId, params, body)
	if err != nil {
		return nil, err
	}
	return ParseGetFixedSlotCapacityResp(rsp)
}

// GetRangeSlotCapacityWithBodyWithResponse request with arbitrary body returning *GetRangeSlotCapacityResp
func (c *ClientWithResponses) GetRangeSlotCapacityWithBodyWithResponse(ctx context.Context, resourceId string, params *GetRangeSlotCapacityParams, contentType string, body io.Reader) (*GetRangeSlotCapacityResp, error) {
	rsp, err := c.GetRangeSlotCapacityWithBody(ctx, resourceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetRangeSlotCapacityResp(rsp)
}

func (c *ClientWithResponses) GetRangeSlotCapacityWithResponse(ctx context.Context, resourceId string, params *GetRangeSlotCapacityParams, body GetRangeSlotCapacityJSONRequestBody) (*GetRangeSlotCapacityResp, error) {
	rsp, err := c.GetRangeSlotCapacity(ctx, resourceId, params, body)
	if err != nil {
		return nil, err
	}
	return ParseGetRangeSlotCapacityResp(rsp)
}

// UpdateScheduleWithBodyWithResponse request with arbitrary body returning *UpdateScheduleResp
func (c *ClientWithResponses) UpdateScheduleWithBodyWithResponse(ctx context.Context, resourceId string, params *UpdateScheduleParams, contentType string, body io.Reader) (*UpdateScheduleResp, error) {
	rsp, err := c.UpdateScheduleWithBody(ctx, resourceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduleResp(rsp)
}

func (c *ClientWithResponses) UpdateScheduleWithResponse(ctx context.Context, resourceId string, params *UpdateScheduleParams, body UpdateScheduleJSONRequestBody) (*UpdateScheduleResp, error) {
	rsp, err := c.UpdateSchedule(ctx, resourceId, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduleResp(rsp)
}

// ParseGetAppointmentSlotsResp parses an HTTP response from a GetAppointmentSlotsWithResponse call
func ParseGetAppointmentSlotsResp(rsp *http.Response) (*GetAppointmentSlotsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppointmentSlotsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateServiceDocumentUploadDestinationResp parses an HTTP response from a CreateServiceDocumentUploadDestinationWithResponse call
func ParseCreateServiceDocumentUploadDestinationResp(rsp *http.Response) (*CreateServiceDocumentUploadDestinationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceDocumentUploadDestinationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateServiceDocumentUploadDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreateServiceDocumentUploadDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreateServiceDocumentUploadDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreateServiceDocumentUploadDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest CreateServiceDocumentUploadDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest CreateServiceDocumentUploadDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest CreateServiceDocumentUploadDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest CreateServiceDocumentUploadDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CreateServiceDocumentUploadDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest CreateServiceDocumentUploadDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateReservationResp parses an HTTP response from a CreateReservationWithResponse call
func ParseCreateReservationResp(rsp *http.Response) (*CreateReservationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReservationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest CreateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest CreateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest CreateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CreateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest CreateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCancelReservationResp parses an HTTP response from a CancelReservationWithResponse call
func ParseCancelReservationResp(rsp *http.Response) (*CancelReservationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelReservationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest CancelReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CancelReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CancelReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CancelReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest CancelReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest CancelReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest CancelReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CancelReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest CancelReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateReservationResp parses an HTTP response from a UpdateReservationWithResponse call
func ParseUpdateReservationResp(rsp *http.Response) (*UpdateReservationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateReservationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest UpdateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest UpdateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UpdateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest UpdateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest UpdateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest UpdateReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetServiceJobsResp parses an HTTP response from a GetServiceJobsWithResponse call
func ParseGetServiceJobsResp(rsp *http.Response) (*GetServiceJobsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceJobsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceJobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetServiceJobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetServiceJobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetServiceJobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest GetServiceJobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest GetServiceJobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetServiceJobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetServiceJobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetServiceJobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetServiceJobByServiceJobIdResp parses an HTTP response from a GetServiceJobByServiceJobIdWithResponse call
func ParseGetServiceJobByServiceJobIdResp(rsp *http.Response) (*GetServiceJobByServiceJobIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceJobByServiceJobIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest GetServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest GetServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest GetServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetAppointmmentSlotsByJobIdResp parses an HTTP response from a GetAppointmmentSlotsByJobIdWithResponse call
func ParseGetAppointmmentSlotsByJobIdResp(rsp *http.Response) (*GetAppointmmentSlotsByJobIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppointmmentSlotsByJobIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAddAppointmentForServiceJobByServiceJobIdResp parses an HTTP response from a AddAppointmentForServiceJobByServiceJobIdWithResponse call
func ParseAddAppointmentForServiceJobByServiceJobIdResp(rsp *http.Response) (*AddAppointmentForServiceJobByServiceJobIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAppointmentForServiceJobByServiceJobIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRescheduleAppointmentForServiceJobByServiceJobIdResp parses an HTTP response from a RescheduleAppointmentForServiceJobByServiceJobIdWithResponse call
func ParseRescheduleAppointmentForServiceJobByServiceJobIdResp(rsp *http.Response) (*RescheduleAppointmentForServiceJobByServiceJobIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RescheduleAppointmentForServiceJobByServiceJobIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest SetAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSetAppointmentFulfillmentDataResp parses an HTTP response from a SetAppointmentFulfillmentDataWithResponse call
func ParseSetAppointmentFulfillmentDataResp(rsp *http.Response) (*SetAppointmentFulfillmentDataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAppointmentFulfillmentDataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAssignAppointmentResourcesResp parses an HTTP response from a AssignAppointmentResourcesWithResponse call
func ParseAssignAppointmentResourcesResp(rsp *http.Response) (*AssignAppointmentResourcesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignAppointmentResourcesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssignAppointmentResourcesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest AssignAppointmentResourcesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AssignAppointmentResourcesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AssignAppointmentResourcesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest AssignAppointmentResourcesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest AssignAppointmentResourcesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest AssignAppointmentResourcesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest AssignAppointmentResourcesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest AssignAppointmentResourcesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest AssignAppointmentResourcesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCancelServiceJobByServiceJobIdResp parses an HTTP response from a CancelServiceJobByServiceJobIdWithResponse call
func ParseCancelServiceJobByServiceJobIdResp(rsp *http.Response) (*CancelServiceJobByServiceJobIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelServiceJobByServiceJobIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CancelServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CancelServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CancelServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest CancelServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest CancelServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest CancelServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest CancelServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CancelServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest CancelServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCompleteServiceJobByServiceJobIdResp parses an HTTP response from a CompleteServiceJobByServiceJobIdWithResponse call
func ParseCompleteServiceJobByServiceJobIdResp(rsp *http.Response) (*CompleteServiceJobByServiceJobIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteServiceJobByServiceJobIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompleteServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CompleteServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CompleteServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CompleteServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest CompleteServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest CompleteServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest CompleteServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest CompleteServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CompleteServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest CompleteServiceJobByServiceJobIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetFixedSlotCapacityResp parses an HTTP response from a GetFixedSlotCapacityWithResponse call
func ParseGetFixedSlotCapacityResp(rsp *http.Response) (*GetFixedSlotCapacityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFixedSlotCapacityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FixedSlotCapacity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest FixedSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest FixedSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest FixedSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest FixedSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest FixedSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest FixedSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest FixedSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest FixedSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest FixedSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetRangeSlotCapacityResp parses an HTTP response from a GetRangeSlotCapacityWithResponse call
func ParseGetRangeSlotCapacityResp(rsp *http.Response) (*GetRangeSlotCapacityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRangeSlotCapacityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RangeSlotCapacity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RangeSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RangeSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RangeSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RangeSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest RangeSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest RangeSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RangeSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest RangeSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest RangeSlotCapacityErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateScheduleResp parses an HTTP response from a UpdateScheduleWithResponse call
func ParseUpdateScheduleResp(rsp *http.Response) (*UpdateScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdateScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdateScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest UpdateScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest UpdateScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UpdateScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest UpdateScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest UpdateScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest UpdateScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
