// Package catalogitemsv20220401 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package catalogitemsv20220401

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ItemImageVariant.
const (
	MAIN ItemImageVariant = "MAIN"
	PT01 ItemImageVariant = "PT01"
	PT02 ItemImageVariant = "PT02"
	PT03 ItemImageVariant = "PT03"
	PT04 ItemImageVariant = "PT04"
	PT05 ItemImageVariant = "PT05"
	PT06 ItemImageVariant = "PT06"
	PT07 ItemImageVariant = "PT07"
	PT08 ItemImageVariant = "PT08"
	SWCH ItemImageVariant = "SWCH"
)

// Defines values for ItemRelationshipType.
const (
	PACKAGEHIERARCHY ItemRelationshipType = "PACKAGE_HIERARCHY"
	VARIATION        ItemRelationshipType = "VARIATION"
)

// Defines values for ItemSummaryByMarketplaceItemClassification.
const (
	BASEPRODUCT     ItemSummaryByMarketplaceItemClassification = "BASE_PRODUCT"
	OTHER           ItemSummaryByMarketplaceItemClassification = "OTHER"
	PRODUCTBUNDLE   ItemSummaryByMarketplaceItemClassification = "PRODUCT_BUNDLE"
	VARIATIONPARENT ItemSummaryByMarketplaceItemClassification = "VARIATION_PARENT"
)

// Defines values for ItemVendorDetailsByMarketplaceReplenishmentCategory.
const (
	ALLOCATED              ItemVendorDetailsByMarketplaceReplenishmentCategory = "ALLOCATED"
	BASICREPLENISHMENT     ItemVendorDetailsByMarketplaceReplenishmentCategory = "BASIC_REPLENISHMENT"
	INSEASON               ItemVendorDetailsByMarketplaceReplenishmentCategory = "IN_SEASON"
	LIMITEDREPLENISHMENT   ItemVendorDetailsByMarketplaceReplenishmentCategory = "LIMITED_REPLENISHMENT"
	MANUFACTUREROUTOFSTOCK ItemVendorDetailsByMarketplaceReplenishmentCategory = "MANUFACTURER_OUT_OF_STOCK"
	NEWPRODUCT             ItemVendorDetailsByMarketplaceReplenishmentCategory = "NEW_PRODUCT"
	NONREPLENISHABLE       ItemVendorDetailsByMarketplaceReplenishmentCategory = "NON_REPLENISHABLE"
	NONSTOCKUPABLE         ItemVendorDetailsByMarketplaceReplenishmentCategory = "NON_STOCKUPABLE"
	OBSOLETE               ItemVendorDetailsByMarketplaceReplenishmentCategory = "OBSOLETE"
	PLANNEDREPLENISHMENT   ItemVendorDetailsByMarketplaceReplenishmentCategory = "PLANNED_REPLENISHMENT"
)

// Defines values for SearchCatalogItemsParamsIdentifiersType.
const (
	ASIN   SearchCatalogItemsParamsIdentifiersType = "ASIN"
	EAN    SearchCatalogItemsParamsIdentifiersType = "EAN"
	GTIN   SearchCatalogItemsParamsIdentifiersType = "GTIN"
	ISBN   SearchCatalogItemsParamsIdentifiersType = "ISBN"
	JAN    SearchCatalogItemsParamsIdentifiersType = "JAN"
	MINSAN SearchCatalogItemsParamsIdentifiersType = "MINSAN"
	SKU    SearchCatalogItemsParamsIdentifiersType = "SKU"
	UPC    SearchCatalogItemsParamsIdentifiersType = "UPC"
)

// Defines values for SearchCatalogItemsParamsIncludedData.
const (
	SearchCatalogItemsParamsIncludedDataAttributes    SearchCatalogItemsParamsIncludedData = "attributes"
	SearchCatalogItemsParamsIncludedDataDimensions    SearchCatalogItemsParamsIncludedData = "dimensions"
	SearchCatalogItemsParamsIncludedDataIdentifiers   SearchCatalogItemsParamsIncludedData = "identifiers"
	SearchCatalogItemsParamsIncludedDataImages        SearchCatalogItemsParamsIncludedData = "images"
	SearchCatalogItemsParamsIncludedDataProductTypes  SearchCatalogItemsParamsIncludedData = "productTypes"
	SearchCatalogItemsParamsIncludedDataRelationships SearchCatalogItemsParamsIncludedData = "relationships"
	SearchCatalogItemsParamsIncludedDataSalesRanks    SearchCatalogItemsParamsIncludedData = "salesRanks"
	SearchCatalogItemsParamsIncludedDataSummaries     SearchCatalogItemsParamsIncludedData = "summaries"
	SearchCatalogItemsParamsIncludedDataVendorDetails SearchCatalogItemsParamsIncludedData = "vendorDetails"
)

// Defines values for GetCatalogItemParamsIncludedData.
const (
	GetCatalogItemParamsIncludedDataAttributes    GetCatalogItemParamsIncludedData = "attributes"
	GetCatalogItemParamsIncludedDataDimensions    GetCatalogItemParamsIncludedData = "dimensions"
	GetCatalogItemParamsIncludedDataIdentifiers   GetCatalogItemParamsIncludedData = "identifiers"
	GetCatalogItemParamsIncludedDataImages        GetCatalogItemParamsIncludedData = "images"
	GetCatalogItemParamsIncludedDataProductTypes  GetCatalogItemParamsIncludedData = "productTypes"
	GetCatalogItemParamsIncludedDataRelationships GetCatalogItemParamsIncludedData = "relationships"
	GetCatalogItemParamsIncludedDataSalesRanks    GetCatalogItemParamsIncludedData = "salesRanks"
	GetCatalogItemParamsIncludedDataSummaries     GetCatalogItemParamsIncludedData = "summaries"
	GetCatalogItemParamsIncludedDataVendorDetails GetCatalogItemParamsIncludedData = "vendorDetails"
)

// BrandRefinement Description of a brand that can be used to get more fine-grained search results.
type BrandRefinement struct {
	// BrandName Brand name. For display and can be used as a search refinement.
	BrandName string `json:"brandName"`

	// NumberOfResults The estimated number of results that would still be returned if refinement key applied.
	NumberOfResults int `json:"numberOfResults"`
}

// ClassificationRefinement Description of a classification that can be used to get more fine-grained search results.
type ClassificationRefinement struct {
	// ClassificationId Identifier for the classification that can be used for search refinement purposes.
	ClassificationId string `json:"classificationId"`

	// DisplayName Display name for the classification.
	DisplayName string `json:"displayName"`

	// NumberOfResults The estimated number of results that would still be returned if refinement key applied.
	NumberOfResults int `json:"numberOfResults"`
}

// Dimension Individual dimension value of an Amazon catalog item or item package.
type Dimension struct {
	// Unit Measurement unit of the dimension value.
	Unit *string `json:"unit,omitempty"`

	// Value Numeric dimension value.
	Value *float32 `json:"value,omitempty"`
}

// Dimensions Dimensions of an Amazon catalog item or item in its packaging.
type Dimensions struct {
	// Height Individual dimension value of an Amazon catalog item or item package.
	Height *Dimension `json:"height,omitempty"`

	// Length Individual dimension value of an Amazon catalog item or item package.
	Length *Dimension `json:"length,omitempty"`

	// Weight Individual dimension value of an Amazon catalog item or item package.
	Weight *Dimension `json:"weight,omitempty"`

	// Width Individual dimension value of an Amazon catalog item or item package.
	Width *Dimension `json:"width,omitempty"`
}

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	Errors []Error `json:"errors"`
}

// Item An item in the Amazon catalog.
type Item struct {
	// Asin Amazon Standard Identification Number (ASIN) is the unique identifier for an item in the Amazon catalog.
	Asin ItemAsin `json:"asin"`

	// Attributes A JSON object that contains structured item attribute data keyed by attribute name. Catalog item attributes conform to the related product type definitions available in the Selling Partner API for Product Type Definitions.
	Attributes *ItemAttributes `json:"attributes,omitempty"`

	// Dimensions Array of dimensions associated with the item in the Amazon catalog by Amazon marketplace.
	Dimensions *ItemDimensions `json:"dimensions,omitempty"`

	// Identifiers Identifiers associated with the item in the Amazon catalog, such as UPC and EAN identifiers.
	Identifiers *ItemIdentifiers `json:"identifiers,omitempty"`

	// Images Images for an item in the Amazon catalog.
	Images *ItemImages `json:"images,omitempty"`

	// ProductTypes Product types associated with the Amazon catalog item.
	ProductTypes *ItemProductTypes `json:"productTypes,omitempty"`

	// Relationships Relationships by marketplace for an Amazon catalog item (for example, variations).
	Relationships *ItemRelationships `json:"relationships,omitempty"`

	// SalesRanks Sales ranks of an Amazon catalog item.
	SalesRanks *ItemSalesRanks `json:"salesRanks,omitempty"`

	// Summaries Summary details of an Amazon catalog item.
	Summaries *ItemSummaries `json:"summaries,omitempty"`

	// VendorDetails Vendor details associated with an Amazon catalog item. Vendor details are available to vendors only.
	VendorDetails *ItemVendorDetails `json:"vendorDetails,omitempty"`
}

// ItemAsin Amazon Standard Identification Number (ASIN) is the unique identifier for an item in the Amazon catalog.
type ItemAsin = string

// ItemAttributes A JSON object that contains structured item attribute data keyed by attribute name. Catalog item attributes conform to the related product type definitions available in the Selling Partner API for Product Type Definitions.
type ItemAttributes map[string]interface{}

// ItemBrowseClassification Classification (browse node) associated with an Amazon catalog item.
type ItemBrowseClassification struct {
	// ClassificationId Identifier of the classification (browse node identifier).
	ClassificationId string `json:"classificationId"`

	// DisplayName Display name for the classification.
	DisplayName string `json:"displayName"`
}

// ItemClassificationSalesRank Sales rank of an Amazon catalog item by classification.
type ItemClassificationSalesRank struct {
	// ClassificationId Identifier of the classification associated with the sales rank.
	ClassificationId string `json:"classificationId"`

	// Link Corresponding Amazon retail website link, or URL, for the sales rank.
	Link *string `json:"link,omitempty"`

	// Rank Sales rank value.
	Rank int `json:"rank"`

	// Title Title, or name, of the sales rank.
	Title string `json:"title"`
}

// ItemContributor Individual contributor to the creation of an item, such as an author or actor.
type ItemContributor struct {
	// Role Role of an individual contributor in the creation of an item, such as author or actor.
	Role ItemContributorRole `json:"role"`

	// Value Name of the contributor, such as Jane Austen.
	Value string `json:"value"`
}

// ItemContributorRole Role of an individual contributor in the creation of an item, such as author or actor.
type ItemContributorRole struct {
	// DisplayName Display name of the role in the requested locale, such as Author or Actor.
	DisplayName *string `json:"displayName,omitempty"`

	// Value Role value for the Amazon catalog item, such as author or actor.
	Value string `json:"value"`
}

// ItemDimensions Array of dimensions associated with the item in the Amazon catalog by Amazon marketplace.
type ItemDimensions = []ItemDimensionsByMarketplace

// ItemDimensionsByMarketplace Dimensions associated with the item in the Amazon catalog for the indicated Amazon marketplace.
type ItemDimensionsByMarketplace struct {
	// Item Dimensions of an Amazon catalog item or item in its packaging.
	Item *Dimensions `json:"item,omitempty"`

	// MarketplaceId Amazon marketplace identifier.
	MarketplaceId string `json:"marketplaceId"`

	// Package Dimensions of an Amazon catalog item or item in its packaging.
	Package *Dimensions `json:"package,omitempty"`
}

// ItemDisplayGroupSalesRank Sales rank of an Amazon catalog item by website display group.
type ItemDisplayGroupSalesRank struct {
	// Link Corresponding Amazon retail website link, or URL, for the sales rank.
	Link *string `json:"link,omitempty"`

	// Rank Sales rank value.
	Rank int `json:"rank"`

	// Title Title, or name, of the sales rank.
	Title string `json:"title"`

	// WebsiteDisplayGroup Name of the website display group associated with the sales rank
	WebsiteDisplayGroup string `json:"websiteDisplayGroup"`
}

// ItemIdentifier Identifier associated with the item in the Amazon catalog, such as a UPC or EAN identifier.
type ItemIdentifier struct {
	// Identifier Identifier.
	Identifier string `json:"identifier"`

	// IdentifierType Type of identifier, such as UPC, EAN, or ISBN.
	IdentifierType string `json:"identifierType"`
}

// ItemIdentifiers Identifiers associated with the item in the Amazon catalog, such as UPC and EAN identifiers.
type ItemIdentifiers = []ItemIdentifiersByMarketplace

// ItemIdentifiersByMarketplace Identifiers associated with the item in the Amazon catalog for the indicated Amazon marketplace.
type ItemIdentifiersByMarketplace struct {
	// Identifiers Identifiers associated with the item in the Amazon catalog for the indicated Amazon marketplace.
	Identifiers []ItemIdentifier `json:"identifiers"`

	// MarketplaceId Amazon marketplace identifier.
	MarketplaceId string `json:"marketplaceId"`
}

// ItemImage Image for an item in the Amazon catalog.
type ItemImage struct {
	// Height Height of the image in pixels.
	Height int `json:"height"`

	// Link Link, or URL, for the image.
	Link string `json:"link"`

	// Variant Variant of the image, such as `MAIN` or `PT01`.
	Variant ItemImageVariant `json:"variant"`

	// Width Width of the image in pixels.
	Width int `json:"width"`
}

// ItemImageVariant Variant of the image, such as `MAIN` or `PT01`.
type ItemImageVariant string

// ItemImages Images for an item in the Amazon catalog.
type ItemImages = []ItemImagesByMarketplace

// ItemImagesByMarketplace Images for an item in the Amazon catalog for the indicated Amazon marketplace.
type ItemImagesByMarketplace struct {
	// Images Images for an item in the Amazon catalog for the indicated Amazon marketplace.
	Images []ItemImage `json:"images"`

	// MarketplaceId Amazon marketplace identifier.
	MarketplaceId string `json:"marketplaceId"`
}

// ItemProductTypeByMarketplace Product type associated with the Amazon catalog item for the indicated Amazon marketplace.
type ItemProductTypeByMarketplace struct {
	// MarketplaceId Amazon marketplace identifier.
	MarketplaceId *string `json:"marketplaceId,omitempty"`

	// ProductType Name of the product type associated with the Amazon catalog item.
	ProductType *string `json:"productType,omitempty"`
}

// ItemProductTypes Product types associated with the Amazon catalog item.
type ItemProductTypes = []ItemProductTypeByMarketplace

// ItemRelationship Relationship details for an Amazon catalog item.
type ItemRelationship struct {
	// ChildAsins Identifiers (ASINs) of the related items that are children of this item.
	ChildAsins *[]string `json:"childAsins,omitempty"`

	// ParentAsins Identifiers (ASINs) of the related items that are parents of this item.
	ParentAsins *[]string `json:"parentAsins,omitempty"`

	// Type Type of relationship.
	Type ItemRelationshipType `json:"type"`

	// VariationTheme Variation theme indicating the combination of Amazon item catalog attributes that define the variation family.
	VariationTheme *ItemVariationTheme `json:"variationTheme,omitempty"`
}

// ItemRelationshipType Type of relationship.
type ItemRelationshipType string

// ItemRelationships Relationships by marketplace for an Amazon catalog item (for example, variations).
type ItemRelationships = []ItemRelationshipsByMarketplace

// ItemRelationshipsByMarketplace Relationship details for the Amazon catalog item for the indicated Amazon marketplace.
type ItemRelationshipsByMarketplace struct {
	// MarketplaceId Amazon marketplace identifier.
	MarketplaceId string `json:"marketplaceId"`

	// Relationships Relationships for the item.
	Relationships []ItemRelationship `json:"relationships"`
}

// ItemSalesRanks Sales ranks of an Amazon catalog item.
type ItemSalesRanks = []ItemSalesRanksByMarketplace

// ItemSalesRanksByMarketplace Sales ranks of an Amazon catalog item for the indicated Amazon marketplace.
type ItemSalesRanksByMarketplace struct {
	// ClassificationRanks Sales ranks of an Amazon catalog item for an Amazon marketplace by classification.
	ClassificationRanks *[]ItemClassificationSalesRank `json:"classificationRanks,omitempty"`

	// DisplayGroupRanks Sales ranks of an Amazon catalog item for an Amazon marketplace by website display group.
	DisplayGroupRanks *[]ItemDisplayGroupSalesRank `json:"displayGroupRanks,omitempty"`

	// MarketplaceId Amazon marketplace identifier.
	MarketplaceId string `json:"marketplaceId"`
}

// ItemSearchResults Items in the Amazon catalog and search related metadata.
type ItemSearchResults struct {
	// Items A list of items from the Amazon catalog.
	Items []Item `json:"items"`

	// NumberOfResults For `identifiers`-based searches, the total number of Amazon catalog items found. For `keywords`-based searches, the estimated total number of Amazon catalog items matched by the search query (only results up to the page count limit will be returned per request regardless of the number found).
	//
	// Note: The maximum number of items (ASINs) that can be returned and paged through is 1000.
	NumberOfResults int `json:"numberOfResults"`

	// Pagination When a request produces a response that exceeds the `pageSize`, pagination occurs. This means the response is divided into individual pages. To retrieve the next page or the previous page, you must pass the `nextToken` value or the `previousToken` value as the `pageToken` parameter in the next request. When you receive the last page, there will be no `nextToken` key in the pagination object.
	Pagination Pagination `json:"pagination"`

	// Refinements Search refinements.
	Refinements Refinements `json:"refinements"`
}

// ItemSummaries Summary details of an Amazon catalog item.
type ItemSummaries = []ItemSummaryByMarketplace

// ItemSummaryByMarketplace Summary details of an Amazon catalog item for the indicated Amazon marketplace.
type ItemSummaryByMarketplace struct {
	// AdultProduct Identifies an Amazon catalog item is intended for an adult audience or is sexual in nature.
	AdultProduct *bool `json:"adultProduct,omitempty"`

	// Autographed Identifies an Amazon catalog item is autographed by a player or celebrity.
	Autographed *bool `json:"autographed,omitempty"`

	// Brand Name of the brand associated with an Amazon catalog item.
	Brand *string `json:"brand,omitempty"`

	// BrowseClassification Classification (browse node) associated with an Amazon catalog item.
	BrowseClassification *ItemBrowseClassification `json:"browseClassification,omitempty"`

	// Color Name of the color associated with an Amazon catalog item.
	Color *string `json:"color,omitempty"`

	// Contributors Individual contributors to the creation of an item, such as the authors or actors.
	Contributors *[]ItemContributor `json:"contributors,omitempty"`

	// ItemClassification Classification type associated with the Amazon catalog item.
	ItemClassification *ItemSummaryByMarketplaceItemClassification `json:"itemClassification,omitempty"`

	// ItemName Name, or title, associated with an Amazon catalog item.
	ItemName *string `json:"itemName,omitempty"`

	// Manufacturer Name of the manufacturer associated with an Amazon catalog item.
	Manufacturer *string `json:"manufacturer,omitempty"`

	// MarketplaceId Amazon marketplace identifier.
	MarketplaceId string `json:"marketplaceId"`

	// Memorabilia Identifies an Amazon catalog item is memorabilia valued for its connection with historical events, culture, or entertainment.
	Memorabilia *bool `json:"memorabilia,omitempty"`

	// ModelNumber Model number associated with an Amazon catalog item.
	ModelNumber *string `json:"modelNumber,omitempty"`

	// PackageQuantity Quantity of an Amazon catalog item in one package.
	PackageQuantity *int `json:"packageQuantity,omitempty"`

	// PartNumber Part number associated with an Amazon catalog item.
	PartNumber *string `json:"partNumber,omitempty"`

	// ReleaseDate First date on which an Amazon catalog item is shippable to customers.
	ReleaseDate *openapi_types.Date `json:"releaseDate,omitempty"`

	// Size Name of the size associated with an Amazon catalog item.
	Size *string `json:"size,omitempty"`

	// Style Name of the style associated with an Amazon catalog item.
	Style *string `json:"style,omitempty"`

	// TradeInEligible Identifies an Amazon catalog item is eligible for trade-in.
	TradeInEligible *bool `json:"tradeInEligible,omitempty"`

	// WebsiteDisplayGroup Identifier of the website display group associated with an Amazon catalog item.
	WebsiteDisplayGroup *string `json:"websiteDisplayGroup,omitempty"`

	// WebsiteDisplayGroupName Display name of the website display group associated with an Amazon catalog item.
	WebsiteDisplayGroupName *string `json:"websiteDisplayGroupName,omitempty"`
}

// ItemSummaryByMarketplaceItemClassification Classification type associated with the Amazon catalog item.
type ItemSummaryByMarketplaceItemClassification string

// ItemVariationTheme Variation theme indicating the combination of Amazon item catalog attributes that define the variation family.
type ItemVariationTheme struct {
	// Attributes Names of the Amazon catalog item attributes associated with the variation theme.
	Attributes *[]string `json:"attributes,omitempty"`

	// Theme Variation theme indicating the combination of Amazon item catalog attributes that define the variation family.
	Theme *string `json:"theme,omitempty"`
}

// ItemVendorDetails Vendor details associated with an Amazon catalog item. Vendor details are available to vendors only.
type ItemVendorDetails = []ItemVendorDetailsByMarketplace

// ItemVendorDetailsByMarketplace Vendor details associated with an Amazon catalog item for the indicated Amazon marketplace.
type ItemVendorDetailsByMarketplace struct {
	// BrandCode Brand code associated with an Amazon catalog item.
	BrandCode *string `json:"brandCode,omitempty"`

	// ManufacturerCode Manufacturer code associated with an Amazon catalog item.
	ManufacturerCode *string `json:"manufacturerCode,omitempty"`

	// ManufacturerCodeParent Parent vendor code of the manufacturer code.
	ManufacturerCodeParent *string `json:"manufacturerCodeParent,omitempty"`

	// MarketplaceId Amazon marketplace identifier.
	MarketplaceId string `json:"marketplaceId"`

	// ProductCategory Product category or subcategory associated with an Amazon catalog item.
	ProductCategory *ItemVendorDetailsCategory `json:"productCategory,omitempty"`

	// ProductGroup Product group associated with an Amazon catalog item.
	ProductGroup *string `json:"productGroup,omitempty"`

	// ProductSubcategory Product category or subcategory associated with an Amazon catalog item.
	ProductSubcategory *ItemVendorDetailsCategory `json:"productSubcategory,omitempty"`

	// ReplenishmentCategory Replenishment category associated with an Amazon catalog item.
	ReplenishmentCategory *ItemVendorDetailsByMarketplaceReplenishmentCategory `json:"replenishmentCategory,omitempty"`
}

// ItemVendorDetailsByMarketplaceReplenishmentCategory Replenishment category associated with an Amazon catalog item.
type ItemVendorDetailsByMarketplaceReplenishmentCategory string

// ItemVendorDetailsCategory Product category or subcategory associated with an Amazon catalog item.
type ItemVendorDetailsCategory struct {
	// DisplayName Display name of the product category or subcategory
	DisplayName *string `json:"displayName,omitempty"`

	// Value Value (code) of the product category or subcategory.
	Value *string `json:"value,omitempty"`
}

// Pagination When a request produces a response that exceeds the `pageSize`, pagination occurs. This means the response is divided into individual pages. To retrieve the next page or the previous page, you must pass the `nextToken` value or the `previousToken` value as the `pageToken` parameter in the next request. When you receive the last page, there will be no `nextToken` key in the pagination object.
type Pagination struct {
	// NextToken A token that can be used to fetch the next page.
	NextToken *string `json:"nextToken,omitempty"`

	// PreviousToken A token that can be used to fetch the previous page.
	PreviousToken *string `json:"previousToken,omitempty"`
}

// Refinements Search refinements.
type Refinements struct {
	// Brands Brand search refinements.
	Brands []BrandRefinement `json:"brands"`

	// Classifications Classification search refinements.
	Classifications []ClassificationRefinement `json:"classifications"`
}

// SearchCatalogItemsParams defines parameters for SearchCatalogItems.
type SearchCatalogItemsParams struct {
	// Identifiers A comma-delimited list of product identifiers to search the Amazon catalog for. **Note:** Cannot be used with `keywords`.
	Identifiers *[]string `form:"identifiers,omitempty" json:"identifiers,omitempty"`

	// IdentifiersType Type of product identifiers to search the Amazon catalog for. **Note:** Required when `identifiers` are provided.
	IdentifiersType *SearchCatalogItemsParamsIdentifiersType `form:"identifiersType,omitempty" json:"identifiersType,omitempty"`

	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IncludedData A comma-delimited list of data sets to include in the response. Default: `summaries`.
	IncludedData *[]SearchCatalogItemsParamsIncludedData `form:"includedData,omitempty" json:"includedData,omitempty"`

	// Locale Locale for retrieving localized summaries. Defaults to the primary locale of the marketplace.
	Locale *string `form:"locale,omitempty" json:"locale,omitempty"`

	// SellerId A selling partner identifier, such as a seller account or vendor code. **Note:** Required when `identifiersType` is `SKU`.
	SellerId *string `form:"sellerId,omitempty" json:"sellerId,omitempty"`

	// Keywords A comma-delimited list of words to search the Amazon catalog for. **Note:** Cannot be used with `identifiers`.
	Keywords *[]string `form:"keywords,omitempty" json:"keywords,omitempty"`

	// BrandNames A comma-delimited list of brand names to limit the search for `keywords`-based queries. **Note:** Cannot be used with `identifiers`.
	BrandNames *[]string `form:"brandNames,omitempty" json:"brandNames,omitempty"`

	// ClassificationIds A comma-delimited list of classification identifiers to limit the search for `keywords`-based queries. **Note:** Cannot be used with `identifiers`.
	ClassificationIds *[]string `form:"classificationIds,omitempty" json:"classificationIds,omitempty"`

	// PageSize Number of results to be returned per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A token to fetch a certain page when there are multiple pages worth of results.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// KeywordsLocale The language of the keywords provided for `keywords`-based queries. Defaults to the primary locale of the marketplace. **Note:** Cannot be used with `identifiers`.
	KeywordsLocale *string `form:"keywordsLocale,omitempty" json:"keywordsLocale,omitempty"`
}

// SearchCatalogItemsParamsIdentifiersType defines parameters for SearchCatalogItems.
type SearchCatalogItemsParamsIdentifiersType string

// SearchCatalogItemsParamsIncludedData defines parameters for SearchCatalogItems.
type SearchCatalogItemsParamsIncludedData string

// GetCatalogItemParams defines parameters for GetCatalogItem.
type GetCatalogItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers. Data sets in the response contain data only for the specified marketplaces.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IncludedData A comma-delimited list of data sets to include in the response. Default: `summaries`.
	IncludedData *[]GetCatalogItemParamsIncludedData `form:"includedData,omitempty" json:"includedData,omitempty"`

	// Locale Locale for retrieving localized summaries. Defaults to the primary locale of the marketplace.
	Locale *string `form:"locale,omitempty" json:"locale,omitempty"`
}

// GetCatalogItemParamsIncludedData defines parameters for GetCatalogItem.
type GetCatalogItemParamsIncludedData string

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SearchCatalogItems request
	SearchCatalogItems(ctx context.Context, params *SearchCatalogItemsParams) (*http.Response, error)

	// GetCatalogItem request
	GetCatalogItem(ctx context.Context, asin string, params *GetCatalogItemParams) (*http.Response, error)
}

func (c *Client) SearchCatalogItems(ctx context.Context, params *SearchCatalogItemsParams) (*http.Response, error) {
	req, err := NewSearchCatalogItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetCatalogItem(ctx context.Context, asin string, params *GetCatalogItemParams) (*http.Response, error) {
	req, err := NewGetCatalogItemRequest(c.Server, asin, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewSearchCatalogItemsRequest generates requests for SearchCatalogItems
func NewSearchCatalogItemsRequest(server string, params *SearchCatalogItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/2022-04-01/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Identifiers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "identifiers", runtime.ParamLocationQuery, *params.Identifiers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IdentifiersType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "identifiersType", runtime.ParamLocationQuery, *params.IdentifiersType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IncludedData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedData", runtime.ParamLocationQuery, *params.IncludedData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SellerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sellerId", runtime.ParamLocationQuery, *params.SellerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Keywords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keywords", runtime.ParamLocationQuery, *params.Keywords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.BrandNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brandNames", runtime.ParamLocationQuery, *params.BrandNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ClassificationIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "classificationIds", runtime.ParamLocationQuery, *params.ClassificationIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.KeywordsLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keywordsLocale", runtime.ParamLocationQuery, *params.KeywordsLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogItemRequest generates requests for GetCatalogItem
func NewGetCatalogItemRequest(server string, asin string, params *GetCatalogItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asin", runtime.ParamLocationPath, asin)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalog/2022-04-01/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IncludedData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedData", runtime.ParamLocationQuery, *params.IncludedData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SearchCatalogItemsWithResponse request
	SearchCatalogItemsWithResponse(ctx context.Context, params *SearchCatalogItemsParams) (*SearchCatalogItemsResp, error)

	// GetCatalogItemWithResponse request
	GetCatalogItemWithResponse(ctx context.Context, asin string, params *GetCatalogItemParams) (*GetCatalogItemResp, error)
}

type SearchCatalogItemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ItemSearchResults
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r SearchCatalogItemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchCatalogItemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Item
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetCatalogItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SearchCatalogItemsWithResponse request returning *SearchCatalogItemsResp
func (c *ClientWithResponses) SearchCatalogItemsWithResponse(ctx context.Context, params *SearchCatalogItemsParams) (*SearchCatalogItemsResp, error) {
	rsp, err := c.SearchCatalogItems(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseSearchCatalogItemsResp(rsp)
}

// GetCatalogItemWithResponse request returning *GetCatalogItemResp
func (c *ClientWithResponses) GetCatalogItemWithResponse(ctx context.Context, asin string, params *GetCatalogItemParams) (*GetCatalogItemResp, error) {
	rsp, err := c.GetCatalogItem(ctx, asin, params)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogItemResp(rsp)
}

// ParseSearchCatalogItemsResp parses an HTTP response from a SearchCatalogItemsWithResponse call
func ParseSearchCatalogItemsResp(rsp *http.Response) (*SearchCatalogItemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchCatalogItemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ItemSearchResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetCatalogItemResp parses an HTTP response from a GetCatalogItemWithResponse call
func ParseGetCatalogItemResp(rsp *http.Response) (*GetCatalogItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
