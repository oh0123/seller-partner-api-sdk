// Package easyshipv20220323 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package easyshipv20220323

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for HandoverMethod.
const (
	Dropoff HandoverMethod = "Dropoff"
	Pickup  HandoverMethod = "Pickup"
)

// Defines values for LabelFormat.
const (
	PDF LabelFormat = "PDF"
	ZPL LabelFormat = "ZPL"
)

// Defines values for PackageStatus.
const (
	AtDestinationFC  PackageStatus = "AtDestinationFC"
	AtOriginFC       PackageStatus = "AtOriginFC"
	DamagedInTransit PackageStatus = "DamagedInTransit"
	Delivered        PackageStatus = "Delivered"
	LabelCanceled    PackageStatus = "LabelCanceled"
	LostInTransit    PackageStatus = "LostInTransit"
	OutForDelivery   PackageStatus = "OutForDelivery"
	PickedUp         PackageStatus = "PickedUp"
	ReadyForPickup   PackageStatus = "ReadyForPickup"
	Rejected         PackageStatus = "Rejected"
	ReturnedToSeller PackageStatus = "ReturnedToSeller"
	Undeliverable    PackageStatus = "Undeliverable"
)

// Defines values for UnitOfLength.
const (
	Cm UnitOfLength = "Cm"
)

// Defines values for UnitOfWeight.
const (
	G     UnitOfWeight = "G"
	Grams UnitOfWeight = "Grams"
)

// AmazonOrderId An Amazon-defined order identifier. Identifies the order that the seller wants to deliver using Amazon Easy Ship.
type AmazonOrderId = string

// CreateScheduledPackageRequest The request schema for the `createScheduledPackage` operation.
type CreateScheduledPackageRequest struct {
	// AmazonOrderId An Amazon-defined order identifier. Identifies the order that the seller wants to deliver using Amazon Easy Ship.
	AmazonOrderId AmazonOrderId `json:"amazonOrderId"`

	// MarketplaceId A string of up to 255 characters.
	MarketplaceId String `json:"marketplaceId"`

	// PackageDetails Package details. Includes `packageItems`, `packageTimeSlot`, and `packageIdentifier`.
	PackageDetails PackageDetails `json:"packageDetails"`
}

// CreateScheduledPackagesRequest The request body for the POST /easyShip/2022-03-23/packages/bulk API.
type CreateScheduledPackagesRequest struct {
	// LabelFormat The file format in which the shipping label will be created.
	LabelFormat LabelFormat `json:"labelFormat"`

	// MarketplaceId A string of up to 255 characters.
	MarketplaceId String `json:"marketplaceId"`

	// OrderScheduleDetailsList An array allowing users to specify orders to be scheduled.
	OrderScheduleDetailsList []OrderScheduleDetails `json:"orderScheduleDetailsList"`
}

// CreateScheduledPackagesResponse The response schema for the bulk scheduling API. It returns by the bulk scheduling API containing an array of the scheduled packtages, an optional list of orders we couldn't schedule with the reason, and a pre-signed URL for a ZIP file containing the associated shipping labels plus the documents enabled for your marketplace.
type CreateScheduledPackagesResponse struct {
	// PrintableDocumentsUrl A pre-signed URL for the zip document containing the shipping labels and the documents enabled for your marketplace.
	PrintableDocumentsUrl *URL `json:"printableDocumentsUrl,omitempty"`

	// RejectedOrders A list of orders we couldn't scheduled on your behalf. Each element contains the reason and details on the error.
	RejectedOrders *[]RejectedOrder `json:"rejectedOrders,omitempty"`

	// ScheduledPackages A list of packages. Refer to the `Package` object.
	ScheduledPackages *[]Package `json:"scheduledPackages,omitempty"`
}

// DateTime A datetime value in ISO 8601 format.
type DateTime = time.Time

// Dimension The numerical value of the specified dimension.
type Dimension = float32

// Dimensions The dimensions of the scheduled package.
type Dimensions struct {
	// Height The numerical value of the specified dimension.
	Height *Dimension `json:"height,omitempty"`

	// Identifier A string of up to 255 characters.
	Identifier *String `json:"identifier,omitempty"`

	// Length The numerical value of the specified dimension.
	Length *Dimension `json:"length,omitempty"`

	// Unit The unit of measurement used to measure the length.
	Unit *UnitOfLength `json:"unit,omitempty"`

	// Width The numerical value of the specified dimension.
	Width *Dimension `json:"width,omitempty"`
}

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors []Error `json:"errors"`
}

// HandoverMethod Identifies the method by which a seller will hand a package over to Amazon Logistics.
type HandoverMethod string

// InvoiceData Invoice number and date.
type InvoiceData struct {
	// InvoiceDate A datetime value in ISO 8601 format.
	InvoiceDate *DateTime `json:"invoiceDate,omitempty"`

	// InvoiceNumber A string of up to 255 characters.
	InvoiceNumber String `json:"invoiceNumber"`
}

// Item Item identifier and serial number information.
type Item struct {
	// OrderItemId The Amazon-defined order item identifier.
	OrderItemId *OrderItemId `json:"orderItemId,omitempty"`

	// OrderItemSerialNumbers A list of serial numbers for the items associated with the `OrderItemId` value.
	OrderItemSerialNumbers *OrderItemSerialNumbers `json:"orderItemSerialNumbers,omitempty"`
}

// Items A list of items contained in the package.
type Items = []Item

// LabelFormat The file format in which the shipping label will be created.
type LabelFormat string

// ListHandoverSlotsRequest The request schema for the `listHandoverSlots` operation.
type ListHandoverSlotsRequest struct {
	// AmazonOrderId An Amazon-defined order identifier. Identifies the order that the seller wants to deliver using Amazon Easy Ship.
	AmazonOrderId AmazonOrderId `json:"amazonOrderId"`

	// MarketplaceId A string of up to 255 characters.
	MarketplaceId String `json:"marketplaceId"`

	// PackageDimensions The dimensions of the scheduled package.
	PackageDimensions Dimensions `json:"packageDimensions"`

	// PackageWeight The weight of the scheduled package
	PackageWeight Weight `json:"packageWeight"`
}

// ListHandoverSlotsResponse The response schema for the `listHandoverSlots` operation.
type ListHandoverSlotsResponse struct {
	// AmazonOrderId An Amazon-defined order identifier. Identifies the order that the seller wants to deliver using Amazon Easy Ship.
	AmazonOrderId AmazonOrderId `json:"amazonOrderId"`

	// TimeSlots A list of time slots.
	TimeSlots TimeSlots `json:"timeSlots"`
}

// OrderItemId The Amazon-defined order item identifier.
type OrderItemId = string

// OrderItemSerialNumber A serial number for an item associated with the `OrderItemId` value.
type OrderItemSerialNumber = string

// OrderItemSerialNumbers A list of serial numbers for the items associated with the `OrderItemId` value.
type OrderItemSerialNumbers = []OrderItemSerialNumber

// OrderScheduleDetails This object allows users to specify an order to be scheduled. Only the amazonOrderId is required.
type OrderScheduleDetails struct {
	// AmazonOrderId An Amazon-defined order identifier. Identifies the order that the seller wants to deliver using Amazon Easy Ship.
	AmazonOrderId AmazonOrderId `json:"amazonOrderId"`

	// PackageDetails Package details. Includes `packageItems`, `packageTimeSlot`, and `packageIdentifier`.
	PackageDetails *PackageDetails `json:"packageDetails,omitempty"`
}

// Package This object contains all the details of the scheduled Easy Ship package.
type Package struct {
	// Invoice Invoice number and date.
	Invoice *InvoiceData `json:"invoice,omitempty"`

	// PackageDimensions The dimensions of the scheduled package.
	PackageDimensions Dimensions `json:"packageDimensions"`

	// PackageIdentifier Optional seller-created identifier that is printed on the shipping label to help the seller identify the package.
	PackageIdentifier *PackageIdentifier `json:"packageIdentifier,omitempty"`

	// PackageItems A list of items contained in the package.
	PackageItems *Items `json:"packageItems,omitempty"`

	// PackageStatus The status of the package.
	PackageStatus *PackageStatus `json:"packageStatus,omitempty"`

	// PackageTimeSlot A time window to hand over an Easy Ship package to Amazon Logistics.
	PackageTimeSlot TimeSlot `json:"packageTimeSlot"`

	// PackageWeight The weight of the scheduled package
	PackageWeight Weight `json:"packageWeight"`

	// ScheduledPackageId Identifies the scheduled package to be updated.
	ScheduledPackageId ScheduledPackageId `json:"scheduledPackageId"`

	// TrackingDetails Representation of tracking metadata.
	TrackingDetails *TrackingDetails `json:"trackingDetails,omitempty"`
}

// PackageDetails Package details. Includes `packageItems`, `packageTimeSlot`, and `packageIdentifier`.
type PackageDetails struct {
	// PackageIdentifier Optional seller-created identifier that is printed on the shipping label to help the seller identify the package.
	PackageIdentifier *PackageIdentifier `json:"packageIdentifier,omitempty"`

	// PackageItems A list of items contained in the package.
	PackageItems *Items `json:"packageItems,omitempty"`

	// PackageTimeSlot A time window to hand over an Easy Ship package to Amazon Logistics.
	PackageTimeSlot TimeSlot `json:"packageTimeSlot"`
}

// PackageId An Amazon-defined identifier for the scheduled package.
type PackageId = string

// PackageIdentifier Optional seller-created identifier that is printed on the shipping label to help the seller identify the package.
type PackageIdentifier = string

// PackageStatus The status of the package.
type PackageStatus string

// Packages A list of packages.
type Packages struct {
	// Packages A list of packages.
	Packages []Package `json:"packages"`
}

// RejectedOrder A order which we couldn't schedule on your behalf. It contains its id, and information on the error.
type RejectedOrder struct {
	// AmazonOrderId An Amazon-defined order identifier. Identifies the order that the seller wants to deliver using Amazon Easy Ship.
	AmazonOrderId AmazonOrderId `json:"amazonOrderId"`

	// Error Error response returned when the request is unsuccessful.
	Error *Error `json:"error,omitempty"`
}

// ScheduledPackageId Identifies the scheduled package to be updated.
type ScheduledPackageId struct {
	// AmazonOrderId An Amazon-defined order identifier. Identifies the order that the seller wants to deliver using Amazon Easy Ship.
	AmazonOrderId AmazonOrderId `json:"amazonOrderId"`

	// PackageId An Amazon-defined identifier for the scheduled package.
	PackageId *PackageId `json:"packageId,omitempty"`
}

// String A string of up to 255 characters.
type String = string

// TimeSlot A time window to hand over an Easy Ship package to Amazon Logistics.
type TimeSlot struct {
	// EndTime A datetime value in ISO 8601 format.
	EndTime *DateTime `json:"endTime,omitempty"`

	// HandoverMethod Identifies the method by which a seller will hand a package over to Amazon Logistics.
	HandoverMethod *HandoverMethod `json:"handoverMethod,omitempty"`

	// SlotId A string of up to 255 characters.
	SlotId String `json:"slotId"`

	// StartTime A datetime value in ISO 8601 format.
	StartTime *DateTime `json:"startTime,omitempty"`
}

// TimeSlots A list of time slots.
type TimeSlots = []TimeSlot

// TrackingDetails Representation of tracking metadata.
type TrackingDetails struct {
	// TrackingId A string of up to 255 characters.
	TrackingId *String `json:"trackingId,omitempty"`
}

// URL A pre-signed URL for the zip document containing the shipping labels and the documents enabled for your marketplace.
type URL = string

// UnitOfLength The unit of measurement used to measure the length.
type UnitOfLength string

// UnitOfWeight The unit of measurement used to measure the weight.
type UnitOfWeight string

// UpdatePackageDetails Request to update the time slot of a package.
type UpdatePackageDetails struct {
	// PackageTimeSlot A time window to hand over an Easy Ship package to Amazon Logistics.
	PackageTimeSlot TimeSlot `json:"packageTimeSlot"`

	// ScheduledPackageId Identifies the scheduled package to be updated.
	ScheduledPackageId ScheduledPackageId `json:"scheduledPackageId"`
}

// UpdatePackageDetailsList A list of package update details.
type UpdatePackageDetailsList = []UpdatePackageDetails

// UpdateScheduledPackagesRequest The request schema for the `updateScheduledPackages` operation.
type UpdateScheduledPackagesRequest struct {
	// MarketplaceId A string of up to 255 characters.
	MarketplaceId String `json:"marketplaceId"`

	// UpdatePackageDetailsList A list of package update details.
	UpdatePackageDetailsList UpdatePackageDetailsList `json:"updatePackageDetailsList"`
}

// Weight The weight of the scheduled package
type Weight struct {
	// Unit The unit of measurement used to measure the weight.
	Unit *UnitOfWeight `json:"unit,omitempty"`

	// Value The weight of the package.
	Value *WeightValue `json:"value,omitempty"`
}

// WeightValue The weight of the package.
type WeightValue = float32

// GetScheduledPackageParams defines parameters for GetScheduledPackage.
type GetScheduledPackageParams struct {
	// AmazonOrderId An Amazon-defined order identifier. Identifies the order that the seller wants to deliver using Amazon Easy Ship.
	AmazonOrderId string `form:"amazonOrderId" json:"amazonOrderId"`

	// MarketplaceId An identifier for the marketplace in which the seller is selling.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// UpdateScheduledPackagesJSONRequestBody defines body for UpdateScheduledPackages for application/json ContentType.
type UpdateScheduledPackagesJSONRequestBody = UpdateScheduledPackagesRequest

// CreateScheduledPackageJSONRequestBody defines body for CreateScheduledPackage for application/json ContentType.
type CreateScheduledPackageJSONRequestBody = CreateScheduledPackageRequest

// CreateScheduledPackageBulkJSONRequestBody defines body for CreateScheduledPackageBulk for application/json ContentType.
type CreateScheduledPackageBulkJSONRequestBody = CreateScheduledPackagesRequest

// ListHandoverSlotsJSONRequestBody defines body for ListHandoverSlots for application/json ContentType.
type ListHandoverSlotsJSONRequestBody = ListHandoverSlotsRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetScheduledPackage request
	GetScheduledPackage(ctx context.Context, params *GetScheduledPackageParams) (*http.Response, error)

	// UpdateScheduledPackagesWithBody request with any body
	UpdateScheduledPackagesWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	UpdateScheduledPackages(ctx context.Context, body UpdateScheduledPackagesJSONRequestBody) (*http.Response, error)

	// CreateScheduledPackageWithBody request with any body
	CreateScheduledPackageWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateScheduledPackage(ctx context.Context, body CreateScheduledPackageJSONRequestBody) (*http.Response, error)

	// CreateScheduledPackageBulkWithBody request with any body
	CreateScheduledPackageBulkWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateScheduledPackageBulk(ctx context.Context, body CreateScheduledPackageBulkJSONRequestBody) (*http.Response, error)

	// ListHandoverSlotsWithBody request with any body
	ListHandoverSlotsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	ListHandoverSlots(ctx context.Context, body ListHandoverSlotsJSONRequestBody) (*http.Response, error)
}

func (c *Client) GetScheduledPackage(ctx context.Context, params *GetScheduledPackageParams) (*http.Response, error) {
	req, err := NewGetScheduledPackageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateScheduledPackagesWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateScheduledPackagesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateScheduledPackages(ctx context.Context, body UpdateScheduledPackagesJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateScheduledPackagesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateScheduledPackageWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateScheduledPackageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateScheduledPackage(ctx context.Context, body CreateScheduledPackageJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateScheduledPackageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateScheduledPackageBulkWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateScheduledPackageBulkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateScheduledPackageBulk(ctx context.Context, body CreateScheduledPackageBulkJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateScheduledPackageBulkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListHandoverSlotsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewListHandoverSlotsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListHandoverSlots(ctx context.Context, body ListHandoverSlotsJSONRequestBody) (*http.Response, error) {
	req, err := NewListHandoverSlotsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewGetScheduledPackageRequest generates requests for GetScheduledPackage
func NewGetScheduledPackageRequest(server string, params *GetScheduledPackageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/easyShip/2022-03-23/package")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amazonOrderId", runtime.ParamLocationQuery, params.AmazonOrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateScheduledPackagesRequest calls the generic UpdateScheduledPackages builder with application/json body
func NewUpdateScheduledPackagesRequest(server string, body UpdateScheduledPackagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateScheduledPackagesRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateScheduledPackagesRequestWithBody generates requests for UpdateScheduledPackages with any type of body
func NewUpdateScheduledPackagesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/easyShip/2022-03-23/package")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateScheduledPackageRequest calls the generic CreateScheduledPackage builder with application/json body
func NewCreateScheduledPackageRequest(server string, body CreateScheduledPackageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateScheduledPackageRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateScheduledPackageRequestWithBody generates requests for CreateScheduledPackage with any type of body
func NewCreateScheduledPackageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/easyShip/2022-03-23/package")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateScheduledPackageBulkRequest calls the generic CreateScheduledPackageBulk builder with application/json body
func NewCreateScheduledPackageBulkRequest(server string, body CreateScheduledPackageBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateScheduledPackageBulkRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateScheduledPackageBulkRequestWithBody generates requests for CreateScheduledPackageBulk with any type of body
func NewCreateScheduledPackageBulkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/easyShip/2022-03-23/packages/bulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListHandoverSlotsRequest calls the generic ListHandoverSlots builder with application/json body
func NewListHandoverSlotsRequest(server string, body ListHandoverSlotsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListHandoverSlotsRequestWithBody(server, "application/json", bodyReader)
}

// NewListHandoverSlotsRequestWithBody generates requests for ListHandoverSlots with any type of body
func NewListHandoverSlotsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/easyShip/2022-03-23/timeSlot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetScheduledPackageWithResponse request
	GetScheduledPackageWithResponse(ctx context.Context, params *GetScheduledPackageParams) (*GetScheduledPackageResp, error)

	// UpdateScheduledPackagesWithBodyWithResponse request with any body
	UpdateScheduledPackagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*UpdateScheduledPackagesResp, error)

	UpdateScheduledPackagesWithResponse(ctx context.Context, body UpdateScheduledPackagesJSONRequestBody) (*UpdateScheduledPackagesResp, error)

	// CreateScheduledPackageWithBodyWithResponse request with any body
	CreateScheduledPackageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateScheduledPackageResp, error)

	CreateScheduledPackageWithResponse(ctx context.Context, body CreateScheduledPackageJSONRequestBody) (*CreateScheduledPackageResp, error)

	// CreateScheduledPackageBulkWithBodyWithResponse request with any body
	CreateScheduledPackageBulkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateScheduledPackageBulkResp, error)

	CreateScheduledPackageBulkWithResponse(ctx context.Context, body CreateScheduledPackageBulkJSONRequestBody) (*CreateScheduledPackageBulkResp, error)

	// ListHandoverSlotsWithBodyWithResponse request with any body
	ListHandoverSlotsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*ListHandoverSlotsResp, error)

	ListHandoverSlotsWithResponse(ctx context.Context, body ListHandoverSlotsJSONRequestBody) (*ListHandoverSlotsResp, error)
}

type GetScheduledPackageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Package
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetScheduledPackageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScheduledPackageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateScheduledPackagesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Packages
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateScheduledPackagesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateScheduledPackagesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateScheduledPackageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Package
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CreateScheduledPackageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateScheduledPackageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateScheduledPackageBulkResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateScheduledPackagesResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CreateScheduledPackageBulkResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateScheduledPackageBulkResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHandoverSlotsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListHandoverSlotsResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListHandoverSlotsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHandoverSlotsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetScheduledPackageWithResponse request returning *GetScheduledPackageResp
func (c *ClientWithResponses) GetScheduledPackageWithResponse(ctx context.Context, params *GetScheduledPackageParams) (*GetScheduledPackageResp, error) {
	rsp, err := c.GetScheduledPackage(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetScheduledPackageResp(rsp)
}

// UpdateScheduledPackagesWithBodyWithResponse request with arbitrary body returning *UpdateScheduledPackagesResp
func (c *ClientWithResponses) UpdateScheduledPackagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*UpdateScheduledPackagesResp, error) {
	rsp, err := c.UpdateScheduledPackagesWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduledPackagesResp(rsp)
}

func (c *ClientWithResponses) UpdateScheduledPackagesWithResponse(ctx context.Context, body UpdateScheduledPackagesJSONRequestBody) (*UpdateScheduledPackagesResp, error) {
	rsp, err := c.UpdateScheduledPackages(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduledPackagesResp(rsp)
}

// CreateScheduledPackageWithBodyWithResponse request with arbitrary body returning *CreateScheduledPackageResp
func (c *ClientWithResponses) CreateScheduledPackageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateScheduledPackageResp, error) {
	rsp, err := c.CreateScheduledPackageWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateScheduledPackageResp(rsp)
}

func (c *ClientWithResponses) CreateScheduledPackageWithResponse(ctx context.Context, body CreateScheduledPackageJSONRequestBody) (*CreateScheduledPackageResp, error) {
	rsp, err := c.CreateScheduledPackage(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateScheduledPackageResp(rsp)
}

// CreateScheduledPackageBulkWithBodyWithResponse request with arbitrary body returning *CreateScheduledPackageBulkResp
func (c *ClientWithResponses) CreateScheduledPackageBulkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateScheduledPackageBulkResp, error) {
	rsp, err := c.CreateScheduledPackageBulkWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateScheduledPackageBulkResp(rsp)
}

func (c *ClientWithResponses) CreateScheduledPackageBulkWithResponse(ctx context.Context, body CreateScheduledPackageBulkJSONRequestBody) (*CreateScheduledPackageBulkResp, error) {
	rsp, err := c.CreateScheduledPackageBulk(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateScheduledPackageBulkResp(rsp)
}

// ListHandoverSlotsWithBodyWithResponse request with arbitrary body returning *ListHandoverSlotsResp
func (c *ClientWithResponses) ListHandoverSlotsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*ListHandoverSlotsResp, error) {
	rsp, err := c.ListHandoverSlotsWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseListHandoverSlotsResp(rsp)
}

func (c *ClientWithResponses) ListHandoverSlotsWithResponse(ctx context.Context, body ListHandoverSlotsJSONRequestBody) (*ListHandoverSlotsResp, error) {
	rsp, err := c.ListHandoverSlots(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseListHandoverSlotsResp(rsp)
}

// ParseGetScheduledPackageResp parses an HTTP response from a GetScheduledPackageWithResponse call
func ParseGetScheduledPackageResp(rsp *http.Response) (*GetScheduledPackageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScheduledPackageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateScheduledPackagesResp parses an HTTP response from a UpdateScheduledPackagesWithResponse call
func ParseUpdateScheduledPackagesResp(rsp *http.Response) (*UpdateScheduledPackagesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateScheduledPackagesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Packages
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateScheduledPackageResp parses an HTTP response from a CreateScheduledPackageWithResponse call
func ParseCreateScheduledPackageResp(rsp *http.Response) (*CreateScheduledPackageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateScheduledPackageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateScheduledPackageBulkResp parses an HTTP response from a CreateScheduledPackageBulkWithResponse call
func ParseCreateScheduledPackageBulkResp(rsp *http.Response) (*CreateScheduledPackageBulkResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateScheduledPackageBulkResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateScheduledPackagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListHandoverSlotsResp parses an HTTP response from a ListHandoverSlotsWithResponse call
func ParseListHandoverSlotsResp(rsp *http.Response) (*ListHandoverSlotsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHandoverSlotsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListHandoverSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
