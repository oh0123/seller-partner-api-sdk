// Package listingsitemsv20210801 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package listingsitemsv20210801

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/bytedance/sonic"
	"github.com/oapi-codegen/runtime"
)

// Defines values for IssueSeverity.
const (
	ERROR   IssueSeverity = "ERROR"
	INFO    IssueSeverity = "INFO"
	WARNING IssueSeverity = "WARNING"
)

// Defines values for IssueExemptionStatus.
const (
	EXEMPT                IssueExemptionStatus = "EXEMPT"
	EXEMPTUNTILEXPIRYDATE IssueExemptionStatus = "EXEMPT_UNTIL_EXPIRY_DATE"
	NOTEXEMPT             IssueExemptionStatus = "NOT_EXEMPT"
)

// Defines values for ItemOfferByMarketplaceOfferType.
const (
	B2B ItemOfferByMarketplaceOfferType = "B2B"
	B2C ItemOfferByMarketplaceOfferType = "B2C"
)

// Defines values for ItemSummaryByMarketplaceConditionType.
const (
	ClubClub               ItemSummaryByMarketplaceConditionType = "club_club"
	CollectibleAcceptable  ItemSummaryByMarketplaceConditionType = "collectible_acceptable"
	CollectibleGood        ItemSummaryByMarketplaceConditionType = "collectible_good"
	CollectibleLikeNew     ItemSummaryByMarketplaceConditionType = "collectible_like_new"
	CollectibleVeryGood    ItemSummaryByMarketplaceConditionType = "collectible_very_good"
	NewNew                 ItemSummaryByMarketplaceConditionType = "new_new"
	NewOem                 ItemSummaryByMarketplaceConditionType = "new_oem"
	NewOpenBox             ItemSummaryByMarketplaceConditionType = "new_open_box"
	RefurbishedRefurbished ItemSummaryByMarketplaceConditionType = "refurbished_refurbished"
	UsedAcceptable         ItemSummaryByMarketplaceConditionType = "used_acceptable"
	UsedGood               ItemSummaryByMarketplaceConditionType = "used_good"
	UsedLikeNew            ItemSummaryByMarketplaceConditionType = "used_like_new"
	UsedVeryGood           ItemSummaryByMarketplaceConditionType = "used_very_good"
)

// Defines values for ItemSummaryByMarketplaceStatus.
const (
	BUYABLE      ItemSummaryByMarketplaceStatus = "BUYABLE"
	DISCOVERABLE ItemSummaryByMarketplaceStatus = "DISCOVERABLE"
)

// Defines values for ListingsItemPutRequestRequirements.
const (
	LISTING            ListingsItemPutRequestRequirements = "LISTING"
	LISTINGOFFERONLY   ListingsItemPutRequestRequirements = "LISTING_OFFER_ONLY"
	LISTINGPRODUCTONLY ListingsItemPutRequestRequirements = "LISTING_PRODUCT_ONLY"
)

// Defines values for ListingsItemSubmissionResponseStatus.
const (
	ACCEPTED ListingsItemSubmissionResponseStatus = "ACCEPTED"
	INVALID  ListingsItemSubmissionResponseStatus = "INVALID"
	VALID    ListingsItemSubmissionResponseStatus = "VALID"
)

// Defines values for PatchOperationOp.
const (
	Add     PatchOperationOp = "add"
	Delete  PatchOperationOp = "delete"
	Replace PatchOperationOp = "replace"
)

// Defines values for GetListingsItemParamsIncludedData.
const (
	GetListingsItemParamsIncludedDataAttributes              GetListingsItemParamsIncludedData = "attributes"
	GetListingsItemParamsIncludedDataFulfillmentAvailability GetListingsItemParamsIncludedData = "fulfillmentAvailability"
	GetListingsItemParamsIncludedDataIssues                  GetListingsItemParamsIncludedData = "issues"
	GetListingsItemParamsIncludedDataOffers                  GetListingsItemParamsIncludedData = "offers"
	GetListingsItemParamsIncludedDataProcurement             GetListingsItemParamsIncludedData = "procurement"
	GetListingsItemParamsIncludedDataSummaries               GetListingsItemParamsIncludedData = "summaries"
)

// Defines values for PatchListingsItemParamsIncludedData.
const (
	PatchListingsItemParamsIncludedDataIdentifiers PatchListingsItemParamsIncludedData = "identifiers"
	PatchListingsItemParamsIncludedDataIssues      PatchListingsItemParamsIncludedData = "issues"
)

// Defines values for PatchListingsItemParamsMode.
const (
	PatchListingsItemParamsModeVALIDATIONPREVIEW PatchListingsItemParamsMode = "VALIDATION_PREVIEW"
)

// Defines values for PutListingsItemParamsIncludedData.
const (
	Identifiers PutListingsItemParamsIncludedData = "identifiers"
	Issues      PutListingsItemParamsIncludedData = "issues"
)

// Defines values for PutListingsItemParamsMode.
const (
	PutListingsItemParamsModeVALIDATIONPREVIEW PutListingsItemParamsMode = "VALIDATION_PREVIEW"
)

// Decimal A decimal number with no loss of precision. Useful when precision loss is unnaceptable, as with currencies. Follows RFC7159 for number representation.
type Decimal = string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	Errors []Error `json:"errors"`
}

// FulfillmentAvailability The fulfillment availability details for the listings item.
type FulfillmentAvailability struct {
	// FulfillmentChannelCode The code of the fulfillment network that will be used.
	FulfillmentChannelCode string `json:"fulfillmentChannelCode"`

	// Quantity The quantity of the item you are making available for sale.
	Quantity *int `json:"quantity,omitempty"`
}

// Issue An issue with a listings item.
type Issue struct {
	// AttributeNames The names of the attributes associated with the issue, if applicable.
	AttributeNames *[]string `json:"attributeNames,omitempty"`

	// Categories List of issue categories.
	//
	// Possible vales:
	//
	// * `INVALID_ATTRIBUTE` - Indicating an invalid attribute in the listing.
	//
	// * `MISSING_ATTRIBUTE` - Highlighting a missing attribute in the listing.
	//
	// * `INVALID_IMAGE` - Signifying an invalid image in the listing.
	//
	// * `MISSING_IMAGE` - Noting the absence of an image in the listing.
	//
	// * `INVALID_PRICE` - Pertaining to issues with the listing's price-related attributes.
	//
	// * `MISSING_PRICE` - Pointing out the absence of a price attribute in the listing.
	//
	// * `DUPLICATE` - Identifying listings with potential duplicate problems, such as this ASIN potentially being a duplicate of another ASIN.
	//
	// * `QUALIFICATION_REQUIRED` - Indicating that the listing requires qualification-related approval.
	Categories []string `json:"categories"`

	// Code An issue code that identifies the type of issue.
	Code string `json:"code"`

	// Enforcements This field provides information about the enforcement actions taken by Amazon that affect the publishing or status of a listing. It also includes details about any associated exemptions.
	Enforcements *IssueEnforcements `json:"enforcements,omitempty"`

	// Message A message that describes the issue.
	Message string `json:"message"`

	// Severity The severity of the issue.
	Severity IssueSeverity `json:"severity"`
}

// IssueSeverity The severity of the issue.
type IssueSeverity string

// IssueEnforcementAction The enforcement action taken by Amazon that affect the publishing or status of a listing
type IssueEnforcementAction struct {
	// Action The enforcement action name.
	//
	// Possible values:
	//
	// * `LISTING_SUPPRESSED` - This enforcement takes down the current listing item's buyability.
	//
	// * `ATTRIBUTE_SUPPRESSED` - An attribute's value on the listing item is invalid, which causes it to be rejected by Amazon.
	//
	// * `CATALOG_ITEM_REMOVED` - This catalog item is inactive on Amazon, and all offers against it in the applicable marketplace are non-buyable.
	//
	// * `SEARCH_SUPPRESSED` - This value indicates that the catalog item is hidden from search results.
	Action string `json:"action"`
}

// IssueEnforcements This field provides information about the enforcement actions taken by Amazon that affect the publishing or status of a listing. It also includes details about any associated exemptions.
type IssueEnforcements struct {
	// Actions List of enforcement actions taken by Amazon that affect the publishing or status of a listing.
	Actions []IssueEnforcementAction `json:"actions"`

	// Exemption Conveying the status of the listed enforcement actions and, if applicable, provides information about the exemption's expiry date.
	Exemption IssueExemption `json:"exemption"`
}

// IssueExemption Conveying the status of the listed enforcement actions and, if applicable, provides information about the exemption's expiry date.
type IssueExemption struct {
	// ExpiryDate This field represents the timestamp, following the ISO 8601 format, which specifies the date when temporary exemptions, if applicable, will expire, and Amazon will begin enforcing the listed actions.
	ExpiryDate *time.Time `json:"expiryDate,omitempty"`

	// Status This field indicates the current exemption status for the listed enforcement actions. It can take values such as `EXEMPT`, signifying permanent exemption, `EXEMPT_UNTIL_EXPIRY_DATE` indicating temporary exemption until a specified date, or `NOT_EXEMPT` signifying no exemptions, and enforcement actions were already applied.
	Status IssueExemptionStatus `json:"status"`
}

// IssueExemptionStatus This field indicates the current exemption status for the listed enforcement actions. It can take values such as `EXEMPT`, signifying permanent exemption, `EXEMPT_UNTIL_EXPIRY_DATE` indicating temporary exemption until a specified date, or `NOT_EXEMPT` signifying no exemptions, and enforcement actions were already applied.
type IssueExemptionStatus string

// Item A listings item.
type Item struct {
	// Attributes A JSON object containing structured listings item attribute data keyed by attribute name.
	Attributes *ItemAttributes `json:"attributes,omitempty"`

	// FulfillmentAvailability The fulfillment availability for the listings item.
	FulfillmentAvailability *[]FulfillmentAvailability `json:"fulfillmentAvailability,omitempty"`

	// Issues The issues associated with the listings item.
	Issues *ItemIssues `json:"issues,omitempty"`

	// Offers Offer details for the listings item.
	Offers *ItemOffers `json:"offers,omitempty"`

	// Procurement The vendor procurement information for the listings item.
	Procurement *[]ItemProcurement `json:"procurement,omitempty"`

	// Sku A selling partner provided identifier for an Amazon listing.
	Sku string `json:"sku"`

	// Summaries Summary details of a listings item.
	Summaries *ItemSummaries `json:"summaries,omitempty"`
}

// ItemAttributes A JSON object containing structured listings item attribute data keyed by attribute name.
type ItemAttributes map[string]interface{}

// ItemIdentifiers Identity attributes associated with the item in the Amazon catalog, such as the ASIN.
type ItemIdentifiers = []ItemIdentifiersByMarketplace

// ItemIdentifiersByMarketplace Identity attributes associated with the item in the Amazon catalog for the indicated Amazon marketplace.
type ItemIdentifiersByMarketplace struct {
	// Asin Amazon Standard Identification Number (ASIN) of the listings item.
	Asin *string `json:"asin,omitempty"`

	// MarketplaceId A marketplace identifier. Identifies the Amazon marketplace for the listings item.
	MarketplaceId *string `json:"marketplaceId,omitempty"`
}

// ItemImage The image for the listings item.
type ItemImage struct {
	// Height The height of the image in pixels.
	Height int `json:"height"`

	// Link The link, or URL, to the image.
	Link string `json:"link"`

	// Width The width of the image in pixels.
	Width int `json:"width"`
}

// ItemIssues The issues associated with the listings item.
type ItemIssues = []Issue

// ItemOfferByMarketplace Offer details of a listings item for an Amazon marketplace.
type ItemOfferByMarketplace struct {
	// MarketplaceId The Amazon marketplace identifier.
	MarketplaceId string `json:"marketplaceId"`

	// OfferType Type of offer for the listings item.
	OfferType ItemOfferByMarketplaceOfferType `json:"offerType"`

	// Points The number of Amazon Points offered with the purchase of an item, and their monetary value. Note that the `Points` element is only returned in Japan (JP).
	Points *Points `json:"points,omitempty"`

	// Price The currency type and amount.
	Price Money `json:"price"`
}

// ItemOfferByMarketplaceOfferType Type of offer for the listings item.
type ItemOfferByMarketplaceOfferType string

// ItemOffers Offer details for the listings item.
type ItemOffers = []ItemOfferByMarketplace

// ItemProcurement The vendor procurement information for the listings item.
type ItemProcurement = []interface{}

// ItemSummaries Summary details of a listings item.
type ItemSummaries = []ItemSummaryByMarketplace

// ItemSummaryByMarketplace Summary details of a listings item for an Amazon marketplace.
type ItemSummaryByMarketplace struct {
	// Asin Amazon Standard Identification Number (ASIN) of the listings item.
	Asin string `json:"asin"`

	// ConditionType Identifies the condition of the listings item.
	ConditionType *ItemSummaryByMarketplaceConditionType `json:"conditionType,omitempty"`

	// CreatedDate The date the listings item was created in ISO 8601 format.
	CreatedDate time.Time `json:"createdDate"`

	// FnSku The fulfillment network stock keeping unit is an identifier used by Amazon fulfillment centers to identify each unique item.
	FnSku *string `json:"fnSku,omitempty"`

	// ItemName The name or title associated with an Amazon catalog item.
	ItemName string `json:"itemName"`

	// LastUpdatedDate The date the listings item was last updated in ISO 8601 format.
	LastUpdatedDate time.Time `json:"lastUpdatedDate"`

	// MainImage The image for the listings item.
	MainImage *ItemImage `json:"mainImage,omitempty"`

	// MarketplaceId A marketplace identifier. Identifies the Amazon marketplace for the listings item.
	MarketplaceId string `json:"marketplaceId"`

	// ProductType The Amazon product type of the listings item.
	ProductType string `json:"productType"`

	// Status Statuses that apply to the listings item.
	Status []ItemSummaryByMarketplaceStatus `json:"status"`
}

// ItemSummaryByMarketplaceConditionType Identifies the condition of the listings item.
type ItemSummaryByMarketplaceConditionType string

// ItemSummaryByMarketplaceStatus defines model for ItemSummaryByMarketplace.Status.
type ItemSummaryByMarketplaceStatus string

// ListingsItemPatchRequest The request body schema for the `patchListingsItem` operation.
type ListingsItemPatchRequest struct {
	// Patches One or more JSON Patch operations to perform on the listings item.
	Patches []PatchOperation `json:"patches"`

	// ProductType The Amazon product type of the listings item.
	ProductType string `json:"productType"`
}

// ListingsItemPutRequest The request body schema for the `putListingsItem` operation.
type ListingsItemPutRequest struct {
	// Attributes A JSON object containing structured listings item attribute data keyed by attribute name.
	Attributes map[string]interface{} `json:"attributes"`

	// ProductType The Amazon product type of the listings item.
	ProductType string `json:"productType"`

	// Requirements The name of the requirements set for the provided data.
	Requirements *ListingsItemPutRequestRequirements `json:"requirements,omitempty"`
}

// ListingsItemPutRequestRequirements The name of the requirements set for the provided data.
type ListingsItemPutRequestRequirements string

// ListingsItemSubmissionResponse Response containing the results of a submission to the Selling Partner API for Listings Items.
type ListingsItemSubmissionResponse struct {
	// Identifiers Identity attributes associated with the item in the Amazon catalog, such as the ASIN.
	Identifiers *ItemIdentifiers `json:"identifiers,omitempty"`

	// Issues Listings item issues related to the listings item submission.
	Issues *[]Issue `json:"issues,omitempty"`

	// Sku A selling partner provided identifier for an Amazon listing.
	Sku string `json:"sku"`

	// Status The status of the listings item submission.
	Status ListingsItemSubmissionResponseStatus `json:"status"`

	// SubmissionId The unique identifier of the listings item submission.
	SubmissionId string `json:"submissionId"`
}

// ListingsItemSubmissionResponseStatus The status of the listings item submission.
type ListingsItemSubmissionResponseStatus string

// Money The currency type and amount.
type Money struct {
	// Amount A decimal number with no loss of precision. Useful when precision loss is unnaceptable, as with currencies. Follows RFC7159 for number representation.
	Amount Decimal `json:"amount"`

	// CurrencyCode Three-digit currency code in ISO 4217 format.
	CurrencyCode string `json:"currencyCode"`
}

// PatchOperation Individual JSON Patch operation for an HTTP PATCH request.
type PatchOperation struct {
	// Op Type of JSON Patch operation. Supported JSON Patch operations include add, replace, and delete. Refer to [JavaScript Object Notation (JSON) Patch](https://tools.ietf.org/html/rfc6902) for more information.
	Op PatchOperationOp `json:"op"`

	// Path JSON Pointer path of the element to patch. Refer to [JavaScript Object Notation (JSON) Patch](https://tools.ietf.org/html/rfc6902) for more information.
	Path string `json:"path"`

	// Value JSON value to add, replace, or delete.
	Value *[]map[string]interface{} `json:"value,omitempty"`
}

// PatchOperationOp Type of JSON Patch operation. Supported JSON Patch operations include add, replace, and delete. Refer to [JavaScript Object Notation (JSON) Patch](https://tools.ietf.org/html/rfc6902) for more information.
type PatchOperationOp string

// Points The number of Amazon Points offered with the purchase of an item, and their monetary value. Note that the `Points` element is only returned in Japan (JP).
type Points struct {
	PointsNumber int `json:"pointsNumber"`
}

// DeleteListingsItemParams defines parameters for DeleteListingsItem.
type DeleteListingsItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IssueLocale A locale for localization of issues. When not provided, the default language code of the first marketplace is used. Examples: `en_US`, `fr_CA`, `fr_FR`. Localized messages default to `en_US` when a localization is not available in the specified locale.
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`
}

// GetListingsItemParams defines parameters for GetListingsItem.
type GetListingsItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IssueLocale A locale for localization of issues. When not provided, the default language code of the first marketplace is used. Examples: `en_US`, `fr_CA`, `fr_FR`. Localized messages default to `en_US` when a localization is not available in the specified locale.
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`

	// IncludedData A comma-delimited list of data sets to include in the response. Default: `summaries`.
	IncludedData *[]GetListingsItemParamsIncludedData `form:"includedData,omitempty" json:"includedData,omitempty"`
}

// GetListingsItemParamsIncludedData defines parameters for GetListingsItem.
type GetListingsItemParamsIncludedData string

// PatchListingsItemParams defines parameters for PatchListingsItem.
type PatchListingsItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IncludedData A comma-delimited list of data sets to include in the response. Default: `issues`.
	IncludedData *[]PatchListingsItemParamsIncludedData `form:"includedData,omitempty" json:"includedData,omitempty"`

	// Mode The mode of operation for the request.
	Mode *PatchListingsItemParamsMode `form:"mode,omitempty" json:"mode,omitempty"`

	// IssueLocale A locale for localization of issues. When not provided, the default language code of the first marketplace is used. Examples: `en_US`, `fr_CA`, `fr_FR`. Localized messages default to `en_US` when a localization is not available in the specified locale.
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`
}

// PatchListingsItemParamsIncludedData defines parameters for PatchListingsItem.
type PatchListingsItemParamsIncludedData string

// PatchListingsItemParamsMode defines parameters for PatchListingsItem.
type PatchListingsItemParamsMode string

// PutListingsItemParams defines parameters for PutListingsItem.
type PutListingsItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IncludedData A comma-delimited list of data sets to include in the response. Default: `issues`.
	IncludedData *[]PutListingsItemParamsIncludedData `form:"includedData,omitempty" json:"includedData,omitempty"`

	// Mode The mode of operation for the request.
	Mode *PutListingsItemParamsMode `form:"mode,omitempty" json:"mode,omitempty"`

	// IssueLocale A locale for localization of issues. When not provided, the default language code of the first marketplace is used. Examples: `en_US`, `fr_CA`, `fr_FR`. Localized messages default to `en_US` when a localization is not available in the specified locale.
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`
}

// PutListingsItemParamsIncludedData defines parameters for PutListingsItem.
type PutListingsItemParamsIncludedData string

// PutListingsItemParamsMode defines parameters for PutListingsItem.
type PutListingsItemParamsMode string

// PatchListingsItemJSONRequestBody defines body for PatchListingsItem for application/json ContentType.
type PatchListingsItemJSONRequestBody = ListingsItemPatchRequest

// PutListingsItemJSONRequestBody defines body for PutListingsItem for application/json ContentType.
type PutListingsItemJSONRequestBody = ListingsItemPutRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteListingsItem request
	DeleteListingsItem(ctx context.Context, sellerId string, sku string, params *DeleteListingsItemParams) (*http.Response, error)

	// GetListingsItem request
	GetListingsItem(ctx context.Context, sellerId string, sku string, params *GetListingsItemParams) (*http.Response, error)

	// PatchListingsItemWithBody request with any body
	PatchListingsItemWithBody(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*http.Response, error)

	PatchListingsItem(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*http.Response, error)

	// PutListingsItemWithBody request with any body
	PutListingsItemWithBody(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*http.Response, error)

	PutListingsItem(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*http.Response, error)
}

func (c *Client) DeleteListingsItem(ctx context.Context, sellerId string, sku string, params *DeleteListingsItemParams) (*http.Response, error) {
	req, err := NewDeleteListingsItemRequest(c.Server, sellerId, sku, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetListingsItem(ctx context.Context, sellerId string, sku string, params *GetListingsItemParams) (*http.Response, error) {
	req, err := NewGetListingsItemRequest(c.Server, sellerId, sku, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PatchListingsItemWithBody(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPatchListingsItemRequestWithBody(c.Server, sellerId, sku, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PatchListingsItem(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*http.Response, error) {
	req, err := NewPatchListingsItemRequest(c.Server, sellerId, sku, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PutListingsItemWithBody(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutListingsItemRequestWithBody(c.Server, sellerId, sku, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PutListingsItem(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*http.Response, error) {
	req, err := NewPutListingsItemRequest(c.Server, sellerId, sku, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewDeleteListingsItemRequest generates requests for DeleteListingsItem
func NewDeleteListingsItemRequest(server string, sellerId string, sku string, params *DeleteListingsItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListingsItemRequest generates requests for GetListingsItem
func NewGetListingsItemRequest(server string, sellerId string, sku string, params *GetListingsItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IncludedData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedData", runtime.ParamLocationQuery, *params.IncludedData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchListingsItemRequest calls the generic PatchListingsItem builder with application/json body
func NewPatchListingsItemRequest(server string, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchListingsItemRequestWithBody(server, sellerId, sku, params, "application/json", bodyReader)
}

// NewPatchListingsItemRequestWithBody generates requests for PatchListingsItem with any type of body
func NewPatchListingsItemRequestWithBody(server string, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IncludedData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedData", runtime.ParamLocationQuery, *params.IncludedData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutListingsItemRequest calls the generic PutListingsItem builder with application/json body
func NewPutListingsItemRequest(server string, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutListingsItemRequestWithBody(server, sellerId, sku, params, "application/json", bodyReader)
}

// NewPutListingsItemRequestWithBody generates requests for PutListingsItem with any type of body
func NewPutListingsItemRequestWithBody(server string, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IncludedData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedData", runtime.ParamLocationQuery, *params.IncludedData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteListingsItemWithResponse request
	DeleteListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *DeleteListingsItemParams) (*DeleteListingsItemResp, error)

	// GetListingsItemWithResponse request
	GetListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *GetListingsItemParams) (*GetListingsItemResp, error)

	// PatchListingsItemWithBodyWithResponse request with any body
	PatchListingsItemWithBodyWithResponse(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*PatchListingsItemResp, error)

	PatchListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*PatchListingsItemResp, error)

	// PutListingsItemWithBodyWithResponse request with any body
	PutListingsItemWithBodyWithResponse(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*PutListingsItemResp, error)

	PutListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*PutListingsItemResp, error)
}

type DeleteListingsItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListingsItemSubmissionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r DeleteListingsItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteListingsItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListingsItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Item
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetListingsItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListingsItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchListingsItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListingsItemSubmissionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r PatchListingsItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchListingsItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutListingsItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListingsItemSubmissionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r PutListingsItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutListingsItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteListingsItemWithResponse request returning *DeleteListingsItemResp
func (c *ClientWithResponses) DeleteListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *DeleteListingsItemParams) (*DeleteListingsItemResp, error) {
	rsp, err := c.DeleteListingsItem(ctx, sellerId, sku, params)
	if err != nil {
		return nil, err
	}
	return ParseDeleteListingsItemResp(rsp)
}

// GetListingsItemWithResponse request returning *GetListingsItemResp
func (c *ClientWithResponses) GetListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *GetListingsItemParams) (*GetListingsItemResp, error) {
	rsp, err := c.GetListingsItem(ctx, sellerId, sku, params)
	if err != nil {
		return nil, err
	}
	return ParseGetListingsItemResp(rsp)
}

// PatchListingsItemWithBodyWithResponse request with arbitrary body returning *PatchListingsItemResp
func (c *ClientWithResponses) PatchListingsItemWithBodyWithResponse(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*PatchListingsItemResp, error) {
	rsp, err := c.PatchListingsItemWithBody(ctx, sellerId, sku, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePatchListingsItemResp(rsp)
}

func (c *ClientWithResponses) PatchListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*PatchListingsItemResp, error) {
	rsp, err := c.PatchListingsItem(ctx, sellerId, sku, params, body)
	if err != nil {
		return nil, err
	}
	return ParsePatchListingsItemResp(rsp)
}

// PutListingsItemWithBodyWithResponse request with arbitrary body returning *PutListingsItemResp
func (c *ClientWithResponses) PutListingsItemWithBodyWithResponse(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*PutListingsItemResp, error) {
	rsp, err := c.PutListingsItemWithBody(ctx, sellerId, sku, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutListingsItemResp(rsp)
}

func (c *ClientWithResponses) PutListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*PutListingsItemResp, error) {
	rsp, err := c.PutListingsItem(ctx, sellerId, sku, params, body)
	if err != nil {
		return nil, err
	}
	return ParsePutListingsItemResp(rsp)
}

// ParseDeleteListingsItemResp parses an HTTP response from a DeleteListingsItemWithResponse call
func ParseDeleteListingsItemResp(rsp *http.Response) (*DeleteListingsItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteListingsItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListingsItemSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetListingsItemResp parses an HTTP response from a GetListingsItemWithResponse call
func ParseGetListingsItemResp(rsp *http.Response) (*GetListingsItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListingsItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePatchListingsItemResp parses an HTTP response from a PatchListingsItemWithResponse call
func ParsePatchListingsItemResp(rsp *http.Response) (*PatchListingsItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchListingsItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListingsItemSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePutListingsItemResp parses an HTTP response from a PutListingsItemWithResponse call
func ParsePutListingsItemResp(rsp *http.Response) (*PutListingsItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutListingsItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListingsItemSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
