// Package listingsitemsv20210801 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package listingsitemsv20210801

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for IssueSeverity.
const (
	IssueSeverityERROR   IssueSeverity = "ERROR"
	IssueSeverityINFO    IssueSeverity = "INFO"
	IssueSeverityWARNING IssueSeverity = "WARNING"
)

// Defines values for IssueExemptionStatus.
const (
	EXEMPT                IssueExemptionStatus = "EXEMPT"
	EXEMPTUNTILEXPIRYDATE IssueExemptionStatus = "EXEMPT_UNTIL_EXPIRY_DATE"
	NOTEXEMPT             IssueExemptionStatus = "NOT_EXEMPT"
)

// Defines values for ItemOfferByMarketplaceOfferType.
const (
	B2B ItemOfferByMarketplaceOfferType = "B2B"
	B2C ItemOfferByMarketplaceOfferType = "B2C"
)

// Defines values for ItemRelationshipType.
const (
	PACKAGEHIERARCHY ItemRelationshipType = "PACKAGE_HIERARCHY"
	VARIATION        ItemRelationshipType = "VARIATION"
)

// Defines values for ItemSummaryByMarketplaceConditionType.
const (
	ClubClub               ItemSummaryByMarketplaceConditionType = "club_club"
	CollectibleAcceptable  ItemSummaryByMarketplaceConditionType = "collectible_acceptable"
	CollectibleGood        ItemSummaryByMarketplaceConditionType = "collectible_good"
	CollectibleLikeNew     ItemSummaryByMarketplaceConditionType = "collectible_like_new"
	CollectibleVeryGood    ItemSummaryByMarketplaceConditionType = "collectible_very_good"
	NewNew                 ItemSummaryByMarketplaceConditionType = "new_new"
	NewOem                 ItemSummaryByMarketplaceConditionType = "new_oem"
	NewOpenBox             ItemSummaryByMarketplaceConditionType = "new_open_box"
	RefurbishedRefurbished ItemSummaryByMarketplaceConditionType = "refurbished_refurbished"
	UsedAcceptable         ItemSummaryByMarketplaceConditionType = "used_acceptable"
	UsedGood               ItemSummaryByMarketplaceConditionType = "used_good"
	UsedLikeNew            ItemSummaryByMarketplaceConditionType = "used_like_new"
	UsedVeryGood           ItemSummaryByMarketplaceConditionType = "used_very_good"
)

// Defines values for ItemSummaryByMarketplaceStatus.
const (
	ItemSummaryByMarketplaceStatusBUYABLE      ItemSummaryByMarketplaceStatus = "BUYABLE"
	ItemSummaryByMarketplaceStatusDISCOVERABLE ItemSummaryByMarketplaceStatus = "DISCOVERABLE"
)

// Defines values for ListingsItemPutRequestRequirements.
const (
	LISTING            ListingsItemPutRequestRequirements = "LISTING"
	LISTINGOFFERONLY   ListingsItemPutRequestRequirements = "LISTING_OFFER_ONLY"
	LISTINGPRODUCTONLY ListingsItemPutRequestRequirements = "LISTING_PRODUCT_ONLY"
)

// Defines values for ListingsItemSubmissionResponseStatus.
const (
	ACCEPTED ListingsItemSubmissionResponseStatus = "ACCEPTED"
	INVALID  ListingsItemSubmissionResponseStatus = "INVALID"
	VALID    ListingsItemSubmissionResponseStatus = "VALID"
)

// Defines values for PatchOperationOp.
const (
	Add     PatchOperationOp = "add"
	Delete  PatchOperationOp = "delete"
	Merge   PatchOperationOp = "merge"
	Replace PatchOperationOp = "replace"
)

// Defines values for SearchListingsItemsParamsIncludedData.
const (
	SearchListingsItemsParamsIncludedDataAttributes              SearchListingsItemsParamsIncludedData = "attributes"
	SearchListingsItemsParamsIncludedDataFulfillmentAvailability SearchListingsItemsParamsIncludedData = "fulfillmentAvailability"
	SearchListingsItemsParamsIncludedDataIssues                  SearchListingsItemsParamsIncludedData = "issues"
	SearchListingsItemsParamsIncludedDataOffers                  SearchListingsItemsParamsIncludedData = "offers"
	SearchListingsItemsParamsIncludedDataProcurement             SearchListingsItemsParamsIncludedData = "procurement"
	SearchListingsItemsParamsIncludedDataProductTypes            SearchListingsItemsParamsIncludedData = "productTypes"
	SearchListingsItemsParamsIncludedDataRelationships           SearchListingsItemsParamsIncludedData = "relationships"
	SearchListingsItemsParamsIncludedDataSummaries               SearchListingsItemsParamsIncludedData = "summaries"
)

// Defines values for SearchListingsItemsParamsIdentifiersType.
const (
	ASIN   SearchListingsItemsParamsIdentifiersType = "ASIN"
	EAN    SearchListingsItemsParamsIdentifiersType = "EAN"
	FNSKU  SearchListingsItemsParamsIdentifiersType = "FNSKU"
	GTIN   SearchListingsItemsParamsIdentifiersType = "GTIN"
	ISBN   SearchListingsItemsParamsIdentifiersType = "ISBN"
	JAN    SearchListingsItemsParamsIdentifiersType = "JAN"
	MINSAN SearchListingsItemsParamsIdentifiersType = "MINSAN"
	SKU    SearchListingsItemsParamsIdentifiersType = "SKU"
	UPC    SearchListingsItemsParamsIdentifiersType = "UPC"
)

// Defines values for SearchListingsItemsParamsWithIssueSeverity.
const (
	SearchListingsItemsParamsWithIssueSeverityERROR   SearchListingsItemsParamsWithIssueSeverity = "ERROR"
	SearchListingsItemsParamsWithIssueSeverityWARNING SearchListingsItemsParamsWithIssueSeverity = "WARNING"
)

// Defines values for SearchListingsItemsParamsWithStatus.
const (
	SearchListingsItemsParamsWithStatusBUYABLE      SearchListingsItemsParamsWithStatus = "BUYABLE"
	SearchListingsItemsParamsWithStatusDISCOVERABLE SearchListingsItemsParamsWithStatus = "DISCOVERABLE"
)

// Defines values for SearchListingsItemsParamsWithoutStatus.
const (
	BUYABLE      SearchListingsItemsParamsWithoutStatus = "BUYABLE"
	DISCOVERABLE SearchListingsItemsParamsWithoutStatus = "DISCOVERABLE"
)

// Defines values for SearchListingsItemsParamsSortBy.
const (
	CreatedDate     SearchListingsItemsParamsSortBy = "createdDate"
	LastUpdatedDate SearchListingsItemsParamsSortBy = "lastUpdatedDate"
	Sku             SearchListingsItemsParamsSortBy = "sku"
)

// Defines values for SearchListingsItemsParamsSortOrder.
const (
	ASC  SearchListingsItemsParamsSortOrder = "ASC"
	DESC SearchListingsItemsParamsSortOrder = "DESC"
)

// Defines values for GetListingsItemParamsIncludedData.
const (
	GetListingsItemParamsIncludedDataAttributes              GetListingsItemParamsIncludedData = "attributes"
	GetListingsItemParamsIncludedDataFulfillmentAvailability GetListingsItemParamsIncludedData = "fulfillmentAvailability"
	GetListingsItemParamsIncludedDataIssues                  GetListingsItemParamsIncludedData = "issues"
	GetListingsItemParamsIncludedDataOffers                  GetListingsItemParamsIncludedData = "offers"
	GetListingsItemParamsIncludedDataProcurement             GetListingsItemParamsIncludedData = "procurement"
	GetListingsItemParamsIncludedDataProductTypes            GetListingsItemParamsIncludedData = "productTypes"
	GetListingsItemParamsIncludedDataRelationships           GetListingsItemParamsIncludedData = "relationships"
	GetListingsItemParamsIncludedDataSummaries               GetListingsItemParamsIncludedData = "summaries"
)

// Defines values for PatchListingsItemParamsIncludedData.
const (
	PatchListingsItemParamsIncludedDataIdentifiers PatchListingsItemParamsIncludedData = "identifiers"
	PatchListingsItemParamsIncludedDataIssues      PatchListingsItemParamsIncludedData = "issues"
)

// Defines values for PatchListingsItemParamsMode.
const (
	PatchListingsItemParamsModeVALIDATIONPREVIEW PatchListingsItemParamsMode = "VALIDATION_PREVIEW"
)

// Defines values for PutListingsItemParamsIncludedData.
const (
	PutListingsItemParamsIncludedDataIdentifiers PutListingsItemParamsIncludedData = "identifiers"
	PutListingsItemParamsIncludedDataIssues      PutListingsItemParamsIncludedData = "issues"
)

// Defines values for PutListingsItemParamsMode.
const (
	PutListingsItemParamsModeVALIDATIONPREVIEW PutListingsItemParamsMode = "VALIDATION_PREVIEW"
)

// Audience Buyer segment or program this offer is applicable to.
type Audience struct {
	// DisplayName Localized display name for the audience.
	DisplayName *string `json:"displayName,omitempty"`

	// Value Name of the audience an offer is applicable to.
	//
	// Common values:
	//
	// * 'ALL' - Standard offer audience for buyers on Amazon retail websites.
	//
	// * 'B2B' - Offer audience for Amazon Business website buyers.
	Value *string `json:"value,omitempty"`
}

// Decimal A decimal number with no loss of precision. Useful when precision loss is unnaceptable, as with currencies. Follows RFC7159 for number representation.
type Decimal = string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	Errors []Error `json:"errors"`
}

// FulfillmentAvailability The fulfillment availability details for the listings item.
type FulfillmentAvailability struct {
	// FulfillmentChannelCode Designates which fulfillment network is used.
	FulfillmentChannelCode string `json:"fulfillmentChannelCode"`

	// Quantity The quantity of the item you are making available for sale.
	Quantity *int `json:"quantity,omitempty"`
}

// Issue An issue with a listings item.
type Issue struct {
	// AttributeNames The names of the attributes associated with the issue, if applicable.
	AttributeNames *[]string `json:"attributeNames,omitempty"`

	// Categories List of issue categories.
	//
	// Possible values:
	//
	// * 'INVALID_ATTRIBUTE' - Indicating an invalid attribute in the listing.
	//
	// * 'MISSING_ATTRIBUTE' - Highlighting a missing attribute in the listing.
	//
	// * 'INVALID_IMAGE' - Signifying an invalid image in the listing.
	//
	// * 'MISSING_IMAGE' - Noting the absence of an image in the listing.
	//
	// * 'INVALID_PRICE' - Pertaining to issues with the listing's price-related attributes.
	//
	// * 'MISSING_PRICE' - Pointing out the absence of a price attribute in the listing.
	//
	// * 'DUPLICATE' - Identifying listings with potential duplicate problems, such as this ASIN potentially being a duplicate of another ASIN.
	//
	// * 'QUALIFICATION_REQUIRED' - Indicating that the listing requires qualification-related approval.
	Categories []string `json:"categories"`

	// Code An issue code that identifies the type of issue.
	Code string `json:"code"`

	// Enforcements This field provides information about the enforcement actions taken by Amazon that affect the publishing or status of a listing. It also includes details about any associated exemptions.
	Enforcements *IssueEnforcements `json:"enforcements,omitempty"`

	// Message A message that describes the issue.
	Message string `json:"message"`

	// Severity The severity of the issue.
	Severity IssueSeverity `json:"severity"`
}

// IssueSeverity The severity of the issue.
type IssueSeverity string

// IssueEnforcementAction The enforcement action taken by Amazon that affect the publishing or status of a listing
type IssueEnforcementAction struct {
	// Action The enforcement action name.
	//
	// Possible values:
	//
	// * `LISTING_SUPPRESSED` - This enforcement takes down the current listing item's buyability.
	//
	// * `ATTRIBUTE_SUPPRESSED` - An attribute's value on the listing item is invalid, which causes it to be rejected by Amazon.
	//
	// * `CATALOG_ITEM_REMOVED` - This catalog item is inactive on Amazon, and all offers against it in the applicable marketplace are non-buyable.
	//
	// * `SEARCH_SUPPRESSED` - This value indicates that the catalog item is hidden from search results.
	Action string `json:"action"`
}

// IssueEnforcements This field provides information about the enforcement actions taken by Amazon that affect the publishing or status of a listing. It also includes details about any associated exemptions.
type IssueEnforcements struct {
	// Actions List of enforcement actions taken by Amazon that affect the publishing or status of a listing.
	Actions []IssueEnforcementAction `json:"actions"`

	// Exemption Conveying the status of the listed enforcement actions and, if applicable, provides information about the exemption's expiry date.
	Exemption IssueExemption `json:"exemption"`
}

// IssueExemption Conveying the status of the listed enforcement actions and, if applicable, provides information about the exemption's expiry date.
type IssueExemption struct {
	// ExpiryDate Represents the timestamp, in ISO 8601 format, that specifies the date when the temporary exemptions expires, and Amazon begins enforcing the listed actions.
	ExpiryDate *time.Time `json:"expiryDate,omitempty"`

	// Status This field indicates the current exemption status for the listed enforcement actions. It can take values such as `EXEMPT`, signifying permanent exemption, `EXEMPT_UNTIL_EXPIRY_DATE` indicating temporary exemption until a specified date, or `NOT_EXEMPT` signifying no exemptions, and enforcement actions were already applied.
	Status IssueExemptionStatus `json:"status"`
}

// IssueExemptionStatus This field indicates the current exemption status for the listed enforcement actions. It can take values such as `EXEMPT`, signifying permanent exemption, `EXEMPT_UNTIL_EXPIRY_DATE` indicating temporary exemption until a specified date, or `NOT_EXEMPT` signifying no exemptions, and enforcement actions were already applied.
type IssueExemptionStatus string

// Item A listings item.
type Item struct {
	// Attributes A JSON object containing structured listings item attribute data keyed by attribute name.
	Attributes *ItemAttributes `json:"attributes,omitempty"`

	// FulfillmentAvailability The fulfillment availability for the listings item.
	FulfillmentAvailability *[]FulfillmentAvailability `json:"fulfillmentAvailability,omitempty"`

	// Issues The issues associated with the listings item.
	Issues *ItemIssues `json:"issues,omitempty"`

	// Offers Offer details for the listings item.
	Offers *ItemOffers `json:"offers,omitempty"`

	// Procurement The vendor procurement information for the listings item.
	Procurement *[]ItemProcurement `json:"procurement,omitempty"`

	// ProductTypes Product types for a listing item, by marketplace.
	ProductTypes *ItemProductTypes `json:"productTypes,omitempty"`

	// Relationships Relationships for a listing item, by marketplace (for example, variations).
	Relationships *ItemRelationships `json:"relationships,omitempty"`

	// Sku A selling partner provided identifier for an Amazon listing.
	Sku string `json:"sku"`

	// Summaries Summary details of a listings item.
	Summaries *ItemSummaries `json:"summaries,omitempty"`
}

// ItemAttributes A JSON object containing structured listings item attribute data keyed by attribute name.
type ItemAttributes map[string]interface{}

// ItemIdentifiers Identity attributes associated with the item in the Amazon catalog, such as the ASIN.
type ItemIdentifiers = []ItemIdentifiersByMarketplace

// ItemIdentifiersByMarketplace Identity attributes associated with the item in the Amazon catalog for the indicated Amazon marketplace.
type ItemIdentifiersByMarketplace struct {
	// Asin Amazon Standard Identification Number (ASIN) of the listings item.
	Asin *string `json:"asin,omitempty"`

	// MarketplaceId A marketplace identifier. Identifies the Amazon marketplace for the listings item.
	MarketplaceId *string `json:"marketplaceId,omitempty"`
}

// ItemImage The image for the listings item.
type ItemImage struct {
	// Height The height of the image in pixels.
	Height int `json:"height"`

	// Link The link, or URL, to the image.
	Link string `json:"link"`

	// Width The width of the image in pixels.
	Width int `json:"width"`
}

// ItemIssues The issues associated with the listings item.
type ItemIssues = []Issue

// ItemOfferByMarketplace Offer details of a listings item for an Amazon marketplace.
type ItemOfferByMarketplace struct {
	// Audience Buyer segment or program this offer is applicable to.
	Audience *Audience `json:"audience,omitempty"`

	// MarketplaceId The Amazon marketplace identifier.
	MarketplaceId string `json:"marketplaceId"`

	// OfferType Type of offer for the listings item.
	OfferType ItemOfferByMarketplaceOfferType `json:"offerType"`

	// Points The number of Amazon Points offered with the purchase of an item, and their monetary value. Note that the `Points` element is only returned in Japan (JP).
	Points *Points `json:"points,omitempty"`

	// Price The currency type and amount.
	Price Money `json:"price"`
}

// ItemOfferByMarketplaceOfferType Type of offer for the listings item.
type ItemOfferByMarketplaceOfferType string

// ItemOffers Offer details for the listings item.
type ItemOffers = []ItemOfferByMarketplace

// ItemProcurement The vendor procurement information for the listings item.
type ItemProcurement = []interface{}

// ItemProductTypeByMarketplace Product types that are associated with the listing item for the specified marketplace.
type ItemProductTypeByMarketplace struct {
	// MarketplaceId Amazon marketplace identifier.
	MarketplaceId string `json:"marketplaceId"`

	// ProductType The name of the product type that is submitted by the Selling Partner.
	ProductType string `json:"productType"`
}

// ItemProductTypes Product types for a listing item, by marketplace.
type ItemProductTypes = []ItemProductTypeByMarketplace

// ItemRelationship The relationship details for a listing item.
type ItemRelationship struct {
	// ChildSkus Identifiers (SKUs) of the related items that are children of this listing item.
	ChildSkus *[]string `json:"childSkus,omitempty"`

	// ParentSkus Identifiers (SKUs) of the related items that are parents of this listing item.
	ParentSkus *[]string `json:"parentSkus,omitempty"`

	// Type The type of relationship.
	Type ItemRelationshipType `json:"type"`

	// VariationTheme A variation theme that indicates the combination of listing item attributes that define the variation family.
	VariationTheme *ItemVariationTheme `json:"variationTheme,omitempty"`
}

// ItemRelationshipType The type of relationship.
type ItemRelationshipType string

// ItemRelationships Relationships for a listing item, by marketplace (for example, variations).
type ItemRelationships = []ItemRelationshipsByMarketplace

// ItemRelationshipsByMarketplace Relationship details for the listing item in the specified marketplace.
type ItemRelationshipsByMarketplace struct {
	// MarketplaceId Amazon marketplace identifier.
	MarketplaceId string `json:"marketplaceId"`

	// Relationships Relationships for the listing item.
	Relationships []ItemRelationship `json:"relationships"`
}

// ItemSearchResults Selling partner listings items and search related metadata.
type ItemSearchResults struct {
	// Items A list of listings items.
	Items []Item `json:"items"`

	// NumberOfResults The total number of selling partner listings items found for the search criteria (only results up to the page count limit is returned per request regardless of the number found).
	//
	// Note: The maximum number of items (SKUs) that can be returned and paged through is 1000.
	NumberOfResults int `json:"numberOfResults"`

	// Pagination When a request produces a response that exceeds the `pageSize`, pagination occurs. This means the response is divided into individual pages. To retrieve the next page or the previous page, you must pass the `nextToken` value or the `previousToken` value as the `pageToken` parameter in the next request. When you receive the last page, there is no `nextToken` key in the pagination object.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ItemSummaries Summary details of a listings item.
type ItemSummaries = []ItemSummaryByMarketplace

// ItemSummaryByMarketplace Summary details of a listings item for an Amazon marketplace.
type ItemSummaryByMarketplace struct {
	// Asin Amazon Standard Identification Number (ASIN) of the listings item.
	Asin *string `json:"asin,omitempty"`

	// ConditionType Identifies the condition of the listings item.
	ConditionType *ItemSummaryByMarketplaceConditionType `json:"conditionType,omitempty"`

	// CreatedDate The date the listings item was created in ISO 8601 format.
	CreatedDate time.Time `json:"createdDate"`

	// FnSku The fulfillment network stock keeping unit is an identifier used by Amazon fulfillment centers to identify each unique item.
	FnSku *string `json:"fnSku,omitempty"`

	// ItemName The name or title associated with an Amazon catalog item.
	ItemName *string `json:"itemName,omitempty"`

	// LastUpdatedDate The date the listings item was last updated in ISO 8601 format.
	LastUpdatedDate time.Time `json:"lastUpdatedDate"`

	// MainImage The image for the listings item.
	MainImage *ItemImage `json:"mainImage,omitempty"`

	// MarketplaceId A marketplace identifier. Identifies the Amazon marketplace for the listings item.
	MarketplaceId string `json:"marketplaceId"`

	// ProductType The Amazon product type of the listings item.
	ProductType string `json:"productType"`

	// Status Statuses that apply to the listings item.
	Status []ItemSummaryByMarketplaceStatus `json:"status"`
}

// ItemSummaryByMarketplaceConditionType Identifies the condition of the listings item.
type ItemSummaryByMarketplaceConditionType string

// ItemSummaryByMarketplaceStatus defines model for ItemSummaryByMarketplace.Status.
type ItemSummaryByMarketplaceStatus string

// ItemVariationTheme A variation theme that indicates the combination of listing item attributes that define the variation family.
type ItemVariationTheme struct {
	// Attributes The names of the listing item attributes that are associated with the variation theme.
	Attributes []string `json:"attributes"`

	// Theme The variation theme that indicates the combination of listing item attributes that define the variation family.
	Theme string `json:"theme"`
}

// ListingsItemPatchRequest The request body schema for the `patchListingsItem` operation.
type ListingsItemPatchRequest struct {
	// Patches One or more JSON Patch operations to perform on the listings item.
	Patches []PatchOperation `json:"patches"`

	// ProductType The Amazon product type of the listings item.
	ProductType string `json:"productType"`
}

// ListingsItemPutRequest The request body schema for the `putListingsItem` operation.
type ListingsItemPutRequest struct {
	// Attributes A JSON object containing structured listings item attribute data keyed by attribute name.
	Attributes map[string]interface{} `json:"attributes"`

	// ProductType The Amazon product type of the listings item.
	ProductType string `json:"productType"`

	// Requirements The name of the requirements set for the provided data.
	Requirements *ListingsItemPutRequestRequirements `json:"requirements,omitempty"`
}

// ListingsItemPutRequestRequirements The name of the requirements set for the provided data.
type ListingsItemPutRequestRequirements string

// ListingsItemSubmissionResponse Response containing the results of a submission to the Selling Partner API for Listings Items.
type ListingsItemSubmissionResponse struct {
	// Identifiers Identity attributes associated with the item in the Amazon catalog, such as the ASIN.
	Identifiers *ItemIdentifiers `json:"identifiers,omitempty"`

	// Issues Listings item issues related to the listings item submission.
	Issues *[]Issue `json:"issues,omitempty"`

	// Sku A selling partner provided identifier for an Amazon listing.
	Sku string `json:"sku"`

	// Status The status of the listings item submission.
	Status ListingsItemSubmissionResponseStatus `json:"status"`

	// SubmissionId The unique identifier of the listings item submission.
	SubmissionId string `json:"submissionId"`
}

// ListingsItemSubmissionResponseStatus The status of the listings item submission.
type ListingsItemSubmissionResponseStatus string

// Money The currency type and amount.
type Money struct {
	// Amount A decimal number with no loss of precision. Useful when precision loss is unnaceptable, as with currencies. Follows RFC7159 for number representation.
	Amount Decimal `json:"amount"`

	// CurrencyCode Three-digit currency code in ISO 4217 format.
	CurrencyCode string `json:"currencyCode"`
}

// Pagination When a request produces a response that exceeds the `pageSize`, pagination occurs. This means the response is divided into individual pages. To retrieve the next page or the previous page, you must pass the `nextToken` value or the `previousToken` value as the `pageToken` parameter in the next request. When you receive the last page, there is no `nextToken` key in the pagination object.
type Pagination struct {
	// NextToken A token that can be used to fetch the next page.
	NextToken *string `json:"nextToken,omitempty"`

	// PreviousToken A token that can be used to fetch the previous page.
	PreviousToken *string `json:"previousToken,omitempty"`
}

// PatchOperation Individual JSON Patch operation for an HTTP PATCH request.
type PatchOperation struct {
	// Op Type of JSON Patch operation. Supported JSON Patch operations include `add`, `replace`, `merge` and `delete`. Refer to <https://tools.ietf.org/html/rfc6902>.
	Op PatchOperationOp `json:"op"`

	// Path JSON Pointer path of the element to patch. Refer to [JavaScript Object Notation (JSON) Patch](https://tools.ietf.org/html/rfc6902) for more information.
	Path string `json:"path"`

	// Value JSON value to `add`, `replace`, `merge` or `delete`.
	Value *[]map[string]interface{} `json:"value,omitempty"`
}

// PatchOperationOp Type of JSON Patch operation. Supported JSON Patch operations include `add`, `replace`, `merge` and `delete`. Refer to <https://tools.ietf.org/html/rfc6902>.
type PatchOperationOp string

// Points The number of Amazon Points offered with the purchase of an item, and their monetary value. Note that the `Points` element is only returned in Japan (JP).
type Points struct {
	PointsNumber int `json:"pointsNumber"`
}

// SearchListingsItemsParams defines parameters for SearchListingsItems.
type SearchListingsItemsParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IssueLocale A locale that is used to localize issues. When not provided, the default language code of the first marketplace is used. Examples: "en_US", "fr_CA", "fr_FR". When a localization is not available in the specified locale, localized messages default to "en_US".
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`

	// IncludedData A comma-delimited list of datasets that you want to include in the response. Default: `summaries`.
	IncludedData *[]SearchListingsItemsParamsIncludedData `form:"includedData,omitempty" json:"includedData,omitempty"`

	// Identifiers A comma-delimited list of product identifiers that you can use to search for listings items.
	//
	// **Note**:
	// 1. This is required when you specify `identifiersType`.
	// 2. You cannot use 'identifiers' if you specify `variationParentSku` or `packageHierarchySku`.
	Identifiers *[]string `form:"identifiers,omitempty" json:"identifiers,omitempty"`

	// IdentifiersType A type of product identifiers that you can use to search for listings items.
	//
	// **Note**:
	// This is required when `identifiers` is provided.
	IdentifiersType *SearchListingsItemsParamsIdentifiersType `form:"identifiersType,omitempty" json:"identifiersType,omitempty"`

	// VariationParentSku Filters results to include listing items that are variation children of the specified SKU.
	//
	// **Note**: You cannot use `variationParentSku` if you include `identifiers` or `packageHierarchySku` in your request.
	VariationParentSku *string `form:"variationParentSku,omitempty" json:"variationParentSku,omitempty"`

	// PackageHierarchySku Filter results to include listing items that contain or are contained by the specified SKU.
	//
	// **Note**: You cannot use `packageHierarchySku` if you include `identifiers` or `variationParentSku` in your request.
	PackageHierarchySku *string `form:"packageHierarchySku,omitempty" json:"packageHierarchySku,omitempty"`

	// CreatedAfter A date-time that is used to filter listing items. The response includes listings items that were created at or after this time. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	CreatedAfter *time.Time `form:"createdAfter,omitempty" json:"createdAfter,omitempty"`

	// CreatedBefore A date-time that is used to filter listing items. The response includes listings items that were created at or before this time. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	CreatedBefore *time.Time `form:"createdBefore,omitempty" json:"createdBefore,omitempty"`

	// LastUpdatedAfter A date-time that is used to filter listing items. The response includes listings items that were last updated at or after this time. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	LastUpdatedAfter *time.Time `form:"lastUpdatedAfter,omitempty" json:"lastUpdatedAfter,omitempty"`

	// LastUpdatedBefore A date-time that is used to filter listing items. The response includes listings items that were last updated at or before this time. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	LastUpdatedBefore *time.Time `form:"lastUpdatedBefore,omitempty" json:"lastUpdatedBefore,omitempty"`

	// WithIssueSeverity Filter results to include only listing items that have issues that match one or more of the specified severity levels.
	WithIssueSeverity *[]SearchListingsItemsParamsWithIssueSeverity `form:"withIssueSeverity,omitempty" json:"withIssueSeverity,omitempty"`

	// WithStatus Filter results to include only listing items that have the specified status.
	WithStatus *[]SearchListingsItemsParamsWithStatus `form:"withStatus,omitempty" json:"withStatus,omitempty"`

	// WithoutStatus Filter results to include only listing items that don't contain the specified statuses.
	WithoutStatus *[]SearchListingsItemsParamsWithoutStatus `form:"withoutStatus,omitempty" json:"withoutStatus,omitempty"`

	// SortBy An attribute by which to sort the returned listing items.
	SortBy *SearchListingsItemsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder The order in which to sort the result items.
	SortOrder *SearchListingsItemsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// PageSize The number of results that you want to include on each page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A token that you can use to fetch a specific page when there are multiple pages of results.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// SearchListingsItemsParamsIncludedData defines parameters for SearchListingsItems.
type SearchListingsItemsParamsIncludedData string

// SearchListingsItemsParamsIdentifiersType defines parameters for SearchListingsItems.
type SearchListingsItemsParamsIdentifiersType string

// SearchListingsItemsParamsWithIssueSeverity defines parameters for SearchListingsItems.
type SearchListingsItemsParamsWithIssueSeverity string

// SearchListingsItemsParamsWithStatus defines parameters for SearchListingsItems.
type SearchListingsItemsParamsWithStatus string

// SearchListingsItemsParamsWithoutStatus defines parameters for SearchListingsItems.
type SearchListingsItemsParamsWithoutStatus string

// SearchListingsItemsParamsSortBy defines parameters for SearchListingsItems.
type SearchListingsItemsParamsSortBy string

// SearchListingsItemsParamsSortOrder defines parameters for SearchListingsItems.
type SearchListingsItemsParamsSortOrder string

// DeleteListingsItemParams defines parameters for DeleteListingsItem.
type DeleteListingsItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IssueLocale A locale for localization of issues. When not provided, the default language code of the first marketplace is used. Examples: `en_US`, `fr_CA`, `fr_FR`. Localized messages default to `en_US` when a localization is not available in the specified locale.
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`
}

// GetListingsItemParams defines parameters for GetListingsItem.
type GetListingsItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IssueLocale A locale for localization of issues. When not provided, the default language code of the first marketplace is used. Examples: `en_US`, `fr_CA`, `fr_FR`. Localized messages default to `en_US` when a localization is not available in the specified locale.
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`

	// IncludedData A comma-delimited list of data sets to include in the response. Default: `summaries`.
	IncludedData *[]GetListingsItemParamsIncludedData `form:"includedData,omitempty" json:"includedData,omitempty"`
}

// GetListingsItemParamsIncludedData defines parameters for GetListingsItem.
type GetListingsItemParamsIncludedData string

// PatchListingsItemParams defines parameters for PatchListingsItem.
type PatchListingsItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IncludedData A comma-delimited list of data sets to include in the response. Default: `issues`.
	IncludedData *[]PatchListingsItemParamsIncludedData `form:"includedData,omitempty" json:"includedData,omitempty"`

	// Mode The mode of operation for the request.
	Mode *PatchListingsItemParamsMode `form:"mode,omitempty" json:"mode,omitempty"`

	// IssueLocale A locale for localization of issues. When not provided, the default language code of the first marketplace is used. Examples: `en_US`, `fr_CA`, `fr_FR`. Localized messages default to `en_US` when a localization is not available in the specified locale.
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`
}

// PatchListingsItemParamsIncludedData defines parameters for PatchListingsItem.
type PatchListingsItemParamsIncludedData string

// PatchListingsItemParamsMode defines parameters for PatchListingsItem.
type PatchListingsItemParamsMode string

// PutListingsItemParams defines parameters for PutListingsItem.
type PutListingsItemParams struct {
	// MarketplaceIds A comma-delimited list of Amazon marketplace identifiers for the request.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`

	// IncludedData A comma-delimited list of data sets to include in the response. Default: `issues`.
	IncludedData *[]PutListingsItemParamsIncludedData `form:"includedData,omitempty" json:"includedData,omitempty"`

	// Mode The mode of operation for the request.
	Mode *PutListingsItemParamsMode `form:"mode,omitempty" json:"mode,omitempty"`

	// IssueLocale A locale for localization of issues. When not provided, the default language code of the first marketplace is used. Examples: `en_US`, `fr_CA`, `fr_FR`. Localized messages default to `en_US` when a localization is not available in the specified locale.
	IssueLocale *string `form:"issueLocale,omitempty" json:"issueLocale,omitempty"`
}

// PutListingsItemParamsIncludedData defines parameters for PutListingsItem.
type PutListingsItemParamsIncludedData string

// PutListingsItemParamsMode defines parameters for PutListingsItem.
type PutListingsItemParamsMode string

// PatchListingsItemJSONRequestBody defines body for PatchListingsItem for application/json ContentType.
type PatchListingsItemJSONRequestBody = ListingsItemPatchRequest

// PutListingsItemJSONRequestBody defines body for PutListingsItem for application/json ContentType.
type PutListingsItemJSONRequestBody = ListingsItemPutRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SearchListingsItems request
	SearchListingsItems(ctx context.Context, sellerId string, params *SearchListingsItemsParams) (*http.Response, error)

	// DeleteListingsItem request
	DeleteListingsItem(ctx context.Context, sellerId string, sku string, params *DeleteListingsItemParams) (*http.Response, error)

	// GetListingsItem request
	GetListingsItem(ctx context.Context, sellerId string, sku string, params *GetListingsItemParams) (*http.Response, error)

	// PatchListingsItemWithBody request with any body
	PatchListingsItemWithBody(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*http.Response, error)

	PatchListingsItem(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*http.Response, error)

	// PutListingsItemWithBody request with any body
	PutListingsItemWithBody(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*http.Response, error)

	PutListingsItem(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*http.Response, error)
}

func (c *Client) SearchListingsItems(ctx context.Context, sellerId string, params *SearchListingsItemsParams) (*http.Response, error) {
	req, err := NewSearchListingsItemsRequest(c.Server, sellerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) DeleteListingsItem(ctx context.Context, sellerId string, sku string, params *DeleteListingsItemParams) (*http.Response, error) {
	req, err := NewDeleteListingsItemRequest(c.Server, sellerId, sku, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetListingsItem(ctx context.Context, sellerId string, sku string, params *GetListingsItemParams) (*http.Response, error) {
	req, err := NewGetListingsItemRequest(c.Server, sellerId, sku, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PatchListingsItemWithBody(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPatchListingsItemRequestWithBody(c.Server, sellerId, sku, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PatchListingsItem(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*http.Response, error) {
	req, err := NewPatchListingsItemRequest(c.Server, sellerId, sku, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PutListingsItemWithBody(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutListingsItemRequestWithBody(c.Server, sellerId, sku, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) PutListingsItem(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*http.Response, error) {
	req, err := NewPutListingsItemRequest(c.Server, sellerId, sku, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewSearchListingsItemsRequest generates requests for SearchListingsItems
func NewSearchListingsItemsRequest(server string, sellerId string, params *SearchListingsItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IncludedData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedData", runtime.ParamLocationQuery, *params.IncludedData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Identifiers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "identifiers", runtime.ParamLocationQuery, *params.Identifiers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IdentifiersType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "identifiersType", runtime.ParamLocationQuery, *params.IdentifiersType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.VariationParentSku != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "variationParentSku", runtime.ParamLocationQuery, *params.VariationParentSku); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PackageHierarchySku != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "packageHierarchySku", runtime.ParamLocationQuery, *params.PackageHierarchySku); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBefore", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastUpdatedAfter", runtime.ParamLocationQuery, *params.LastUpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastUpdatedBefore", runtime.ParamLocationQuery, *params.LastUpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.WithIssueSeverity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withIssueSeverity", runtime.ParamLocationQuery, *params.WithIssueSeverity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.WithStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withStatus", runtime.ParamLocationQuery, *params.WithStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.WithoutStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withoutStatus", runtime.ParamLocationQuery, *params.WithoutStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteListingsItemRequest generates requests for DeleteListingsItem
func NewDeleteListingsItemRequest(server string, sellerId string, sku string, params *DeleteListingsItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListingsItemRequest generates requests for GetListingsItem
func NewGetListingsItemRequest(server string, sellerId string, sku string, params *GetListingsItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IncludedData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedData", runtime.ParamLocationQuery, *params.IncludedData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchListingsItemRequest calls the generic PatchListingsItem builder with application/json body
func NewPatchListingsItemRequest(server string, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchListingsItemRequestWithBody(server, sellerId, sku, params, "application/json", bodyReader)
}

// NewPatchListingsItemRequestWithBody generates requests for PatchListingsItem with any type of body
func NewPatchListingsItemRequestWithBody(server string, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IncludedData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedData", runtime.ParamLocationQuery, *params.IncludedData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutListingsItemRequest calls the generic PutListingsItem builder with application/json body
func NewPutListingsItemRequest(server string, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutListingsItemRequestWithBody(server, sellerId, sku, params, "application/json", bodyReader)
}

// NewPutListingsItemRequestWithBody generates requests for PutListingsItem with any type of body
func NewPutListingsItemRequestWithBody(server string, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerId", runtime.ParamLocationPath, sellerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sku", runtime.ParamLocationPath, sku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listings/2021-08-01/items/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.IncludedData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedData", runtime.ParamLocationQuery, *params.IncludedData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IssueLocale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueLocale", runtime.ParamLocationQuery, *params.IssueLocale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SearchListingsItemsWithResponse request
	SearchListingsItemsWithResponse(ctx context.Context, sellerId string, params *SearchListingsItemsParams) (*SearchListingsItemsResp, error)

	// DeleteListingsItemWithResponse request
	DeleteListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *DeleteListingsItemParams) (*DeleteListingsItemResp, error)

	// GetListingsItemWithResponse request
	GetListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *GetListingsItemParams) (*GetListingsItemResp, error)

	// PatchListingsItemWithBodyWithResponse request with any body
	PatchListingsItemWithBodyWithResponse(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*PatchListingsItemResp, error)

	PatchListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*PatchListingsItemResp, error)

	// PutListingsItemWithBodyWithResponse request with any body
	PutListingsItemWithBodyWithResponse(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*PutListingsItemResp, error)

	PutListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*PutListingsItemResp, error)
}

type SearchListingsItemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ItemSearchResults
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r SearchListingsItemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchListingsItemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteListingsItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListingsItemSubmissionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r DeleteListingsItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteListingsItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListingsItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Item
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetListingsItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListingsItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchListingsItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListingsItemSubmissionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r PatchListingsItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchListingsItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutListingsItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListingsItemSubmissionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r PutListingsItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutListingsItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SearchListingsItemsWithResponse request returning *SearchListingsItemsResp
func (c *ClientWithResponses) SearchListingsItemsWithResponse(ctx context.Context, sellerId string, params *SearchListingsItemsParams) (*SearchListingsItemsResp, error) {
	rsp, err := c.SearchListingsItems(ctx, sellerId, params)
	if err != nil {
		return nil, err
	}
	return ParseSearchListingsItemsResp(rsp)
}

// DeleteListingsItemWithResponse request returning *DeleteListingsItemResp
func (c *ClientWithResponses) DeleteListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *DeleteListingsItemParams) (*DeleteListingsItemResp, error) {
	rsp, err := c.DeleteListingsItem(ctx, sellerId, sku, params)
	if err != nil {
		return nil, err
	}
	return ParseDeleteListingsItemResp(rsp)
}

// GetListingsItemWithResponse request returning *GetListingsItemResp
func (c *ClientWithResponses) GetListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *GetListingsItemParams) (*GetListingsItemResp, error) {
	rsp, err := c.GetListingsItem(ctx, sellerId, sku, params)
	if err != nil {
		return nil, err
	}
	return ParseGetListingsItemResp(rsp)
}

// PatchListingsItemWithBodyWithResponse request with arbitrary body returning *PatchListingsItemResp
func (c *ClientWithResponses) PatchListingsItemWithBodyWithResponse(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, contentType string, body io.Reader) (*PatchListingsItemResp, error) {
	rsp, err := c.PatchListingsItemWithBody(ctx, sellerId, sku, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePatchListingsItemResp(rsp)
}

func (c *ClientWithResponses) PatchListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *PatchListingsItemParams, body PatchListingsItemJSONRequestBody) (*PatchListingsItemResp, error) {
	rsp, err := c.PatchListingsItem(ctx, sellerId, sku, params, body)
	if err != nil {
		return nil, err
	}
	return ParsePatchListingsItemResp(rsp)
}

// PutListingsItemWithBodyWithResponse request with arbitrary body returning *PutListingsItemResp
func (c *ClientWithResponses) PutListingsItemWithBodyWithResponse(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, contentType string, body io.Reader) (*PutListingsItemResp, error) {
	rsp, err := c.PutListingsItemWithBody(ctx, sellerId, sku, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutListingsItemResp(rsp)
}

func (c *ClientWithResponses) PutListingsItemWithResponse(ctx context.Context, sellerId string, sku string, params *PutListingsItemParams, body PutListingsItemJSONRequestBody) (*PutListingsItemResp, error) {
	rsp, err := c.PutListingsItem(ctx, sellerId, sku, params, body)
	if err != nil {
		return nil, err
	}
	return ParsePutListingsItemResp(rsp)
}

// ParseSearchListingsItemsResp parses an HTTP response from a SearchListingsItemsWithResponse call
func ParseSearchListingsItemsResp(rsp *http.Response) (*SearchListingsItemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchListingsItemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ItemSearchResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteListingsItemResp parses an HTTP response from a DeleteListingsItemWithResponse call
func ParseDeleteListingsItemResp(rsp *http.Response) (*DeleteListingsItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteListingsItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListingsItemSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetListingsItemResp parses an HTTP response from a GetListingsItemWithResponse call
func ParseGetListingsItemResp(rsp *http.Response) (*GetListingsItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListingsItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePatchListingsItemResp parses an HTTP response from a PatchListingsItemWithResponse call
func ParsePatchListingsItemResp(rsp *http.Response) (*PatchListingsItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchListingsItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListingsItemSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePutListingsItemResp parses an HTTP response from a PutListingsItemWithResponse call
func ParsePutListingsItemResp(rsp *http.Response) (*PutListingsItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutListingsItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListingsItemSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
