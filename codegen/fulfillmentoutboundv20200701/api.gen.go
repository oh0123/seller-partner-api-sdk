// Package fulfillmentoutboundv20200701 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package fulfillmentoutboundv20200701

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/bytedance/sonic"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AdditionalLocationInfo.
const (
	ASINSTRUCTED   AdditionalLocationInfo = "AS_INSTRUCTED"
	CARPORT        AdditionalLocationInfo = "CARPORT"
	CUSTOMERPICKUP AdditionalLocationInfo = "CUSTOMER_PICKUP"
	DECK           AdditionalLocationInfo = "DECK"
	DOORPERSON     AdditionalLocationInfo = "DOOR_PERSON"
	FRONTDESK      AdditionalLocationInfo = "FRONT_DESK"
	FRONTDOOR      AdditionalLocationInfo = "FRONT_DOOR"
	GARAGE         AdditionalLocationInfo = "GARAGE"
	GUARD          AdditionalLocationInfo = "GUARD"
	MAILBOX        AdditionalLocationInfo = "MAILBOX"
	MAILROOM       AdditionalLocationInfo = "MAIL_ROOM"
	MAILSLOT       AdditionalLocationInfo = "MAIL_SLOT"
	MCBOY          AdditionalLocationInfo = "MC_BOY"
	MCGIRL         AdditionalLocationInfo = "MC_GIRL"
	MCMAN          AdditionalLocationInfo = "MC_MAN"
	MCWOMAN        AdditionalLocationInfo = "MC_WOMAN"
	NEIGHBOR       AdditionalLocationInfo = "NEIGHBOR"
	OFFICE         AdditionalLocationInfo = "OFFICE"
	OUTBUILDING    AdditionalLocationInfo = "OUTBUILDING"
	PATIO          AdditionalLocationInfo = "PATIO"
	PORCH          AdditionalLocationInfo = "PORCH"
	REARDOOR       AdditionalLocationInfo = "REAR_DOOR"
	RECEIVER       AdditionalLocationInfo = "RECEIVER"
	RECEPTIONIST   AdditionalLocationInfo = "RECEPTIONIST"
	SECURELOCATION AdditionalLocationInfo = "SECURE_LOCATION"
	SIDEDOOR       AdditionalLocationInfo = "SIDE_DOOR"
)

// Defines values for CurrentStatus.
const (
	AVAILABLEFORPICKUP    CurrentStatus = "AVAILABLE_FOR_PICKUP"
	CUSTOMERACTION        CurrentStatus = "CUSTOMER_ACTION"
	DELAYED               CurrentStatus = "DELAYED"
	DELIVERED             CurrentStatus = "DELIVERED"
	DELIVERYATTEMPTED     CurrentStatus = "DELIVERY_ATTEMPTED"
	INTRANSIT             CurrentStatus = "IN_TRANSIT"
	OUTFORDELIVERY        CurrentStatus = "OUT_FOR_DELIVERY"
	PICKUPATTEMPTED       CurrentStatus = "PICKUP_ATTEMPTED"
	PICKUPCANCELLED       CurrentStatus = "PICKUP_CANCELLED"
	PICKUPSCHEDULED       CurrentStatus = "PICKUP_SCHEDULED"
	PICKUPSUCCESSFUL      CurrentStatus = "PICKUP_SUCCESSFUL"
	REFUNDISSUED          CurrentStatus = "REFUND_ISSUED"
	RETURNED              CurrentStatus = "RETURNED"
	RETURNING             CurrentStatus = "RETURNING"
	RETURNRECEIVEDINFC    CurrentStatus = "RETURN_RECEIVED_IN_FC"
	RETURNREQUESTACCEPTED CurrentStatus = "RETURN_REQUEST_ACCEPTED"
	UNDELIVERABLE         CurrentStatus = "UNDELIVERABLE"
	UNKNOWN               CurrentStatus = "UNKNOWN"
)

// Defines values for EventCode.
const (
	EVENT101 EventCode = "EVENT_101"
	EVENT102 EventCode = "EVENT_102"
	EVENT201 EventCode = "EVENT_201"
	EVENT202 EventCode = "EVENT_202"
	EVENT203 EventCode = "EVENT_203"
	EVENT204 EventCode = "EVENT_204"
	EVENT205 EventCode = "EVENT_205"
	EVENT206 EventCode = "EVENT_206"
	EVENT301 EventCode = "EVENT_301"
	EVENT302 EventCode = "EVENT_302"
	EVENT304 EventCode = "EVENT_304"
	EVENT306 EventCode = "EVENT_306"
	EVENT307 EventCode = "EVENT_307"
	EVENT308 EventCode = "EVENT_308"
	EVENT309 EventCode = "EVENT_309"
	EVENT401 EventCode = "EVENT_401"
	EVENT402 EventCode = "EVENT_402"
	EVENT403 EventCode = "EVENT_403"
	EVENT404 EventCode = "EVENT_404"
	EVENT405 EventCode = "EVENT_405"
	EVENT406 EventCode = "EVENT_406"
	EVENT407 EventCode = "EVENT_407"
	EVENT408 EventCode = "EVENT_408"
	EVENT409 EventCode = "EVENT_409"
	EVENT411 EventCode = "EVENT_411"
	EVENT412 EventCode = "EVENT_412"
	EVENT413 EventCode = "EVENT_413"
	EVENT414 EventCode = "EVENT_414"
	EVENT415 EventCode = "EVENT_415"
	EVENT416 EventCode = "EVENT_416"
	EVENT417 EventCode = "EVENT_417"
	EVENT418 EventCode = "EVENT_418"
	EVENT419 EventCode = "EVENT_419"
)

// Defines values for FeatureSettingsFeatureFulfillmentPolicy.
const (
	NotRequired FeatureSettingsFeatureFulfillmentPolicy = "NotRequired"
	Required    FeatureSettingsFeatureFulfillmentPolicy = "Required"
)

// Defines values for FeeName.
const (
	FBAFulfillmentCODFee      FeeName = "FBAFulfillmentCODFee"
	FBAPerOrderFulfillmentFee FeeName = "FBAPerOrderFulfillmentFee"
	FBAPerUnitFulfillmentFee  FeeName = "FBAPerUnitFulfillmentFee"
	FBATransportationFee      FeeName = "FBATransportationFee"
)

// Defines values for FulfillmentAction.
const (
	Hold FulfillmentAction = "Hold"
	Ship FulfillmentAction = "Ship"
)

// Defines values for FulfillmentOrderStatus.
const (
	FulfillmentOrderStatusCancelled          FulfillmentOrderStatus = "Cancelled"
	FulfillmentOrderStatusComplete           FulfillmentOrderStatus = "Complete"
	FulfillmentOrderStatusCompletePartialled FulfillmentOrderStatus = "CompletePartialled"
	FulfillmentOrderStatusInvalid            FulfillmentOrderStatus = "Invalid"
	FulfillmentOrderStatusNew                FulfillmentOrderStatus = "New"
	FulfillmentOrderStatusPlanning           FulfillmentOrderStatus = "Planning"
	FulfillmentOrderStatusProcessing         FulfillmentOrderStatus = "Processing"
	FulfillmentOrderStatusReceived           FulfillmentOrderStatus = "Received"
	FulfillmentOrderStatusUnfulfillable      FulfillmentOrderStatus = "Unfulfillable"
)

// Defines values for FulfillmentPolicy.
const (
	FillAll          FulfillmentPolicy = "FillAll"
	FillAllAvailable FulfillmentPolicy = "FillAllAvailable"
	FillOrKill       FulfillmentPolicy = "FillOrKill"
)

// Defines values for FulfillmentPreviewItemShippingWeightCalculationMethod.
const (
	Dimensional FulfillmentPreviewItemShippingWeightCalculationMethod = "Dimensional"
	Package     FulfillmentPreviewItemShippingWeightCalculationMethod = "Package"
)

// Defines values for FulfillmentReturnItemStatus.
const (
	FulfillmentReturnItemStatusNew       FulfillmentReturnItemStatus = "New"
	FulfillmentReturnItemStatusProcessed FulfillmentReturnItemStatus = "Processed"
)

// Defines values for FulfillmentShipmentFulfillmentShipmentStatus.
const (
	CANCELLEDBYFULFILLER FulfillmentShipmentFulfillmentShipmentStatus = "CANCELLED_BY_FULFILLER"
	CANCELLEDBYSELLER    FulfillmentShipmentFulfillmentShipmentStatus = "CANCELLED_BY_SELLER"
	PENDING              FulfillmentShipmentFulfillmentShipmentStatus = "PENDING"
	SHIPPED              FulfillmentShipmentFulfillmentShipmentStatus = "SHIPPED"
)

// Defines values for InvalidItemReasonCode.
const (
	DuplicateRequest     InvalidItemReasonCode = "DuplicateRequest"
	InvalidValues        InvalidItemReasonCode = "InvalidValues"
	NoCompletedShipItems InvalidItemReasonCode = "NoCompletedShipItems"
	NoReturnableQuantity InvalidItemReasonCode = "NoReturnableQuantity"
)

// Defines values for ReturnItemDisposition.
const (
	CarrierDamaged   ReturnItemDisposition = "CarrierDamaged"
	CustomerDamaged  ReturnItemDisposition = "CustomerDamaged"
	Defective        ReturnItemDisposition = "Defective"
	FulfillerDamaged ReturnItemDisposition = "FulfillerDamaged"
	Sellable         ReturnItemDisposition = "Sellable"
)

// Defines values for ShippingSpeedCategory.
const (
	Expedited         ShippingSpeedCategory = "Expedited"
	Priority          ShippingSpeedCategory = "Priority"
	ScheduledDelivery ShippingSpeedCategory = "ScheduledDelivery"
	Standard          ShippingSpeedCategory = "Standard"
)

// Defines values for WeightUnit.
const (
	KG        WeightUnit = "KG"
	KILOGRAMS WeightUnit = "KILOGRAMS"
	LB        WeightUnit = "LB"
	POUNDS    WeightUnit = "POUNDS"
)

// AdditionalLocationInfo Additional location information.
type AdditionalLocationInfo string

// Address A physical address.
type Address struct {
	// AddressLine1 The first line of the address.
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Additional address information, if required.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 Additional address information, if required.
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// City The city where the person, business, or institution is located. This property is required in all countries except Japan. It should not be used in Japan.
	City *string `json:"city,omitempty"`

	// CountryCode The two digit country code. In ISO 3166-1 alpha-2 format.
	CountryCode string `json:"countryCode"`

	// DistrictOrCounty The district or county where the person, business, or institution is located.
	DistrictOrCounty *string `json:"districtOrCounty,omitempty"`

	// Name The name of the person, business or institution at the address.
	Name string `json:"name"`

	// Phone The phone number of the person, business, or institution located at the address.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The postal code of the address.
	PostalCode string `json:"postalCode"`

	// StateOrRegion The state or region where the person, business or institution is located.
	StateOrRegion string `json:"stateOrRegion"`
}

// CODSettings The COD (Cash On Delivery) charges that you associate with a COD fulfillment order.
type CODSettings struct {
	// CodCharge An amount of money, including units in the form of currency.
	CodCharge *Money `json:"codCharge,omitempty"`

	// CodChargeTax An amount of money, including units in the form of currency.
	CodChargeTax *Money `json:"codChargeTax,omitempty"`

	// IsCodRequired When true, this fulfillment order requires a COD (Cash On Delivery) payment.
	IsCodRequired bool `json:"isCodRequired"`

	// ShippingCharge An amount of money, including units in the form of currency.
	ShippingCharge *Money `json:"shippingCharge,omitempty"`

	// ShippingChargeTax An amount of money, including units in the form of currency.
	ShippingChargeTax *Money `json:"shippingChargeTax,omitempty"`
}

// CancelFulfillmentOrderResponse The response schema for the `cancelFulfillmentOrder` operation.
type CancelFulfillmentOrderResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// CreateFulfillmentOrderItem Item information for creating a fulfillment order.
type CreateFulfillmentOrderItem struct {
	// DisplayableComment Item-specific text that displays in recipient-facing materials such as the outbound shipment packing slip.
	DisplayableComment *string `json:"displayableComment,omitempty"`

	// FulfillmentNetworkSku Amazon's fulfillment network SKU of the item.
	FulfillmentNetworkSku *string `json:"fulfillmentNetworkSku,omitempty"`

	// GiftMessage A message to the gift recipient, if applicable.
	GiftMessage *string `json:"giftMessage,omitempty"`

	// PerUnitDeclaredValue An amount of money, including units in the form of currency.
	PerUnitDeclaredValue *Money `json:"perUnitDeclaredValue,omitempty"`

	// PerUnitPrice An amount of money, including units in the form of currency.
	PerUnitPrice *Money `json:"perUnitPrice,omitempty"`

	// PerUnitTax An amount of money, including units in the form of currency.
	PerUnitTax *Money `json:"perUnitTax,omitempty"`

	// Quantity The item quantity.
	Quantity Quantity `json:"quantity"`

	// SellerFulfillmentOrderItemId A fulfillment order item identifier that the seller creates to track fulfillment order items. Used to disambiguate multiple fulfillment items that have the same `SellerSKU`. For example, the seller might assign different `SellerFulfillmentOrderItemId` values to two items in a fulfillment order that share the same `SellerSKU` but have different `GiftMessage` values.
	SellerFulfillmentOrderItemId string `json:"sellerFulfillmentOrderItemId"`

	// SellerSku The seller SKU of the item.
	SellerSku string `json:"sellerSku"`
}

// CreateFulfillmentOrderItemList An array of item information for creating a fulfillment order.
type CreateFulfillmentOrderItemList = []CreateFulfillmentOrderItem

// CreateFulfillmentOrderRequest The request body schema for the `createFulfillmentOrder` operation.
type CreateFulfillmentOrderRequest struct {
	// CodSettings The COD (Cash On Delivery) charges that you associate with a COD fulfillment order.
	CodSettings *CODSettings `json:"codSettings,omitempty"`

	// DeliveryWindow The time range within which a Scheduled Delivery fulfillment order should be delivered. This is only available in the JP marketplace.
	DeliveryWindow *DeliveryWindow `json:"deliveryWindow,omitempty"`

	// DestinationAddress A physical address.
	DestinationAddress Address `json:"destinationAddress"`

	// DisplayableOrderComment Order-specific text that appears in recipient-facing materials such as the outbound shipment packing slip.
	DisplayableOrderComment string    `json:"displayableOrderComment"`
	DisplayableOrderDate    Timestamp `json:"displayableOrderDate"`

	// DisplayableOrderId A fulfillment order identifier that the seller creates. This value displays as the order identifier in recipient-facing materials such as the outbound shipment packing slip. The value of `DisplayableOrderId` should match the order identifier that the seller provides to the recipient. The seller can use the `SellerFulfillmentOrderId` for this value or they can specify an alternate value if they want the recipient to reference an alternate order identifier.
	//
	// The value must be an alpha-numeric or ISO 8859-1 compliant string from one to 40 characters in length. Cannot contain two spaces in a row. Leading and trailing white space is removed.
	DisplayableOrderId string `json:"displayableOrderId"`

	// FeatureConstraints A list of features and their fulfillment policies to apply to the order.
	FeatureConstraints *[]FeatureSettings `json:"featureConstraints,omitempty"`

	// FulfillmentAction Specifies whether the fulfillment order should ship now or have an order hold put on it.
	FulfillmentAction *FulfillmentAction `json:"fulfillmentAction,omitempty"`

	// FulfillmentPolicy The `FulfillmentPolicy` value specified when you submitted the `createFulfillmentOrder` operation.
	FulfillmentPolicy *FulfillmentPolicy `json:"fulfillmentPolicy,omitempty"`

	// Items An array of item information for creating a fulfillment order.
	Items CreateFulfillmentOrderItemList `json:"items"`

	// MarketplaceId The marketplace the fulfillment order is placed against.
	MarketplaceId *string `json:"marketplaceId,omitempty"`

	// NotificationEmails A list of email addresses that the seller provides that are used by Amazon to send ship-complete notifications to recipients on behalf of the seller.
	NotificationEmails *NotificationEmailList `json:"notificationEmails,omitempty"`

	// PaymentInformation An array of various payment attributes related to this fulfillment order.
	PaymentInformation *PaymentInformationList `json:"paymentInformation,omitempty"`

	// SellerFulfillmentOrderId A fulfillment order identifier that the seller creates to track their fulfillment order. The `SellerFulfillmentOrderId` must be unique for each fulfillment order that a seller creates. If the seller's system already creates unique order identifiers, then these might be good values for them to use.
	SellerFulfillmentOrderId string `json:"sellerFulfillmentOrderId"`

	// ShipFromCountryCode The two-character country code for the country from which the fulfillment order ships. Must be in ISO 3166-1 alpha-2 format.
	ShipFromCountryCode *string `json:"shipFromCountryCode,omitempty"`

	// ShippingSpeedCategory The shipping method used for the fulfillment order. When this value is `ScheduledDelivery`, choose Ship for the `fulfillmentAction`. Hold is not a valid `fulfillmentAction` value when the `shippingSpeedCategory` value is `ScheduledDelivery`.
	ShippingSpeedCategory ShippingSpeedCategory `json:"shippingSpeedCategory"`
}

// CreateFulfillmentOrderResponse The response schema for the `createFulfillmentOrder` operation.
type CreateFulfillmentOrderResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// CreateFulfillmentReturnRequest The `createFulfillmentReturn` operation creates a fulfillment return for items that were fulfilled using the `createFulfillmentOrder` operation. For calls to `createFulfillmentReturn`, you must include `ReturnReasonCode` values returned by a previous call to the `listReturnReasonCodes` operation.
type CreateFulfillmentReturnRequest struct {
	// Items An array of items to be returned.
	Items CreateReturnItemList `json:"items"`
}

// CreateFulfillmentReturnResponse The response schema for the `createFulfillmentReturn` operation.
type CreateFulfillmentReturnResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList                     `json:"errors,omitempty"`
	Payload *CreateFulfillmentReturnResult `json:"payload,omitempty"`
}

// CreateFulfillmentReturnResult defines model for CreateFulfillmentReturnResult.
type CreateFulfillmentReturnResult struct {
	// InvalidReturnItems An array of invalid return item information.
	InvalidReturnItems *InvalidReturnItemList `json:"invalidReturnItems,omitempty"`

	// ReturnAuthorizations An array of return authorization information.
	ReturnAuthorizations *ReturnAuthorizationList `json:"returnAuthorizations,omitempty"`

	// ReturnItems An array of items that Amazon accepted for return. Returns empty if no items were accepted for return.
	ReturnItems *ReturnItemList `json:"returnItems,omitempty"`
}

// CreateReturnItem An item that Amazon accepted for return.
type CreateReturnItem struct {
	// AmazonShipmentId The identifier for the shipment that is associated with the return item.
	AmazonShipmentId string `json:"amazonShipmentId"`

	// ReturnComment An optional comment about the return item.
	ReturnComment *string `json:"returnComment,omitempty"`

	// ReturnReasonCode The return reason code assigned to the return item by the seller.
	ReturnReasonCode string `json:"returnReasonCode"`

	// SellerFulfillmentOrderItemId The identifier assigned to the item by the seller when the fulfillment order was created.
	SellerFulfillmentOrderItemId string `json:"sellerFulfillmentOrderItemId"`

	// SellerReturnItemId An identifier assigned by the seller to the return item.
	SellerReturnItemId string `json:"sellerReturnItemId"`
}

// CreateReturnItemList An array of items to be returned.
type CreateReturnItemList = []CreateReturnItem

// CurrentStatus The current delivery status of the package.
type CurrentStatus string

// Decimal A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation.
type Decimal = string

// DeliveryWindow The time range within which a Scheduled Delivery fulfillment order should be delivered. This is only available in the JP marketplace.
type DeliveryWindow struct {
	EndDate   Timestamp `json:"endDate"`
	StartDate Timestamp `json:"startDate"`
}

// DeliveryWindowList An array of delivery windows.
type DeliveryWindowList = []DeliveryWindow

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// EventCode The event code for the delivery event.
type EventCode string

// Feature A Multi-Channel Fulfillment feature.
type Feature struct {
	// FeatureDescription The feature description.
	FeatureDescription string `json:"featureDescription"`

	// FeatureName The feature name.
	FeatureName string `json:"featureName"`

	// SellerEligible When true, indicates that the seller is eligible to use the feature.
	SellerEligible *bool `json:"sellerEligible,omitempty"`
}

// FeatureSettings `FeatureSettings` allows users to apply fulfillment features to an order. To block an order from being shipped using Amazon Logistics (AMZL) and an AMZL tracking number, use `featureName` as `BLOCK_AMZL` and `featureFulfillmentPolicy` as `Required`. Blocking AMZL will incur an additional fee surcharge on your MCF orders and increase the risk of some of your orders being unfulfilled or delivered late if there are no alternative carriers available. Using `BLOCK_AMZL` in an order request will take precedence over your Seller Central account setting. To ship in non-Amazon branded packaging (blank boxes), use featureName `BLANK_BOX`.
type FeatureSettings struct {
	// FeatureFulfillmentPolicy Specifies the policy to use when fulfilling an order.
	FeatureFulfillmentPolicy *FeatureSettingsFeatureFulfillmentPolicy `json:"featureFulfillmentPolicy,omitempty"`

	// FeatureName The name of the feature.
	FeatureName *string `json:"featureName,omitempty"`
}

// FeatureSettingsFeatureFulfillmentPolicy Specifies the policy to use when fulfilling an order.
type FeatureSettingsFeatureFulfillmentPolicy string

// FeatureSku Information about an SKU, including the count available, identifiers, and a list of overlapping SKUs that share the same inventory pool.
type FeatureSku struct {
	// Asin The Amazon Standard Identification Number (ASIN) of the item.
	Asin *string `json:"asin,omitempty"`

	// FnSku The unique SKU used by Amazon's fulfillment network.
	FnSku *string `json:"fnSku,omitempty"`

	// OverlappingSkus Other seller SKUs that are shared across the same inventory.
	OverlappingSkus *[]string `json:"overlappingSkus,omitempty"`

	// SellerSku Used to identify an item in the given marketplace. `SellerSKU` is qualified by the seller's SellerId, which is included with every operation that you submit.
	SellerSku *string `json:"sellerSku,omitempty"`

	// SkuCount The number of SKUs available for this service.
	SkuCount *float32 `json:"skuCount,omitempty"`
}

// Features An array of features.
type Features = []Feature

// Fee Fee type and cost.
type Fee struct {
	// Amount An amount of money, including units in the form of currency.
	Amount Money `json:"amount"`

	// Name The type of fee.
	Name FeeName `json:"name"`
}

// FeeName The type of fee.
type FeeName string

// FeeList An array of fee type and cost pairs.
type FeeList = []Fee

// FulfillmentAction Specifies whether the fulfillment order should ship now or have an order hold put on it.
type FulfillmentAction string

// FulfillmentOrder General information about a fulfillment order, including its status.
type FulfillmentOrder struct {
	// CodSettings The COD (Cash On Delivery) charges that you associate with a COD fulfillment order.
	CodSettings *CODSettings `json:"codSettings,omitempty"`

	// DeliveryWindow The time range within which a Scheduled Delivery fulfillment order should be delivered. This is only available in the JP marketplace.
	DeliveryWindow *DeliveryWindow `json:"deliveryWindow,omitempty"`

	// DestinationAddress A physical address.
	DestinationAddress Address `json:"destinationAddress"`

	// DisplayableOrderComment A text block submitted with the `createFulfillmentOrder` operation. Displays in recipient-facing materials such as the packing slip.
	DisplayableOrderComment string    `json:"displayableOrderComment"`
	DisplayableOrderDate    Timestamp `json:"displayableOrderDate"`

	// DisplayableOrderId A fulfillment order identifier submitted with the `createFulfillmentOrder` operation. Displays as the order identifier in recipient-facing materials such as the packing slip.
	DisplayableOrderId string `json:"displayableOrderId"`

	// FeatureConstraints A list of features and their fulfillment policies to apply to the order.
	FeatureConstraints *[]FeatureSettings `json:"featureConstraints,omitempty"`

	// FulfillmentAction Specifies whether the fulfillment order should ship now or have an order hold put on it.
	FulfillmentAction *FulfillmentAction `json:"fulfillmentAction,omitempty"`

	// FulfillmentOrderStatus The current status of the fulfillment order.
	FulfillmentOrderStatus FulfillmentOrderStatus `json:"fulfillmentOrderStatus"`

	// FulfillmentPolicy The `FulfillmentPolicy` value specified when you submitted the `createFulfillmentOrder` operation.
	FulfillmentPolicy *FulfillmentPolicy `json:"fulfillmentPolicy,omitempty"`

	// MarketplaceId The identifier for the marketplace the fulfillment order is placed against.
	MarketplaceId string `json:"marketplaceId"`

	// NotificationEmails A list of email addresses that the seller provides that are used by Amazon to send ship-complete notifications to recipients on behalf of the seller.
	NotificationEmails *NotificationEmailList `json:"notificationEmails,omitempty"`
	ReceivedDate       Timestamp              `json:"receivedDate"`

	// SellerFulfillmentOrderId The fulfillment order identifier submitted with the `createFulfillmentOrder` operation.
	SellerFulfillmentOrderId string `json:"sellerFulfillmentOrderId"`

	// ShippingSpeedCategory The shipping method used for the fulfillment order. When this value is `ScheduledDelivery`, choose Ship for the `fulfillmentAction`. Hold is not a valid `fulfillmentAction` value when the `shippingSpeedCategory` value is `ScheduledDelivery`.
	ShippingSpeedCategory ShippingSpeedCategory `json:"shippingSpeedCategory"`
	StatusUpdatedDate     Timestamp             `json:"statusUpdatedDate"`
}

// FulfillmentOrderItem Item information for a fulfillment order.
type FulfillmentOrderItem struct {
	// CancelledQuantity The item quantity.
	CancelledQuantity Quantity `json:"cancelledQuantity"`

	// DisplayableComment Item-specific text that displays in recipient-facing materials such as the outbound shipment packing slip.
	DisplayableComment   *string    `json:"displayableComment,omitempty"`
	EstimatedArrivalDate *Timestamp `json:"estimatedArrivalDate,omitempty"`
	EstimatedShipDate    *Timestamp `json:"estimatedShipDate,omitempty"`

	// FulfillmentNetworkSku Amazon's fulfillment network SKU of the item.
	FulfillmentNetworkSku *string `json:"fulfillmentNetworkSku,omitempty"`

	// GiftMessage A message to the gift recipient, if applicable.
	GiftMessage *string `json:"giftMessage,omitempty"`

	// OrderItemDisposition Indicates whether the item is sellable or unsellable.
	OrderItemDisposition *string `json:"orderItemDisposition,omitempty"`

	// PerUnitDeclaredValue An amount of money, including units in the form of currency.
	PerUnitDeclaredValue *Money `json:"perUnitDeclaredValue,omitempty"`

	// PerUnitPrice An amount of money, including units in the form of currency.
	PerUnitPrice *Money `json:"perUnitPrice,omitempty"`

	// PerUnitTax An amount of money, including units in the form of currency.
	PerUnitTax *Money `json:"perUnitTax,omitempty"`

	// Quantity The item quantity.
	Quantity Quantity `json:"quantity"`

	// SellerFulfillmentOrderItemId A fulfillment order item identifier submitted with a call to the `createFulfillmentOrder` operation.
	SellerFulfillmentOrderItemId string `json:"sellerFulfillmentOrderItemId"`

	// SellerSku The seller SKU of the item.
	SellerSku string `json:"sellerSku"`

	// UnfulfillableQuantity The item quantity.
	UnfulfillableQuantity Quantity `json:"unfulfillableQuantity"`
}

// FulfillmentOrderItemList An array of fulfillment order item information.
type FulfillmentOrderItemList = []FulfillmentOrderItem

// FulfillmentOrderStatus The current status of the fulfillment order.
type FulfillmentOrderStatus string

// FulfillmentPolicy The `FulfillmentPolicy` value specified when you submitted the `createFulfillmentOrder` operation.
type FulfillmentPolicy string

// FulfillmentPreview Information about a fulfillment order preview, including delivery and fee information based on shipping method.
type FulfillmentPreview struct {
	// EstimatedFees An array of fee type and cost pairs.
	EstimatedFees *FeeList `json:"estimatedFees,omitempty"`

	// EstimatedShippingWeight The weight.
	EstimatedShippingWeight *Weight `json:"estimatedShippingWeight,omitempty"`

	// FeatureConstraints A list of features and their fulfillment policies to apply to the order.
	FeatureConstraints *[]FeatureSettings `json:"featureConstraints,omitempty"`

	// FulfillmentPreviewShipments An array of fulfillment preview shipment information.
	FulfillmentPreviewShipments *FulfillmentPreviewShipmentList `json:"fulfillmentPreviewShipments,omitempty"`

	// IsCODCapable When true, this fulfillment order preview is for COD (Cash On Delivery).
	IsCODCapable bool `json:"isCODCapable"`

	// IsFulfillable When true, this fulfillment order preview is fulfillable.
	IsFulfillable bool `json:"isFulfillable"`

	// MarketplaceId The marketplace the fulfillment order is placed against.
	MarketplaceId             string      `json:"marketplaceId"`
	OrderUnfulfillableReasons *StringList `json:"orderUnfulfillableReasons,omitempty"`

	// ScheduledDeliveryInfo Delivery information for a scheduled delivery. This is only available in the JP marketplace.
	ScheduledDeliveryInfo *ScheduledDeliveryInfo `json:"scheduledDeliveryInfo,omitempty"`

	// ShippingSpeedCategory The shipping method used for the fulfillment order. When this value is `ScheduledDelivery`, choose Ship for the `fulfillmentAction`. Hold is not a valid `fulfillmentAction` value when the `shippingSpeedCategory` value is `ScheduledDelivery`.
	ShippingSpeedCategory ShippingSpeedCategory `json:"shippingSpeedCategory"`

	// UnfulfillablePreviewItems An array of unfulfillable preview item information.
	UnfulfillablePreviewItems *UnfulfillablePreviewItemList `json:"unfulfillablePreviewItems,omitempty"`
}

// FulfillmentPreviewItem Item information for a shipment in a fulfillment order preview.
type FulfillmentPreviewItem struct {
	// EstimatedShippingWeight The weight.
	EstimatedShippingWeight *Weight `json:"estimatedShippingWeight,omitempty"`

	// Quantity The item quantity.
	Quantity Quantity `json:"quantity"`

	// SellerFulfillmentOrderItemId A fulfillment order item identifier that the seller created with a call to the `createFulfillmentOrder` operation.
	SellerFulfillmentOrderItemId string `json:"sellerFulfillmentOrderItemId"`

	// SellerSku The seller SKU of the item.
	SellerSku string `json:"sellerSku"`

	// ShippingWeightCalculationMethod The method used to calculate the estimated shipping weight.
	ShippingWeightCalculationMethod *FulfillmentPreviewItemShippingWeightCalculationMethod `json:"shippingWeightCalculationMethod,omitempty"`
}

// FulfillmentPreviewItemShippingWeightCalculationMethod The method used to calculate the estimated shipping weight.
type FulfillmentPreviewItemShippingWeightCalculationMethod string

// FulfillmentPreviewItemList An array of fulfillment preview item information.
type FulfillmentPreviewItemList = []FulfillmentPreviewItem

// FulfillmentPreviewList An array of fulfillment preview information.
type FulfillmentPreviewList = []FulfillmentPreview

// FulfillmentPreviewShipment Delivery and item information for a shipment in a fulfillment order preview.
type FulfillmentPreviewShipment struct {
	EarliestArrivalDate *Timestamp `json:"earliestArrivalDate,omitempty"`
	EarliestShipDate    *Timestamp `json:"earliestShipDate,omitempty"`

	// FulfillmentPreviewItems An array of fulfillment preview item information.
	FulfillmentPreviewItems FulfillmentPreviewItemList `json:"fulfillmentPreviewItems"`
	LatestArrivalDate       *Timestamp                 `json:"latestArrivalDate,omitempty"`
	LatestShipDate          *Timestamp                 `json:"latestShipDate,omitempty"`

	// ShippingNotes Provides additional insight into the shipment timeline when exact delivery dates are not able to be precomputed.
	ShippingNotes *[]string `json:"shippingNotes,omitempty"`
}

// FulfillmentPreviewShipmentList An array of fulfillment preview shipment information.
type FulfillmentPreviewShipmentList = []FulfillmentPreviewShipment

// FulfillmentReturnItemStatus Indicates if the return item has been processed by a fulfillment center.
type FulfillmentReturnItemStatus string

// FulfillmentShipment Delivery and item information for a shipment in a fulfillment order.
type FulfillmentShipment struct {
	// AmazonShipmentId A shipment identifier assigned by Amazon.
	AmazonShipmentId     string     `json:"amazonShipmentId"`
	EstimatedArrivalDate *Timestamp `json:"estimatedArrivalDate,omitempty"`

	// FulfillmentCenterId An identifier for the fulfillment center that the shipment will be sent from.
	FulfillmentCenterId string `json:"fulfillmentCenterId"`

	// FulfillmentShipmentItem An array of fulfillment shipment item information.
	FulfillmentShipmentItem FulfillmentShipmentItemList `json:"fulfillmentShipmentItem"`

	// FulfillmentShipmentPackage An array of fulfillment shipment package information.
	FulfillmentShipmentPackage *FulfillmentShipmentPackageList `json:"fulfillmentShipmentPackage,omitempty"`

	// FulfillmentShipmentStatus The current status of the shipment.
	FulfillmentShipmentStatus FulfillmentShipmentFulfillmentShipmentStatus `json:"fulfillmentShipmentStatus"`
	ShippingDate              *Timestamp                                   `json:"shippingDate,omitempty"`

	// ShippingNotes Provides additional insight into shipment timeline. Primairly used to communicate that actual delivery dates aren't available.
	ShippingNotes *[]string `json:"shippingNotes,omitempty"`
}

// FulfillmentShipmentFulfillmentShipmentStatus The current status of the shipment.
type FulfillmentShipmentFulfillmentShipmentStatus string

// FulfillmentShipmentItem Item information for a shipment in a fulfillment order.
type FulfillmentShipmentItem struct {
	// PackageNumber An identifier for the package that contains the item quantity.
	PackageNumber *int32 `json:"packageNumber,omitempty"`

	// Quantity The item quantity.
	Quantity Quantity `json:"quantity"`

	// SellerFulfillmentOrderItemId The fulfillment order item identifier that the seller created and submitted with a call to the `createFulfillmentOrder` operation.
	SellerFulfillmentOrderItemId string `json:"sellerFulfillmentOrderItemId"`

	// SellerSku The seller SKU of the item.
	SellerSku string `json:"sellerSku"`

	// SerialNumber The serial number of the shipped item.
	SerialNumber *string `json:"serialNumber,omitempty"`
}

// FulfillmentShipmentItemList An array of fulfillment shipment item information.
type FulfillmentShipmentItemList = []FulfillmentShipmentItem

// FulfillmentShipmentList An array of fulfillment shipment information.
type FulfillmentShipmentList = []FulfillmentShipment

// FulfillmentShipmentPackage Package information for a shipment in a fulfillment order.
type FulfillmentShipmentPackage struct {
	// CarrierCode Identifies the carrier who will deliver the shipment to the recipient.
	CarrierCode          string     `json:"carrierCode"`
	EstimatedArrivalDate *Timestamp `json:"estimatedArrivalDate,omitempty"`

	// PackageNumber Identifies a package in a shipment.
	PackageNumber int32 `json:"packageNumber"`

	// TrackingNumber The tracking number, if provided, can be used to obtain tracking and delivery information.
	TrackingNumber *string `json:"trackingNumber,omitempty"`
}

// FulfillmentShipmentPackageList An array of fulfillment shipment package information.
type FulfillmentShipmentPackageList = []FulfillmentShipmentPackage

// GetFeatureInventoryResponse The breakdown of eligibility inventory by feature.
type GetFeatureInventoryResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The payload for the `getEligibileInventory` operation.
	Payload *GetFeatureInventoryResult `json:"payload,omitempty"`
}

// GetFeatureInventoryResult The payload for the `getEligibileInventory` operation.
type GetFeatureInventoryResult struct {
	// FeatureName The name of the feature.
	FeatureName string `json:"featureName"`

	// FeatureSkus An array of SKUs eligible for this feature and the quantity available.
	FeatureSkus *[]FeatureSku `json:"featureSkus,omitempty"`

	// MarketplaceId The requested marketplace.
	MarketplaceId string `json:"marketplaceId"`

	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"nextToken,omitempty"`
}

// GetFeatureSkuResponse The response schema for the `getFeatureSKU` operation.
type GetFeatureSkuResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The payload for the `getFeatureSKU` operation.
	Payload *GetFeatureSkuResult `json:"payload,omitempty"`
}

// GetFeatureSkuResult The payload for the `getFeatureSKU` operation.
type GetFeatureSkuResult struct {
	// FeatureName The name of the feature.
	FeatureName string `json:"featureName"`

	// IneligibleReasons A list of one or more reasons that the seller SKU is ineligibile for the feature.
	//
	// Possible values:
	// * `MERCHANT_NOT_ENROLLED` - The merchant isn't enrolled for the feature.
	// * `SKU_NOT_ELIGIBLE` - The SKU doesn't reside in a warehouse that supports the feature.
	// * `INVALID_SKU` - There is an issue with the SKU provided.
	IneligibleReasons *[]string `json:"ineligibleReasons,omitempty"`

	// IsEligible When true, the seller SKU is eligible for the requested feature.
	IsEligible bool `json:"isEligible"`

	// MarketplaceId The requested marketplace.
	MarketplaceId string `json:"marketplaceId"`

	// SkuInfo Information about an SKU, including the count available, identifiers, and a list of overlapping SKUs that share the same inventory pool.
	SkuInfo *FeatureSku `json:"skuInfo,omitempty"`
}

// GetFeaturesResponse The response schema for the `getFeatures` operation.
type GetFeaturesResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The payload for the `getFeatures` operation.
	Payload *GetFeaturesResult `json:"payload,omitempty"`
}

// GetFeaturesResult The payload for the `getFeatures` operation.
type GetFeaturesResult struct {
	// Features An array of features.
	Features Features `json:"features"`
}

// GetFulfillmentOrderResponse The response schema for the `getFulfillmentOrder` operation.
type GetFulfillmentOrderResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList                 `json:"errors,omitempty"`
	Payload *GetFulfillmentOrderResult `json:"payload,omitempty"`
}

// GetFulfillmentOrderResult defines model for GetFulfillmentOrderResult.
type GetFulfillmentOrderResult struct {
	// FulfillmentOrder General information about a fulfillment order, including its status.
	FulfillmentOrder FulfillmentOrder `json:"fulfillmentOrder"`

	// FulfillmentOrderItems An array of fulfillment order item information.
	FulfillmentOrderItems FulfillmentOrderItemList `json:"fulfillmentOrderItems"`

	// FulfillmentShipments An array of fulfillment shipment information.
	FulfillmentShipments *FulfillmentShipmentList `json:"fulfillmentShipments,omitempty"`

	// PaymentInformation An array of various payment attributes related to this fulfillment order.
	PaymentInformation *PaymentInformationList `json:"paymentInformation,omitempty"`

	// ReturnAuthorizations An array of return authorization information.
	ReturnAuthorizations ReturnAuthorizationList `json:"returnAuthorizations"`

	// ReturnItems An array of items that Amazon accepted for return. Returns empty if no items were accepted for return.
	ReturnItems ReturnItemList `json:"returnItems"`
}

// GetFulfillmentPreviewItem Item information for a fulfillment order preview.
type GetFulfillmentPreviewItem struct {
	// PerUnitDeclaredValue An amount of money, including units in the form of currency.
	PerUnitDeclaredValue *Money `json:"perUnitDeclaredValue,omitempty"`

	// Quantity The item quantity.
	Quantity Quantity `json:"quantity"`

	// SellerFulfillmentOrderItemId A fulfillment order item identifier that the seller creates to track items in the fulfillment preview.
	SellerFulfillmentOrderItemId string `json:"sellerFulfillmentOrderItemId"`

	// SellerSku The seller SKU of the item.
	SellerSku string `json:"sellerSku"`
}

// GetFulfillmentPreviewItemList An array of fulfillment preview item information.
type GetFulfillmentPreviewItemList = []GetFulfillmentPreviewItem

// GetFulfillmentPreviewRequest The request body schema for the `getFulfillmentPreview` operation.
type GetFulfillmentPreviewRequest struct {
	// Address A physical address.
	Address Address `json:"address"`

	// FeatureConstraints A list of features and their fulfillment policies to apply to the order.
	FeatureConstraints *[]FeatureSettings `json:"featureConstraints,omitempty"`

	// IncludeCODFulfillmentPreview When true, returns all fulfillment order previews both for COD and not for COD. Otherwise, returns only fulfillment order previews that are not for COD.
	IncludeCODFulfillmentPreview *bool `json:"includeCODFulfillmentPreview,omitempty"`

	// IncludeDeliveryWindows When true, returns the `ScheduledDeliveryInfo` response object, which contains the available delivery windows for a Scheduled Delivery. The `ScheduledDeliveryInfo` response object can only be returned for fulfillment order previews with `ShippingSpeedCategories` = `ScheduledDelivery`.
	IncludeDeliveryWindows *bool `json:"includeDeliveryWindows,omitempty"`

	// Items An array of fulfillment preview item information.
	Items GetFulfillmentPreviewItemList `json:"items"`

	// MarketplaceId The marketplace the fulfillment order is placed against.
	MarketplaceId           *string                    `json:"marketplaceId,omitempty"`
	ShippingSpeedCategories *ShippingSpeedCategoryList `json:"shippingSpeedCategories,omitempty"`
}

// GetFulfillmentPreviewResponse The response schema for the `getFulfillmentPreview` operation.
type GetFulfillmentPreviewResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload A list of fulfillment order previews, including estimated shipping weights, estimated shipping fees, and estimated ship dates and arrival dates.
	Payload *GetFulfillmentPreviewResult `json:"payload,omitempty"`
}

// GetFulfillmentPreviewResult A list of fulfillment order previews, including estimated shipping weights, estimated shipping fees, and estimated ship dates and arrival dates.
type GetFulfillmentPreviewResult struct {
	// FulfillmentPreviews An array of fulfillment preview information.
	FulfillmentPreviews *FulfillmentPreviewList `json:"fulfillmentPreviews,omitempty"`
}

// GetPackageTrackingDetailsResponse The response schema for the `getPackageTrackingDetails` operation.
type GetPackageTrackingDetailsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList              `json:"errors,omitempty"`
	Payload *PackageTrackingDetails `json:"payload,omitempty"`
}

// InvalidItemReason The reason that the item is invalid for return.
type InvalidItemReason struct {
	// Description A human readable description of the invalid item reason code.
	Description string `json:"description"`

	// InvalidItemReasonCode A code for why the item is invalid for return.
	InvalidItemReasonCode InvalidItemReasonCode `json:"invalidItemReasonCode"`
}

// InvalidItemReasonCode A code for why the item is invalid for return.
type InvalidItemReasonCode string

// InvalidReturnItem An item that is invalid for return.
type InvalidReturnItem struct {
	// InvalidItemReason The reason that the item is invalid for return.
	InvalidItemReason InvalidItemReason `json:"invalidItemReason"`

	// SellerFulfillmentOrderItemId The identifier assigned to the item by the seller when the fulfillment order was created.
	SellerFulfillmentOrderItemId string `json:"sellerFulfillmentOrderItemId"`

	// SellerReturnItemId An identifier assigned by the seller to the return item.
	SellerReturnItemId string `json:"sellerReturnItemId"`
}

// InvalidReturnItemList An array of invalid return item information.
type InvalidReturnItemList = []InvalidReturnItem

// ListAllFulfillmentOrdersResponse The response schema for the `listAllFulfillmentOrders` operation.
type ListAllFulfillmentOrdersResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList                      `json:"errors,omitempty"`
	Payload *ListAllFulfillmentOrdersResult `json:"payload,omitempty"`
}

// ListAllFulfillmentOrdersResult defines model for ListAllFulfillmentOrdersResult.
type ListAllFulfillmentOrdersResult struct {
	// FulfillmentOrders An array of fulfillment order information.
	FulfillmentOrders *[]FulfillmentOrder `json:"fulfillmentOrders,omitempty"`

	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"nextToken,omitempty"`
}

// ListReturnReasonCodesResponse The response schema for the `listReturnReasonCodes` operation.
type ListReturnReasonCodesResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList                   `json:"errors,omitempty"`
	Payload *ListReturnReasonCodesResult `json:"payload,omitempty"`
}

// ListReturnReasonCodesResult defines model for ListReturnReasonCodesResult.
type ListReturnReasonCodesResult struct {
	// ReasonCodeDetails An array of return reason code details.
	ReasonCodeDetails *ReasonCodeDetailsList `json:"reasonCodeDetails,omitempty"`
}

// Money An amount of money, including units in the form of currency.
type Money struct {
	// CurrencyCode Three digit currency code in ISO 4217 format.
	CurrencyCode string `json:"currencyCode"`

	// Value A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation.
	Value Decimal `json:"value"`
}

// NotificationEmailList A list of email addresses that the seller provides that are used by Amazon to send ship-complete notifications to recipients on behalf of the seller.
type NotificationEmailList = []string

// PackageTrackingDetails defines model for PackageTrackingDetails.
type PackageTrackingDetails struct {
	// AdditionalLocationInfo Additional location information.
	AdditionalLocationInfo *AdditionalLocationInfo `json:"additionalLocationInfo,omitempty"`

	// CarrierCode The name of the carrier.
	CarrierCode *string `json:"carrierCode,omitempty"`

	// CarrierPhoneNumber The phone number of the carrier.
	CarrierPhoneNumber *string `json:"carrierPhoneNumber,omitempty"`

	// CarrierURL The URL of the carrier's website.
	CarrierURL *string `json:"carrierURL,omitempty"`

	// CurrentStatus The current delivery status of the package.
	CurrentStatus *CurrentStatus `json:"currentStatus,omitempty"`

	// CurrentStatusDescription Description corresponding to the `CurrentStatus` value.
	CurrentStatusDescription *string `json:"currentStatusDescription,omitempty"`

	// CustomerTrackingLink Link on swiship.com that allows customers to track the package.
	CustomerTrackingLink *string    `json:"customerTrackingLink,omitempty"`
	EstimatedArrivalDate *Timestamp `json:"estimatedArrivalDate,omitempty"`

	// PackageNumber The package identifier.
	PackageNumber int32      `json:"packageNumber"`
	ShipDate      *Timestamp `json:"shipDate,omitempty"`

	// ShipToAddress Address information for tracking the package.
	ShipToAddress *TrackingAddress `json:"shipToAddress,omitempty"`

	// SignedForBy The name of the person who signed for the package.
	SignedForBy *string `json:"signedForBy,omitempty"`

	// TrackingEvents An array of tracking event information.
	TrackingEvents *TrackingEventList `json:"trackingEvents,omitempty"`

	// TrackingNumber The tracking number for the package.
	TrackingNumber *string `json:"trackingNumber,omitempty"`
}

// PaymentInformation The attributes related to the payment made from customer to seller for this order.
type PaymentInformation struct {
	PaymentDate Timestamp `json:"paymentDate"`

	// PaymentMode The transaction mode of this payment.
	PaymentMode string `json:"paymentMode"`

	// PaymentTransactionId The transaction identifier of this payment.
	PaymentTransactionId string `json:"paymentTransactionId"`
}

// PaymentInformationList An array of various payment attributes related to this fulfillment order.
type PaymentInformationList = []PaymentInformation

// Quantity The item quantity.
type Quantity = int32

// ReasonCodeDetails A return reason code, a description, and an optional description translation.
type ReasonCodeDetails struct {
	// Description A human readable description of the return reason code.
	Description string `json:"description"`

	// ReturnReasonCode A code that indicates a valid return reason.
	ReturnReasonCode string `json:"returnReasonCode"`

	// TranslatedDescription A translation of the description. The translation is in the language specified in the Language request parameter.
	TranslatedDescription *string `json:"translatedDescription,omitempty"`
}

// ReasonCodeDetailsList An array of return reason code details.
type ReasonCodeDetailsList = []ReasonCodeDetails

// ReturnAuthorization Return authorization information for items accepted for return.
type ReturnAuthorization struct {
	// AmazonRmaId The return merchandise authorization (RMA) that Amazon needs to process the return.
	AmazonRmaId string `json:"amazonRmaId"`

	// FulfillmentCenterId An identifier for the Amazon fulfillment center that the return items should be sent to.
	FulfillmentCenterId string `json:"fulfillmentCenterId"`

	// ReturnAuthorizationId An identifier for the return authorization. This identifier associates return items with the return authorization used to return them.
	ReturnAuthorizationId string `json:"returnAuthorizationId"`

	// ReturnToAddress A physical address.
	ReturnToAddress Address `json:"returnToAddress"`

	// RmaPageURL A URL for a web page that contains the return authorization barcode and the mailing label. This does not include pre-paid shipping.
	RmaPageURL string `json:"rmaPageURL"`
}

// ReturnAuthorizationList An array of return authorization information.
type ReturnAuthorizationList = []ReturnAuthorization

// ReturnItem An item that Amazon accepted for return.
type ReturnItem struct {
	// AmazonReturnReasonCode The return reason code that the Amazon fulfillment center assigned to the return item.
	AmazonReturnReasonCode *string `json:"amazonReturnReasonCode,omitempty"`

	// AmazonShipmentId The identifier for the shipment that is associated with the return item.
	AmazonShipmentId string `json:"amazonShipmentId"`

	// FulfillmentCenterId The identifier for the Amazon fulfillment center that processed the return item.
	FulfillmentCenterId *string `json:"fulfillmentCenterId,omitempty"`

	// ReturnAuthorizationId Identifies the return authorization used to return this item. Refer to `ReturnAuthorization`.
	ReturnAuthorizationId *string `json:"returnAuthorizationId,omitempty"`

	// ReturnComment An optional comment about the return item.
	ReturnComment *string `json:"returnComment,omitempty"`

	// ReturnReceivedCondition The condition of the return item when received by an Amazon fulfillment center.
	ReturnReceivedCondition *ReturnItemDisposition `json:"returnReceivedCondition,omitempty"`

	// SellerFulfillmentOrderItemId The identifier assigned to the item by the seller when the fulfillment order was created.
	SellerFulfillmentOrderItemId string `json:"sellerFulfillmentOrderItemId"`

	// SellerReturnItemId An identifier assigned by the seller to the return item.
	SellerReturnItemId string `json:"sellerReturnItemId"`

	// SellerReturnReasonCode The return reason code assigned to the return item by the seller.
	SellerReturnReasonCode string `json:"sellerReturnReasonCode"`

	// Status Indicates if the return item has been processed by a fulfillment center.
	Status            FulfillmentReturnItemStatus `json:"status"`
	StatusChangedDate Timestamp                   `json:"statusChangedDate"`
}

// ReturnItemDisposition The condition of the return item when received by an Amazon fulfillment center.
type ReturnItemDisposition string

// ReturnItemList An array of items that Amazon accepted for return. Returns empty if no items were accepted for return.
type ReturnItemList = []ReturnItem

// ScheduledDeliveryInfo Delivery information for a scheduled delivery. This is only available in the JP marketplace.
type ScheduledDeliveryInfo struct {
	// DeliveryTimeZone The time zone of the destination address for the fulfillment order preview. Must be an IANA time zone name. Example: Asia/Tokyo.
	DeliveryTimeZone string `json:"deliveryTimeZone"`

	// DeliveryWindows An array of delivery windows.
	DeliveryWindows DeliveryWindowList `json:"deliveryWindows"`
}

// ShippingSpeedCategory The shipping method used for the fulfillment order. When this value is `ScheduledDelivery`, choose Ship for the `fulfillmentAction`. Hold is not a valid `fulfillmentAction` value when the `shippingSpeedCategory` value is `ScheduledDelivery`.
type ShippingSpeedCategory string

// ShippingSpeedCategoryList defines model for ShippingSpeedCategoryList.
type ShippingSpeedCategoryList = []ShippingSpeedCategory

// StringList defines model for StringList.
type StringList = []string

// SubmitFulfillmentOrderStatusUpdateRequest The request body schema for the `submitFulfillmentOrderStatusUpdate` operation.
type SubmitFulfillmentOrderStatusUpdateRequest struct {
	// FulfillmentOrderStatus The current status of the fulfillment order.
	FulfillmentOrderStatus *FulfillmentOrderStatus `json:"fulfillmentOrderStatus,omitempty"`
}

// SubmitFulfillmentOrderStatusUpdateResponse The response schema for the `SubmitFulfillmentOrderStatusUpdate` operation.
type SubmitFulfillmentOrderStatusUpdateResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// Timestamp defines model for Timestamp.
type Timestamp = time.Time

// TrackingAddress Address information for tracking the package.
type TrackingAddress struct {
	// City The city.
	City string `json:"city"`

	// Country The country.
	Country string `json:"country"`

	// State The state.
	State string `json:"state"`
}

// TrackingEvent Information for tracking package deliveries.
type TrackingEvent struct {
	// EventAddress Address information for tracking the package.
	EventAddress TrackingAddress `json:"eventAddress"`

	// EventCode The event code for the delivery event.
	EventCode EventCode `json:"eventCode"`
	EventDate Timestamp `json:"eventDate"`

	// EventDescription A description for the corresponding event code.
	EventDescription string `json:"eventDescription"`
}

// TrackingEventList An array of tracking event information.
type TrackingEventList = []TrackingEvent

// UnfulfillablePreviewItem Information about unfulfillable items in a fulfillment order preview.
type UnfulfillablePreviewItem struct {
	ItemUnfulfillableReasons *StringList `json:"itemUnfulfillableReasons,omitempty"`

	// Quantity The item quantity.
	Quantity Quantity `json:"quantity"`

	// SellerFulfillmentOrderItemId A fulfillment order item identifier created with a call to the `getFulfillmentPreview` operation.
	SellerFulfillmentOrderItemId string `json:"sellerFulfillmentOrderItemId"`

	// SellerSku The seller SKU of the item.
	SellerSku string `json:"sellerSku"`
}

// UnfulfillablePreviewItemList An array of unfulfillable preview item information.
type UnfulfillablePreviewItemList = []UnfulfillablePreviewItem

// UpdateFulfillmentOrderItem Item information for updating a fulfillment order.
type UpdateFulfillmentOrderItem struct {
	// DisplayableComment Item-specific text that displays in recipient-facing materials such as the outbound shipment packing slip.
	DisplayableComment *string `json:"displayableComment,omitempty"`

	// FulfillmentNetworkSku Amazon's fulfillment network SKU of the item.
	FulfillmentNetworkSku *string `json:"fulfillmentNetworkSku,omitempty"`

	// GiftMessage A message to the gift recipient, if applicable.
	GiftMessage *string `json:"giftMessage,omitempty"`

	// OrderItemDisposition Indicates whether the item is sellable or unsellable.
	OrderItemDisposition *string `json:"orderItemDisposition,omitempty"`

	// PerUnitDeclaredValue An amount of money, including units in the form of currency.
	PerUnitDeclaredValue *Money `json:"perUnitDeclaredValue,omitempty"`

	// PerUnitPrice An amount of money, including units in the form of currency.
	PerUnitPrice *Money `json:"perUnitPrice,omitempty"`

	// PerUnitTax An amount of money, including units in the form of currency.
	PerUnitTax *Money `json:"perUnitTax,omitempty"`

	// Quantity The item quantity.
	Quantity Quantity `json:"quantity"`

	// SellerFulfillmentOrderItemId Identifies the fulfillment order item to update. Created with a previous call to the `createFulfillmentOrder` operation.
	SellerFulfillmentOrderItemId string `json:"sellerFulfillmentOrderItemId"`

	// SellerSku The seller SKU of the item.
	SellerSku *string `json:"sellerSku,omitempty"`
}

// UpdateFulfillmentOrderItemList An array of fulfillment order item information for updating a fulfillment order.
type UpdateFulfillmentOrderItemList = []UpdateFulfillmentOrderItem

// UpdateFulfillmentOrderRequest The request body schema for the `updateFulfillmentOrder` operation.
type UpdateFulfillmentOrderRequest struct {
	// DestinationAddress A physical address.
	DestinationAddress *Address `json:"destinationAddress,omitempty"`

	// DisplayableOrderComment Order-specific text that appears in recipient-facing materials such as the outbound shipment packing slip.
	DisplayableOrderComment *string    `json:"displayableOrderComment,omitempty"`
	DisplayableOrderDate    *Timestamp `json:"displayableOrderDate,omitempty"`

	// DisplayableOrderId A fulfillment order identifier that the seller creates. This value displays as the order identifier in recipient-facing materials such as the outbound shipment packing slip. The value of `DisplayableOrderId` should match the order identifier that the seller provides to the recipient. The seller can use the `SellerFulfillmentOrderId` for this value or they can specify an alternate value if they want the recipient to reference an alternate order identifier.
	DisplayableOrderId *string `json:"displayableOrderId,omitempty"`

	// FeatureConstraints A list of features and their fulfillment policies to apply to the order.
	FeatureConstraints *[]FeatureSettings `json:"featureConstraints,omitempty"`

	// FulfillmentAction Specifies whether the fulfillment order should ship now or have an order hold put on it.
	FulfillmentAction *FulfillmentAction `json:"fulfillmentAction,omitempty"`

	// FulfillmentPolicy The `FulfillmentPolicy` value specified when you submitted the `createFulfillmentOrder` operation.
	FulfillmentPolicy *FulfillmentPolicy `json:"fulfillmentPolicy,omitempty"`

	// Items An array of fulfillment order item information for updating a fulfillment order.
	Items *UpdateFulfillmentOrderItemList `json:"items,omitempty"`

	// MarketplaceId The marketplace the fulfillment order is placed against.
	MarketplaceId *string `json:"marketplaceId,omitempty"`

	// NotificationEmails A list of email addresses that the seller provides that are used by Amazon to send ship-complete notifications to recipients on behalf of the seller.
	NotificationEmails *NotificationEmailList `json:"notificationEmails,omitempty"`

	// ShipFromCountryCode The two-character country code for the country from which the fulfillment order ships. Must be in ISO 3166-1 alpha-2 format.
	ShipFromCountryCode *string `json:"shipFromCountryCode,omitempty"`

	// ShippingSpeedCategory The shipping method used for the fulfillment order. When this value is `ScheduledDelivery`, choose Ship for the `fulfillmentAction`. Hold is not a valid `fulfillmentAction` value when the `shippingSpeedCategory` value is `ScheduledDelivery`.
	ShippingSpeedCategory *ShippingSpeedCategory `json:"shippingSpeedCategory,omitempty"`
}

// UpdateFulfillmentOrderResponse The response schema for the `updateFulfillmentOrder` operation.
type UpdateFulfillmentOrderResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// Weight The weight.
type Weight struct {
	// Unit The unit of weight.
	Unit WeightUnit `json:"unit"`

	// Value The weight value.
	Value string `json:"value"`
}

// WeightUnit The unit of weight.
type WeightUnit string

// GetFeaturesParams defines parameters for GetFeatures.
type GetFeaturesParams struct {
	// MarketplaceId The marketplace for which to return the list of features.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// GetFeatureInventoryParams defines parameters for GetFeatureInventory.
type GetFeatureInventoryParams struct {
	// MarketplaceId The marketplace for which to return a list of the inventory that is eligible for the specified feature.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`

	// NextToken A string token returned in the response to your previous request that is used to return the next response page. A value of null will return the first page.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// GetFeatureSKUParams defines parameters for GetFeatureSKU.
type GetFeatureSKUParams struct {
	// MarketplaceId The marketplace for which to return the count.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// ListAllFulfillmentOrdersParams defines parameters for ListAllFulfillmentOrders.
type ListAllFulfillmentOrdersParams struct {
	// QueryStartDate A date used to select fulfillment orders that were last updated after (or at) a specified time. An update is defined as any change in fulfillment order status, including the creation of a new fulfillment order.
	QueryStartDate *time.Time `form:"queryStartDate,omitempty" json:"queryStartDate,omitempty"`

	// NextToken A string token returned in the response to your previous request.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// ListReturnReasonCodesParams defines parameters for ListReturnReasonCodes.
type ListReturnReasonCodesParams struct {
	// SellerSku The seller SKU for which return reason codes are required.
	SellerSku string `form:"sellerSku" json:"sellerSku"`

	// MarketplaceId The marketplace for which the seller wants return reason codes.
	MarketplaceId *string `form:"marketplaceId,omitempty" json:"marketplaceId,omitempty"`

	// SellerFulfillmentOrderId The identifier assigned to the item by the seller when the fulfillment order was created. The service uses this value to determine the marketplace for which the seller wants return reason codes.
	SellerFulfillmentOrderId *string `form:"sellerFulfillmentOrderId,omitempty" json:"sellerFulfillmentOrderId,omitempty"`

	// Language The language that the `TranslatedDescription` property of the `ReasonCodeDetails` response object should be translated into.
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// GetPackageTrackingDetailsParams defines parameters for GetPackageTrackingDetails.
type GetPackageTrackingDetailsParams struct {
	// PackageNumber The unencrypted package identifier returned by the `getFulfillmentOrder` operation.
	PackageNumber int32 `form:"packageNumber" json:"packageNumber"`
}

// CreateFulfillmentOrderJSONRequestBody defines body for CreateFulfillmentOrder for application/json ContentType.
type CreateFulfillmentOrderJSONRequestBody = CreateFulfillmentOrderRequest

// GetFulfillmentPreviewJSONRequestBody defines body for GetFulfillmentPreview for application/json ContentType.
type GetFulfillmentPreviewJSONRequestBody = GetFulfillmentPreviewRequest

// UpdateFulfillmentOrderJSONRequestBody defines body for UpdateFulfillmentOrder for application/json ContentType.
type UpdateFulfillmentOrderJSONRequestBody = UpdateFulfillmentOrderRequest

// CreateFulfillmentReturnJSONRequestBody defines body for CreateFulfillmentReturn for application/json ContentType.
type CreateFulfillmentReturnJSONRequestBody = CreateFulfillmentReturnRequest

// SubmitFulfillmentOrderStatusUpdateJSONRequestBody defines body for SubmitFulfillmentOrderStatusUpdate for application/json ContentType.
type SubmitFulfillmentOrderStatusUpdateJSONRequestBody = SubmitFulfillmentOrderStatusUpdateRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetFeatures request
	GetFeatures(ctx context.Context, params *GetFeaturesParams) (*http.Response, error)

	// GetFeatureInventory request
	GetFeatureInventory(ctx context.Context, featureName string, params *GetFeatureInventoryParams) (*http.Response, error)

	// GetFeatureSKU request
	GetFeatureSKU(ctx context.Context, featureName string, sellerSku string, params *GetFeatureSKUParams) (*http.Response, error)

	// ListAllFulfillmentOrders request
	ListAllFulfillmentOrders(ctx context.Context, params *ListAllFulfillmentOrdersParams) (*http.Response, error)

	// CreateFulfillmentOrderWithBody request with any body
	CreateFulfillmentOrderWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateFulfillmentOrder(ctx context.Context, body CreateFulfillmentOrderJSONRequestBody) (*http.Response, error)

	// GetFulfillmentPreviewWithBody request with any body
	GetFulfillmentPreviewWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	GetFulfillmentPreview(ctx context.Context, body GetFulfillmentPreviewJSONRequestBody) (*http.Response, error)

	// GetFulfillmentOrder request
	GetFulfillmentOrder(ctx context.Context, sellerFulfillmentOrderId string) (*http.Response, error)

	// UpdateFulfillmentOrderWithBody request with any body
	UpdateFulfillmentOrderWithBody(ctx context.Context, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*http.Response, error)

	UpdateFulfillmentOrder(ctx context.Context, sellerFulfillmentOrderId string, body UpdateFulfillmentOrderJSONRequestBody) (*http.Response, error)

	// CancelFulfillmentOrder request
	CancelFulfillmentOrder(ctx context.Context, sellerFulfillmentOrderId string) (*http.Response, error)

	// CreateFulfillmentReturnWithBody request with any body
	CreateFulfillmentReturnWithBody(ctx context.Context, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*http.Response, error)

	CreateFulfillmentReturn(ctx context.Context, sellerFulfillmentOrderId string, body CreateFulfillmentReturnJSONRequestBody) (*http.Response, error)

	// SubmitFulfillmentOrderStatusUpdateWithBody request with any body
	SubmitFulfillmentOrderStatusUpdateWithBody(ctx context.Context, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*http.Response, error)

	SubmitFulfillmentOrderStatusUpdate(ctx context.Context, sellerFulfillmentOrderId string, body SubmitFulfillmentOrderStatusUpdateJSONRequestBody) (*http.Response, error)

	// ListReturnReasonCodes request
	ListReturnReasonCodes(ctx context.Context, params *ListReturnReasonCodesParams) (*http.Response, error)

	// GetPackageTrackingDetails request
	GetPackageTrackingDetails(ctx context.Context, params *GetPackageTrackingDetailsParams) (*http.Response, error)
}

func (c *Client) GetFeatures(ctx context.Context, params *GetFeaturesParams) (*http.Response, error) {
	req, err := NewGetFeaturesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetFeatureInventory(ctx context.Context, featureName string, params *GetFeatureInventoryParams) (*http.Response, error) {
	req, err := NewGetFeatureInventoryRequest(c.Server, featureName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetFeatureSKU(ctx context.Context, featureName string, sellerSku string, params *GetFeatureSKUParams) (*http.Response, error) {
	req, err := NewGetFeatureSKURequest(c.Server, featureName, sellerSku, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListAllFulfillmentOrders(ctx context.Context, params *ListAllFulfillmentOrdersParams) (*http.Response, error) {
	req, err := NewListAllFulfillmentOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateFulfillmentOrderWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateFulfillmentOrderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateFulfillmentOrder(ctx context.Context, body CreateFulfillmentOrderJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateFulfillmentOrderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetFulfillmentPreviewWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetFulfillmentPreviewRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetFulfillmentPreview(ctx context.Context, body GetFulfillmentPreviewJSONRequestBody) (*http.Response, error) {
	req, err := NewGetFulfillmentPreviewRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetFulfillmentOrder(ctx context.Context, sellerFulfillmentOrderId string) (*http.Response, error) {
	req, err := NewGetFulfillmentOrderRequest(c.Server, sellerFulfillmentOrderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateFulfillmentOrderWithBody(ctx context.Context, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateFulfillmentOrderRequestWithBody(c.Server, sellerFulfillmentOrderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateFulfillmentOrder(ctx context.Context, sellerFulfillmentOrderId string, body UpdateFulfillmentOrderJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateFulfillmentOrderRequest(c.Server, sellerFulfillmentOrderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CancelFulfillmentOrder(ctx context.Context, sellerFulfillmentOrderId string) (*http.Response, error) {
	req, err := NewCancelFulfillmentOrderRequest(c.Server, sellerFulfillmentOrderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateFulfillmentReturnWithBody(ctx context.Context, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateFulfillmentReturnRequestWithBody(c.Server, sellerFulfillmentOrderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateFulfillmentReturn(ctx context.Context, sellerFulfillmentOrderId string, body CreateFulfillmentReturnJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateFulfillmentReturnRequest(c.Server, sellerFulfillmentOrderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SubmitFulfillmentOrderStatusUpdateWithBody(ctx context.Context, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSubmitFulfillmentOrderStatusUpdateRequestWithBody(c.Server, sellerFulfillmentOrderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SubmitFulfillmentOrderStatusUpdate(ctx context.Context, sellerFulfillmentOrderId string, body SubmitFulfillmentOrderStatusUpdateJSONRequestBody) (*http.Response, error) {
	req, err := NewSubmitFulfillmentOrderStatusUpdateRequest(c.Server, sellerFulfillmentOrderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListReturnReasonCodes(ctx context.Context, params *ListReturnReasonCodesParams) (*http.Response, error) {
	req, err := NewListReturnReasonCodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetPackageTrackingDetails(ctx context.Context, params *GetPackageTrackingDetailsParams) (*http.Response, error) {
	req, err := NewGetPackageTrackingDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewGetFeaturesRequest generates requests for GetFeatures
func NewGetFeaturesRequest(server string, params *GetFeaturesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeatureInventoryRequest generates requests for GetFeatureInventory
func NewGetFeatureInventoryRequest(server string, featureName string, params *GetFeatureInventoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "featureName", runtime.ParamLocationPath, featureName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/features/inventory/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeatureSKURequest generates requests for GetFeatureSKU
func NewGetFeatureSKURequest(server string, featureName string, sellerSku string, params *GetFeatureSKUParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "featureName", runtime.ParamLocationPath, featureName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sellerSku", runtime.ParamLocationPath, sellerSku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/features/inventory/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllFulfillmentOrdersRequest generates requests for ListAllFulfillmentOrders
func NewListAllFulfillmentOrdersRequest(server string, params *ListAllFulfillmentOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/fulfillmentOrders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.QueryStartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queryStartDate", runtime.ParamLocationQuery, *params.QueryStartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFulfillmentOrderRequest calls the generic CreateFulfillmentOrder builder with application/json body
func NewCreateFulfillmentOrderRequest(server string, body CreateFulfillmentOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFulfillmentOrderRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFulfillmentOrderRequestWithBody generates requests for CreateFulfillmentOrder with any type of body
func NewCreateFulfillmentOrderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/fulfillmentOrders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFulfillmentPreviewRequest calls the generic GetFulfillmentPreview builder with application/json body
func NewGetFulfillmentPreviewRequest(server string, body GetFulfillmentPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetFulfillmentPreviewRequestWithBody(server, "application/json", bodyReader)
}

// NewGetFulfillmentPreviewRequestWithBody generates requests for GetFulfillmentPreview with any type of body
func NewGetFulfillmentPreviewRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/fulfillmentOrders/preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFulfillmentOrderRequest generates requests for GetFulfillmentOrder
func NewGetFulfillmentOrderRequest(server string, sellerFulfillmentOrderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerFulfillmentOrderId", runtime.ParamLocationPath, sellerFulfillmentOrderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/fulfillmentOrders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFulfillmentOrderRequest calls the generic UpdateFulfillmentOrder builder with application/json body
func NewUpdateFulfillmentOrderRequest(server string, sellerFulfillmentOrderId string, body UpdateFulfillmentOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFulfillmentOrderRequestWithBody(server, sellerFulfillmentOrderId, "application/json", bodyReader)
}

// NewUpdateFulfillmentOrderRequestWithBody generates requests for UpdateFulfillmentOrder with any type of body
func NewUpdateFulfillmentOrderRequestWithBody(server string, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerFulfillmentOrderId", runtime.ParamLocationPath, sellerFulfillmentOrderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/fulfillmentOrders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelFulfillmentOrderRequest generates requests for CancelFulfillmentOrder
func NewCancelFulfillmentOrderRequest(server string, sellerFulfillmentOrderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerFulfillmentOrderId", runtime.ParamLocationPath, sellerFulfillmentOrderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/fulfillmentOrders/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFulfillmentReturnRequest calls the generic CreateFulfillmentReturn builder with application/json body
func NewCreateFulfillmentReturnRequest(server string, sellerFulfillmentOrderId string, body CreateFulfillmentReturnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFulfillmentReturnRequestWithBody(server, sellerFulfillmentOrderId, "application/json", bodyReader)
}

// NewCreateFulfillmentReturnRequestWithBody generates requests for CreateFulfillmentReturn with any type of body
func NewCreateFulfillmentReturnRequestWithBody(server string, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerFulfillmentOrderId", runtime.ParamLocationPath, sellerFulfillmentOrderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/fulfillmentOrders/%s/return", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSubmitFulfillmentOrderStatusUpdateRequest calls the generic SubmitFulfillmentOrderStatusUpdate builder with application/json body
func NewSubmitFulfillmentOrderStatusUpdateRequest(server string, sellerFulfillmentOrderId string, body SubmitFulfillmentOrderStatusUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitFulfillmentOrderStatusUpdateRequestWithBody(server, sellerFulfillmentOrderId, "application/json", bodyReader)
}

// NewSubmitFulfillmentOrderStatusUpdateRequestWithBody generates requests for SubmitFulfillmentOrderStatusUpdate with any type of body
func NewSubmitFulfillmentOrderStatusUpdateRequestWithBody(server string, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerFulfillmentOrderId", runtime.ParamLocationPath, sellerFulfillmentOrderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/fulfillmentOrders/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListReturnReasonCodesRequest generates requests for ListReturnReasonCodes
func NewListReturnReasonCodesRequest(server string, params *ListReturnReasonCodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/returnReasonCodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sellerSku", runtime.ParamLocationQuery, params.SellerSku); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.MarketplaceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, *params.MarketplaceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SellerFulfillmentOrderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sellerFulfillmentOrderId", runtime.ParamLocationQuery, *params.SellerFulfillmentOrderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackageTrackingDetailsRequest generates requests for GetPackageTrackingDetails
func NewGetPackageTrackingDetailsRequest(server string, params *GetPackageTrackingDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/outbound/2020-07-01/tracking")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "packageNumber", runtime.ParamLocationQuery, params.PackageNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetFeaturesWithResponse request
	GetFeaturesWithResponse(ctx context.Context, params *GetFeaturesParams) (*GetFeaturesResp, error)

	// GetFeatureInventoryWithResponse request
	GetFeatureInventoryWithResponse(ctx context.Context, featureName string, params *GetFeatureInventoryParams) (*GetFeatureInventoryResp, error)

	// GetFeatureSKUWithResponse request
	GetFeatureSKUWithResponse(ctx context.Context, featureName string, sellerSku string, params *GetFeatureSKUParams) (*GetFeatureSKUResp, error)

	// ListAllFulfillmentOrdersWithResponse request
	ListAllFulfillmentOrdersWithResponse(ctx context.Context, params *ListAllFulfillmentOrdersParams) (*ListAllFulfillmentOrdersResp, error)

	// CreateFulfillmentOrderWithBodyWithResponse request with any body
	CreateFulfillmentOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateFulfillmentOrderResp, error)

	CreateFulfillmentOrderWithResponse(ctx context.Context, body CreateFulfillmentOrderJSONRequestBody) (*CreateFulfillmentOrderResp, error)

	// GetFulfillmentPreviewWithBodyWithResponse request with any body
	GetFulfillmentPreviewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetFulfillmentPreviewResp, error)

	GetFulfillmentPreviewWithResponse(ctx context.Context, body GetFulfillmentPreviewJSONRequestBody) (*GetFulfillmentPreviewResp, error)

	// GetFulfillmentOrderWithResponse request
	GetFulfillmentOrderWithResponse(ctx context.Context, sellerFulfillmentOrderId string) (*GetFulfillmentOrderResp, error)

	// UpdateFulfillmentOrderWithBodyWithResponse request with any body
	UpdateFulfillmentOrderWithBodyWithResponse(ctx context.Context, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*UpdateFulfillmentOrderResp, error)

	UpdateFulfillmentOrderWithResponse(ctx context.Context, sellerFulfillmentOrderId string, body UpdateFulfillmentOrderJSONRequestBody) (*UpdateFulfillmentOrderResp, error)

	// CancelFulfillmentOrderWithResponse request
	CancelFulfillmentOrderWithResponse(ctx context.Context, sellerFulfillmentOrderId string) (*CancelFulfillmentOrderResp, error)

	// CreateFulfillmentReturnWithBodyWithResponse request with any body
	CreateFulfillmentReturnWithBodyWithResponse(ctx context.Context, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*CreateFulfillmentReturnResp, error)

	CreateFulfillmentReturnWithResponse(ctx context.Context, sellerFulfillmentOrderId string, body CreateFulfillmentReturnJSONRequestBody) (*CreateFulfillmentReturnResp, error)

	// SubmitFulfillmentOrderStatusUpdateWithBodyWithResponse request with any body
	SubmitFulfillmentOrderStatusUpdateWithBodyWithResponse(ctx context.Context, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*SubmitFulfillmentOrderStatusUpdateResp, error)

	SubmitFulfillmentOrderStatusUpdateWithResponse(ctx context.Context, sellerFulfillmentOrderId string, body SubmitFulfillmentOrderStatusUpdateJSONRequestBody) (*SubmitFulfillmentOrderStatusUpdateResp, error)

	// ListReturnReasonCodesWithResponse request
	ListReturnReasonCodesWithResponse(ctx context.Context, params *ListReturnReasonCodesParams) (*ListReturnReasonCodesResp, error)

	// GetPackageTrackingDetailsWithResponse request
	GetPackageTrackingDetailsWithResponse(ctx context.Context, params *GetPackageTrackingDetailsParams) (*GetPackageTrackingDetailsResp, error)
}

type GetFeaturesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFeaturesResponse
	JSON400      *GetFeaturesResponse
	JSON401      *GetFeaturesResponse
	JSON403      *GetFeaturesResponse
	JSON404      *GetFeaturesResponse
	JSON429      *GetFeaturesResponse
	JSON500      *GetFeaturesResponse
	JSON503      *GetFeaturesResponse
}

// Status returns HTTPResponse.Status
func (r GetFeaturesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeaturesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeatureInventoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFeatureInventoryResponse
	JSON400      *GetFeatureInventoryResponse
	JSON401      *GetFeatureInventoryResponse
	JSON403      *GetFeatureInventoryResponse
	JSON404      *GetFeatureInventoryResponse
	JSON429      *GetFeatureInventoryResponse
	JSON500      *GetFeatureInventoryResponse
	JSON503      *GetFeatureInventoryResponse
}

// Status returns HTTPResponse.Status
func (r GetFeatureInventoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeatureInventoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeatureSKUResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFeatureSkuResponse
	JSON400      *GetFeatureSkuResponse
	JSON401      *GetFeatureSkuResponse
	JSON403      *GetFeatureSkuResponse
	JSON404      *GetFeatureSkuResponse
	JSON429      *GetFeatureSkuResponse
	JSON500      *GetFeatureSkuResponse
	JSON503      *GetFeatureSkuResponse
}

// Status returns HTTPResponse.Status
func (r GetFeatureSKUResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeatureSKUResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllFulfillmentOrdersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAllFulfillmentOrdersResponse
	JSON400      *ListAllFulfillmentOrdersResponse
	JSON401      *ListAllFulfillmentOrdersResponse
	JSON403      *ListAllFulfillmentOrdersResponse
	JSON404      *ListAllFulfillmentOrdersResponse
	JSON429      *ListAllFulfillmentOrdersResponse
	JSON500      *ListAllFulfillmentOrdersResponse
	JSON503      *ListAllFulfillmentOrdersResponse
}

// Status returns HTTPResponse.Status
func (r ListAllFulfillmentOrdersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllFulfillmentOrdersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFulfillmentOrderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateFulfillmentOrderResponse
	JSON400      *CreateFulfillmentOrderResponse
	JSON401      *CreateFulfillmentOrderResponse
	JSON403      *CreateFulfillmentOrderResponse
	JSON404      *CreateFulfillmentOrderResponse
	JSON429      *CreateFulfillmentOrderResponse
	JSON500      *CreateFulfillmentOrderResponse
	JSON503      *CreateFulfillmentOrderResponse
}

// Status returns HTTPResponse.Status
func (r CreateFulfillmentOrderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFulfillmentOrderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFulfillmentPreviewResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFulfillmentPreviewResponse
	JSON400      *GetFulfillmentPreviewResponse
	JSON401      *GetFulfillmentPreviewResponse
	JSON403      *GetFulfillmentPreviewResponse
	JSON404      *GetFulfillmentPreviewResponse
	JSON429      *GetFulfillmentPreviewResponse
	JSON500      *GetFulfillmentPreviewResponse
	JSON503      *GetFulfillmentPreviewResponse
}

// Status returns HTTPResponse.Status
func (r GetFulfillmentPreviewResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFulfillmentPreviewResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFulfillmentOrderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFulfillmentOrderResponse
	JSON400      *GetFulfillmentOrderResponse
	JSON401      *GetFulfillmentOrderResponse
	JSON403      *GetFulfillmentOrderResponse
	JSON404      *GetFulfillmentOrderResponse
	JSON429      *GetFulfillmentOrderResponse
	JSON500      *GetFulfillmentOrderResponse
	JSON503      *GetFulfillmentOrderResponse
}

// Status returns HTTPResponse.Status
func (r GetFulfillmentOrderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFulfillmentOrderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFulfillmentOrderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateFulfillmentOrderResponse
	JSON400      *UpdateFulfillmentOrderResponse
	JSON401      *UpdateFulfillmentOrderResponse
	JSON403      *UpdateFulfillmentOrderResponse
	JSON404      *UpdateFulfillmentOrderResponse
	JSON429      *UpdateFulfillmentOrderResponse
	JSON500      *UpdateFulfillmentOrderResponse
	JSON503      *UpdateFulfillmentOrderResponse
}

// Status returns HTTPResponse.Status
func (r UpdateFulfillmentOrderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFulfillmentOrderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelFulfillmentOrderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelFulfillmentOrderResponse
	JSON400      *CancelFulfillmentOrderResponse
	JSON401      *CancelFulfillmentOrderResponse
	JSON403      *CancelFulfillmentOrderResponse
	JSON404      *CancelFulfillmentOrderResponse
	JSON429      *CancelFulfillmentOrderResponse
	JSON500      *CancelFulfillmentOrderResponse
	JSON503      *CancelFulfillmentOrderResponse
}

// Status returns HTTPResponse.Status
func (r CancelFulfillmentOrderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelFulfillmentOrderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFulfillmentReturnResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateFulfillmentReturnResponse
	JSON400      *CreateFulfillmentReturnResponse
	JSON401      *CreateFulfillmentReturnResponse
	JSON403      *CreateFulfillmentReturnResponse
	JSON404      *CreateFulfillmentReturnResponse
	JSON429      *CreateFulfillmentReturnResponse
	JSON500      *CreateFulfillmentReturnResponse
	JSON503      *CreateFulfillmentReturnResponse
}

// Status returns HTTPResponse.Status
func (r CreateFulfillmentReturnResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFulfillmentReturnResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitFulfillmentOrderStatusUpdateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubmitFulfillmentOrderStatusUpdateResponse
	JSON400      *SubmitFulfillmentOrderStatusUpdateResponse
	JSON401      *SubmitFulfillmentOrderStatusUpdateResponse
	JSON403      *SubmitFulfillmentOrderStatusUpdateResponse
	JSON404      *SubmitFulfillmentOrderStatusUpdateResponse
	JSON429      *SubmitFulfillmentOrderStatusUpdateResponse
	JSON500      *SubmitFulfillmentOrderStatusUpdateResponse
	JSON503      *SubmitFulfillmentOrderStatusUpdateResponse
}

// Status returns HTTPResponse.Status
func (r SubmitFulfillmentOrderStatusUpdateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitFulfillmentOrderStatusUpdateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReturnReasonCodesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListReturnReasonCodesResponse
	JSON400      *ListReturnReasonCodesResponse
	JSON401      *ListReturnReasonCodesResponse
	JSON403      *ListReturnReasonCodesResponse
	JSON404      *ListReturnReasonCodesResponse
	JSON429      *ListReturnReasonCodesResponse
	JSON500      *ListReturnReasonCodesResponse
	JSON503      *ListReturnReasonCodesResponse
}

// Status returns HTTPResponse.Status
func (r ListReturnReasonCodesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReturnReasonCodesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageTrackingDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPackageTrackingDetailsResponse
	JSON400      *GetPackageTrackingDetailsResponse
	JSON401      *GetPackageTrackingDetailsResponse
	JSON403      *GetPackageTrackingDetailsResponse
	JSON404      *GetPackageTrackingDetailsResponse
	JSON429      *GetPackageTrackingDetailsResponse
	JSON500      *GetPackageTrackingDetailsResponse
	JSON503      *GetPackageTrackingDetailsResponse
}

// Status returns HTTPResponse.Status
func (r GetPackageTrackingDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageTrackingDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetFeaturesWithResponse request returning *GetFeaturesResp
func (c *ClientWithResponses) GetFeaturesWithResponse(ctx context.Context, params *GetFeaturesParams) (*GetFeaturesResp, error) {
	rsp, err := c.GetFeatures(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetFeaturesResp(rsp)
}

// GetFeatureInventoryWithResponse request returning *GetFeatureInventoryResp
func (c *ClientWithResponses) GetFeatureInventoryWithResponse(ctx context.Context, featureName string, params *GetFeatureInventoryParams) (*GetFeatureInventoryResp, error) {
	rsp, err := c.GetFeatureInventory(ctx, featureName, params)
	if err != nil {
		return nil, err
	}
	return ParseGetFeatureInventoryResp(rsp)
}

// GetFeatureSKUWithResponse request returning *GetFeatureSKUResp
func (c *ClientWithResponses) GetFeatureSKUWithResponse(ctx context.Context, featureName string, sellerSku string, params *GetFeatureSKUParams) (*GetFeatureSKUResp, error) {
	rsp, err := c.GetFeatureSKU(ctx, featureName, sellerSku, params)
	if err != nil {
		return nil, err
	}
	return ParseGetFeatureSKUResp(rsp)
}

// ListAllFulfillmentOrdersWithResponse request returning *ListAllFulfillmentOrdersResp
func (c *ClientWithResponses) ListAllFulfillmentOrdersWithResponse(ctx context.Context, params *ListAllFulfillmentOrdersParams) (*ListAllFulfillmentOrdersResp, error) {
	rsp, err := c.ListAllFulfillmentOrders(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListAllFulfillmentOrdersResp(rsp)
}

// CreateFulfillmentOrderWithBodyWithResponse request with arbitrary body returning *CreateFulfillmentOrderResp
func (c *ClientWithResponses) CreateFulfillmentOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateFulfillmentOrderResp, error) {
	rsp, err := c.CreateFulfillmentOrderWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateFulfillmentOrderResp(rsp)
}

func (c *ClientWithResponses) CreateFulfillmentOrderWithResponse(ctx context.Context, body CreateFulfillmentOrderJSONRequestBody) (*CreateFulfillmentOrderResp, error) {
	rsp, err := c.CreateFulfillmentOrder(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateFulfillmentOrderResp(rsp)
}

// GetFulfillmentPreviewWithBodyWithResponse request with arbitrary body returning *GetFulfillmentPreviewResp
func (c *ClientWithResponses) GetFulfillmentPreviewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetFulfillmentPreviewResp, error) {
	rsp, err := c.GetFulfillmentPreviewWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetFulfillmentPreviewResp(rsp)
}

func (c *ClientWithResponses) GetFulfillmentPreviewWithResponse(ctx context.Context, body GetFulfillmentPreviewJSONRequestBody) (*GetFulfillmentPreviewResp, error) {
	rsp, err := c.GetFulfillmentPreview(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseGetFulfillmentPreviewResp(rsp)
}

// GetFulfillmentOrderWithResponse request returning *GetFulfillmentOrderResp
func (c *ClientWithResponses) GetFulfillmentOrderWithResponse(ctx context.Context, sellerFulfillmentOrderId string) (*GetFulfillmentOrderResp, error) {
	rsp, err := c.GetFulfillmentOrder(ctx, sellerFulfillmentOrderId)
	if err != nil {
		return nil, err
	}
	return ParseGetFulfillmentOrderResp(rsp)
}

// UpdateFulfillmentOrderWithBodyWithResponse request with arbitrary body returning *UpdateFulfillmentOrderResp
func (c *ClientWithResponses) UpdateFulfillmentOrderWithBodyWithResponse(ctx context.Context, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*UpdateFulfillmentOrderResp, error) {
	rsp, err := c.UpdateFulfillmentOrderWithBody(ctx, sellerFulfillmentOrderId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFulfillmentOrderResp(rsp)
}

func (c *ClientWithResponses) UpdateFulfillmentOrderWithResponse(ctx context.Context, sellerFulfillmentOrderId string, body UpdateFulfillmentOrderJSONRequestBody) (*UpdateFulfillmentOrderResp, error) {
	rsp, err := c.UpdateFulfillmentOrder(ctx, sellerFulfillmentOrderId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFulfillmentOrderResp(rsp)
}

// CancelFulfillmentOrderWithResponse request returning *CancelFulfillmentOrderResp
func (c *ClientWithResponses) CancelFulfillmentOrderWithResponse(ctx context.Context, sellerFulfillmentOrderId string) (*CancelFulfillmentOrderResp, error) {
	rsp, err := c.CancelFulfillmentOrder(ctx, sellerFulfillmentOrderId)
	if err != nil {
		return nil, err
	}
	return ParseCancelFulfillmentOrderResp(rsp)
}

// CreateFulfillmentReturnWithBodyWithResponse request with arbitrary body returning *CreateFulfillmentReturnResp
func (c *ClientWithResponses) CreateFulfillmentReturnWithBodyWithResponse(ctx context.Context, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*CreateFulfillmentReturnResp, error) {
	rsp, err := c.CreateFulfillmentReturnWithBody(ctx, sellerFulfillmentOrderId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateFulfillmentReturnResp(rsp)
}

func (c *ClientWithResponses) CreateFulfillmentReturnWithResponse(ctx context.Context, sellerFulfillmentOrderId string, body CreateFulfillmentReturnJSONRequestBody) (*CreateFulfillmentReturnResp, error) {
	rsp, err := c.CreateFulfillmentReturn(ctx, sellerFulfillmentOrderId, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateFulfillmentReturnResp(rsp)
}

// SubmitFulfillmentOrderStatusUpdateWithBodyWithResponse request with arbitrary body returning *SubmitFulfillmentOrderStatusUpdateResp
func (c *ClientWithResponses) SubmitFulfillmentOrderStatusUpdateWithBodyWithResponse(ctx context.Context, sellerFulfillmentOrderId string, contentType string, body io.Reader) (*SubmitFulfillmentOrderStatusUpdateResp, error) {
	rsp, err := c.SubmitFulfillmentOrderStatusUpdateWithBody(ctx, sellerFulfillmentOrderId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitFulfillmentOrderStatusUpdateResp(rsp)
}

func (c *ClientWithResponses) SubmitFulfillmentOrderStatusUpdateWithResponse(ctx context.Context, sellerFulfillmentOrderId string, body SubmitFulfillmentOrderStatusUpdateJSONRequestBody) (*SubmitFulfillmentOrderStatusUpdateResp, error) {
	rsp, err := c.SubmitFulfillmentOrderStatusUpdate(ctx, sellerFulfillmentOrderId, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitFulfillmentOrderStatusUpdateResp(rsp)
}

// ListReturnReasonCodesWithResponse request returning *ListReturnReasonCodesResp
func (c *ClientWithResponses) ListReturnReasonCodesWithResponse(ctx context.Context, params *ListReturnReasonCodesParams) (*ListReturnReasonCodesResp, error) {
	rsp, err := c.ListReturnReasonCodes(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListReturnReasonCodesResp(rsp)
}

// GetPackageTrackingDetailsWithResponse request returning *GetPackageTrackingDetailsResp
func (c *ClientWithResponses) GetPackageTrackingDetailsWithResponse(ctx context.Context, params *GetPackageTrackingDetailsParams) (*GetPackageTrackingDetailsResp, error) {
	rsp, err := c.GetPackageTrackingDetails(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageTrackingDetailsResp(rsp)
}

// ParseGetFeaturesResp parses an HTTP response from a GetFeaturesWithResponse call
func ParseGetFeaturesResp(rsp *http.Response) (*GetFeaturesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeaturesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFeaturesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetFeaturesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetFeaturesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetFeaturesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetFeaturesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetFeaturesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetFeaturesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetFeaturesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetFeatureInventoryResp parses an HTTP response from a GetFeatureInventoryWithResponse call
func ParseGetFeatureInventoryResp(rsp *http.Response) (*GetFeatureInventoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeatureInventoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFeatureInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetFeatureInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetFeatureInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetFeatureInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetFeatureInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetFeatureInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetFeatureInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetFeatureInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetFeatureSKUResp parses an HTTP response from a GetFeatureSKUWithResponse call
func ParseGetFeatureSKUResp(rsp *http.Response) (*GetFeatureSKUResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeatureSKUResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFeatureSkuResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetFeatureSkuResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetFeatureSkuResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetFeatureSkuResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetFeatureSkuResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetFeatureSkuResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetFeatureSkuResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetFeatureSkuResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListAllFulfillmentOrdersResp parses an HTTP response from a ListAllFulfillmentOrdersWithResponse call
func ParseListAllFulfillmentOrdersResp(rsp *http.Response) (*ListAllFulfillmentOrdersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllFulfillmentOrdersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAllFulfillmentOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ListAllFulfillmentOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ListAllFulfillmentOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ListAllFulfillmentOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ListAllFulfillmentOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ListAllFulfillmentOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ListAllFulfillmentOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ListAllFulfillmentOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateFulfillmentOrderResp parses an HTTP response from a CreateFulfillmentOrderWithResponse call
func ParseCreateFulfillmentOrderResp(rsp *http.Response) (*CreateFulfillmentOrderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFulfillmentOrderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest CreateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CreateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest CreateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetFulfillmentPreviewResp parses an HTTP response from a GetFulfillmentPreviewWithResponse call
func ParseGetFulfillmentPreviewResp(rsp *http.Response) (*GetFulfillmentPreviewResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFulfillmentPreviewResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFulfillmentPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetFulfillmentPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetFulfillmentPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetFulfillmentPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetFulfillmentPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetFulfillmentPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetFulfillmentPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetFulfillmentPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetFulfillmentOrderResp parses an HTTP response from a GetFulfillmentOrderWithResponse call
func ParseGetFulfillmentOrderResp(rsp *http.Response) (*GetFulfillmentOrderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFulfillmentOrderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateFulfillmentOrderResp parses an HTTP response from a UpdateFulfillmentOrderWithResponse call
func ParseUpdateFulfillmentOrderResp(rsp *http.Response) (*UpdateFulfillmentOrderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFulfillmentOrderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UpdateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest UpdateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest UpdateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest UpdateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest UpdateFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCancelFulfillmentOrderResp parses an HTTP response from a CancelFulfillmentOrderWithResponse call
func ParseCancelFulfillmentOrderResp(rsp *http.Response) (*CancelFulfillmentOrderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelFulfillmentOrderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CancelFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CancelFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CancelFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CancelFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest CancelFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CancelFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest CancelFulfillmentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateFulfillmentReturnResp parses an HTTP response from a CreateFulfillmentReturnWithResponse call
func ParseCreateFulfillmentReturnResp(rsp *http.Response) (*CreateFulfillmentReturnResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFulfillmentReturnResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateFulfillmentReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreateFulfillmentReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreateFulfillmentReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreateFulfillmentReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreateFulfillmentReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest CreateFulfillmentReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CreateFulfillmentReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest CreateFulfillmentReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSubmitFulfillmentOrderStatusUpdateResp parses an HTTP response from a SubmitFulfillmentOrderStatusUpdateWithResponse call
func ParseSubmitFulfillmentOrderStatusUpdateResp(rsp *http.Response) (*SubmitFulfillmentOrderStatusUpdateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitFulfillmentOrderStatusUpdateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubmitFulfillmentOrderStatusUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SubmitFulfillmentOrderStatusUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest SubmitFulfillmentOrderStatusUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SubmitFulfillmentOrderStatusUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest SubmitFulfillmentOrderStatusUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest SubmitFulfillmentOrderStatusUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest SubmitFulfillmentOrderStatusUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest SubmitFulfillmentOrderStatusUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListReturnReasonCodesResp parses an HTTP response from a ListReturnReasonCodesWithResponse call
func ParseListReturnReasonCodesResp(rsp *http.Response) (*ListReturnReasonCodesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReturnReasonCodesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListReturnReasonCodesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ListReturnReasonCodesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ListReturnReasonCodesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ListReturnReasonCodesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ListReturnReasonCodesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ListReturnReasonCodesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ListReturnReasonCodesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ListReturnReasonCodesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPackageTrackingDetailsResp parses an HTTP response from a GetPackageTrackingDetailsWithResponse call
func ParseGetPackageTrackingDetailsResp(rsp *http.Response) (*GetPackageTrackingDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageTrackingDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPackageTrackingDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPackageTrackingDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPackageTrackingDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPackageTrackingDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPackageTrackingDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetPackageTrackingDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetPackageTrackingDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetPackageTrackingDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
