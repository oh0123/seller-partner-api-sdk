// Package invoicesv20240619 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package invoicesv20240619

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ExportStatus.
const (
	ExportStatusDONE       ExportStatus = "DONE"
	ExportStatusERROR      ExportStatus = "ERROR"
	ExportStatusPROCESSING ExportStatus = "PROCESSING"
	ExportStatusREQUESTED  ExportStatus = "REQUESTED"
)

// Defines values for FileFormat.
const (
	XML FileFormat = "XML"
)

// Defines values for GetInvoicesExportsParamsStatus.
const (
	GetInvoicesExportsParamsStatusDONE       GetInvoicesExportsParamsStatus = "DONE"
	GetInvoicesExportsParamsStatusERROR      GetInvoicesExportsParamsStatus = "ERROR"
	GetInvoicesExportsParamsStatusPROCESSING GetInvoicesExportsParamsStatus = "PROCESSING"
	GetInvoicesExportsParamsStatusREQUESTED  GetInvoicesExportsParamsStatus = "REQUESTED"
)

// Defines values for GetInvoicesParamsSortOrder.
const (
	ASC  GetInvoicesParamsSortOrder = "ASC"
	DESC GetInvoicesParamsSortOrder = "DESC"
)

// Defines values for GetInvoicesParamsSortBy.
const (
	STARTDATETIME GetInvoicesParamsSortBy = "START_DATE_TIME"
)

// AttributeOption The definition of the attribute option.
type AttributeOption struct {
	// Description The description of the attribute value.
	Description *string `json:"description,omitempty"`

	// Value The possible values for the attribute option.
	Value *string `json:"value,omitempty"`
}

// Error The error response that is returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses that are returned when a request is unsuccessful.
type ErrorList struct {
	// Errors List of errors.
	Errors []Error `json:"errors"`
}

// Export Detailed information about the export.
type Export struct {
	// ErrorMessage When the export generation fails, this attribute contains a description of the error.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// ExportId The export identifier.
	ExportId *string `json:"exportId,omitempty"`

	// GenerateExportFinishedAt The date and time when the export generation finished. Vales are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	GenerateExportFinishedAt *time.Time `json:"generateExportFinishedAt,omitempty"`

	// GenerateExportStartedAt The date and time when the export generation started. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	GenerateExportStartedAt *time.Time `json:"generateExportStartedAt,omitempty"`

	// InvoicesDocumentIds The identifier for the export documents. To get the information required to retrieve the export document's contents, pass each ID in the `getInvoicesDocument` operation.
	//
	// This list is empty until the status is `DONE`.
	InvoicesDocumentIds *[]string `json:"invoicesDocumentIds,omitempty"`

	// Status The current status of the request.
	Status *ExportStatus `json:"status,omitempty"`
}

// ExportInvoicesRequest The information required to create the export request.
type ExportInvoicesRequest struct {
	// DateEnd The latest invoice creation date for invoices that you want to include in the response. Dates are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format. The default is the time of the request.
	DateEnd *openapi_types.Date `json:"dateEnd,omitempty"`

	// DateStart The earliest invoice creation date for invoices that you want to include in the response. Dates are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format. The default is 24 hours prior to the time of the request.
	DateStart *openapi_types.Date `json:"dateStart,omitempty"`

	// ExternalInvoiceId The external ID of the invoices you want included in the response.
	ExternalInvoiceId *string `json:"externalInvoiceId,omitempty"`

	// FileFormat Supported invoice file extensions.
	FileFormat *FileFormat `json:"fileFormat,omitempty"`

	// InvoiceType The marketplace-specific classification of the invoice type. Use the `getInvoicesAttributes` operation to check `invoiceType` options.
	InvoiceType *string `json:"invoiceType,omitempty"`

	// MarketplaceId The ID of the marketplace from which you want the invoices.
	MarketplaceId string `json:"marketplaceId"`

	// Series The series number of the invoices you want included in the response.
	Series *string `json:"series,omitempty"`

	// Statuses A list of statuses that you can use to filter invoices. Use the `getInvoicesAttributes` operation to check invoice status options.
	//
	// Min count: 1
	Statuses *[]string `json:"statuses,omitempty"`

	// TransactionIdentifier The identifier for a transaction.
	TransactionIdentifier *TransactionIdentifier `json:"transactionIdentifier,omitempty"`

	// TransactionType The marketplace-specific classification of the transaction type for which the invoice was created. Use the `getInvoicesAttributes` operation to check `transactionType` options
	TransactionType *string `json:"transactionType,omitempty"`
}

// ExportInvoicesResponse Success.
type ExportInvoicesResponse struct {
	// ExportId The export identifier.
	ExportId *string `json:"exportId,omitempty"`
}

// ExportStatus The current status of the request.
type ExportStatus string

// FileFormat Supported invoice file extensions.
type FileFormat string

// GetInvoiceResponse Success.
type GetInvoiceResponse struct {
	// Invoice Provides detailed information about an invoice.
	Invoice *Invoice `json:"invoice,omitempty"`
}

// GetInvoicesAttributesResponse Success.
type GetInvoicesAttributesResponse struct {
	// InvoicesAttributes An object that contains the invoice attributes definition.
	InvoicesAttributes *InvoicesAttributes `json:"invoicesAttributes,omitempty"`
}

// GetInvoicesDocumentResponse Success.
type GetInvoicesDocumentResponse struct {
	// InvoicesDocument An object that contains the `documentId` and an S3 pre-signed URL that you can use to download the specified file.
	InvoicesDocument *InvoicesDocument `json:"invoicesDocument,omitempty"`
}

// GetInvoicesExportResponse Success.
type GetInvoicesExportResponse struct {
	// Export Detailed information about the export.
	Export *Export `json:"export,omitempty"`
}

// GetInvoicesExportsResponse Success.
type GetInvoicesExportsResponse struct {
	// Exports A list of exports.
	Exports *[]Export `json:"exports,omitempty"`

	// NextToken This token is returned when the number of results exceeds the specified `pageSize` value. To get the next page of results, call the `getInvoices` operation and include this token with the previous call parameters.
	NextToken *string `json:"nextToken,omitempty"`
}

// GetInvoicesResponse Success.
type GetInvoicesResponse struct {
	// Invoices A list of invoices.
	Invoices *[]Invoice `json:"invoices,omitempty"`

	// NextToken This token is returned when the number of results exceeds the specified `pageSize` value. To get the next page of results, call the `getInvoices` operation and include this token with the previous call parameters.
	NextToken *string `json:"nextToken,omitempty"`
}

// Invoice Provides detailed information about an invoice.
type Invoice struct {
	// Date The date and time the invoice is issued. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	Date *time.Time `json:"date,omitempty"`

	// ErrorCode If the invoice is in an error state, this attribute displays the error code.
	ErrorCode *string `json:"errorCode,omitempty"`

	// ExternalInvoiceId The invoice identifier that is used by an external party. This is typically the government agency that authorized the invoice.
	ExternalInvoiceId *string `json:"externalInvoiceId,omitempty"`

	// GovResponse The response message from the government authority when there is an error during invoice issuance.
	GovResponse *string `json:"govResponse,omitempty"`

	// Id The invoice identifier.
	Id *string `json:"id,omitempty"`

	// InvoiceType The classification of the invoice type. This varies across marketplaces. Use the `getInvoicesAttributes` operation to check `invoiceType` options.
	InvoiceType *string `json:"invoiceType,omitempty"`

	// Series Use this identifier in conjunction with `externalInvoiceId` to identify invoices from the same seller.
	Series *string `json:"series,omitempty"`

	// Status The invoice status classification. Use the `getInvoicesAttributes` operation to check invoice status options.
	Status *string `json:"status,omitempty"`

	// TransactionIds List with identifiers for the transactions associated to the invoice.
	TransactionIds *[]TransactionIdentifier `json:"transactionIds,omitempty"`

	// TransactionType Classification of the transaction that originated this invoice. Use the `getInvoicesAttributes` operation to check `transactionType` options.
	TransactionType *string `json:"transactionType,omitempty"`
}

// InvoicesAttributes An object that contains the invoice attributes definition.
type InvoicesAttributes struct {
	// InvoiceStatusOptions A list of all the options that are available for the invoice status attribute.
	InvoiceStatusOptions *[]AttributeOption `json:"invoiceStatusOptions,omitempty"`

	// InvoiceTypeOptions A list of all the options that are available for the invoice type attribute.
	InvoiceTypeOptions *[]AttributeOption `json:"invoiceTypeOptions,omitempty"`

	// TransactionIdentifierNameOptions A list of all the options that are available for the transaction identifier name attribute.
	TransactionIdentifierNameOptions *[]AttributeOption `json:"transactionIdentifierNameOptions,omitempty"`

	// TransactionTypeOptions A list of all the options that are available for the transaction type attribute.
	TransactionTypeOptions *[]AttributeOption `json:"transactionTypeOptions,omitempty"`
}

// InvoicesDocument An object that contains the `documentId` and an S3 pre-signed URL that you can use to download the specified file.
type InvoicesDocument struct {
	// InvoicesDocumentId The identifier of the export document.
	InvoicesDocumentId *string `json:"invoicesDocumentId,omitempty"`

	// InvoicesDocumentUrl A pre-signed URL that you can use to download the invoices document in zip format. This URL expires after 30 seconds.
	InvoicesDocumentUrl *string `json:"invoicesDocumentUrl,omitempty"`
}

// TransactionIdentifier The identifier for a transaction.
type TransactionIdentifier struct {
	// Id The transaction identifier.
	Id *string `json:"id,omitempty"`

	// Name The transaction identifier name. Use the `getInvoicesAttributes` operation to check `transactionIdentifierName` options.
	Name *string `json:"name,omitempty"`
}

// GetInvoicesAttributesParams defines parameters for GetInvoicesAttributes.
type GetInvoicesAttributesParams struct {
	// MarketplaceId The marketplace identifier.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// GetInvoicesExportsParams defines parameters for GetInvoicesExports.
type GetInvoicesExportsParams struct {
	// MarketplaceId The returned exports match the specified marketplace.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`

	// DateStart The earliest export creation date and time for exports that you want to include in the response. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format. The default is 30 days ago.
	DateStart *time.Time `form:"dateStart,omitempty" json:"dateStart,omitempty"`

	// NextToken The response includes `nextToken` when the number of results exceeds the specified `pageSize` value. To get the next page of results, call the operation with this token and include the same arguments as the call that produced the token. To get a complete list, call this operation until `nextToken` is null. Note that this operation can return empty pages.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// PageSize The maximum number of invoices to return in a single call.
	//
	// Minimum: 1
	//
	// Maximum: 100
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// DateEnd The latest export creation date and time for exports that you want to include in the response. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format. The default value is the time of the request.
	DateEnd *time.Time `form:"dateEnd,omitempty" json:"dateEnd,omitempty"`

	// Status Return exports matching the status specified.
	Status *GetInvoicesExportsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetInvoicesExportsParamsStatus defines parameters for GetInvoicesExports.
type GetInvoicesExportsParamsStatus string

// GetInvoicesParams defines parameters for GetInvoices.
type GetInvoicesParams struct {
	// TransactionIdentifierName The name of the transaction identifier filter. If you provide a value for this field, you must also provide a value for the `transactionIdentifierId` field.Use the `getInvoicesAttributes` operation to check `transactionIdentifierName` options.
	TransactionIdentifierName *string `form:"transactionIdentifierName,omitempty" json:"transactionIdentifierName,omitempty"`

	// PageSize The maximum number of invoices you want to return in a single call.
	//
	// Minimum: 1
	//
	// Maximum: 200
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// DateEnd The latest invoice creation date for invoices that you want to include in the response. Dates are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format. The default is the current date-time.
	DateEnd *time.Time `form:"dateEnd,omitempty" json:"dateEnd,omitempty"`

	// MarketplaceId The response includes only the invoices that match the specified marketplace.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`

	// TransactionType The marketplace-specific classification of the transaction type for which the invoice was created. Use the `getInvoicesAttributes` operation to check `transactionType` options.
	TransactionType *string `form:"transactionType,omitempty" json:"transactionType,omitempty"`

	// TransactionIdentifierId The ID of the transaction identifier filter. If you provide a value for this field, you must also provide a value for the `transactionIdentifierName` field.
	TransactionIdentifierId *string `form:"transactionIdentifierId,omitempty" json:"transactionIdentifierId,omitempty"`

	// DateStart The earliest invoice creation date for invoices that you want to include in the response. Dates are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format. The default is 24 hours prior to the time of the request.
	DateStart *time.Time `form:"dateStart,omitempty" json:"dateStart,omitempty"`

	// Series Return invoices with the specified series number.
	Series *string `form:"series,omitempty" json:"series,omitempty"`

	// NextToken The response includes `nextToken` when the number of results exceeds the specified `pageSize` value. To get the next page of results, call the operation with this token and include the same arguments as the call that produced the token. To get a complete list, call this operation until `nextToken` is null. Note that this operation can return empty pages.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// SortOrder Sort the invoices in the response in ascending or descending order.
	SortOrder *GetInvoicesParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// InvoiceType The marketplace-specific classification of the invoice type. Use the `getInvoicesAttributes` operation to check `invoiceType` options.
	InvoiceType *string `form:"invoiceType,omitempty" json:"invoiceType,omitempty"`

	// Statuses A list of statuses that you can use to filter invoices. Use the `getInvoicesAttributes` operation to check invoice status options.
	//
	// Min count: 1
	Statuses *[]string `form:"statuses,omitempty" json:"statuses,omitempty"`

	// ExternalInvoiceId Return invoices that match this external ID. This is typically the Government Invoice ID.
	ExternalInvoiceId *string `form:"externalInvoiceId,omitempty" json:"externalInvoiceId,omitempty"`

	// SortBy The attribute by which you want to sort the invoices in the response.
	SortBy *GetInvoicesParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`
}

// GetInvoicesParamsSortOrder defines parameters for GetInvoices.
type GetInvoicesParamsSortOrder string

// GetInvoicesParamsSortBy defines parameters for GetInvoices.
type GetInvoicesParamsSortBy string

// GetInvoiceParams defines parameters for GetInvoice.
type GetInvoiceParams struct {
	// MarketplaceId The marketplace from which you want the invoice.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// CreateInvoicesExportJSONRequestBody defines body for CreateInvoicesExport for application/json ContentType.
type CreateInvoicesExportJSONRequestBody = ExportInvoicesRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetInvoicesAttributes request
	GetInvoicesAttributes(ctx context.Context, params *GetInvoicesAttributesParams) (*http.Response, error)

	// GetInvoicesDocument request
	GetInvoicesDocument(ctx context.Context, invoicesDocumentId string) (*http.Response, error)

	// GetInvoicesExports request
	GetInvoicesExports(ctx context.Context, params *GetInvoicesExportsParams) (*http.Response, error)

	// CreateInvoicesExportWithBody request with any body
	CreateInvoicesExportWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateInvoicesExport(ctx context.Context, body CreateInvoicesExportJSONRequestBody) (*http.Response, error)

	// GetInvoicesExport request
	GetInvoicesExport(ctx context.Context, exportId string) (*http.Response, error)

	// GetInvoices request
	GetInvoices(ctx context.Context, params *GetInvoicesParams) (*http.Response, error)

	// GetInvoice request
	GetInvoice(ctx context.Context, invoiceId string, params *GetInvoiceParams) (*http.Response, error)
}

func (c *Client) GetInvoicesAttributes(ctx context.Context, params *GetInvoicesAttributesParams) (*http.Response, error) {
	req, err := NewGetInvoicesAttributesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInvoicesDocument(ctx context.Context, invoicesDocumentId string) (*http.Response, error) {
	req, err := NewGetInvoicesDocumentRequest(c.Server, invoicesDocumentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInvoicesExports(ctx context.Context, params *GetInvoicesExportsParams) (*http.Response, error) {
	req, err := NewGetInvoicesExportsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateInvoicesExportWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateInvoicesExportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateInvoicesExport(ctx context.Context, body CreateInvoicesExportJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateInvoicesExportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInvoicesExport(ctx context.Context, exportId string) (*http.Response, error) {
	req, err := NewGetInvoicesExportRequest(c.Server, exportId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInvoices(ctx context.Context, params *GetInvoicesParams) (*http.Response, error) {
	req, err := NewGetInvoicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInvoice(ctx context.Context, invoiceId string, params *GetInvoiceParams) (*http.Response, error) {
	req, err := NewGetInvoiceRequest(c.Server, invoiceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewGetInvoicesAttributesRequest generates requests for GetInvoicesAttributes
func NewGetInvoicesAttributesRequest(server string, params *GetInvoicesAttributesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tax/invoices/2024-06-19/attributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoicesDocumentRequest generates requests for GetInvoicesDocument
func NewGetInvoicesDocumentRequest(server string, invoicesDocumentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoicesDocumentId", runtime.ParamLocationPath, invoicesDocumentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tax/invoices/2024-06-19/documents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoicesExportsRequest generates requests for GetInvoicesExports
func NewGetInvoicesExportsRequest(server string, params *GetInvoicesExportsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tax/invoices/2024-06-19/exports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.DateStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateStart", runtime.ParamLocationQuery, *params.DateStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.DateEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateEnd", runtime.ParamLocationQuery, *params.DateEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInvoicesExportRequest calls the generic CreateInvoicesExport builder with application/json body
func NewCreateInvoicesExportRequest(server string, body CreateInvoicesExportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInvoicesExportRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateInvoicesExportRequestWithBody generates requests for CreateInvoicesExport with any type of body
func NewCreateInvoicesExportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tax/invoices/2024-06-19/exports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInvoicesExportRequest generates requests for GetInvoicesExport
func NewGetInvoicesExportRequest(server string, exportId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "exportId", runtime.ParamLocationPath, exportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tax/invoices/2024-06-19/exports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoicesRequest generates requests for GetInvoices
func NewGetInvoicesRequest(server string, params *GetInvoicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tax/invoices/2024-06-19/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionIdentifierName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transactionIdentifierName", runtime.ParamLocationQuery, *params.TransactionIdentifierName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.DateEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateEnd", runtime.ParamLocationQuery, *params.DateEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.TransactionType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transactionType", runtime.ParamLocationQuery, *params.TransactionType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.TransactionIdentifierId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transactionIdentifierId", runtime.ParamLocationQuery, *params.TransactionIdentifierId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.DateStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateStart", runtime.ParamLocationQuery, *params.DateStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Series != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "series", runtime.ParamLocationQuery, *params.Series); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.InvoiceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invoiceType", runtime.ParamLocationQuery, *params.InvoiceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ExternalInvoiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "externalInvoiceId", runtime.ParamLocationQuery, *params.ExternalInvoiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoiceRequest generates requests for GetInvoice
func NewGetInvoiceRequest(server string, invoiceId string, params *GetInvoiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tax/invoices/2024-06-19/invoices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetInvoicesAttributesWithResponse request
	GetInvoicesAttributesWithResponse(ctx context.Context, params *GetInvoicesAttributesParams) (*GetInvoicesAttributesResp, error)

	// GetInvoicesDocumentWithResponse request
	GetInvoicesDocumentWithResponse(ctx context.Context, invoicesDocumentId string) (*GetInvoicesDocumentResp, error)

	// GetInvoicesExportsWithResponse request
	GetInvoicesExportsWithResponse(ctx context.Context, params *GetInvoicesExportsParams) (*GetInvoicesExportsResp, error)

	// CreateInvoicesExportWithBodyWithResponse request with any body
	CreateInvoicesExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateInvoicesExportResp, error)

	CreateInvoicesExportWithResponse(ctx context.Context, body CreateInvoicesExportJSONRequestBody) (*CreateInvoicesExportResp, error)

	// GetInvoicesExportWithResponse request
	GetInvoicesExportWithResponse(ctx context.Context, exportId string) (*GetInvoicesExportResp, error)

	// GetInvoicesWithResponse request
	GetInvoicesWithResponse(ctx context.Context, params *GetInvoicesParams) (*GetInvoicesResp, error)

	// GetInvoiceWithResponse request
	GetInvoiceWithResponse(ctx context.Context, invoiceId string, params *GetInvoiceParams) (*GetInvoiceResp, error)
}

type GetInvoicesAttributesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInvoicesAttributesResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetInvoicesAttributesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesAttributesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesDocumentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInvoicesDocumentResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetInvoicesDocumentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesDocumentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesExportsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInvoicesExportsResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetInvoicesExportsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesExportsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInvoicesExportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ExportInvoicesResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CreateInvoicesExportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInvoicesExportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesExportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInvoicesExportResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetInvoicesExportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesExportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInvoicesResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetInvoicesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInvoiceResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetInvoiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetInvoicesAttributesWithResponse request returning *GetInvoicesAttributesResp
func (c *ClientWithResponses) GetInvoicesAttributesWithResponse(ctx context.Context, params *GetInvoicesAttributesParams) (*GetInvoicesAttributesResp, error) {
	rsp, err := c.GetInvoicesAttributes(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesAttributesResp(rsp)
}

// GetInvoicesDocumentWithResponse request returning *GetInvoicesDocumentResp
func (c *ClientWithResponses) GetInvoicesDocumentWithResponse(ctx context.Context, invoicesDocumentId string) (*GetInvoicesDocumentResp, error) {
	rsp, err := c.GetInvoicesDocument(ctx, invoicesDocumentId)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesDocumentResp(rsp)
}

// GetInvoicesExportsWithResponse request returning *GetInvoicesExportsResp
func (c *ClientWithResponses) GetInvoicesExportsWithResponse(ctx context.Context, params *GetInvoicesExportsParams) (*GetInvoicesExportsResp, error) {
	rsp, err := c.GetInvoicesExports(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesExportsResp(rsp)
}

// CreateInvoicesExportWithBodyWithResponse request with arbitrary body returning *CreateInvoicesExportResp
func (c *ClientWithResponses) CreateInvoicesExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateInvoicesExportResp, error) {
	rsp, err := c.CreateInvoicesExportWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateInvoicesExportResp(rsp)
}

func (c *ClientWithResponses) CreateInvoicesExportWithResponse(ctx context.Context, body CreateInvoicesExportJSONRequestBody) (*CreateInvoicesExportResp, error) {
	rsp, err := c.CreateInvoicesExport(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateInvoicesExportResp(rsp)
}

// GetInvoicesExportWithResponse request returning *GetInvoicesExportResp
func (c *ClientWithResponses) GetInvoicesExportWithResponse(ctx context.Context, exportId string) (*GetInvoicesExportResp, error) {
	rsp, err := c.GetInvoicesExport(ctx, exportId)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesExportResp(rsp)
}

// GetInvoicesWithResponse request returning *GetInvoicesResp
func (c *ClientWithResponses) GetInvoicesWithResponse(ctx context.Context, params *GetInvoicesParams) (*GetInvoicesResp, error) {
	rsp, err := c.GetInvoices(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesResp(rsp)
}

// GetInvoiceWithResponse request returning *GetInvoiceResp
func (c *ClientWithResponses) GetInvoiceWithResponse(ctx context.Context, invoiceId string, params *GetInvoiceParams) (*GetInvoiceResp, error) {
	rsp, err := c.GetInvoice(ctx, invoiceId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoiceResp(rsp)
}

// ParseGetInvoicesAttributesResp parses an HTTP response from a GetInvoicesAttributesWithResponse call
func ParseGetInvoicesAttributesResp(rsp *http.Response) (*GetInvoicesAttributesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesAttributesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInvoicesAttributesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetInvoicesDocumentResp parses an HTTP response from a GetInvoicesDocumentWithResponse call
func ParseGetInvoicesDocumentResp(rsp *http.Response) (*GetInvoicesDocumentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesDocumentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInvoicesDocumentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetInvoicesExportsResp parses an HTTP response from a GetInvoicesExportsWithResponse call
func ParseGetInvoicesExportsResp(rsp *http.Response) (*GetInvoicesExportsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesExportsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInvoicesExportsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateInvoicesExportResp parses an HTTP response from a CreateInvoicesExportWithResponse call
func ParseCreateInvoicesExportResp(rsp *http.Response) (*CreateInvoicesExportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInvoicesExportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ExportInvoicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetInvoicesExportResp parses an HTTP response from a GetInvoicesExportWithResponse call
func ParseGetInvoicesExportResp(rsp *http.Response) (*GetInvoicesExportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesExportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInvoicesExportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetInvoicesResp parses an HTTP response from a GetInvoicesWithResponse call
func ParseGetInvoicesResp(rsp *http.Response) (*GetInvoicesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInvoicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetInvoiceResp parses an HTTP response from a GetInvoiceWithResponse call
func ParseGetInvoiceResp(rsp *http.Response) (*GetInvoiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInvoiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
