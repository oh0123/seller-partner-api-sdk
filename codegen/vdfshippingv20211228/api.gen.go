// Package vdfshippingv20211228 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package vdfshippingv20211228

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for CarrierId.
const (
	SWA CarrierId = "SWA"
)

// Defines values for ContainerContainerType.
const (
	Carton ContainerContainerType = "Carton"
	Pallet ContainerContainerType = "Pallet"
)

// Defines values for ContainerLabelFormat.
const (
	ContainerLabelFormatPNG ContainerLabelFormat = "PNG"
	ContainerLabelFormatZPL ContainerLabelFormat = "ZPL"
)

// Defines values for DimensionsUnitOfMeasure.
const (
	CM DimensionsUnitOfMeasure = "CM"
	IN DimensionsUnitOfMeasure = "IN"
)

// Defines values for PackingSlipContentType.
const (
	Applicationpdf PackingSlipContentType = "application/pdf"
)

// Defines values for ShipmentDetailsShipmentStatus.
const (
	FLOORDENIAL ShipmentDetailsShipmentStatus = "FLOOR_DENIAL"
	SHIPPED     ShipmentDetailsShipmentStatus = "SHIPPED"
)

// Defines values for ShippingLabelLabelFormat.
const (
	ShippingLabelLabelFormatPNG ShippingLabelLabelFormat = "PNG"
	ShippingLabelLabelFormatZPL ShippingLabelLabelFormat = "ZPL"
)

// Defines values for TaxRegistrationDetailsTaxRegistrationType.
const (
	GST TaxRegistrationDetailsTaxRegistrationType = "GST"
	VAT TaxRegistrationDetailsTaxRegistrationType = "VAT"
)

// Defines values for WeightUnitOfMeasure.
const (
	KG WeightUnitOfMeasure = "KG"
	LB WeightUnitOfMeasure = "LB"
)

// Defines values for GetCustomerInvoicesParamsSortOrder.
const (
	GetCustomerInvoicesParamsSortOrderASC  GetCustomerInvoicesParamsSortOrder = "ASC"
	GetCustomerInvoicesParamsSortOrderDESC GetCustomerInvoicesParamsSortOrder = "DESC"
)

// Defines values for GetPackingSlipsParamsSortOrder.
const (
	GetPackingSlipsParamsSortOrderASC  GetPackingSlipsParamsSortOrder = "ASC"
	GetPackingSlipsParamsSortOrderDESC GetPackingSlipsParamsSortOrder = "DESC"
)

// Defines values for GetShippingLabelsParamsSortOrder.
const (
	ASC  GetShippingLabelsParamsSortOrder = "ASC"
	DESC GetShippingLabelsParamsSortOrder = "DESC"
)

// Address Address of the party.
type Address struct {
	// AddressLine1 First line of the address.
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Additional street address information, if required.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 Additional street address information, if required.
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// City The city where the person, business or institution is located.
	City *string `json:"city,omitempty"`

	// CountryCode The two-letter country code in [ISO 3166-1 alpha-2](https://www.iban.com/country-codes) format.
	CountryCode string `json:"countryCode"`

	// County The county where person, business or institution is located.
	County *string `json:"county,omitempty"`

	// District The district where person, business or institution is located.
	District *string `json:"district,omitempty"`

	// Name The name of the person, business or institution at that address.
	Name string `json:"name"`

	// Phone The phone number of the person, business or institution located at that address.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The postal code of that address. It contains a series of letters or digits or both, sometimes including spaces or punctuation.
	PostalCode *string `json:"postalCode,omitempty"`

	// StateOrRegion The state or region where person, business or institution is located.
	StateOrRegion *string `json:"stateOrRegion,omitempty"`
}

// CarrierId The unique carrier code for the carrier for whom container labels are requested.
type CarrierId string

// Container A container used for shipping and packing items.
type Container struct {
	// Carrier Carrier required for EU VOC vendors only.
	Carrier *string `json:"carrier,omitempty"`

	// ContainerIdentifier The container identifier.
	ContainerIdentifier string `json:"containerIdentifier"`

	// ContainerSequenceNumber An integer that must be submitted for multi-box shipments only, where one item may come in separate packages.
	ContainerSequenceNumber *int `json:"containerSequenceNumber,omitempty"`

	// ContainerType The type of container.
	ContainerType ContainerContainerType `json:"containerType"`

	// Dimensions Physical dimensional measurements of a container.
	Dimensions *Dimensions `json:"dimensions,omitempty"`

	// ManifestDate The date of the manifest.
	ManifestDate *string `json:"manifestDate,omitempty"`

	// ManifestId The manifest identifier.
	ManifestId *string `json:"manifestId,omitempty"`

	// PackedItems A list of packed items.
	PackedItems []PackedItem `json:"packedItems"`

	// ScacCode SCAC code required for NA VOC vendors only.
	ScacCode *string `json:"scacCode,omitempty"`

	// ShipMethod The shipment method. This property is required when calling the `submitShipmentConfirmations` operation, and optional otherwise.
	ShipMethod *string `json:"shipMethod,omitempty"`

	// TrackingNumber The tracking number.
	TrackingNumber *string `json:"trackingNumber,omitempty"`

	// Weight The weight.
	Weight Weight `json:"weight"`
}

// ContainerContainerType The type of container.
type ContainerContainerType string

// ContainerLabel The details of the container label.
type ContainerLabel struct {
	// ContainerTrackingNumber The container (pallet) tracking identifier from the shipping carrier.
	ContainerTrackingNumber *string `json:"containerTrackingNumber,omitempty"`

	// Content The container label content encoded into a Base64 string.
	Content string `json:"content"`

	// Format The format of the container label.
	Format ContainerLabelFormat `json:"format"`
}

// ContainerLabelFormat The format of the container label.
type ContainerLabelFormat string

// CreateContainerLabelRequest The request body schema for the `createContainerLabel` operation.
type CreateContainerLabelRequest struct {
	// CarrierId The unique carrier code for the carrier for whom container labels are requested.
	CarrierId CarrierId `json:"carrierId"`

	// Packages An array of package objects in a container.
	Packages Packages `json:"packages"`

	// SellingParty The name, address, and tax details of a party.
	SellingParty PartyIdentification `json:"sellingParty"`

	// ShipFromParty The name, address, and tax details of a party.
	ShipFromParty PartyIdentification `json:"shipFromParty"`

	// VendorContainerId The unique, vendor-provided identifier for the container.
	VendorContainerId VendorContainerId `json:"vendorContainerId"`
}

// CreateContainerLabelResponse The response schema for the `createContainerLabel` operation.
type CreateContainerLabelResponse struct {
	// ContainerLabel The details of the container label.
	ContainerLabel ContainerLabel `json:"containerLabel"`
}

// CreateShippingLabelsRequest The request body for the createShippingLabels operation.
type CreateShippingLabelsRequest struct {
	// Containers A list of the packages in this shipment.
	Containers *[]Container `json:"containers,omitempty"`

	// SellingParty The name, address, and tax details of a party.
	SellingParty PartyIdentification `json:"sellingParty"`

	// ShipFromParty The name, address, and tax details of a party.
	ShipFromParty PartyIdentification `json:"shipFromParty"`
}

// CustomerInvoice Represents a customer invoice associated with a purchase order.
type CustomerInvoice struct {
	// Content The Base64 customer invoice.
	Content string `json:"content"`

	// PurchaseOrderNumber The purchase order number for this order.
	PurchaseOrderNumber string `json:"purchaseOrderNumber"`
}

// CustomerInvoiceList Represents a list of customer invoices, potentially paginated.
type CustomerInvoiceList struct {
	// CustomerInvoices Represents a customer invoice within the `CustomerInvoiceList`.
	CustomerInvoices *[]CustomerInvoice `json:"customerInvoices,omitempty"`

	// Pagination The pagination elements required to retrieve the remaining data.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// Decimal A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation.  <br>**Pattern** : `^-?(0|([1-9]\\d*))(\\.\\d+)?([eE][+-]?\\d+)?$`.
type Decimal = string

// Dimensions Physical dimensional measurements of a container.
type Dimensions struct {
	// Height A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation.  <br>**Pattern** : `^-?(0|([1-9]\\d*))(\\.\\d+)?([eE][+-]?\\d+)?$`.
	Height Decimal `json:"height"`

	// Length A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation.  <br>**Pattern** : `^-?(0|([1-9]\\d*))(\\.\\d+)?([eE][+-]?\\d+)?$`.
	Length Decimal `json:"length"`

	// UnitOfMeasure The unit of measure for dimensions.
	UnitOfMeasure DimensionsUnitOfMeasure `json:"unitOfMeasure"`

	// Width A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation.  <br>**Pattern** : `^-?(0|([1-9]\\d*))(\\.\\d+)?([eE][+-]?\\d+)?$`.
	Width Decimal `json:"width"`
}

// DimensionsUnitOfMeasure The unit of measure for dimensions.
type DimensionsUnitOfMeasure string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	// Errors An array of Error objects representing individual errors encountered during the request.
	Errors []Error `json:"errors"`
}

// Item Details of the item being shipped.
type Item struct {
	// BuyerProductIdentifier The buyer's Amazon Standard Identification Number (ASIN) of an item. Either `buyerProductIdentifier` or `vendorProductIdentifier` is required.
	BuyerProductIdentifier *string `json:"buyerProductIdentifier,omitempty"`

	// ItemSequenceNumber The sequence number of the item. The number must be the same as the order number of the item.
	ItemSequenceNumber int `json:"itemSequenceNumber"`

	// ShippedQuantity Details of item quantity.
	ShippedQuantity ItemQuantity `json:"shippedQuantity"`

	// VendorProductIdentifier An item's product identifier, which the vendor selects. This identifier should be the same as the identifier, such as a SKU, in the purchase order.
	VendorProductIdentifier *string `json:"vendorProductIdentifier,omitempty"`
}

// ItemQuantity Details of item quantity.
type ItemQuantity struct {
	// Amount Quantity of units shipped for a specific item at a shipment level. If the item is present only in certain packages or pallets within the shipment, please provide this at the appropriate package or pallet level.
	Amount int `json:"amount"`

	// UnitOfMeasure Unit of measure for the shipped quantity.
	UnitOfMeasure string `json:"unitOfMeasure"`
}

// LabelData Details of the shipment label.
type LabelData struct {
	// Content This field will contain the Base64 string of the shipment label content.
	Content string `json:"content"`

	// PackageIdentifier Identifier for the package. The first package will be 001, the second 002, and so on. This number is used as a reference to refer to this package from the pallet level.
	PackageIdentifier *string `json:"packageIdentifier,omitempty"`

	// ShipMethod Ship method to be used for shipping the order. Amazon defines Ship Method Codes indicating shipping carrier and shipment service level. Ship Method Codes are case and format sensitive. The same ship method code should returned on the shipment confirmation. Note that the Ship Method Codes are vendor specific and will be provided to each vendor during the implementation.
	ShipMethod *string `json:"shipMethod,omitempty"`

	// ShipMethodName Shipping method name for internal reference.
	ShipMethodName *string `json:"shipMethodName,omitempty"`

	// TrackingNumber Package tracking identifier from the shipping carrier.
	TrackingNumber *string `json:"trackingNumber,omitempty"`
}

// Package The package that is associated with the container.
type Package struct {
	// PackageTrackingNumber The tracking number on the label of shipment package, that you can fetch from the `shippingLabels` response. You can also scan the bar code on the shipping label to get the tracking number.
	PackageTrackingNumber string `json:"packageTrackingNumber"`
}

// Packages An array of package objects in a container.
type Packages = []Package

// PackedItem An item that has been packed into a container for shipping.
type PackedItem struct {
	// BuyerProductIdentifier The buyer's Amazon Standard Identification Number (ASIN) of an item. Either `buyerProductIdentifier` or `vendorProductIdentifier` is required.
	BuyerProductIdentifier *string `json:"buyerProductIdentifier,omitempty"`

	// ItemSequenceNumber The sequence number of the item. The number must be the same as the order number of the item.
	ItemSequenceNumber int `json:"itemSequenceNumber"`

	// PackedQuantity Details of item quantity.
	PackedQuantity ItemQuantity `json:"packedQuantity"`

	// PieceNumber The piece number of the item in this container. This is required when the item is split across different containers.
	PieceNumber *int `json:"pieceNumber,omitempty"`

	// VendorProductIdentifier An item's product identifier, which the vendor selects. This identifier should be the same as the identifier, such as a SKU, in the purchase order.
	VendorProductIdentifier *string `json:"vendorProductIdentifier,omitempty"`
}

// PackingSlip Packing slip information.
type PackingSlip struct {
	// Content A Base64 string of the packing slip PDF.
	Content string `json:"content"`

	// ContentType The format of the file such as PDF, JPEG etc.
	ContentType *PackingSlipContentType `json:"contentType,omitempty"`

	// PurchaseOrderNumber Purchase order number of the shipment that the packing slip is for.
	PurchaseOrderNumber string `json:"purchaseOrderNumber"`
}

// PackingSlipContentType The format of the file such as PDF, JPEG etc.
type PackingSlipContentType string

// PackingSlipList A list of packing slips.
type PackingSlipList struct {
	// PackingSlips An array of packing slip objects.
	PackingSlips *[]PackingSlip `json:"packingSlips,omitempty"`

	// Pagination The pagination elements required to retrieve the remaining data.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// Pagination The pagination elements required to retrieve the remaining data.
type Pagination struct {
	// NextToken Pagination occurs when a request produces a response that exceeds the `pageSize`. This means that the response is divided into individual pages. To retrieve the next page or the previous page, you must pass the `nextToken` value or the `previousToken` value as the `pageToken` parameter in the next request. There is no `nextToken` in the pagination object on the last page.
	NextToken *string `json:"nextToken,omitempty"`
}

// PartyIdentification The name, address, and tax details of a party.
type PartyIdentification struct {
	// Address Address of the party.
	Address *Address `json:"address,omitempty"`

	// PartyId The identifier of the party.
	PartyId string `json:"partyId"`

	// TaxRegistrationDetails The tax registration details of the party.
	TaxRegistrationDetails *[]TaxRegistrationDetails `json:"taxRegistrationDetails,omitempty"`
}

// ShipmentConfirmation Represents the confirmation details of a shipment, including the purchase order number and other shipment details.
type ShipmentConfirmation struct {
	// Containers Provide the details of the items in this shipment. If any of the item details field is common at a package or a pallet level, then provide them at the corresponding package.
	Containers *[]Container `json:"containers,omitempty"`

	// Items Provide the details of the items in this shipment. If any of the item details field is common at a package or a pallet level, then provide them at the corresponding package.
	Items []Item `json:"items"`

	// PurchaseOrderNumber Purchase order number corresponding to the shipment.
	PurchaseOrderNumber string `json:"purchaseOrderNumber"`

	// SellingParty The name, address, and tax details of a party.
	SellingParty PartyIdentification `json:"sellingParty"`

	// ShipFromParty The name, address, and tax details of a party.
	ShipFromParty PartyIdentification `json:"shipFromParty"`

	// ShipmentDetails Details about a shipment.
	ShipmentDetails ShipmentDetails `json:"shipmentDetails"`
}

// ShipmentDetails Details about a shipment.
type ShipmentDetails struct {
	// EstimatedDeliveryDate The date on which the shipment is expected to reach the buyer's warehouse. The date is estimated based on the average transit time between the ship-from location and the destination. Usually, the exact appointment time is unknown when creating the shipment confirmation and is later provided by the buyer.
	EstimatedDeliveryDate *time.Time `json:"estimatedDeliveryDate,omitempty"`

	// IsPriorityShipment Provide the priority of the shipment.
	IsPriorityShipment *bool `json:"isPriorityShipment,omitempty"`

	// ShipmentStatus The shipment status.
	ShipmentStatus ShipmentDetailsShipmentStatus `json:"shipmentStatus"`

	// ShippedDate The date of the shipment's departure from vendor's location. Vendors send ASNs within 30 minutes of departure from their warehouse/distribution center or six hours prior to the appointment time at the Amazon destination warehouse. The shipped date mentioned in the shipment confirmation cannot be in the future.
	ShippedDate time.Time `json:"shippedDate"`

	// VendorOrderNumber The vendor order number is a unique identifier generated by a vendor for their reference.
	VendorOrderNumber *string `json:"vendorOrderNumber,omitempty"`
}

// ShipmentDetailsShipmentStatus The shipment status.
type ShipmentDetailsShipmentStatus string

// ShipmentSchedule Details about the estimated delivery window.
type ShipmentSchedule struct {
	// ApptWindowEndDateTime The date and time at the end of the appointment window when the shipment is expected to be delivered. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format, with UTC time zone or UTC offset. For example, 2020-07-16T23:00:00Z or 2020-07-16T23:00:00+01:00.
	ApptWindowEndDateTime *time.Time `json:"apptWindowEndDateTime,omitempty"`

	// ApptWindowStartDateTime The date and time at the start of the appointment window when the shipment is expected to be delivered. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format, with UTC time zone or UTC offset. For example, 2020-07-16T23:00:00Z or 2020-07-16T23:00:00+01:00.
	ApptWindowStartDateTime *time.Time `json:"apptWindowStartDateTime,omitempty"`

	// EstimatedDeliveryDateTime Date on which the shipment is expected to reach the customer delivery location. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format, with UTC time zone or UTC offset. For example, 2020-07-16T23:00:00Z or 2020-07-16T23:00:00+01:00.
	EstimatedDeliveryDateTime *time.Time `json:"estimatedDeliveryDateTime,omitempty"`
}

// ShipmentStatusUpdate Represents an update to the status of a shipment.
type ShipmentStatusUpdate struct {
	// PurchaseOrderNumber Purchase order number of the shipment for which to update the shipment status.
	PurchaseOrderNumber string `json:"purchaseOrderNumber"`

	// SellingParty The name, address, and tax details of a party.
	SellingParty PartyIdentification `json:"sellingParty"`

	// ShipFromParty The name, address, and tax details of a party.
	ShipFromParty PartyIdentification `json:"shipFromParty"`

	// StatusUpdateDetails Details for the shipment status update given by the vendor for the specific package.
	StatusUpdateDetails StatusUpdateDetails `json:"statusUpdateDetails"`
}

// ShippingLabel Shipping label information for an order, including the purchase order number, selling party, ship from party, label format, and package details.
type ShippingLabel struct {
	// LabelData Provides the details of the packages in this shipment.
	LabelData []LabelData `json:"labelData"`

	// LabelFormat Format of the label.
	LabelFormat ShippingLabelLabelFormat `json:"labelFormat"`

	// PurchaseOrderNumber This field will contain the Purchase Order Number for this order.
	PurchaseOrderNumber string `json:"purchaseOrderNumber"`

	// SellingParty The name, address, and tax details of a party.
	SellingParty PartyIdentification `json:"sellingParty"`

	// ShipFromParty The name, address, and tax details of a party.
	ShipFromParty PartyIdentification `json:"shipFromParty"`
}

// ShippingLabelLabelFormat Format of the label.
type ShippingLabelLabelFormat string

// ShippingLabelList Response payload with the list of shipping labels.
type ShippingLabelList struct {
	// Pagination The pagination elements required to retrieve the remaining data.
	Pagination *Pagination `json:"pagination,omitempty"`

	// ShippingLabels An array containing the details of the generated shipping labels.
	ShippingLabels *[]ShippingLabel `json:"shippingLabels,omitempty"`
}

// ShippingLabelRequest Represents the request payload for creating a shipping label, containing the purchase order number, selling party, ship from party, and a list of containers or packages in the shipment.
type ShippingLabelRequest struct {
	// Containers A list of the packages in this shipment.
	Containers *[]Container `json:"containers,omitempty"`

	// PurchaseOrderNumber The purchase order number of the order for which to create a shipping label.
	PurchaseOrderNumber string `json:"purchaseOrderNumber"`

	// SellingParty The name, address, and tax details of a party.
	SellingParty PartyIdentification `json:"sellingParty"`

	// ShipFromParty The name, address, and tax details of a party.
	ShipFromParty PartyIdentification `json:"shipFromParty"`
}

// StatusUpdateDetails Details for the shipment status update given by the vendor for the specific package.
type StatusUpdateDetails struct {
	// ReasonCode Provides a reason code for the status of the package that will provide additional information about the transportation status. For more information, refer to the [Additional Fields Explanation](https://developer-docs.amazon.com/sp-api/docs/vendor-direct-fulfillment-shipping-api-use-case-guide#additional-fields-explanation).
	ReasonCode string `json:"reasonCode"`

	// ShipmentSchedule Details about the estimated delivery window.
	ShipmentSchedule *ShipmentSchedule `json:"shipmentSchedule,omitempty"`

	// StatusCode Indicates the shipment status code of the package that provides transportation information for Amazon tracking systems and ultimately for the final customer. For more information, refer to the [Additional Fields Explanation](https://developer-docs.amazon.com/sp-api/docs/vendor-direct-fulfillment-shipping-api-use-case-guide#additional-fields-explanation).
	StatusCode string `json:"statusCode"`

	// StatusDateTime The date and time when the shipment status was updated. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format, with UTC time zone or UTC offset. For example, 2020-07-16T23:00:00Z or 2020-07-16T23:00:00+01:00.
	StatusDateTime time.Time `json:"statusDateTime"`

	// StatusLocationAddress Address of the party.
	StatusLocationAddress Address `json:"statusLocationAddress"`

	// TrackingNumber The shipment tracking number is required for every package and should match the `trackingNumber` sent for the shipment confirmation.
	TrackingNumber string `json:"trackingNumber"`
}

// SubmitShipmentConfirmationsRequest The request schema for the submitShipmentConfirmations operation.
type SubmitShipmentConfirmationsRequest struct {
	// ShipmentConfirmations Array of `ShipmentConfirmation` objects. Each `ShipmentConfirmation` object represents the confirmation details for a specific shipment.
	ShipmentConfirmations *[]ShipmentConfirmation `json:"shipmentConfirmations,omitempty"`
}

// SubmitShipmentStatusUpdatesRequest The request schema for the `submitShipmentStatusUpdates` operation.
type SubmitShipmentStatusUpdatesRequest struct {
	// ShipmentStatusUpdates Contains a list of one or more `ShipmentStatusUpdate` objects. Each `ShipmentStatusUpdate` object represents an update to the status of a specific shipment.
	ShipmentStatusUpdates *[]ShipmentStatusUpdate `json:"shipmentStatusUpdates,omitempty"`
}

// SubmitShippingLabelsRequest The request schema for the `submitShippingLabelRequest` operation.
type SubmitShippingLabelsRequest struct {
	// ShippingLabelRequests An array of shipping label requests to be processed.
	ShippingLabelRequests *[]ShippingLabelRequest `json:"shippingLabelRequests,omitempty"`
}

// TaxRegistrationDetails Tax registration details of the entity.
type TaxRegistrationDetails struct {
	// TaxRegistrationAddress Address of the party.
	TaxRegistrationAddress *Address `json:"taxRegistrationAddress,omitempty"`

	// TaxRegistrationMessages Tax registration message that can be used for additional tax related details.
	TaxRegistrationMessages *string `json:"taxRegistrationMessages,omitempty"`

	// TaxRegistrationNumber Tax registration number for the party. For example, VAT ID.
	TaxRegistrationNumber string `json:"taxRegistrationNumber"`

	// TaxRegistrationType Tax registration type for the entity.
	TaxRegistrationType *TaxRegistrationDetailsTaxRegistrationType `json:"taxRegistrationType,omitempty"`
}

// TaxRegistrationDetailsTaxRegistrationType Tax registration type for the entity.
type TaxRegistrationDetailsTaxRegistrationType string

// TransactionReference Response containing the transaction ID.
type TransactionReference struct {
	// TransactionId GUID to identify this transaction. This value can be used with the Transaction Status API to return the status of this transaction.
	TransactionId *string `json:"transactionId,omitempty"`
}

// VendorContainerId The unique, vendor-provided identifier for the container.
type VendorContainerId = string

// Weight The weight.
type Weight struct {
	// UnitOfMeasure The unit of measurement.
	UnitOfMeasure WeightUnitOfMeasure `json:"unitOfMeasure"`

	// Value A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation.  <br>**Pattern** : `^-?(0|([1-9]\\d*))(\\.\\d+)?([eE][+-]?\\d+)?$`.
	Value Decimal `json:"value"`
}

// WeightUnitOfMeasure The unit of measurement.
type WeightUnitOfMeasure string

// GetCustomerInvoicesParams defines parameters for GetCustomerInvoices.
type GetCustomerInvoicesParams struct {
	// ShipFromPartyId The vendor warehouseId for order fulfillment. If not specified, the result will contain orders for all warehouses.
	ShipFromPartyId *string `form:"shipFromPartyId,omitempty" json:"shipFromPartyId,omitempty"`

	// Limit The limit to the number of records returned
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// CreatedAfter Orders that became available after this date and time will be included in the result. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	CreatedAfter time.Time `form:"createdAfter" json:"createdAfter"`

	// CreatedBefore Orders that became available before this date and time will be included in the result. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	CreatedBefore time.Time `form:"createdBefore" json:"createdBefore"`

	// SortOrder Sort ASC or DESC by order creation date.
	SortOrder *GetCustomerInvoicesParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// NextToken Used for pagination when there are more orders than the specified result size limit. The token value is returned in the previous API call.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// GetCustomerInvoicesParamsSortOrder defines parameters for GetCustomerInvoices.
type GetCustomerInvoicesParamsSortOrder string

// GetPackingSlipsParams defines parameters for GetPackingSlips.
type GetPackingSlipsParams struct {
	// ShipFromPartyId The vendor `warehouseId` for order fulfillment. If not specified, the result contains orders for all warehouses.
	ShipFromPartyId *string `form:"shipFromPartyId,omitempty" json:"shipFromPartyId,omitempty"`

	// Limit The maximum number of records to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// CreatedAfter Packing slips that become available after this date and time will be included in the result. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	CreatedAfter time.Time `form:"createdAfter" json:"createdAfter"`

	// CreatedBefore Packing slips that became available before this date and time will be included in the result. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	CreatedBefore time.Time `form:"createdBefore" json:"createdBefore"`

	// SortOrder The packing slip creation dates, which are sorted by ascending or descending order.
	SortOrder *GetPackingSlipsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// NextToken Used for pagination when there are more packing slips than the specified result size limit. The token value is returned in the previous API call.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// GetPackingSlipsParamsSortOrder defines parameters for GetPackingSlips.
type GetPackingSlipsParamsSortOrder string

// GetShippingLabelsParams defines parameters for GetShippingLabels.
type GetShippingLabelsParams struct {
	// ShipFromPartyId The vendor `warehouseId` for order fulfillment. If not specified, the result contains orders for all warehouses.
	ShipFromPartyId *string `form:"shipFromPartyId,omitempty" json:"shipFromPartyId,omitempty"`

	// Limit The limit to the number of records returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// CreatedAfter Shipping labels that became available after this date and time will be included in the result. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	CreatedAfter time.Time `form:"createdAfter" json:"createdAfter"`

	// CreatedBefore Shipping labels that became available before this date and time will be included in the result. Values are in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	CreatedBefore time.Time `form:"createdBefore" json:"createdBefore"`

	// SortOrder The sort order creation date. You can choose between ascending (`ASC`) or descending (`DESC`) sort order.
	SortOrder *GetShippingLabelsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// NextToken Used for pagination when there are more ship labels than the specified result size limit. The token value is returned in the previous API call.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// GetShippingLabelsParamsSortOrder defines parameters for GetShippingLabels.
type GetShippingLabelsParamsSortOrder string

// CreateContainerLabelJSONRequestBody defines body for CreateContainerLabel for application/json ContentType.
type CreateContainerLabelJSONRequestBody = CreateContainerLabelRequest

// SubmitShipmentConfirmationsJSONRequestBody defines body for SubmitShipmentConfirmations for application/json ContentType.
type SubmitShipmentConfirmationsJSONRequestBody = SubmitShipmentConfirmationsRequest

// SubmitShipmentStatusUpdatesJSONRequestBody defines body for SubmitShipmentStatusUpdates for application/json ContentType.
type SubmitShipmentStatusUpdatesJSONRequestBody = SubmitShipmentStatusUpdatesRequest

// SubmitShippingLabelRequestJSONRequestBody defines body for SubmitShippingLabelRequest for application/json ContentType.
type SubmitShippingLabelRequestJSONRequestBody = SubmitShippingLabelsRequest

// CreateShippingLabelsJSONRequestBody defines body for CreateShippingLabels for application/json ContentType.
type CreateShippingLabelsJSONRequestBody = CreateShippingLabelsRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateContainerLabelWithBody request with any body
	CreateContainerLabelWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateContainerLabel(ctx context.Context, body CreateContainerLabelJSONRequestBody) (*http.Response, error)

	// GetCustomerInvoices request
	GetCustomerInvoices(ctx context.Context, params *GetCustomerInvoicesParams) (*http.Response, error)

	// GetCustomerInvoice request
	GetCustomerInvoice(ctx context.Context, purchaseOrderNumber string) (*http.Response, error)

	// GetPackingSlips request
	GetPackingSlips(ctx context.Context, params *GetPackingSlipsParams) (*http.Response, error)

	// GetPackingSlip request
	GetPackingSlip(ctx context.Context, purchaseOrderNumber string) (*http.Response, error)

	// SubmitShipmentConfirmationsWithBody request with any body
	SubmitShipmentConfirmationsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	SubmitShipmentConfirmations(ctx context.Context, body SubmitShipmentConfirmationsJSONRequestBody) (*http.Response, error)

	// SubmitShipmentStatusUpdatesWithBody request with any body
	SubmitShipmentStatusUpdatesWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	SubmitShipmentStatusUpdates(ctx context.Context, body SubmitShipmentStatusUpdatesJSONRequestBody) (*http.Response, error)

	// GetShippingLabels request
	GetShippingLabels(ctx context.Context, params *GetShippingLabelsParams) (*http.Response, error)

	// SubmitShippingLabelRequestWithBody request with any body
	SubmitShippingLabelRequestWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	SubmitShippingLabelRequest(ctx context.Context, body SubmitShippingLabelRequestJSONRequestBody) (*http.Response, error)

	// GetShippingLabel request
	GetShippingLabel(ctx context.Context, purchaseOrderNumber string) (*http.Response, error)

	// CreateShippingLabelsWithBody request with any body
	CreateShippingLabelsWithBody(ctx context.Context, purchaseOrderNumber string, contentType string, body io.Reader) (*http.Response, error)

	CreateShippingLabels(ctx context.Context, purchaseOrderNumber string, body CreateShippingLabelsJSONRequestBody) (*http.Response, error)
}

func (c *Client) CreateContainerLabelWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateContainerLabelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateContainerLabel(ctx context.Context, body CreateContainerLabelJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateContainerLabelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetCustomerInvoices(ctx context.Context, params *GetCustomerInvoicesParams) (*http.Response, error) {
	req, err := NewGetCustomerInvoicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetCustomerInvoice(ctx context.Context, purchaseOrderNumber string) (*http.Response, error) {
	req, err := NewGetCustomerInvoiceRequest(c.Server, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetPackingSlips(ctx context.Context, params *GetPackingSlipsParams) (*http.Response, error) {
	req, err := NewGetPackingSlipsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetPackingSlip(ctx context.Context, purchaseOrderNumber string) (*http.Response, error) {
	req, err := NewGetPackingSlipRequest(c.Server, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SubmitShipmentConfirmationsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSubmitShipmentConfirmationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SubmitShipmentConfirmations(ctx context.Context, body SubmitShipmentConfirmationsJSONRequestBody) (*http.Response, error) {
	req, err := NewSubmitShipmentConfirmationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SubmitShipmentStatusUpdatesWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSubmitShipmentStatusUpdatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SubmitShipmentStatusUpdates(ctx context.Context, body SubmitShipmentStatusUpdatesJSONRequestBody) (*http.Response, error) {
	req, err := NewSubmitShipmentStatusUpdatesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetShippingLabels(ctx context.Context, params *GetShippingLabelsParams) (*http.Response, error) {
	req, err := NewGetShippingLabelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SubmitShippingLabelRequestWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSubmitShippingLabelRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SubmitShippingLabelRequest(ctx context.Context, body SubmitShippingLabelRequestJSONRequestBody) (*http.Response, error) {
	req, err := NewSubmitShippingLabelRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetShippingLabel(ctx context.Context, purchaseOrderNumber string) (*http.Response, error) {
	req, err := NewGetShippingLabelRequest(c.Server, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateShippingLabelsWithBody(ctx context.Context, purchaseOrderNumber string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateShippingLabelsRequestWithBody(c.Server, purchaseOrderNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateShippingLabels(ctx context.Context, purchaseOrderNumber string, body CreateShippingLabelsJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateShippingLabelsRequest(c.Server, purchaseOrderNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewCreateContainerLabelRequest calls the generic CreateContainerLabel builder with application/json body
func NewCreateContainerLabelRequest(server string, body CreateContainerLabelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateContainerLabelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateContainerLabelRequestWithBody generates requests for CreateContainerLabel with any type of body
func NewCreateContainerLabelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/shipping/2021-12-28/containerLabel")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomerInvoicesRequest generates requests for GetCustomerInvoices
func NewGetCustomerInvoicesRequest(server string, params *GetCustomerInvoicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/shipping/2021-12-28/customerInvoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShipFromPartyId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipFromPartyId", runtime.ParamLocationQuery, *params.ShipFromPartyId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, params.CreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBefore", runtime.ParamLocationQuery, params.CreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomerInvoiceRequest generates requests for GetCustomerInvoice
func NewGetCustomerInvoiceRequest(server string, purchaseOrderNumber string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "purchaseOrderNumber", runtime.ParamLocationPath, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/shipping/2021-12-28/customerInvoices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackingSlipsRequest generates requests for GetPackingSlips
func NewGetPackingSlipsRequest(server string, params *GetPackingSlipsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/shipping/2021-12-28/packingSlips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShipFromPartyId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipFromPartyId", runtime.ParamLocationQuery, *params.ShipFromPartyId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, params.CreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBefore", runtime.ParamLocationQuery, params.CreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackingSlipRequest generates requests for GetPackingSlip
func NewGetPackingSlipRequest(server string, purchaseOrderNumber string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "purchaseOrderNumber", runtime.ParamLocationPath, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/shipping/2021-12-28/packingSlips/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitShipmentConfirmationsRequest calls the generic SubmitShipmentConfirmations builder with application/json body
func NewSubmitShipmentConfirmationsRequest(server string, body SubmitShipmentConfirmationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitShipmentConfirmationsRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitShipmentConfirmationsRequestWithBody generates requests for SubmitShipmentConfirmations with any type of body
func NewSubmitShipmentConfirmationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/shipping/2021-12-28/shipmentConfirmations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSubmitShipmentStatusUpdatesRequest calls the generic SubmitShipmentStatusUpdates builder with application/json body
func NewSubmitShipmentStatusUpdatesRequest(server string, body SubmitShipmentStatusUpdatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitShipmentStatusUpdatesRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitShipmentStatusUpdatesRequestWithBody generates requests for SubmitShipmentStatusUpdates with any type of body
func NewSubmitShipmentStatusUpdatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/shipping/2021-12-28/shipmentStatusUpdates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetShippingLabelsRequest generates requests for GetShippingLabels
func NewGetShippingLabelsRequest(server string, params *GetShippingLabelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/shipping/2021-12-28/shippingLabels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShipFromPartyId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipFromPartyId", runtime.ParamLocationQuery, *params.ShipFromPartyId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, params.CreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBefore", runtime.ParamLocationQuery, params.CreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitShippingLabelRequestRequest calls the generic SubmitShippingLabelRequest builder with application/json body
func NewSubmitShippingLabelRequestRequest(server string, body SubmitShippingLabelRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitShippingLabelRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitShippingLabelRequestRequestWithBody generates requests for SubmitShippingLabelRequest with any type of body
func NewSubmitShippingLabelRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/shipping/2021-12-28/shippingLabels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetShippingLabelRequest generates requests for GetShippingLabel
func NewGetShippingLabelRequest(server string, purchaseOrderNumber string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "purchaseOrderNumber", runtime.ParamLocationPath, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/shipping/2021-12-28/shippingLabels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateShippingLabelsRequest calls the generic CreateShippingLabels builder with application/json body
func NewCreateShippingLabelsRequest(server string, purchaseOrderNumber string, body CreateShippingLabelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateShippingLabelsRequestWithBody(server, purchaseOrderNumber, "application/json", bodyReader)
}

// NewCreateShippingLabelsRequestWithBody generates requests for CreateShippingLabels with any type of body
func NewCreateShippingLabelsRequestWithBody(server string, purchaseOrderNumber string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "purchaseOrderNumber", runtime.ParamLocationPath, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/shipping/2021-12-28/shippingLabels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateContainerLabelWithBodyWithResponse request with any body
	CreateContainerLabelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateContainerLabelResp, error)

	CreateContainerLabelWithResponse(ctx context.Context, body CreateContainerLabelJSONRequestBody) (*CreateContainerLabelResp, error)

	// GetCustomerInvoicesWithResponse request
	GetCustomerInvoicesWithResponse(ctx context.Context, params *GetCustomerInvoicesParams) (*GetCustomerInvoicesResp, error)

	// GetCustomerInvoiceWithResponse request
	GetCustomerInvoiceWithResponse(ctx context.Context, purchaseOrderNumber string) (*GetCustomerInvoiceResp, error)

	// GetPackingSlipsWithResponse request
	GetPackingSlipsWithResponse(ctx context.Context, params *GetPackingSlipsParams) (*GetPackingSlipsResp, error)

	// GetPackingSlipWithResponse request
	GetPackingSlipWithResponse(ctx context.Context, purchaseOrderNumber string) (*GetPackingSlipResp, error)

	// SubmitShipmentConfirmationsWithBodyWithResponse request with any body
	SubmitShipmentConfirmationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SubmitShipmentConfirmationsResp, error)

	SubmitShipmentConfirmationsWithResponse(ctx context.Context, body SubmitShipmentConfirmationsJSONRequestBody) (*SubmitShipmentConfirmationsResp, error)

	// SubmitShipmentStatusUpdatesWithBodyWithResponse request with any body
	SubmitShipmentStatusUpdatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SubmitShipmentStatusUpdatesResp, error)

	SubmitShipmentStatusUpdatesWithResponse(ctx context.Context, body SubmitShipmentStatusUpdatesJSONRequestBody) (*SubmitShipmentStatusUpdatesResp, error)

	// GetShippingLabelsWithResponse request
	GetShippingLabelsWithResponse(ctx context.Context, params *GetShippingLabelsParams) (*GetShippingLabelsResp, error)

	// SubmitShippingLabelRequestWithBodyWithResponse request with any body
	SubmitShippingLabelRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SubmitShippingLabelRequestResp, error)

	SubmitShippingLabelRequestWithResponse(ctx context.Context, body SubmitShippingLabelRequestJSONRequestBody) (*SubmitShippingLabelRequestResp, error)

	// GetShippingLabelWithResponse request
	GetShippingLabelWithResponse(ctx context.Context, purchaseOrderNumber string) (*GetShippingLabelResp, error)

	// CreateShippingLabelsWithBodyWithResponse request with any body
	CreateShippingLabelsWithBodyWithResponse(ctx context.Context, purchaseOrderNumber string, contentType string, body io.Reader) (*CreateShippingLabelsResp, error)

	CreateShippingLabelsWithResponse(ctx context.Context, purchaseOrderNumber string, body CreateShippingLabelsJSONRequestBody) (*CreateShippingLabelsResp, error)
}

type CreateContainerLabelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateContainerLabelResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CreateContainerLabelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateContainerLabelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerInvoicesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomerInvoiceList
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetCustomerInvoicesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerInvoicesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerInvoiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomerInvoice
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetCustomerInvoiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerInvoiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackingSlipsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackingSlipList
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetPackingSlipsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackingSlipsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackingSlipResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackingSlip
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetPackingSlipResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackingSlipResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitShipmentConfirmationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TransactionReference
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r SubmitShipmentConfirmationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitShipmentConfirmationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitShipmentStatusUpdatesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TransactionReference
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r SubmitShipmentStatusUpdatesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitShipmentStatusUpdatesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShippingLabelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShippingLabelList
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetShippingLabelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShippingLabelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitShippingLabelRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TransactionReference
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r SubmitShippingLabelRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitShippingLabelRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShippingLabelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShippingLabel
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetShippingLabelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShippingLabelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateShippingLabelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShippingLabel
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON409      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CreateShippingLabelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateShippingLabelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateContainerLabelWithBodyWithResponse request with arbitrary body returning *CreateContainerLabelResp
func (c *ClientWithResponses) CreateContainerLabelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateContainerLabelResp, error) {
	rsp, err := c.CreateContainerLabelWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateContainerLabelResp(rsp)
}

func (c *ClientWithResponses) CreateContainerLabelWithResponse(ctx context.Context, body CreateContainerLabelJSONRequestBody) (*CreateContainerLabelResp, error) {
	rsp, err := c.CreateContainerLabel(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateContainerLabelResp(rsp)
}

// GetCustomerInvoicesWithResponse request returning *GetCustomerInvoicesResp
func (c *ClientWithResponses) GetCustomerInvoicesWithResponse(ctx context.Context, params *GetCustomerInvoicesParams) (*GetCustomerInvoicesResp, error) {
	rsp, err := c.GetCustomerInvoices(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerInvoicesResp(rsp)
}

// GetCustomerInvoiceWithResponse request returning *GetCustomerInvoiceResp
func (c *ClientWithResponses) GetCustomerInvoiceWithResponse(ctx context.Context, purchaseOrderNumber string) (*GetCustomerInvoiceResp, error) {
	rsp, err := c.GetCustomerInvoice(ctx, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerInvoiceResp(rsp)
}

// GetPackingSlipsWithResponse request returning *GetPackingSlipsResp
func (c *ClientWithResponses) GetPackingSlipsWithResponse(ctx context.Context, params *GetPackingSlipsParams) (*GetPackingSlipsResp, error) {
	rsp, err := c.GetPackingSlips(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetPackingSlipsResp(rsp)
}

// GetPackingSlipWithResponse request returning *GetPackingSlipResp
func (c *ClientWithResponses) GetPackingSlipWithResponse(ctx context.Context, purchaseOrderNumber string) (*GetPackingSlipResp, error) {
	rsp, err := c.GetPackingSlip(ctx, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}
	return ParseGetPackingSlipResp(rsp)
}

// SubmitShipmentConfirmationsWithBodyWithResponse request with arbitrary body returning *SubmitShipmentConfirmationsResp
func (c *ClientWithResponses) SubmitShipmentConfirmationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SubmitShipmentConfirmationsResp, error) {
	rsp, err := c.SubmitShipmentConfirmationsWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitShipmentConfirmationsResp(rsp)
}

func (c *ClientWithResponses) SubmitShipmentConfirmationsWithResponse(ctx context.Context, body SubmitShipmentConfirmationsJSONRequestBody) (*SubmitShipmentConfirmationsResp, error) {
	rsp, err := c.SubmitShipmentConfirmations(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitShipmentConfirmationsResp(rsp)
}

// SubmitShipmentStatusUpdatesWithBodyWithResponse request with arbitrary body returning *SubmitShipmentStatusUpdatesResp
func (c *ClientWithResponses) SubmitShipmentStatusUpdatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SubmitShipmentStatusUpdatesResp, error) {
	rsp, err := c.SubmitShipmentStatusUpdatesWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitShipmentStatusUpdatesResp(rsp)
}

func (c *ClientWithResponses) SubmitShipmentStatusUpdatesWithResponse(ctx context.Context, body SubmitShipmentStatusUpdatesJSONRequestBody) (*SubmitShipmentStatusUpdatesResp, error) {
	rsp, err := c.SubmitShipmentStatusUpdates(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitShipmentStatusUpdatesResp(rsp)
}

// GetShippingLabelsWithResponse request returning *GetShippingLabelsResp
func (c *ClientWithResponses) GetShippingLabelsWithResponse(ctx context.Context, params *GetShippingLabelsParams) (*GetShippingLabelsResp, error) {
	rsp, err := c.GetShippingLabels(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetShippingLabelsResp(rsp)
}

// SubmitShippingLabelRequestWithBodyWithResponse request with arbitrary body returning *SubmitShippingLabelRequestResp
func (c *ClientWithResponses) SubmitShippingLabelRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SubmitShippingLabelRequestResp, error) {
	rsp, err := c.SubmitShippingLabelRequestWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitShippingLabelRequestResp(rsp)
}

func (c *ClientWithResponses) SubmitShippingLabelRequestWithResponse(ctx context.Context, body SubmitShippingLabelRequestJSONRequestBody) (*SubmitShippingLabelRequestResp, error) {
	rsp, err := c.SubmitShippingLabelRequest(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitShippingLabelRequestResp(rsp)
}

// GetShippingLabelWithResponse request returning *GetShippingLabelResp
func (c *ClientWithResponses) GetShippingLabelWithResponse(ctx context.Context, purchaseOrderNumber string) (*GetShippingLabelResp, error) {
	rsp, err := c.GetShippingLabel(ctx, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}
	return ParseGetShippingLabelResp(rsp)
}

// CreateShippingLabelsWithBodyWithResponse request with arbitrary body returning *CreateShippingLabelsResp
func (c *ClientWithResponses) CreateShippingLabelsWithBodyWithResponse(ctx context.Context, purchaseOrderNumber string, contentType string, body io.Reader) (*CreateShippingLabelsResp, error) {
	rsp, err := c.CreateShippingLabelsWithBody(ctx, purchaseOrderNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateShippingLabelsResp(rsp)
}

func (c *ClientWithResponses) CreateShippingLabelsWithResponse(ctx context.Context, purchaseOrderNumber string, body CreateShippingLabelsJSONRequestBody) (*CreateShippingLabelsResp, error) {
	rsp, err := c.CreateShippingLabels(ctx, purchaseOrderNumber, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateShippingLabelsResp(rsp)
}

// ParseCreateContainerLabelResp parses an HTTP response from a CreateContainerLabelWithResponse call
func ParseCreateContainerLabelResp(rsp *http.Response) (*CreateContainerLabelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateContainerLabelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateContainerLabelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetCustomerInvoicesResp parses an HTTP response from a GetCustomerInvoicesWithResponse call
func ParseGetCustomerInvoicesResp(rsp *http.Response) (*GetCustomerInvoicesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerInvoicesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomerInvoiceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetCustomerInvoiceResp parses an HTTP response from a GetCustomerInvoiceWithResponse call
func ParseGetCustomerInvoiceResp(rsp *http.Response) (*GetCustomerInvoiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerInvoiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomerInvoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPackingSlipsResp parses an HTTP response from a GetPackingSlipsWithResponse call
func ParseGetPackingSlipsResp(rsp *http.Response) (*GetPackingSlipsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackingSlipsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackingSlipList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPackingSlipResp parses an HTTP response from a GetPackingSlipWithResponse call
func ParseGetPackingSlipResp(rsp *http.Response) (*GetPackingSlipResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackingSlipResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackingSlip
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSubmitShipmentConfirmationsResp parses an HTTP response from a SubmitShipmentConfirmationsWithResponse call
func ParseSubmitShipmentConfirmationsResp(rsp *http.Response) (*SubmitShipmentConfirmationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitShipmentConfirmationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TransactionReference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSubmitShipmentStatusUpdatesResp parses an HTTP response from a SubmitShipmentStatusUpdatesWithResponse call
func ParseSubmitShipmentStatusUpdatesResp(rsp *http.Response) (*SubmitShipmentStatusUpdatesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitShipmentStatusUpdatesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TransactionReference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetShippingLabelsResp parses an HTTP response from a GetShippingLabelsWithResponse call
func ParseGetShippingLabelsResp(rsp *http.Response) (*GetShippingLabelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShippingLabelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShippingLabelList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSubmitShippingLabelRequestResp parses an HTTP response from a SubmitShippingLabelRequestWithResponse call
func ParseSubmitShippingLabelRequestResp(rsp *http.Response) (*SubmitShippingLabelRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitShippingLabelRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TransactionReference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetShippingLabelResp parses an HTTP response from a GetShippingLabelWithResponse call
func ParseGetShippingLabelResp(rsp *http.Response) (*GetShippingLabelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShippingLabelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShippingLabel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateShippingLabelsResp parses an HTTP response from a CreateShippingLabelsWithResponse call
func ParseCreateShippingLabelsResp(rsp *http.Response) (*CreateShippingLabelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateShippingLabelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShippingLabel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
