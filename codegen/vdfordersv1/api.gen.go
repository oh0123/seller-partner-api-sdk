// Package vdfordersv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package vdfordersv1

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/bytedance/sonic"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ItemQuantityUnitOfMeasure.
const (
	Each ItemQuantityUnitOfMeasure = "Each"
)

// Defines values for OrderDetailsOrderStatus.
const (
	OrderDetailsOrderStatusACCEPTED  OrderDetailsOrderStatus = "ACCEPTED"
	OrderDetailsOrderStatusCANCELLED OrderDetailsOrderStatus = "CANCELLED"
	OrderDetailsOrderStatusNEW       OrderDetailsOrderStatus = "NEW"
	OrderDetailsOrderStatusSHIPPED   OrderDetailsOrderStatus = "SHIPPED"
)

// Defines values for TaxDetailsType.
const (
	TaxDetailsTypeCONSUMPTION TaxDetailsType = "CONSUMPTION"
	TaxDetailsTypeGST         TaxDetailsType = "GST"
	TaxDetailsTypeMwSt        TaxDetailsType = "MwSt."
	TaxDetailsTypePST         TaxDetailsType = "PST"
	TaxDetailsTypeTOTAL       TaxDetailsType = "TOTAL"
	TaxDetailsTypeTVA         TaxDetailsType = "TVA"
	TaxDetailsTypeVAT         TaxDetailsType = "VAT"
)

// Defines values for TaxRegistrationDetailsTaxRegistrationType.
const (
	TaxRegistrationDetailsTaxRegistrationTypeGST TaxRegistrationDetailsTaxRegistrationType = "GST"
	TaxRegistrationDetailsTaxRegistrationTypeVAT TaxRegistrationDetailsTaxRegistrationType = "VAT"
)

// Defines values for GetOrdersParamsStatus.
const (
	GetOrdersParamsStatusACCEPTED  GetOrdersParamsStatus = "ACCEPTED"
	GetOrdersParamsStatusCANCELLED GetOrdersParamsStatus = "CANCELLED"
	GetOrdersParamsStatusNEW       GetOrdersParamsStatus = "NEW"
	GetOrdersParamsStatusSHIPPED   GetOrdersParamsStatus = "SHIPPED"
)

// Defines values for GetOrdersParamsSortOrder.
const (
	ASC  GetOrdersParamsSortOrder = "ASC"
	DESC GetOrdersParamsSortOrder = "DESC"
)

// AcknowledgementStatus Status of acknowledgement.
type AcknowledgementStatus struct {
	// Code Acknowledgement code is a unique two digit value which indicates the status of the acknowledgement. For a list of acknowledgement codes that Amazon supports, see the Vendor Direct Fulfillment APIs Use Case Guide.
	Code *string `json:"code,omitempty"`

	// Description Reason for the acknowledgement code.
	Description *string `json:"description,omitempty"`
}

// Address Address of the party.
type Address struct {
	// AddressLine1 First line of the address. For Amazon label only vendors, this field will have the value `xxxxx` within the object `shipToParty`.
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Additional address information, if required. For Amazon label only vendors, this field will have the value `xxxxx` within the object `shipToParty`.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 Additional address information, if required. For Amazon label only vendors, this field will have the value `xxxxx` within the object `shipToParty`.
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// Attention The attention name of the person at that address. For Amazon label only vendors, this field will have the value `xxxxx` within the object `shipToParty`.
	Attention *string `json:"attention,omitempty"`

	// City The city where the person, business, or institution is located. For Amazon label only vendors, this field will have the value `xxxxx` within the object `shipToParty`.
	City *string `json:"city,omitempty"`

	// CountryCode The two digit country code. In ISO 3166-1 alpha-2 format.
	CountryCode string `json:"countryCode"`

	// County The county where the person, business, or institution is located. For Amazon label only vendors, this field will have the value `xxxxx` within the object `shipToParty`.
	County *string `json:"county,omitempty"`

	// District The district where the person, business, or institution is located. For Amazon label only vendors, this field will have the value `xxxxx` within the object `shipToParty`.
	District *string `json:"district,omitempty"`

	// Name The name of the person, business, or institution at that address. For Amazon label only vendors, this field will have the value `xxxxx` within the object `shipToParty`.
	Name string `json:"name"`

	// Phone The phone number of the person, business, or institution located at that address. For Amazon label only vendors, this field will have the value `xxxxx` within the object `shipToParty`.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The postal code of that address. It conatins a series of letters or digits or both, sometimes including spaces or punctuation.
	PostalCode *string `json:"postalCode,omitempty"`

	// StateOrRegion The state or region where person, business or institution is located.
	StateOrRegion string `json:"stateOrRegion"`
}

// Decimal A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation.
type Decimal = string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// GetOrderResponse The response schema for the getOrder operation.
type GetOrderResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Represents a purchase order.
	Payload *Order `json:"payload,omitempty"`
}

// GetOrdersResponse The response schema for the getOrders operation.
type GetOrdersResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload A purchase orders list returned as a response.
	Payload *OrderList `json:"payload,omitempty"`
}

// GiftDetails Gift details for the item.
type GiftDetails struct {
	// GiftMessage Gift message to be printed in shipment.
	GiftMessage *string `json:"giftMessage,omitempty"`

	// GiftWrapId Gift wrap identifier for the gift wrapping, if any.
	GiftWrapId *string `json:"giftWrapId,omitempty"`
}

// ItemQuantity Details of quantity ordered.
type ItemQuantity struct {
	// Amount Acknowledged quantity. This value should not be zero.
	Amount *int `json:"amount,omitempty"`

	// UnitOfMeasure Unit of measure for the acknowledged quantity.
	UnitOfMeasure *ItemQuantityUnitOfMeasure `json:"unitOfMeasure,omitempty"`
}

// ItemQuantityUnitOfMeasure Unit of measure for the acknowledged quantity.
type ItemQuantityUnitOfMeasure string

// Money An amount of money, including units in the form of currency.
type Money struct {
	// Amount A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation.
	Amount *Decimal `json:"amount,omitempty"`

	// CurrencyCode Three digit currency code in ISO 4217 format. String of length 3.
	CurrencyCode *string `json:"currencyCode,omitempty"`
}

// Order Represents a purchase order.
type Order struct {
	// OrderDetails Details of an order.
	OrderDetails *OrderDetails `json:"orderDetails,omitempty"`

	// PurchaseOrderNumber The purchase order number for this order. Formatting Notes: alpha-numeric code.
	PurchaseOrderNumber string `json:"purchaseOrderNumber"`
}

// OrderAcknowledgementItem Details of an individual order being acknowledged.
type OrderAcknowledgementItem struct {
	// AcknowledgementDate The date and time when the order is acknowledged, in ISO-8601 date/time format. For example: 2018-07-16T23:00:00Z / 2018-07-16T23:00:00-05:00 / 2018-07-16T23:00:00-08:00.
	AcknowledgementDate time.Time `json:"acknowledgementDate"`

	// AcknowledgementStatus Status of acknowledgement.
	AcknowledgementStatus AcknowledgementStatus `json:"acknowledgementStatus"`

	// ItemAcknowledgements Item details including acknowledged quantity.
	ItemAcknowledgements []OrderItemAcknowledgement `json:"itemAcknowledgements"`

	// PurchaseOrderNumber The purchase order number for this order. Formatting Notes: alpha-numeric code.
	PurchaseOrderNumber string `json:"purchaseOrderNumber"`

	// SellingParty Name, address, and tax details of a party.
	SellingParty PartyIdentification `json:"sellingParty"`

	// ShipFromParty Name, address, and tax details of a party.
	ShipFromParty PartyIdentification `json:"shipFromParty"`

	// VendorOrderNumber The vendor's order number for this order.
	VendorOrderNumber string `json:"vendorOrderNumber"`
}

// OrderDetails Details of an order.
type OrderDetails struct {
	// BillToParty Name, address, and tax details of a party.
	BillToParty PartyIdentification `json:"billToParty"`

	// CustomerOrderNumber The customer order number.
	CustomerOrderNumber string `json:"customerOrderNumber"`

	// Items A list of items in this purchase order.
	Items []OrderItem `json:"items"`

	// OrderDate The date the order was placed. This field is expected to be in ISO-8601 date/time format, for example:2018-07-16T23:00:00Z/ 2018-07-16T23:00:00-05:00 /2018-07-16T23:00:00-08:00. If no time zone is specified, UTC should be assumed.
	OrderDate time.Time `json:"orderDate"`

	// OrderStatus Current status of the order.
	OrderStatus *OrderDetailsOrderStatus `json:"orderStatus,omitempty"`

	// SellingParty Name, address, and tax details of a party.
	SellingParty PartyIdentification `json:"sellingParty"`

	// ShipFromParty Name, address, and tax details of a party.
	ShipFromParty PartyIdentification `json:"shipFromParty"`

	// ShipToParty Address of the party.
	ShipToParty Address `json:"shipToParty"`

	// ShipmentDetails Shipment details required for the shipment.
	ShipmentDetails ShipmentDetails `json:"shipmentDetails"`

	// TaxTotal The total tax object within the shipment that relates to the order.
	TaxTotal *struct {
		// TaxLineItem A list of tax line items.
		TaxLineItem *TaxLineItem `json:"taxLineItem,omitempty"`
	} `json:"taxTotal,omitempty"`
}

// OrderDetailsOrderStatus Current status of the order.
type OrderDetailsOrderStatus string

// OrderItem An order item.
type OrderItem struct {
	// BuyerProductIdentifier Buyer's standard identification number (ASIN) of an item.
	BuyerProductIdentifier *string `json:"buyerProductIdentifier,omitempty"`

	// GiftDetails Gift details for the item.
	GiftDetails *GiftDetails `json:"giftDetails,omitempty"`

	// ItemSequenceNumber Numbering of the item on the purchase order. The first item will be 1, the second 2, and so on.
	ItemSequenceNumber string `json:"itemSequenceNumber"`

	// NetPrice An amount of money, including units in the form of currency.
	NetPrice Money `json:"netPrice"`

	// OrderedQuantity Details of quantity ordered.
	OrderedQuantity ItemQuantity `json:"orderedQuantity"`

	// ScheduledDeliveryShipment Dates for the scheduled delivery shipments.
	ScheduledDeliveryShipment *ScheduledDeliveryShipment `json:"scheduledDeliveryShipment,omitempty"`

	// TaxDetails Total tax details for the line item.
	TaxDetails *struct {
		// TaxLineItem A list of tax line items.
		TaxLineItem *TaxLineItem `json:"taxLineItem,omitempty"`
	} `json:"taxDetails,omitempty"`

	// Title Title for the item.
	Title *string `json:"title,omitempty"`

	// TotalPrice An amount of money, including units in the form of currency.
	TotalPrice *Money `json:"totalPrice,omitempty"`

	// VendorProductIdentifier The vendor selected product identification of the item.
	VendorProductIdentifier *string `json:"vendorProductIdentifier,omitempty"`
}

// OrderItemAcknowledgement Individual item details within the acknowledged order.
type OrderItemAcknowledgement struct {
	// AcknowledgedQuantity Details of quantity ordered.
	AcknowledgedQuantity ItemQuantity `json:"acknowledgedQuantity"`

	// BuyerProductIdentifier Buyer's standard identification number (ASIN) of an item.
	BuyerProductIdentifier *string `json:"buyerProductIdentifier,omitempty"`

	// ItemSequenceNumber Line item sequence number for the item.
	ItemSequenceNumber string `json:"itemSequenceNumber"`

	// VendorProductIdentifier The vendor selected product identification of the item. Should be the same as was provided in the purchase order.
	VendorProductIdentifier *string `json:"vendorProductIdentifier,omitempty"`
}

// OrderList A purchase orders list returned as a response.
type OrderList struct {
	// Orders Represents a purchase order within the `OrderList`.
	Orders *[]Order `json:"orders,omitempty"`

	// Pagination The pagination elements required to retrieve the remaining data.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// Pagination The pagination elements required to retrieve the remaining data.
type Pagination struct {
	// NextToken A generated string used to pass information to your next request. If NextToken is returned, pass the value of NextToken to the next request. If NextToken is not returned, there are no more order items to return.
	NextToken *string `json:"nextToken,omitempty"`
}

// PartyIdentification Name, address, and tax details of a party.
type PartyIdentification struct {
	// Address Address of the party.
	Address *Address `json:"address,omitempty"`

	// PartyId Assigned identification for the party. For example, warehouse code or vendor code. Please refer to specific party for more details.
	PartyId string `json:"partyId"`

	// TaxInfo Tax registration details of the entity.
	TaxInfo *TaxRegistrationDetails `json:"taxInfo,omitempty"`
}

// ScheduledDeliveryShipment Dates for the scheduled delivery shipments.
type ScheduledDeliveryShipment struct {
	// EarliestNominatedDeliveryDate Earliest nominated delivery date for the scheduled delivery.
	EarliestNominatedDeliveryDate *time.Time `json:"earliestNominatedDeliveryDate,omitempty"`

	// LatestNominatedDeliveryDate Latest nominated delivery date for the scheduled delivery.
	LatestNominatedDeliveryDate *time.Time `json:"latestNominatedDeliveryDate,omitempty"`

	// ScheduledDeliveryServiceType Scheduled delivery service type.
	ScheduledDeliveryServiceType *string `json:"scheduledDeliveryServiceType,omitempty"`
}

// ShipmentDates Shipment dates.
type ShipmentDates struct {
	// PromisedDeliveryDate Delivery date promised to the Amazon customer.
	PromisedDeliveryDate *time.Time `json:"promisedDeliveryDate,omitempty"`

	// RequiredShipDate Time by which the vendor is required to ship the order.
	RequiredShipDate time.Time `json:"requiredShipDate"`
}

// ShipmentDetails Shipment details required for the shipment.
type ShipmentDetails struct {
	// IsGift When true, the order contain a gift. Include the gift message and gift wrap information.
	IsGift *bool `json:"isGift,omitempty"`

	// IsPriorityShipment When true, this is a priority shipment.
	IsPriorityShipment bool `json:"isPriorityShipment"`

	// IsPslipRequired When true, a packing slip is required to be sent to the customer.
	IsPslipRequired bool `json:"isPslipRequired"`

	// IsScheduledDeliveryShipment When true, this order is part of a scheduled delivery program.
	IsScheduledDeliveryShipment *bool `json:"isScheduledDeliveryShipment,omitempty"`

	// MessageToCustomer Message to customer for order status.
	MessageToCustomer string `json:"messageToCustomer"`

	// ShipMethod Ship method to be used for shipping the order. Amazon defines ship method codes indicating the shipping carrier and shipment service level. To see the full list of ship methods in use, including both the code and the friendly name, search the 'Help' section on Vendor Central for 'ship methods'.
	ShipMethod string `json:"shipMethod"`

	// ShipmentDates Shipment dates.
	ShipmentDates ShipmentDates `json:"shipmentDates"`
}

// SubmitAcknowledgementRequest The request schema for the submitAcknowledgement operation.
type SubmitAcknowledgementRequest struct {
	// OrderAcknowledgements A list of one or more purchase orders.
	OrderAcknowledgements *[]OrderAcknowledgementItem `json:"orderAcknowledgements,omitempty"`
}

// SubmitAcknowledgementResponse The response schema for the submitAcknowledgement operation.
type SubmitAcknowledgementResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Response that contains the transaction ID.
	Payload *TransactionId `json:"payload,omitempty"`
}

// TaxDetails The order's tax details.
type TaxDetails struct {
	// TaxAmount An amount of money, including units in the form of currency.
	TaxAmount Money `json:"taxAmount"`

	// TaxRate A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation.
	TaxRate *Decimal `json:"taxRate,omitempty"`

	// TaxableAmount An amount of money, including units in the form of currency.
	TaxableAmount *Money `json:"taxableAmount,omitempty"`

	// Type Tax type.
	Type *TaxDetailsType `json:"type,omitempty"`
}

// TaxDetailsType Tax type.
type TaxDetailsType string

// TaxLineItem A list of tax line items.
type TaxLineItem = []TaxDetails

// TaxRegistrationDetails Tax registration details of the entity.
type TaxRegistrationDetails struct {
	// TaxRegistrationAddress Address of the party.
	TaxRegistrationAddress *Address `json:"taxRegistrationAddress,omitempty"`

	// TaxRegistrationMessages Tax registration message that can be used for additional tax related details.
	TaxRegistrationMessages *string `json:"taxRegistrationMessages,omitempty"`

	// TaxRegistrationNumber Tax registration number for the party. For example, VAT ID.
	TaxRegistrationNumber string `json:"taxRegistrationNumber"`

	// TaxRegistrationType Tax registration type for the entity.
	TaxRegistrationType *TaxRegistrationDetailsTaxRegistrationType `json:"taxRegistrationType,omitempty"`
}

// TaxRegistrationDetailsTaxRegistrationType Tax registration type for the entity.
type TaxRegistrationDetailsTaxRegistrationType string

// TransactionId Response that contains the transaction ID.
type TransactionId struct {
	// TransactionId GUID assigned by Amazon to identify this transaction. This value can be used with the Transaction Status API to return the status of this transaction.
	TransactionId *string `json:"transactionId,omitempty"`
}

// GetOrdersParams defines parameters for GetOrders.
type GetOrdersParams struct {
	// ShipFromPartyId The vendor warehouse identifier for the fulfillment warehouse. If not specified, the result will contain orders for all warehouses.
	ShipFromPartyId *string `form:"shipFromPartyId,omitempty" json:"shipFromPartyId,omitempty"`

	// Status Returns only the purchase orders that match the specified status. If not specified, the result will contain orders that match any status.
	Status *GetOrdersParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Limit The limit to the number of purchase orders returned.
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// CreatedAfter Purchase orders that became available after this date and time will be included in the result. Must be in ISO-8601 date/time format.
	CreatedAfter time.Time `form:"createdAfter" json:"createdAfter"`

	// CreatedBefore Purchase orders that became available before this date and time will be included in the result. Must be in ISO-8601 date/time format.
	CreatedBefore time.Time `form:"createdBefore" json:"createdBefore"`

	// SortOrder Sort the list in ascending or descending order by order creation date.
	SortOrder *GetOrdersParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// NextToken Used for pagination when there are more orders than the specified result size limit. The token value is returned in the previous API call.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// IncludeDetails When true, returns the complete purchase order details. Otherwise, only purchase order numbers are returned.
	IncludeDetails *string `form:"includeDetails,omitempty" json:"includeDetails,omitempty"`
}

// GetOrdersParamsStatus defines parameters for GetOrders.
type GetOrdersParamsStatus string

// GetOrdersParamsSortOrder defines parameters for GetOrders.
type GetOrdersParamsSortOrder string

// SubmitAcknowledgementJSONRequestBody defines body for SubmitAcknowledgement for application/json ContentType.
type SubmitAcknowledgementJSONRequestBody = SubmitAcknowledgementRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SubmitAcknowledgementWithBody request with any body
	SubmitAcknowledgementWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	SubmitAcknowledgement(ctx context.Context, body SubmitAcknowledgementJSONRequestBody) (*http.Response, error)

	// GetOrders request
	GetOrders(ctx context.Context, params *GetOrdersParams) (*http.Response, error)

	// GetOrder request
	GetOrder(ctx context.Context, purchaseOrderNumber string) (*http.Response, error)
}

func (c *Client) SubmitAcknowledgementWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSubmitAcknowledgementRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SubmitAcknowledgement(ctx context.Context, body SubmitAcknowledgementJSONRequestBody) (*http.Response, error) {
	req, err := NewSubmitAcknowledgementRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetOrders(ctx context.Context, params *GetOrdersParams) (*http.Response, error) {
	req, err := NewGetOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetOrder(ctx context.Context, purchaseOrderNumber string) (*http.Response, error) {
	req, err := NewGetOrderRequest(c.Server, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewSubmitAcknowledgementRequest calls the generic SubmitAcknowledgement builder with application/json body
func NewSubmitAcknowledgementRequest(server string, body SubmitAcknowledgementJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitAcknowledgementRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitAcknowledgementRequestWithBody generates requests for SubmitAcknowledgement with any type of body
func NewSubmitAcknowledgementRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/orders/v1/acknowledgements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrdersRequest generates requests for GetOrders
func NewGetOrdersRequest(server string, params *GetOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/orders/v1/purchaseOrders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShipFromPartyId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipFromPartyId", runtime.ParamLocationQuery, *params.ShipFromPartyId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, params.CreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBefore", runtime.ParamLocationQuery, params.CreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IncludeDetails != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeDetails", runtime.ParamLocationQuery, *params.IncludeDetails); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderRequest generates requests for GetOrder
func NewGetOrderRequest(server string, purchaseOrderNumber string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "purchaseOrderNumber", runtime.ParamLocationPath, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/directFulfillment/orders/v1/purchaseOrders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SubmitAcknowledgementWithBodyWithResponse request with any body
	SubmitAcknowledgementWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SubmitAcknowledgementResp, error)

	SubmitAcknowledgementWithResponse(ctx context.Context, body SubmitAcknowledgementJSONRequestBody) (*SubmitAcknowledgementResp, error)

	// GetOrdersWithResponse request
	GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams) (*GetOrdersResp, error)

	// GetOrderWithResponse request
	GetOrderWithResponse(ctx context.Context, purchaseOrderNumber string) (*GetOrderResp, error)
}

type SubmitAcknowledgementResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SubmitAcknowledgementResponse
	JSON400      *SubmitAcknowledgementResponse
	JSON403      *SubmitAcknowledgementResponse
	JSON404      *SubmitAcknowledgementResponse
	JSON413      *SubmitAcknowledgementResponse
	JSON415      *SubmitAcknowledgementResponse
	JSON429      *SubmitAcknowledgementResponse
	JSON500      *SubmitAcknowledgementResponse
	JSON503      *SubmitAcknowledgementResponse
}

// Status returns HTTPResponse.Status
func (r SubmitAcknowledgementResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitAcknowledgementResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrdersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrdersResponse
	JSON400      *GetOrdersResponse
	JSON403      *GetOrdersResponse
	JSON404      *GetOrdersResponse
	JSON415      *GetOrdersResponse
	JSON429      *GetOrdersResponse
	JSON500      *GetOrdersResponse
	JSON503      *GetOrdersResponse
}

// Status returns HTTPResponse.Status
func (r GetOrdersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderResponse
	JSON400      *GetOrderResponse
	JSON401      *GetOrderResponse
	JSON403      *GetOrderResponse
	JSON404      *GetOrderResponse
	JSON415      *GetOrderResponse
	JSON429      *GetOrderResponse
	JSON500      *GetOrderResponse
	JSON503      *GetOrderResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SubmitAcknowledgementWithBodyWithResponse request with arbitrary body returning *SubmitAcknowledgementResp
func (c *ClientWithResponses) SubmitAcknowledgementWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SubmitAcknowledgementResp, error) {
	rsp, err := c.SubmitAcknowledgementWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitAcknowledgementResp(rsp)
}

func (c *ClientWithResponses) SubmitAcknowledgementWithResponse(ctx context.Context, body SubmitAcknowledgementJSONRequestBody) (*SubmitAcknowledgementResp, error) {
	rsp, err := c.SubmitAcknowledgement(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitAcknowledgementResp(rsp)
}

// GetOrdersWithResponse request returning *GetOrdersResp
func (c *ClientWithResponses) GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams) (*GetOrdersResp, error) {
	rsp, err := c.GetOrders(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersResp(rsp)
}

// GetOrderWithResponse request returning *GetOrderResp
func (c *ClientWithResponses) GetOrderWithResponse(ctx context.Context, purchaseOrderNumber string) (*GetOrderResp, error) {
	rsp, err := c.GetOrder(ctx, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderResp(rsp)
}

// ParseSubmitAcknowledgementResp parses an HTTP response from a SubmitAcknowledgementWithResponse call
func ParseSubmitAcknowledgementResp(rsp *http.Response) (*SubmitAcknowledgementResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitAcknowledgementResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrdersResp parses an HTTP response from a GetOrdersWithResponse call
func ParseGetOrdersResp(rsp *http.Response) (*GetOrdersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetOrderResp parses an HTTP response from a GetOrderWithResponse call
func ParseGetOrderResp(rsp *http.Response) (*GetOrderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
