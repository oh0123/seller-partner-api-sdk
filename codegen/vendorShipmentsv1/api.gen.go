// Package vendorshipmentsv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package vendorshipmentsv1

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/bytedance/sonic"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ContainerIdentificationContainerIdentificationType.
const (
	AMZNCC ContainerIdentificationContainerIdentificationType = "AMZNCC"
	BPS    ContainerIdentificationContainerIdentificationType = "BPS"
	CID    ContainerIdentificationContainerIdentificationType = "CID"
	GTIN   ContainerIdentificationContainerIdentificationType = "GTIN"
	SSCC   ContainerIdentificationContainerIdentificationType = "SSCC"
)

// Defines values for ContainersContainerType.
const (
	ContainersContainerTypeCarton ContainersContainerType = "carton"
	ContainersContainerTypePallet ContainersContainerType = "pallet"
)

// Defines values for DimensionsUnitOfMeasure.
const (
	Ft    DimensionsUnitOfMeasure = "Ft"
	In    DimensionsUnitOfMeasure = "In"
	Meter DimensionsUnitOfMeasure = "Meter"
	Yard  DimensionsUnitOfMeasure = "Yard"
)

// Defines values for DurationDurationUnit.
const (
	Days   DurationDurationUnit = "Days"
	Months DurationDurationUnit = "Months"
)

// Defines values for ImportDetailsHandlingInstructions.
const (
	ImportDetailsHandlingInstructionsFood           ImportDetailsHandlingInstructions = "Food"
	ImportDetailsHandlingInstructionsFragile        ImportDetailsHandlingInstructions = "Fragile"
	ImportDetailsHandlingInstructionsHandleWithCare ImportDetailsHandlingInstructions = "HandleWithCare"
	ImportDetailsHandlingInstructionsOversized      ImportDetailsHandlingInstructions = "Oversized"
)

// Defines values for ImportDetailsMethodOfPayment.
const (
	CollectOnDelivery       ImportDetailsMethodOfPayment = "CollectOnDelivery"
	DefinedByBuyerAndSeller ImportDetailsMethodOfPayment = "DefinedByBuyerAndSeller"
	FOBPortOfCall           ImportDetailsMethodOfPayment = "FOBPortOfCall"
	PaidByBuyer             ImportDetailsMethodOfPayment = "PaidByBuyer"
	PaidBySeller            ImportDetailsMethodOfPayment = "PaidBySeller"
	PrepaidBySeller         ImportDetailsMethodOfPayment = "PrepaidBySeller"
)

// Defines values for ItemDetailsHandlingCode.
const (
	ItemDetailsHandlingCodeFood           ItemDetailsHandlingCode = "Food"
	ItemDetailsHandlingCodeFragile        ItemDetailsHandlingCode = "Fragile"
	ItemDetailsHandlingCodeHandleWithCare ItemDetailsHandlingCode = "HandleWithCare"
	ItemDetailsHandlingCodeOversized      ItemDetailsHandlingCode = "Oversized"
)

// Defines values for ItemQuantityUnitOfMeasure.
const (
	Cases  ItemQuantityUnitOfMeasure = "Cases"
	Eaches ItemQuantityUnitOfMeasure = "Eaches"
)

// Defines values for ShipmentCurrentShipmentStatus.
const (
	ShipmentCurrentShipmentStatusCarrierAssigned         ShipmentCurrentShipmentStatus = "CarrierAssigned"
	ShipmentCurrentShipmentStatusCreated                 ShipmentCurrentShipmentStatus = "Created"
	ShipmentCurrentShipmentStatusShipped                 ShipmentCurrentShipmentStatus = "Shipped"
	ShipmentCurrentShipmentStatusTransportationRequested ShipmentCurrentShipmentStatus = "TransportationRequested"
)

// Defines values for ShipmentShipmentFreightTerm.
const (
	Collect ShipmentShipmentFreightTerm = "Collect"
	Prepaid ShipmentShipmentFreightTerm = "Prepaid"
)

// Defines values for ShipmentTransactionType.
const (
	Cancel ShipmentTransactionType = "Cancel"
	New    ShipmentTransactionType = "New"
)

// Defines values for ShipmentConfirmationShipmentConfirmationType.
const (
	Original ShipmentConfirmationShipmentConfirmationType = "Original"
	Replace  ShipmentConfirmationShipmentConfirmationType = "Replace"
)

// Defines values for ShipmentConfirmationShipmentStructure.
const (
	LooseAssortmentCase      ShipmentConfirmationShipmentStructure = "LooseAssortmentCase"
	LooseStandardCase        ShipmentConfirmationShipmentStructure = "LooseStandardCase"
	MasterCase               ShipmentConfirmationShipmentStructure = "MasterCase"
	MasterPallet             ShipmentConfirmationShipmentStructure = "MasterPallet"
	PalletOfItems            ShipmentConfirmationShipmentStructure = "PalletOfItems"
	PalletizedAssortmentCase ShipmentConfirmationShipmentStructure = "PalletizedAssortmentCase"
	PalletizedStandardCase   ShipmentConfirmationShipmentStructure = "PalletizedStandardCase"
)

// Defines values for ShipmentConfirmationShipmentType.
const (
	ShipmentConfirmationShipmentTypeLessThanTruckLoad ShipmentConfirmationShipmentType = "LessThanTruckLoad"
	ShipmentConfirmationShipmentTypeSmallParcel       ShipmentConfirmationShipmentType = "SmallParcel"
	ShipmentConfirmationShipmentTypeTruckLoad         ShipmentConfirmationShipmentType = "TruckLoad"
)

// Defines values for ShipmentStatusDetailsShipmentStatus.
const (
	ShipmentStatusDetailsShipmentStatusCarrierAssigned         ShipmentStatusDetailsShipmentStatus = "CarrierAssigned"
	ShipmentStatusDetailsShipmentStatusCreated                 ShipmentStatusDetailsShipmentStatus = "Created"
	ShipmentStatusDetailsShipmentStatusShipped                 ShipmentStatusDetailsShipmentStatus = "Shipped"
	ShipmentStatusDetailsShipmentStatusTransportationRequested ShipmentStatusDetailsShipmentStatus = "TransportationRequested"
)

// Defines values for StopFunctionCode.
const (
	FreightPayableAt StopFunctionCode = "FreightPayableAt"
	PortOfDischarge  StopFunctionCode = "PortOfDischarge"
	PortOfLoading    StopFunctionCode = "PortOfLoading"
)

// Defines values for TaxRegistrationDetailsTaxRegistrationType.
const (
	GST TaxRegistrationDetailsTaxRegistrationType = "GST"
	VAT TaxRegistrationDetailsTaxRegistrationType = "VAT"
)

// Defines values for TransportationDetailsShipMode.
const (
	TransportationDetailsShipModeLessThanTruckLoad TransportationDetailsShipMode = "LessThanTruckLoad"
	TransportationDetailsShipModeSmallParcel       TransportationDetailsShipMode = "SmallParcel"
	TransportationDetailsShipModeTruckLoad         TransportationDetailsShipMode = "TruckLoad"
)

// Defines values for TransportationDetailsTransportationMode.
const (
	TransportationDetailsTransportationModeAir   TransportationDetailsTransportationMode = "Air"
	TransportationDetailsTransportationModeOcean TransportationDetailsTransportationMode = "Ocean"
	TransportationDetailsTransportationModeRoad  TransportationDetailsTransportationMode = "Road"
)

// Defines values for TransportationDetailsForShipmentConfirmationTransportationMode.
const (
	TransportationDetailsForShipmentConfirmationTransportationModeAir   TransportationDetailsForShipmentConfirmationTransportationMode = "Air"
	TransportationDetailsForShipmentConfirmationTransportationModeOcean TransportationDetailsForShipmentConfirmationTransportationMode = "Ocean"
	TransportationDetailsForShipmentConfirmationTransportationModeRoad  TransportationDetailsForShipmentConfirmationTransportationMode = "Road"
)

// Defines values for VolumeUnitOfMeasure.
const (
	CuFt VolumeUnitOfMeasure = "CuFt"
	CuIn VolumeUnitOfMeasure = "CuIn"
	CuM  VolumeUnitOfMeasure = "CuM"
	CuY  VolumeUnitOfMeasure = "CuY"
)

// Defines values for WeightUnitOfMeasure.
const (
	G  WeightUnitOfMeasure = "G"
	Kg WeightUnitOfMeasure = "Kg"
	Lb WeightUnitOfMeasure = "Lb"
	Oz WeightUnitOfMeasure = "Oz"
)

// Defines values for GetShipmentDetailsParamsSortOrder.
const (
	ASC  GetShipmentDetailsParamsSortOrder = "ASC"
	DESC GetShipmentDetailsParamsSortOrder = "DESC"
)

// Address Address of the party.
type Address struct {
	// AddressLine1 First line of the address.
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Additional street address information, if required.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 Additional street address information, if required.
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// City The city where the person, business or institution is located.
	City *string `json:"city,omitempty"`

	// CountryCode The two digit country code in ISO 3166-1 alpha-2 format.
	CountryCode string `json:"countryCode"`

	// County The county where person, business or institution is located.
	County *string `json:"county,omitempty"`

	// District The district where person, business or institution is located.
	District *string `json:"district,omitempty"`

	// Name The name of the person, business or institution at that address.
	Name string `json:"name"`

	// Phone The phone number of the person, business or institution located at that address.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The postal code of that address. It contains a series of letters or digits or both, sometimes including spaces or punctuation.
	PostalCode *string `json:"postalCode,omitempty"`

	// StateOrRegion The state or region where person, business or institution is located.
	StateOrRegion *string `json:"stateOrRegion,omitempty"`
}

// CarrierDetails Indicates the carrier details and their contact informations
type CarrierDetails struct {
	// Code Code that identifies the carrier for the shipment. The Standard Carrier Alpha Code (SCAC) is a unique two to four letter code used to identify a carrier. Carrier SCAC codes are assigned and maintained by the NMFTA (National Motor Freight Association).
	Code *string `json:"code,omitempty"`

	// Email The field is used to represent the carrier Email id.
	Email *string `json:"email,omitempty"`

	// Name The field is used to represent the carrier used for performing the shipment.
	Name *string `json:"name,omitempty"`

	// Phone The field is used to represent the Carrier contact number.
	Phone *string `json:"phone,omitempty"`

	// ShipmentReferenceNumber The field is also known as PRO number is a unique number assigned by the carrier. It is used to identify and track the shipment that goes out for delivery. This field is mandatory for US, CA, MX shipment confirmations.
	ShipmentReferenceNumber *string `json:"shipmentReferenceNumber,omitempty"`
}

// Carton Details of the carton/package being shipped.
type Carton struct {
	// CartonIdentifiers A list of carton identifiers.
	CartonIdentifiers *[]ContainerIdentification `json:"cartonIdentifiers,omitempty"`

	// CartonSequenceNumber Carton sequence number for the carton. The first carton will be 001, the second 002, and so on. This number is used as a reference to refer to this carton from the pallet level.
	CartonSequenceNumber string `json:"cartonSequenceNumber"`

	// Dimensions Physical dimensional measurements of a container.
	Dimensions *Dimensions `json:"dimensions,omitempty"`

	// Items A list of container item details.
	Items []ContainerItem `json:"items"`

	// TrackingNumber This is required to be provided for every carton in the small parcel shipments.
	TrackingNumber *string `json:"trackingNumber,omitempty"`

	// Weight The weight of the shipment.
	Weight *Weight `json:"weight,omitempty"`
}

// CartonReferenceDetails Carton reference details.
type CartonReferenceDetails struct {
	// CartonCount Pallet level carton count is mandatory for single item pallet and optional for mixed item pallet.
	CartonCount *int `json:"cartonCount,omitempty"`

	// CartonReferenceNumbers Array of reference numbers for the carton that are part of this pallet/shipment. Please provide the cartonSequenceNumber from the 'cartons' segment to refer to that carton's details here.
	CartonReferenceNumbers []string `json:"cartonReferenceNumbers"`
}

// CollectFreightPickupDetails Transport Request pickup date from Vendor Warehouse by Buyer
type CollectFreightPickupDetails struct {
	// CarrierAssignmentDate Date on which the carrier is being scheduled to pickup items from vendor warehouse by Byer used for WePay/Collect vendors.
	CarrierAssignmentDate *time.Time `json:"carrierAssignmentDate,omitempty"`

	// RequestedPickUp Date on which the items can be picked up from vendor warehouse by Buyer used for WePay/Collect vendors.
	RequestedPickUp *time.Time `json:"requestedPickUp,omitempty"`

	// ScheduledPickUp Date on which the items are scheduled to be picked from vendor warehouse by Buyer used for WePay/Collect vendors.
	ScheduledPickUp *time.Time `json:"scheduledPickUp,omitempty"`
}

// ContainerIdentification A list of carton identifiers.
type ContainerIdentification struct {
	// ContainerIdentificationNumber Container identification number that adheres to the definition of the container identification type.
	ContainerIdentificationNumber string `json:"containerIdentificationNumber"`

	// ContainerIdentificationType The container identification type.
	ContainerIdentificationType ContainerIdentificationContainerIdentificationType `json:"containerIdentificationType"`
}

// ContainerIdentificationContainerIdentificationType The container identification type.
type ContainerIdentificationContainerIdentificationType string

// ContainerItem Carton/Pallet level details for the item.
type ContainerItem struct {
	// ItemDetails Item details for be provided for every item in shipment at either the item or carton or pallet level, whichever is appropriate.
	ItemDetails *ItemDetails `json:"itemDetails,omitempty"`

	// ItemReference The reference number for the item. Please provide the itemSequenceNumber from the 'items' segment to refer to that item's details here.
	ItemReference string `json:"itemReference"`

	// ShippedQuantity Details of item quantity.
	ShippedQuantity ItemQuantity `json:"shippedQuantity"`
}

// ContainerSequenceNumbers Container sequence numbers that are involved in this shipment.
type ContainerSequenceNumbers struct {
	// ContainerSequenceNumber A list of containers shipped
	ContainerSequenceNumber *string `json:"containerSequenceNumber,omitempty"`
}

// Containers A list of the items in this transportation and their associated inner container details. If any of the item detail fields are common at a carton or a pallet level, provide them at the corresponding carton or pallet level.
type Containers struct {
	// Block Number of cartons per layer on the pallet.
	Block *int `json:"block,omitempty"`

	// ContainerIdentifiers A list of carton identifiers.
	ContainerIdentifiers []ContainerIdentification `json:"containerIdentifiers"`

	// ContainerSequenceNumber An integer that must be submitted for multi-box shipments only, where one item may come in separate packages.
	ContainerSequenceNumber *string `json:"containerSequenceNumber,omitempty"`

	// ContainerType The type of container.
	ContainerType ContainersContainerType `json:"containerType"`

	// Dimensions Physical dimensional measurements of a container.
	Dimensions *Dimensions `json:"dimensions,omitempty"`

	// InnerContainersDetails Details of the innerContainersDetails.
	InnerContainersDetails *InnerContainersDetails `json:"innerContainersDetails,omitempty"`

	// PackedItems A list of packed items.
	PackedItems *[]PackedItems `json:"packedItems,omitempty"`

	// Tier Number of layers per pallet.
	Tier *int `json:"tier,omitempty"`

	// TrackingNumber The tracking number used for identifying the shipment.
	TrackingNumber *string `json:"trackingNumber,omitempty"`

	// Weight The weight of the shipment.
	Weight *Weight `json:"weight,omitempty"`
}

// ContainersContainerType The type of container.
type ContainersContainerType string

// Decimal A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation. <br>**Pattern** : `^-?(0|([1-9]\d*))(\.\d+)?([eE][+-]?\d+)?$`.
type Decimal = string

// Dimensions Physical dimensional measurements of a container.
type Dimensions struct {
	// Height A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation. <br>**Pattern** : `^-?(0|([1-9]\d*))(\.\d+)?([eE][+-]?\d+)?$`.
	Height Decimal `json:"height"`

	// Length A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation. <br>**Pattern** : `^-?(0|([1-9]\d*))(\.\d+)?([eE][+-]?\d+)?$`.
	Length Decimal `json:"length"`

	// UnitOfMeasure The unit of measure for dimensions.
	UnitOfMeasure DimensionsUnitOfMeasure `json:"unitOfMeasure"`

	// Width A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation. <br>**Pattern** : `^-?(0|([1-9]\d*))(\.\d+)?([eE][+-]?\d+)?$`.
	Width Decimal `json:"width"`
}

// DimensionsUnitOfMeasure The unit of measure for dimensions.
type DimensionsUnitOfMeasure string

// Duration Duration after manufacturing date during which the product is valid for consumption.
type Duration struct {
	// DurationUnit Unit for duration.
	DurationUnit DurationDurationUnit `json:"durationUnit"`

	// DurationValue Value for the duration in terms of the durationUnit.
	DurationValue int `json:"durationValue"`
}

// DurationDurationUnit Unit for duration.
type DurationDurationUnit string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// Expiry Expiry refers to the collection of dates required  for certain items. These could be either expiryDate or mfgDate and expiryAfterDuration. These are mandatory for perishable items.
type Expiry struct {
	// ExpiryAfterDuration Duration after manufacturing date during which the product is valid for consumption.
	ExpiryAfterDuration *Duration `json:"expiryAfterDuration,omitempty"`

	// ExpiryDate The date that determines the limit of consumption or use of a product. Its meaning is determined based on the trade item context.
	ExpiryDate *time.Time `json:"expiryDate,omitempty"`

	// ManufacturerDate Production, packaging or assembly date determined by the manufacturer. Its meaning is determined based on the trade item context.
	ManufacturerDate *time.Time `json:"manufacturerDate,omitempty"`
}

// GetShipmentDetailsResponse The response schema for the GetShipmentDetails operation.
type GetShipmentDetailsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The request schema for the GetShipmentDetails operation.
	Payload *ShipmentDetails `json:"payload,omitempty"`
}

// ImportDetails Provide these fields only if this shipment is a direct import.
type ImportDetails struct {
	// BillableWeight The weight of the shipment.
	BillableWeight *Weight `json:"billableWeight,omitempty"`

	// EstimatedShipByDate Date on which the shipment is expected to be shipped. This value should not be in the past and not more than 60 days out in the future.
	EstimatedShipByDate *time.Time `json:"estimatedShipByDate,omitempty"`

	// HandlingInstructions Identification of the instructions on how specified item/carton/pallet should be handled.
	HandlingInstructions *ImportDetailsHandlingInstructions `json:"handlingInstructions,omitempty"`

	// ImportContainers Types and numbers of container(s) for import purchase orders. Can be a comma-separated list if shipment has multiple containers.
	ImportContainers *string `json:"importContainers,omitempty"`

	// MethodOfPayment This is used for import purchase orders only. If the recipient requests, this field will contain the shipment method of payment.
	MethodOfPayment *ImportDetailsMethodOfPayment `json:"methodOfPayment,omitempty"`

	// Route This is used only for direct import shipment confirmations.
	Route *Route `json:"route,omitempty"`

	// SealNumber The container's seal number.
	SealNumber *string `json:"sealNumber,omitempty"`
}

// ImportDetailsHandlingInstructions Identification of the instructions on how specified item/carton/pallet should be handled.
type ImportDetailsHandlingInstructions string

// ImportDetailsMethodOfPayment This is used for import purchase orders only. If the recipient requests, this field will contain the shipment method of payment.
type ImportDetailsMethodOfPayment string

// InnerContainersDetails Details of the innerContainersDetails.
type InnerContainersDetails struct {
	// ContainerCount Total containers as part of the shipment
	ContainerCount *int `json:"containerCount,omitempty"`

	// ContainerSequenceNumbers Container sequence numbers that are involved in this shipment.
	ContainerSequenceNumbers *[]ContainerSequenceNumbers `json:"containerSequenceNumbers,omitempty"`
}

// Item Details of the item being shipped.
type Item struct {
	// AmazonProductIdentifier Buyer Standard Identification Number (ASIN) of an item.
	AmazonProductIdentifier *string `json:"amazonProductIdentifier,omitempty"`

	// ItemDetails Item details for be provided for every item in shipment at either the item or carton or pallet level, whichever is appropriate.
	ItemDetails *ItemDetails `json:"itemDetails,omitempty"`

	// ItemSequenceNumber Item sequence number for the item. The first item will be 001, the second 002, and so on. This number is used as a reference to refer to this item from the carton or pallet level.
	ItemSequenceNumber string `json:"itemSequenceNumber"`

	// ShippedQuantity Details of item quantity.
	ShippedQuantity ItemQuantity `json:"shippedQuantity"`

	// VendorProductIdentifier The vendor selected product identification of the item. Should be the same as was sent in the purchase order.
	VendorProductIdentifier *string `json:"vendorProductIdentifier,omitempty"`
}

// ItemDetails Item details for be provided for every item in shipment at either the item or carton or pallet level, whichever is appropriate.
type ItemDetails struct {
	// Expiry Expiry refers to the collection of dates required  for certain items. These could be either expiryDate or mfgDate and expiryAfterDuration. These are mandatory for perishable items.
	Expiry *Expiry `json:"expiry,omitempty"`

	// HandlingCode Identification of the instructions on how specified item/carton/pallet should be handled.
	HandlingCode *ItemDetailsHandlingCode `json:"handlingCode,omitempty"`

	// LotNumber The batch or lot number associates an item with information the manufacturer considers relevant for traceability of the trade item to which the Element String is applied. The data may refer to the trade item itself or to items contained. This field is mandatory for all perishable items.
	LotNumber *string `json:"lotNumber,omitempty"`

	// MaximumRetailPrice An amount of money, including units in the form of currency.
	MaximumRetailPrice *Money `json:"maximumRetailPrice,omitempty"`

	// PurchaseOrderNumber The purchase order number for the shipment being confirmed. If the items in this shipment belong to multiple purchase order numbers that are in particular carton or pallet within the shipment, then provide the purchaseOrderNumber at the appropriate carton or pallet level. Formatting Notes: 8-character alpha-numeric code.
	PurchaseOrderNumber *string `json:"purchaseOrderNumber,omitempty"`
}

// ItemDetailsHandlingCode Identification of the instructions on how specified item/carton/pallet should be handled.
type ItemDetailsHandlingCode string

// ItemQuantity Details of item quantity.
type ItemQuantity struct {
	// Amount Amount of units shipped for a specific item at a shipment level. If the item is present only in certain cartons or pallets within the shipment, please provide this at the appropriate carton or pallet level.
	Amount int `json:"amount"`

	// UnitOfMeasure Unit of measure for the shipped quantity.
	UnitOfMeasure ItemQuantityUnitOfMeasure `json:"unitOfMeasure"`

	// UnitSize The case size, in the event that we ordered using cases. Otherwise, 1.
	UnitSize *int `json:"unitSize,omitempty"`
}

// ItemQuantityUnitOfMeasure Unit of measure for the shipped quantity.
type ItemQuantityUnitOfMeasure string

// Location Location identifier.
type Location struct {
	// CountryCode The two digit country code. In ISO 3166-1 alpha-2 format.
	CountryCode *string `json:"countryCode,omitempty"`

	// LocationCode Location code.
	LocationCode *string `json:"locationCode,omitempty"`

	// Type Type of location identification.
	Type *string `json:"type,omitempty"`
}

// Money An amount of money, including units in the form of currency.
type Money struct {
	// Amount A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation. <br>**Pattern** : `^-?(0|([1-9]\d*))(\.\d+)?([eE][+-]?\d+)?$`.
	Amount Decimal `json:"amount"`

	// CurrencyCode Three digit currency code in ISO 4217 format.
	CurrencyCode string `json:"currencyCode"`
}

// PackageItemDetails Item details for be provided for every item in shipment at either the item or carton or pallet level, whichever is appropriate.
type PackageItemDetails struct {
	// Expiry Expiry refers to the collection of dates required  for certain items. These could be either expiryDate or mfgDate and expiryAfterDuration. These are mandatory for perishable items.
	Expiry *Expiry `json:"expiry,omitempty"`

	// LotNumber The batch or lot number associates an item with information the manufacturer considers relevant for traceability of the trade item to which the Element String is applied. The data may refer to the trade item itself or to items contained. This field is mandatory for all perishable items.
	LotNumber *string `json:"lotNumber,omitempty"`

	// PurchaseOrderNumber The purchase order number for the shipment being confirmed. If the items in this shipment belong to multiple purchase order numbers that are in particular carton or pallet within the shipment, then provide the purchaseOrderNumber at the appropriate carton or pallet level. Formatting Notes: 8-character alpha-numeric code.
	PurchaseOrderNumber *string `json:"purchaseOrderNumber,omitempty"`
}

// PackedItems Details of the item being shipped.
type PackedItems struct {
	// BuyerProductIdentifier Buyer Standard Identification Number (ASIN) of an item.
	BuyerProductIdentifier *string `json:"buyerProductIdentifier,omitempty"`

	// ItemDetails Item details for be provided for every item in shipment at either the item or carton or pallet level, whichever is appropriate.
	ItemDetails *PackageItemDetails `json:"itemDetails,omitempty"`

	// ItemSequenceNumber Item sequence number for the item. The first item will be 001, the second 002, and so on. This number is used as a reference to refer to this item from the carton or pallet level.
	ItemSequenceNumber *string `json:"itemSequenceNumber,omitempty"`

	// PackedQuantity Details of item quantity.
	PackedQuantity *ItemQuantity `json:"packedQuantity,omitempty"`

	// VendorProductIdentifier The vendor selected product identification of the item. Should be the same as was sent in the purchase order.
	VendorProductIdentifier *string `json:"vendorProductIdentifier,omitempty"`
}

// Pagination The pagination elements required to retrieve the remaining data.
type Pagination struct {
	// NextToken A generated string used to pass information to your next request. If NextToken is returned, pass the value of NextToken to the next request. If NextToken is not returned, there are no more shipment items to return.
	NextToken *string `json:"nextToken,omitempty"`
}

// Pallet Details of the Pallet/Tare being shipped.
type Pallet struct {
	// Block Number of cartons per layer on the pallet. Only applicable to container type Pallet.
	Block *int `json:"block,omitempty"`

	// CartonReferenceDetails Carton reference details.
	CartonReferenceDetails *CartonReferenceDetails `json:"cartonReferenceDetails,omitempty"`

	// Dimensions Physical dimensional measurements of a container.
	Dimensions *Dimensions `json:"dimensions,omitempty"`

	// Items A list of container item details.
	Items *[]ContainerItem `json:"items,omitempty"`

	// PalletIdentifiers A list of pallet identifiers.
	PalletIdentifiers []ContainerIdentification `json:"palletIdentifiers"`

	// Tier Number of layers per pallet. Only applicable to container type Pallet.
	Tier *int `json:"tier,omitempty"`

	// Weight The weight of the shipment.
	Weight *Weight `json:"weight,omitempty"`
}

// PartyIdentification Name/Address and tax details of the party.
type PartyIdentification struct {
	// Address Address of the party.
	Address *Address `json:"address,omitempty"`

	// PartyId Assigned identification for the party.
	PartyId string `json:"partyId"`

	// TaxRegistrationDetails Tax registration details of the entity.
	TaxRegistrationDetails *[]TaxRegistrationDetails `json:"taxRegistrationDetails,omitempty"`
}

// PurchaseOrderItems Details of the item being shipped.
type PurchaseOrderItems struct {
	// BuyerProductIdentifier Amazon Standard Identification Number (ASIN) for a SKU
	BuyerProductIdentifier *string `json:"buyerProductIdentifier,omitempty"`

	// ItemSequenceNumber Item sequence number for the item. The first item will be 001, the second 002, and so on. This number is used as a reference to refer to this item from the carton or pallet level.
	ItemSequenceNumber string `json:"itemSequenceNumber"`

	// MaximumRetailPrice An amount of money, including units in the form of currency.
	MaximumRetailPrice *Money `json:"maximumRetailPrice,omitempty"`

	// ShippedQuantity Details of item quantity.
	ShippedQuantity ItemQuantity `json:"shippedQuantity"`

	// VendorProductIdentifier The vendor selected product identification of the item. Should be the same as was sent in the purchase order.
	VendorProductIdentifier *string `json:"vendorProductIdentifier,omitempty"`
}

// PurchaseOrders Transport Request pickup date
type PurchaseOrders struct {
	// Items A list of the items that are associated to the PO in this transport and their associated details.
	Items *[]PurchaseOrderItems `json:"items,omitempty"`

	// PurchaseOrderDate Purchase order numbers involved in this shipment, list all the PO that are involved as part of this shipment.
	PurchaseOrderDate *time.Time `json:"purchaseOrderDate,omitempty"`

	// PurchaseOrderNumber Purchase order numbers involved in this shipment, list all the PO that are involved as part of this shipment.
	PurchaseOrderNumber *string `json:"purchaseOrderNumber,omitempty"`

	// ShipWindow Date range in which shipment is expected for these purchase orders.
	ShipWindow *string `json:"shipWindow,omitempty"`
}

// Route This is used only for direct import shipment confirmations.
type Route struct {
	// Stops The port or location involved in transporting the cargo, as specified in transportation contracts or operational plans.
	Stops []Stop `json:"stops"`
}

// Shipment A list of one or more shipments with respective details.
type Shipment struct {
	// BuyerReferenceNumber The buyer Reference Number is a unique identifier generated by buyer for all Collect/WePay shipments when you submit a transportation request. This field is mandatory for Collect/WePay shipments.
	BuyerReferenceNumber *string `json:"buyerReferenceNumber,omitempty"`

	// CollectFreightPickupDetails Transport Request pickup date from Vendor Warehouse by Buyer
	CollectFreightPickupDetails *CollectFreightPickupDetails `json:"collectFreightPickupDetails,omitempty"`

	// Containers A list of the items in this transportation and their associated inner container details. If any of the item detail fields are common at a carton or a pallet level, provide them at the corresponding carton or pallet level.
	Containers *[]Containers `json:"containers,omitempty"`

	// CurrentShipmentStatus Indicates the current shipment status.
	CurrentShipmentStatus *ShipmentCurrentShipmentStatus `json:"currentShipmentStatus,omitempty"`

	// CurrentshipmentStatusDate Date and time when the last status was updated.
	CurrentshipmentStatusDate *time.Time `json:"currentshipmentStatusDate,omitempty"`

	// ImportDetails Provide these fields only if this shipment is a direct import.
	ImportDetails *ImportDetails `json:"importDetails,omitempty"`

	// PackageLabelCreateDate The date and time of the package label created for the shipment by buyer.
	PackageLabelCreateDate *time.Time `json:"packageLabelCreateDate,omitempty"`

	// PurchaseOrders Indicates the purchase orders involved for the transportation request. This group is an array create 1 for each PO and list their corresponding items. This information is used for deciding the route,truck allocation and storage efficiently. This is a mandatory information for Buyer performing transportation from vendor warehouse (WePay/Collect)
	PurchaseOrders *[]PurchaseOrders `json:"purchaseOrders,omitempty"`

	// SellingParty Name/Address and tax details of the party.
	SellingParty PartyIdentification `json:"sellingParty"`

	// ShipFromParty Name/Address and tax details of the party.
	ShipFromParty PartyIdentification `json:"shipFromParty"`

	// ShipToParty Name/Address and tax details of the party.
	ShipToParty PartyIdentification `json:"shipToParty"`

	// ShipmentConfirmDate The date and time of the departure of the shipment from the vendor's location. Vendors are requested to send ASNs within 30 minutes of departure from their warehouse/distribution center or at least 6 hours prior to the appointment time at the Buyer destination warehouse, whichever is sooner. Shipped date mentioned in the shipment confirmation should not be in the future.
	ShipmentConfirmDate *time.Time `json:"shipmentConfirmDate,omitempty"`

	// ShipmentCreateDate The date and time of the shipment request created by vendor.
	ShipmentCreateDate *time.Time `json:"shipmentCreateDate,omitempty"`

	// ShipmentFreightTerm Indicates if this transportation request is WePay/Collect or TheyPay/Prepaid. This is a mandatory information.
	ShipmentFreightTerm *ShipmentShipmentFreightTerm `json:"shipmentFreightTerm,omitempty"`

	// ShipmentMeasurements Shipment measurement details.
	ShipmentMeasurements *TransportShipmentMeasurements `json:"shipmentMeasurements,omitempty"`

	// ShipmentStatusDetails Indicates the list of current shipment status details and when the last update was received from carrier this is available on shipment Details response.
	ShipmentStatusDetails *[]ShipmentStatusDetails `json:"shipmentStatusDetails,omitempty"`

	// TransactionDate Date on which the transportation request was submitted.
	TransactionDate time.Time `json:"transactionDate"`

	// TransactionType Indicates the type of  transportation request such as (New,Cancel,Confirm and PackageLabelRequest). Each transactiontype has a unique set of operation and there are corresponding details to be populated for each operation.
	TransactionType ShipmentTransactionType `json:"transactionType"`

	// TransportationDetails Transportation details for this shipment.
	TransportationDetails *TransportationDetails `json:"transportationDetails,omitempty"`

	// VendorShipmentIdentifier Unique Transportation ID created by Vendor (Should not be used over the last 365 days).
	VendorShipmentIdentifier string `json:"vendorShipmentIdentifier"`
}

// ShipmentCurrentShipmentStatus Indicates the current shipment status.
type ShipmentCurrentShipmentStatus string

// ShipmentShipmentFreightTerm Indicates if this transportation request is WePay/Collect or TheyPay/Prepaid. This is a mandatory information.
type ShipmentShipmentFreightTerm string

// ShipmentTransactionType Indicates the type of  transportation request such as (New,Cancel,Confirm and PackageLabelRequest). Each transactiontype has a unique set of operation and there are corresponding details to be populated for each operation.
type ShipmentTransactionType string

// ShipmentConfirmation A list of one or more shipment confirmations.
type ShipmentConfirmation struct {
	// AmazonReferenceNumber The Amazon Reference Number is a unique identifier generated by Amazon for all Collect/WePay shipments when you submit  a routing request. This field is mandatory for Collect/WePay shipments.
	AmazonReferenceNumber *string `json:"amazonReferenceNumber,omitempty"`

	// Cartons A list of the cartons in this shipment.
	Cartons *[]Carton `json:"cartons,omitempty"`

	// EstimatedDeliveryDate The date and time on which the shipment is estimated to reach buyer's warehouse. It needs to be an estimate based on the average transit time between ship from location and the destination. The exact appointment time will be provided by the buyer and is potentially not known when creating the shipment confirmation.
	EstimatedDeliveryDate *time.Time `json:"estimatedDeliveryDate,omitempty"`

	// ImportDetails Provide these fields only if this shipment is a direct import.
	ImportDetails *ImportDetails `json:"importDetails,omitempty"`

	// Pallets A list of the pallets in this shipment.
	Pallets *[]Pallet `json:"pallets,omitempty"`

	// SellingParty Name/Address and tax details of the party.
	SellingParty PartyIdentification `json:"sellingParty"`

	// ShipFromParty Name/Address and tax details of the party.
	ShipFromParty PartyIdentification `json:"shipFromParty"`

	// ShipToParty Name/Address and tax details of the party.
	ShipToParty PartyIdentification `json:"shipToParty"`

	// ShipmentConfirmationDate Date on which the shipment confirmation was submitted.
	ShipmentConfirmationDate time.Time `json:"shipmentConfirmationDate"`

	// ShipmentConfirmationType Indicates if this shipment confirmation is the initial confirmation, or intended to replace an already posted shipment confirmation. If replacing an existing shipment confirmation, be sure to provide the identical shipmentIdentifier and sellingParty information as in the previous confirmation.
	ShipmentConfirmationType ShipmentConfirmationShipmentConfirmationType `json:"shipmentConfirmationType"`

	// ShipmentIdentifier Unique shipment ID (not used over the last 365 days).
	ShipmentIdentifier string `json:"shipmentIdentifier"`

	// ShipmentMeasurements Shipment measurement details.
	ShipmentMeasurements *ShipmentMeasurements `json:"shipmentMeasurements,omitempty"`

	// ShipmentStructure Shipment hierarchical structure.
	ShipmentStructure *ShipmentConfirmationShipmentStructure `json:"shipmentStructure,omitempty"`

	// ShipmentType The type of shipment.
	ShipmentType *ShipmentConfirmationShipmentType `json:"shipmentType,omitempty"`

	// ShippedDate The date and time of the departure of the shipment from the vendor's location. Vendors are requested to send ASNs within 30 minutes of departure from their warehouse/distribution center or at least 6 hours prior to the appointment time at the buyer destination warehouse, whichever is sooner. Shipped date mentioned in the shipment confirmation should not be in the future.
	ShippedDate *time.Time `json:"shippedDate,omitempty"`

	// ShippedItems A list of the items in this shipment and their associated details. If any of the item detail fields are common at a carton or a pallet level, provide them at the corresponding carton or pallet level.
	ShippedItems []Item `json:"shippedItems"`

	// TransportationDetails Transportation details for this shipment.
	TransportationDetails *TransportationDetailsForShipmentConfirmation `json:"transportationDetails,omitempty"`
}

// ShipmentConfirmationShipmentConfirmationType Indicates if this shipment confirmation is the initial confirmation, or intended to replace an already posted shipment confirmation. If replacing an existing shipment confirmation, be sure to provide the identical shipmentIdentifier and sellingParty information as in the previous confirmation.
type ShipmentConfirmationShipmentConfirmationType string

// ShipmentConfirmationShipmentStructure Shipment hierarchical structure.
type ShipmentConfirmationShipmentStructure string

// ShipmentConfirmationShipmentType The type of shipment.
type ShipmentConfirmationShipmentType string

// ShipmentDetails The request schema for the GetShipmentDetails operation.
type ShipmentDetails struct {
	// Pagination The pagination elements required to retrieve the remaining data.
	Pagination *Pagination `json:"pagination,omitempty"`

	// Shipments A list of one or more shipments with underlying details.
	Shipments *[]Shipment `json:"shipments,omitempty"`
}

// ShipmentMeasurements Shipment measurement details.
type ShipmentMeasurements struct {
	// CartonCount Number of cartons present in the shipment. Provide the cartonCount only for non-palletized shipments.
	CartonCount *int `json:"cartonCount,omitempty"`

	// GrossShipmentWeight The weight of the shipment.
	GrossShipmentWeight *Weight `json:"grossShipmentWeight,omitempty"`

	// PalletCount Number of pallets present in the shipment. Provide the palletCount only for palletized shipments.
	PalletCount *int `json:"palletCount,omitempty"`

	// ShipmentVolume The volume of the shipment.
	ShipmentVolume *Volume `json:"shipmentVolume,omitempty"`
}

// ShipmentStatusDetails Shipment Status details.
type ShipmentStatusDetails struct {
	// ShipmentStatus Current status of the shipment on whether it is picked up or scheduled.
	ShipmentStatus *ShipmentStatusDetailsShipmentStatus `json:"shipmentStatus,omitempty"`

	// ShipmentStatusDate Date and time on last status update received for the shipment
	ShipmentStatusDate *time.Time `json:"shipmentStatusDate,omitempty"`
}

// ShipmentStatusDetailsShipmentStatus Current status of the shipment on whether it is picked up or scheduled.
type ShipmentStatusDetailsShipmentStatus string

// Stop Contractual or operational port or point relevant to the movement of the cargo.
type Stop struct {
	// ArrivalTime Date and time of the arrival of the cargo.
	ArrivalTime *time.Time `json:"arrivalTime,omitempty"`

	// DepartureTime Date and time of the departure of the cargo.
	DepartureTime *time.Time `json:"departureTime,omitempty"`

	// FunctionCode Provide the function code.
	FunctionCode StopFunctionCode `json:"functionCode"`

	// LocationIdentification Location identifier.
	LocationIdentification *Location `json:"locationIdentification,omitempty"`
}

// StopFunctionCode Provide the function code.
type StopFunctionCode string

// SubmitShipmentConfirmationsRequest The request schema for the SubmitShipmentConfirmations operation.
type SubmitShipmentConfirmationsRequest struct {
	// ShipmentConfirmations A list of one or more shipment confirmations.
	ShipmentConfirmations *[]ShipmentConfirmation `json:"shipmentConfirmations,omitempty"`
}

// SubmitShipmentConfirmationsResponse The response schema for the SubmitShipmentConfirmations operation.
type SubmitShipmentConfirmationsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload The response payload for the SubmitShipmentConfirmations operation.
	Payload *TransactionReference `json:"payload,omitempty"`
}

// SubmitShipments The request schema for the SubmitShipments operation.
type SubmitShipments struct {
	// Shipments A list of one or more shipments with underlying details.
	Shipments *[]Shipment `json:"shipments,omitempty"`
}

// TaxRegistrationDetails Tax registration details of the entity.
type TaxRegistrationDetails struct {
	// TaxRegistrationNumber Tax registration number for the entity. For example, VAT ID.
	TaxRegistrationNumber string `json:"taxRegistrationNumber"`

	// TaxRegistrationType Tax registration type for the entity.
	TaxRegistrationType TaxRegistrationDetailsTaxRegistrationType `json:"taxRegistrationType"`
}

// TaxRegistrationDetailsTaxRegistrationType Tax registration type for the entity.
type TaxRegistrationDetailsTaxRegistrationType string

// TransactionReference The response payload for the SubmitShipmentConfirmations operation.
type TransactionReference struct {
	// TransactionId GUID assigned by Buyer to identify this transaction. This value can be used with the Transaction Status API to return the status of this transaction.
	TransactionId *string `json:"transactionId,omitempty"`
}

// TransportShipmentMeasurements Shipment measurement details.
type TransportShipmentMeasurements struct {
	// ShipmentVolume The volume of the shipment.
	ShipmentVolume *Volume `json:"shipmentVolume,omitempty"`

	// ShipmentWeight The weight of the shipment.
	ShipmentWeight *Weight `json:"shipmentWeight,omitempty"`

	// TotalCartonCount Total number of cartons present in the shipment. Provide the cartonCount only for non-palletized shipments.
	TotalCartonCount *int `json:"totalCartonCount,omitempty"`

	// TotalPalletNonStackable Total number of Non Stackable Pallets present in the shipment.
	TotalPalletNonStackable *int `json:"totalPalletNonStackable,omitempty"`

	// TotalPalletStackable Total number of Stackable Pallets present in the shipment.
	TotalPalletStackable *int `json:"totalPalletStackable,omitempty"`
}

// TransportationDetails Transportation details for this shipment.
type TransportationDetails struct {
	// BillOfLadingNumber The Bill of Lading (BOL) number is a unique number assigned to each shipment of goods by the vendor or shipper during the creation of the Bill of Lading. This number must be unique for every shipment and cannot be a date/time or single character. The BOL numer is mandatory in Shipment Confirmation message for FTL and LTL shipments, and must match the paper BOL provided with the shipment. Instead of BOL, an alternative reference number (like Delivery Note Number) for the shipment can also be sent in this field.
	BillOfLadingNumber *string `json:"billOfLadingNumber,omitempty"`

	// CarrierDetails Indicates the carrier details and their contact informations
	CarrierDetails *CarrierDetails `json:"carrierDetails,omitempty"`

	// EstimatedDeliveryDate Estimated Date on which shipment will be delivered from Vendor to Buyer
	EstimatedDeliveryDate *time.Time `json:"estimatedDeliveryDate,omitempty"`

	// ShipMode The type of shipment.
	ShipMode *TransportationDetailsShipMode `json:"shipMode,omitempty"`

	// ShipmentDeliveryDate Date on which shipment will be delivered from Vendor to Buyer
	ShipmentDeliveryDate *time.Time `json:"shipmentDeliveryDate,omitempty"`

	// ShippedDate Date when shipment is performed by the Vendor to Buyer
	ShippedDate *time.Time `json:"shippedDate,omitempty"`

	// TransportationMode The mode of transportation for this shipment.
	TransportationMode *TransportationDetailsTransportationMode `json:"transportationMode,omitempty"`
}

// TransportationDetailsShipMode The type of shipment.
type TransportationDetailsShipMode string

// TransportationDetailsTransportationMode The mode of transportation for this shipment.
type TransportationDetailsTransportationMode string

// TransportationDetailsForShipmentConfirmation Transportation details for this shipment.
type TransportationDetailsForShipmentConfirmation struct {
	// BillOfLadingNumber The Bill of Lading (BOL) number is a unique number assigned to each shipment of goods by the vendor or shipper during the creation of the Bill of Lading. This number must be unique for every shipment and cannot be a date/time or single character. The BOL numer is mandatory in Shipment Confirmation message for FTL and LTL shipments, and must match the paper BOL provided with the shipment. Instead of BOL, an alternative reference number (like Delivery Note Number) for the shipment can also be sent in this field.
	BillOfLadingNumber *string `json:"billOfLadingNumber,omitempty"`

	// CarrierScac Code that identifies the carrier for the shipment. The Standard Carrier Alpha Code (SCAC) is a unique two to four letter code used to identify a carrier. Carrier SCAC codes are assigned and maintained by the NMFTA (National Motor Freight Association). This field is mandatory for US, CA, MX shipment confirmations.
	CarrierScac *string `json:"carrierScac,omitempty"`

	// CarrierShipmentReferenceNumber The field also known as PRO number is a unique number assigned by the carrier. It is used to identify and track the shipment that goes out for delivery. This field is mandatory for UA, CA, MX shipment confirmations.
	CarrierShipmentReferenceNumber *string `json:"carrierShipmentReferenceNumber,omitempty"`

	// TransportationMode The mode of transportation for this shipment.
	TransportationMode *TransportationDetailsForShipmentConfirmationTransportationMode `json:"transportationMode,omitempty"`
}

// TransportationDetailsForShipmentConfirmationTransportationMode The mode of transportation for this shipment.
type TransportationDetailsForShipmentConfirmationTransportationMode string

// Volume The volume of the shipment.
type Volume struct {
	// UnitOfMeasure The unit of measurement.
	UnitOfMeasure VolumeUnitOfMeasure `json:"unitOfMeasure"`

	// Value A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation. <br>**Pattern** : `^-?(0|([1-9]\d*))(\.\d+)?([eE][+-]?\d+)?$`.
	Value Decimal `json:"value"`
}

// VolumeUnitOfMeasure The unit of measurement.
type VolumeUnitOfMeasure string

// Weight The weight of the shipment.
type Weight struct {
	// UnitOfMeasure The unit of measurement.
	UnitOfMeasure WeightUnitOfMeasure `json:"unitOfMeasure"`

	// Value A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation. <br>**Pattern** : `^-?(0|([1-9]\d*))(\.\d+)?([eE][+-]?\d+)?$`.
	Value Decimal `json:"value"`
}

// WeightUnitOfMeasure The unit of measurement.
type WeightUnitOfMeasure string

// GetShipmentDetailsParams defines parameters for GetShipmentDetails.
type GetShipmentDetailsParams struct {
	// Limit The limit to the number of records returned. Default value is 50 records.
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// SortOrder Sort in ascending or descending order by purchase order creation date.
	SortOrder *GetShipmentDetailsParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// NextToken Used for pagination when there are more shipments than the specified result size limit.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// CreatedAfter Get Shipment Details that became available after this timestamp will be included in the result. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	CreatedAfter *time.Time `form:"createdAfter,omitempty" json:"createdAfter,omitempty"`

	// CreatedBefore Get Shipment Details that became available before this timestamp will be included in the result. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	CreatedBefore *time.Time `form:"createdBefore,omitempty" json:"createdBefore,omitempty"`

	// ShipmentConfirmedBefore Get Shipment Details by passing Shipment confirmed create Date Before. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	ShipmentConfirmedBefore *time.Time `form:"shipmentConfirmedBefore,omitempty" json:"shipmentConfirmedBefore,omitempty"`

	// ShipmentConfirmedAfter Get Shipment Details by passing Shipment confirmed create Date After. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	ShipmentConfirmedAfter *time.Time `form:"shipmentConfirmedAfter,omitempty" json:"shipmentConfirmedAfter,omitempty"`

	// PackageLabelCreatedBefore Get Shipment Details by passing Package label create Date by buyer. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	PackageLabelCreatedBefore *time.Time `form:"packageLabelCreatedBefore,omitempty" json:"packageLabelCreatedBefore,omitempty"`

	// PackageLabelCreatedAfter Get Shipment Details by passing Package label create Date After by buyer. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	PackageLabelCreatedAfter *time.Time `form:"packageLabelCreatedAfter,omitempty" json:"packageLabelCreatedAfter,omitempty"`

	// ShippedBefore Get Shipment Details by passing Shipped Date Before. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	ShippedBefore *time.Time `form:"shippedBefore,omitempty" json:"shippedBefore,omitempty"`

	// ShippedAfter Get Shipment Details by passing Shipped Date After. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	ShippedAfter *time.Time `form:"shippedAfter,omitempty" json:"shippedAfter,omitempty"`

	// EstimatedDeliveryBefore Get Shipment Details by passing Estimated Delivery Date Before. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	EstimatedDeliveryBefore *time.Time `form:"estimatedDeliveryBefore,omitempty" json:"estimatedDeliveryBefore,omitempty"`

	// EstimatedDeliveryAfter Get Shipment Details by passing Estimated Delivery Date Before. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	EstimatedDeliveryAfter *time.Time `form:"estimatedDeliveryAfter,omitempty" json:"estimatedDeliveryAfter,omitempty"`

	// ShipmentDeliveryBefore Get Shipment Details by passing Shipment Delivery Date Before. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	ShipmentDeliveryBefore *time.Time `form:"shipmentDeliveryBefore,omitempty" json:"shipmentDeliveryBefore,omitempty"`

	// ShipmentDeliveryAfter Get Shipment Details by passing Shipment Delivery Date After. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	ShipmentDeliveryAfter *time.Time `form:"shipmentDeliveryAfter,omitempty" json:"shipmentDeliveryAfter,omitempty"`

	// RequestedPickUpBefore Get Shipment Details by passing Before Requested pickup date. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	RequestedPickUpBefore *time.Time `form:"requestedPickUpBefore,omitempty" json:"requestedPickUpBefore,omitempty"`

	// RequestedPickUpAfter Get Shipment Details by passing After Requested pickup date. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	RequestedPickUpAfter *time.Time `form:"requestedPickUpAfter,omitempty" json:"requestedPickUpAfter,omitempty"`

	// ScheduledPickUpBefore Get Shipment Details by passing Before scheduled pickup date. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	ScheduledPickUpBefore *time.Time `form:"scheduledPickUpBefore,omitempty" json:"scheduledPickUpBefore,omitempty"`

	// ScheduledPickUpAfter Get Shipment Details by passing After Scheduled pickup date. Must be in <a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'>ISO 8601</a> format.
	ScheduledPickUpAfter *time.Time `form:"scheduledPickUpAfter,omitempty" json:"scheduledPickUpAfter,omitempty"`

	// CurrentShipmentStatus Get Shipment Details by passing Current shipment status.
	CurrentShipmentStatus *string `form:"currentShipmentStatus,omitempty" json:"currentShipmentStatus,omitempty"`

	// VendorShipmentIdentifier Get Shipment Details by passing Vendor Shipment ID
	VendorShipmentIdentifier *string `form:"vendorShipmentIdentifier,omitempty" json:"vendorShipmentIdentifier,omitempty"`

	// BuyerReferenceNumber Get Shipment Details by passing buyer Reference ID
	BuyerReferenceNumber *string `form:"buyerReferenceNumber,omitempty" json:"buyerReferenceNumber,omitempty"`

	// BuyerWarehouseCode Get Shipping Details based on buyer warehouse code. This value should be same as 'shipToParty.partyId' in the Shipment.
	BuyerWarehouseCode *string `form:"buyerWarehouseCode,omitempty" json:"buyerWarehouseCode,omitempty"`

	// SellerWarehouseCode Get Shipping Details based on vendor warehouse code. This value should be same as 'sellingParty.partyId' in the Shipment.
	SellerWarehouseCode *string `form:"sellerWarehouseCode,omitempty" json:"sellerWarehouseCode,omitempty"`
}

// GetShipmentDetailsParamsSortOrder defines parameters for GetShipmentDetails.
type GetShipmentDetailsParamsSortOrder string

// SubmitShipmentConfirmationsJSONRequestBody defines body for SubmitShipmentConfirmations for application/json ContentType.
type SubmitShipmentConfirmationsJSONRequestBody = SubmitShipmentConfirmationsRequest

// SubmitShipmentsJSONRequestBody defines body for SubmitShipments for application/json ContentType.
type SubmitShipmentsJSONRequestBody = SubmitShipments

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SubmitShipmentConfirmationsWithBody request with any body
	SubmitShipmentConfirmationsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	SubmitShipmentConfirmations(ctx context.Context, body SubmitShipmentConfirmationsJSONRequestBody) (*http.Response, error)

	// GetShipmentDetails request
	GetShipmentDetails(ctx context.Context, params *GetShipmentDetailsParams) (*http.Response, error)

	// SubmitShipmentsWithBody request with any body
	SubmitShipmentsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	SubmitShipments(ctx context.Context, body SubmitShipmentsJSONRequestBody) (*http.Response, error)
}

func (c *Client) SubmitShipmentConfirmationsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSubmitShipmentConfirmationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SubmitShipmentConfirmations(ctx context.Context, body SubmitShipmentConfirmationsJSONRequestBody) (*http.Response, error) {
	req, err := NewSubmitShipmentConfirmationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetShipmentDetails(ctx context.Context, params *GetShipmentDetailsParams) (*http.Response, error) {
	req, err := NewGetShipmentDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SubmitShipmentsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSubmitShipmentsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SubmitShipments(ctx context.Context, body SubmitShipmentsJSONRequestBody) (*http.Response, error) {
	req, err := NewSubmitShipmentsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewSubmitShipmentConfirmationsRequest calls the generic SubmitShipmentConfirmations builder with application/json body
func NewSubmitShipmentConfirmationsRequest(server string, body SubmitShipmentConfirmationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitShipmentConfirmationsRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitShipmentConfirmationsRequestWithBody generates requests for SubmitShipmentConfirmations with any type of body
func NewSubmitShipmentConfirmationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/shipping/v1/shipmentConfirmations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetShipmentDetailsRequest generates requests for GetShipmentDetails
func NewGetShipmentDetailsRequest(server string, params *GetShipmentDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/shipping/v1/shipments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBefore", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ShipmentConfirmedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipmentConfirmedBefore", runtime.ParamLocationQuery, *params.ShipmentConfirmedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ShipmentConfirmedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipmentConfirmedAfter", runtime.ParamLocationQuery, *params.ShipmentConfirmedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PackageLabelCreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "packageLabelCreatedBefore", runtime.ParamLocationQuery, *params.PackageLabelCreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PackageLabelCreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "packageLabelCreatedAfter", runtime.ParamLocationQuery, *params.PackageLabelCreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ShippedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shippedBefore", runtime.ParamLocationQuery, *params.ShippedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ShippedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shippedAfter", runtime.ParamLocationQuery, *params.ShippedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.EstimatedDeliveryBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "estimatedDeliveryBefore", runtime.ParamLocationQuery, *params.EstimatedDeliveryBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.EstimatedDeliveryAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "estimatedDeliveryAfter", runtime.ParamLocationQuery, *params.EstimatedDeliveryAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ShipmentDeliveryBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipmentDeliveryBefore", runtime.ParamLocationQuery, *params.ShipmentDeliveryBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ShipmentDeliveryAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipmentDeliveryAfter", runtime.ParamLocationQuery, *params.ShipmentDeliveryAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.RequestedPickUpBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestedPickUpBefore", runtime.ParamLocationQuery, *params.RequestedPickUpBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.RequestedPickUpAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestedPickUpAfter", runtime.ParamLocationQuery, *params.RequestedPickUpAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ScheduledPickUpBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduledPickUpBefore", runtime.ParamLocationQuery, *params.ScheduledPickUpBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ScheduledPickUpAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduledPickUpAfter", runtime.ParamLocationQuery, *params.ScheduledPickUpAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CurrentShipmentStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "currentShipmentStatus", runtime.ParamLocationQuery, *params.CurrentShipmentStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.VendorShipmentIdentifier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vendorShipmentIdentifier", runtime.ParamLocationQuery, *params.VendorShipmentIdentifier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.BuyerReferenceNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buyerReferenceNumber", runtime.ParamLocationQuery, *params.BuyerReferenceNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.BuyerWarehouseCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buyerWarehouseCode", runtime.ParamLocationQuery, *params.BuyerWarehouseCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SellerWarehouseCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sellerWarehouseCode", runtime.ParamLocationQuery, *params.SellerWarehouseCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitShipmentsRequest calls the generic SubmitShipments builder with application/json body
func NewSubmitShipmentsRequest(server string, body SubmitShipmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitShipmentsRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitShipmentsRequestWithBody generates requests for SubmitShipments with any type of body
func NewSubmitShipmentsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/shipping/v1/shipments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SubmitShipmentConfirmationsWithBodyWithResponse request with any body
	SubmitShipmentConfirmationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SubmitShipmentConfirmationsResp, error)

	SubmitShipmentConfirmationsWithResponse(ctx context.Context, body SubmitShipmentConfirmationsJSONRequestBody) (*SubmitShipmentConfirmationsResp, error)

	// GetShipmentDetailsWithResponse request
	GetShipmentDetailsWithResponse(ctx context.Context, params *GetShipmentDetailsParams) (*GetShipmentDetailsResp, error)

	// SubmitShipmentsWithBodyWithResponse request with any body
	SubmitShipmentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SubmitShipmentsResp, error)

	SubmitShipmentsWithResponse(ctx context.Context, body SubmitShipmentsJSONRequestBody) (*SubmitShipmentsResp, error)
}

type SubmitShipmentConfirmationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SubmitShipmentConfirmationsResponse
	JSON400      *SubmitShipmentConfirmationsResponse
	JSON403      *SubmitShipmentConfirmationsResponse
	JSON404      *SubmitShipmentConfirmationsResponse
	JSON413      *SubmitShipmentConfirmationsResponse
	JSON415      *SubmitShipmentConfirmationsResponse
	JSON429      *SubmitShipmentConfirmationsResponse
	JSON500      *SubmitShipmentConfirmationsResponse
	JSON503      *SubmitShipmentConfirmationsResponse
}

// Status returns HTTPResponse.Status
func (r SubmitShipmentConfirmationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitShipmentConfirmationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShipmentDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetShipmentDetailsResponse
	JSON400      *GetShipmentDetailsResponse
	JSON401      *GetShipmentDetailsResponse
	JSON403      *GetShipmentDetailsResponse
	JSON404      *GetShipmentDetailsResponse
	JSON415      *GetShipmentDetailsResponse
	JSON429      *GetShipmentDetailsResponse
	JSON500      *GetShipmentDetailsResponse
	JSON503      *GetShipmentDetailsResponse
}

// Status returns HTTPResponse.Status
func (r GetShipmentDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShipmentDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitShipmentsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SubmitShipmentConfirmationsResponse
	JSON400      *SubmitShipmentConfirmationsResponse
	JSON403      *SubmitShipmentConfirmationsResponse
	JSON404      *SubmitShipmentConfirmationsResponse
	JSON413      *SubmitShipmentConfirmationsResponse
	JSON415      *SubmitShipmentConfirmationsResponse
	JSON429      *SubmitShipmentConfirmationsResponse
	JSON500      *SubmitShipmentConfirmationsResponse
	JSON503      *SubmitShipmentConfirmationsResponse
}

// Status returns HTTPResponse.Status
func (r SubmitShipmentsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitShipmentsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SubmitShipmentConfirmationsWithBodyWithResponse request with arbitrary body returning *SubmitShipmentConfirmationsResp
func (c *ClientWithResponses) SubmitShipmentConfirmationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SubmitShipmentConfirmationsResp, error) {
	rsp, err := c.SubmitShipmentConfirmationsWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitShipmentConfirmationsResp(rsp)
}

func (c *ClientWithResponses) SubmitShipmentConfirmationsWithResponse(ctx context.Context, body SubmitShipmentConfirmationsJSONRequestBody) (*SubmitShipmentConfirmationsResp, error) {
	rsp, err := c.SubmitShipmentConfirmations(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitShipmentConfirmationsResp(rsp)
}

// GetShipmentDetailsWithResponse request returning *GetShipmentDetailsResp
func (c *ClientWithResponses) GetShipmentDetailsWithResponse(ctx context.Context, params *GetShipmentDetailsParams) (*GetShipmentDetailsResp, error) {
	rsp, err := c.GetShipmentDetails(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetShipmentDetailsResp(rsp)
}

// SubmitShipmentsWithBodyWithResponse request with arbitrary body returning *SubmitShipmentsResp
func (c *ClientWithResponses) SubmitShipmentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SubmitShipmentsResp, error) {
	rsp, err := c.SubmitShipmentsWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitShipmentsResp(rsp)
}

func (c *ClientWithResponses) SubmitShipmentsWithResponse(ctx context.Context, body SubmitShipmentsJSONRequestBody) (*SubmitShipmentsResp, error) {
	rsp, err := c.SubmitShipments(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseSubmitShipmentsResp(rsp)
}

// ParseSubmitShipmentConfirmationsResp parses an HTTP response from a SubmitShipmentConfirmationsWithResponse call
func ParseSubmitShipmentConfirmationsResp(rsp *http.Response) (*SubmitShipmentConfirmationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitShipmentConfirmationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetShipmentDetailsResp parses an HTTP response from a GetShipmentDetailsWithResponse call
func ParseGetShipmentDetailsResp(rsp *http.Response) (*GetShipmentDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShipmentDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetShipmentDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetShipmentDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetShipmentDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetShipmentDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetShipmentDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest GetShipmentDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetShipmentDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetShipmentDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetShipmentDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSubmitShipmentsResp parses an HTTP response from a SubmitShipmentsWithResponse call
func ParseSubmitShipmentsResp(rsp *http.Response) (*SubmitShipmentsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitShipmentsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest SubmitShipmentConfirmationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
