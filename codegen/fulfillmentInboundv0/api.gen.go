// Package fulfillmentinboundv0 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package fulfillmentinboundv0

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for BarcodeInstruction.
const (
	CanUseOriginalBarcode BarcodeInstruction = "CanUseOriginalBarcode"
	MustProvideSellerSKU  BarcodeInstruction = "MustProvideSellerSKU"
	RequiresFNSKULabel    BarcodeInstruction = "RequiresFNSKULabel"
)

// Defines values for BoxContentsSource.
const (
	FEED        BoxContentsSource = "FEED"
	INTERACTIVE BoxContentsSource = "INTERACTIVE"
	N2DBARCODE  BoxContentsSource = "2D_BARCODE"
	NONE        BoxContentsSource = "NONE"
)

// Defines values for CurrencyCode.
const (
	GBP CurrencyCode = "GBP"
	USD CurrencyCode = "USD"
)

// Defines values for ErrorReason.
const (
	ErrorReasonDoesNotExist ErrorReason = "DoesNotExist"
	ErrorReasonInvalidASIN  ErrorReason = "InvalidASIN"
)

// Defines values for LabelPrepType.
const (
	AMAZONLABEL LabelPrepType = "AMAZON_LABEL"
	NOLABEL     LabelPrepType = "NO_LABEL"
	SELLERLABEL LabelPrepType = "SELLER_LABEL"
)

// Defines values for PrepGuidance.
const (
	ConsultHelpDocuments     PrepGuidance = "ConsultHelpDocuments"
	NoAdditionalPrepRequired PrepGuidance = "NoAdditionalPrepRequired"
	SeePrepInstructionsList  PrepGuidance = "SeePrepInstructionsList"
)

// Defines values for PrepInstruction.
const (
	BlackShrinkWrapping     PrepInstruction = "BlackShrinkWrapping"
	BlankStickering         PrepInstruction = "BlankStickering"
	Boxing                  PrepInstruction = "Boxing"
	BubbleWrapping          PrepInstruction = "BubbleWrapping"
	CapSealing              PrepInstruction = "CapSealing"
	Debundle                PrepInstruction = "Debundle"
	HangGarment             PrepInstruction = "HangGarment"
	Labeling                PrepInstruction = "Labeling"
	NoPrep                  PrepInstruction = "NoPrep"
	Polybagging             PrepInstruction = "Polybagging"
	RemoveFromHanger        PrepInstruction = "RemoveFromHanger"
	SetCreation             PrepInstruction = "SetCreation"
	SetStickering           PrepInstruction = "SetStickering"
	ShipsInProductPackaging PrepInstruction = "ShipsInProductPackaging"
	SuffocationStickering   PrepInstruction = "SuffocationStickering"
	Taping                  PrepInstruction = "Taping"
)

// Defines values for PrepOwner.
const (
	AMAZON PrepOwner = "AMAZON"
	SELLER PrepOwner = "SELLER"
)

// Defines values for ShipmentStatus.
const (
	ShipmentStatusCANCELLED ShipmentStatus = "CANCELLED"
	ShipmentStatusCHECKEDIN ShipmentStatus = "CHECKED_IN"
	ShipmentStatusCLOSED    ShipmentStatus = "CLOSED"
	ShipmentStatusDELETED   ShipmentStatus = "DELETED"
	ShipmentStatusDELIVERED ShipmentStatus = "DELIVERED"
	ShipmentStatusERROR     ShipmentStatus = "ERROR"
	ShipmentStatusINTRANSIT ShipmentStatus = "IN_TRANSIT"
	ShipmentStatusRECEIVING ShipmentStatus = "RECEIVING"
	ShipmentStatusSHIPPED   ShipmentStatus = "SHIPPED"
	ShipmentStatusWORKING   ShipmentStatus = "WORKING"
)

// Defines values for GetShipmentItemsParamsQueryType.
const (
	GetShipmentItemsParamsQueryTypeDATERANGE GetShipmentItemsParamsQueryType = "DATE_RANGE"
	GetShipmentItemsParamsQueryTypeNEXTTOKEN GetShipmentItemsParamsQueryType = "NEXT_TOKEN"
)

// Defines values for GetShipmentsParamsShipmentStatusList.
const (
	GetShipmentsParamsShipmentStatusListCANCELLED   GetShipmentsParamsShipmentStatusList = "CANCELLED"
	GetShipmentsParamsShipmentStatusListCHECKEDIN   GetShipmentsParamsShipmentStatusList = "CHECKED_IN"
	GetShipmentsParamsShipmentStatusListCLOSED      GetShipmentsParamsShipmentStatusList = "CLOSED"
	GetShipmentsParamsShipmentStatusListDELETED     GetShipmentsParamsShipmentStatusList = "DELETED"
	GetShipmentsParamsShipmentStatusListDELIVERED   GetShipmentsParamsShipmentStatusList = "DELIVERED"
	GetShipmentsParamsShipmentStatusListERROR       GetShipmentsParamsShipmentStatusList = "ERROR"
	GetShipmentsParamsShipmentStatusListINTRANSIT   GetShipmentsParamsShipmentStatusList = "IN_TRANSIT"
	GetShipmentsParamsShipmentStatusListREADYTOSHIP GetShipmentsParamsShipmentStatusList = "READY_TO_SHIP"
	GetShipmentsParamsShipmentStatusListRECEIVING   GetShipmentsParamsShipmentStatusList = "RECEIVING"
	GetShipmentsParamsShipmentStatusListSHIPPED     GetShipmentsParamsShipmentStatusList = "SHIPPED"
	GetShipmentsParamsShipmentStatusListWORKING     GetShipmentsParamsShipmentStatusList = "WORKING"
)

// Defines values for GetShipmentsParamsQueryType.
const (
	GetShipmentsParamsQueryTypeDATERANGE GetShipmentsParamsQueryType = "DATE_RANGE"
	GetShipmentsParamsQueryTypeNEXTTOKEN GetShipmentsParamsQueryType = "NEXT_TOKEN"
	GetShipmentsParamsQueryTypeSHIPMENT  GetShipmentsParamsQueryType = "SHIPMENT"
)

// Defines values for GetLabelsParamsPageType.
const (
	PackageLabelA42                      GetLabelsParamsPageType = "PackageLabel_A4_2"
	PackageLabelA44                      GetLabelsParamsPageType = "PackageLabel_A4_4"
	PackageLabelLetter2                  GetLabelsParamsPageType = "PackageLabel_Letter_2"
	PackageLabelLetter4                  GetLabelsParamsPageType = "PackageLabel_Letter_4"
	PackageLabelLetter6                  GetLabelsParamsPageType = "PackageLabel_Letter_6"
	PackageLabelLetter6CarrierLeft       GetLabelsParamsPageType = "PackageLabel_Letter_6_CarrierLeft"
	PackageLabelPlainPaper               GetLabelsParamsPageType = "PackageLabel_Plain_Paper"
	PackageLabelPlainPaperCarrierBottom  GetLabelsParamsPageType = "PackageLabel_Plain_Paper_CarrierBottom"
	PackageLabelThermal                  GetLabelsParamsPageType = "PackageLabel_Thermal"
	PackageLabelThermalNoCarrierRotation GetLabelsParamsPageType = "PackageLabel_Thermal_No_Carrier_Rotation"
	PackageLabelThermalNonPCP            GetLabelsParamsPageType = "PackageLabel_Thermal_NonPCP"
	PackageLabelThermalUnified           GetLabelsParamsPageType = "PackageLabel_Thermal_Unified"
)

// Defines values for GetLabelsParamsLabelType.
const (
	BARCODE2D GetLabelsParamsLabelType = "BARCODE_2D"
	PALLET    GetLabelsParamsLabelType = "PALLET"
	UNIQUE    GetLabelsParamsLabelType = "UNIQUE"
)

// ASINPrepInstructions Item preparation instructions to help with item sourcing decisions.
type ASINPrepInstructions struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN *string `json:"ASIN,omitempty"`

	// BarcodeInstruction Labeling requirements for the item. For more information about FBA labeling requirements, see the Seller Central Help for your marketplace.
	BarcodeInstruction *BarcodeInstruction `json:"BarcodeInstruction,omitempty"`

	// PrepGuidance Item preparation instructions.
	PrepGuidance *PrepGuidance `json:"PrepGuidance,omitempty"`

	// PrepInstructionList A list of preparation instructions to help with item sourcing decisions.
	PrepInstructionList *PrepInstructionList `json:"PrepInstructionList,omitempty"`
}

// ASINPrepInstructionsList A list of item preparation instructions.
type ASINPrepInstructionsList = []ASINPrepInstructions

// Address Specific details to identify a place.
type Address struct {
	// AddressLine1 The street address information.
	AddressLine1 string `json:"AddressLine1"`

	// AddressLine2 Additional street address information, if required.
	AddressLine2 *string `json:"AddressLine2,omitempty"`

	// City The city.
	City string `json:"City"`

	// CountryCode The country code in two-character ISO 3166-1 alpha-2 format.
	CountryCode string `json:"CountryCode"`

	// DistrictOrCounty The district or county.
	DistrictOrCounty *string `json:"DistrictOrCounty,omitempty"`

	// Name Name of the individual or business.
	Name string `json:"Name"`

	// PostalCode The postal code.
	//
	// If postal codes are used in your marketplace, we recommended that you include one with your request. This helps Amazon select the most appropriate Amazon fulfillment center for the inbound shipment plan.
	PostalCode string `json:"PostalCode"`

	// StateOrProvinceCode The state or province code.
	//
	// If state or province codes are used in your marketplace, it is recommended that you include one with your request. This helps Amazon to select the most appropriate Amazon fulfillment center for your inbound shipment plan.
	StateOrProvinceCode string `json:"StateOrProvinceCode"`
}

// AmazonPrepFeesDetails The fees for Amazon to prep goods for shipment.
type AmazonPrepFeesDetails struct {
	// FeePerUnit The monetary value.
	FeePerUnit *Amount `json:"FeePerUnit,omitempty"`

	// PrepInstruction Preparation instructions for shipping an item to Amazon's fulfillment network. For more information about preparing items for shipment to Amazon's fulfillment network, see the Seller Central Help for your marketplace.
	PrepInstruction *PrepInstruction `json:"PrepInstruction,omitempty"`
}

// AmazonPrepFeesDetailsList A list of preparation instructions and fees for Amazon to prep goods for shipment.
type AmazonPrepFeesDetailsList = []AmazonPrepFeesDetails

// Amount The monetary value.
type Amount struct {
	// CurrencyCode The currency code.
	CurrencyCode CurrencyCode `json:"CurrencyCode"`

	// Value Number format that supports decimal.
	Value BigDecimalType `json:"Value"`
}

// BarcodeInstruction Labeling requirements for the item. For more information about FBA labeling requirements, see the Seller Central Help for your marketplace.
type BarcodeInstruction string

// BigDecimalType Number format that supports decimal.
type BigDecimalType = float64

// BillOfLadingDownloadURL Download URL for the bill of lading.
type BillOfLadingDownloadURL struct {
	// DownloadURL URL to download the bill of lading for the package. Note: The URL will only be valid for 15 seconds
	DownloadURL *string `json:"DownloadURL,omitempty"`
}

// BoxContentsFeeDetails The manual processing fee per unit and total fee for a shipment.
type BoxContentsFeeDetails struct {
	// FeePerUnit The monetary value.
	FeePerUnit *Amount `json:"FeePerUnit,omitempty"`

	// TotalFee The monetary value.
	TotalFee *Amount `json:"TotalFee,omitempty"`

	// TotalUnits The item quantity.
	TotalUnits *Quantity `json:"TotalUnits,omitempty"`
}

// BoxContentsSource Where the seller provided box contents information for a shipment.
type BoxContentsSource string

// CurrencyCode The currency code.
type CurrencyCode string

// DateStringType Type containing date in string format
type DateStringType = openapi_types.Date

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occured.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition in a human-readable form.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// ErrorReason The reason that the ASIN is invalid.
type ErrorReason string

// GetBillOfLadingResponse The response schema for the getBillOfLading operation.
type GetBillOfLadingResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Download URL for the bill of lading.
	Payload *BillOfLadingDownloadURL `json:"payload,omitempty"`
}

// GetLabelsResponse The response schema for the getLabels operation.
type GetLabelsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Download URL for a label
	Payload *LabelDownloadURL `json:"payload,omitempty"`
}

// GetPrepInstructionsResponse The response schema for the getPrepInstructions operation.
type GetPrepInstructionsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Result for the get prep instructions operation
	Payload *GetPrepInstructionsResult `json:"payload,omitempty"`
}

// GetPrepInstructionsResult Result for the get prep instructions operation
type GetPrepInstructionsResult struct {
	// ASINPrepInstructionsList A list of item preparation instructions.
	ASINPrepInstructionsList *ASINPrepInstructionsList `json:"ASINPrepInstructionsList,omitempty"`

	// InvalidASINList A list of invalid ASIN values and the reasons they are invalid.
	InvalidASINList *InvalidASINList `json:"InvalidASINList,omitempty"`

	// InvalidSKUList A list of invalid SKU values and the reason they are invalid.
	InvalidSKUList *InvalidSKUList `json:"InvalidSKUList,omitempty"`

	// SKUPrepInstructionsList A list of SKU labeling requirements and item preparation instructions.
	SKUPrepInstructionsList *SKUPrepInstructionsList `json:"SKUPrepInstructionsList,omitempty"`
}

// GetShipmentItemsResponse The response schema for the getShipmentItems operation.
type GetShipmentItemsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Result for the get shipment items operation
	Payload *GetShipmentItemsResult `json:"payload,omitempty"`
}

// GetShipmentItemsResult Result for the get shipment items operation
type GetShipmentItemsResult struct {
	// ItemData A list of inbound shipment item information.
	ItemData *InboundShipmentItemList `json:"ItemData,omitempty"`

	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"NextToken,omitempty"`
}

// GetShipmentsResponse The response schema for the getShipments operation.
type GetShipmentsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Payload Result for the get shipments operation
	Payload *GetShipmentsResult `json:"payload,omitempty"`
}

// GetShipmentsResult Result for the get shipments operation
type GetShipmentsResult struct {
	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"NextToken,omitempty"`

	// ShipmentData A list of inbound shipment information.
	ShipmentData *InboundShipmentList `json:"ShipmentData,omitempty"`
}

// InboundShipmentInfo Information about the seller's inbound shipments. Returned by the listInboundShipments operation.
type InboundShipmentInfo struct {
	// AreCasesRequired Indicates whether or not an inbound shipment contains case-packed boxes. When AreCasesRequired = true for an inbound shipment, all items in the inbound shipment must be case packed.
	AreCasesRequired bool `json:"AreCasesRequired"`

	// BoxContentsSource Where the seller provided box contents information for a shipment.
	BoxContentsSource *BoxContentsSource `json:"BoxContentsSource,omitempty"`

	// ConfirmedNeedByDate Type containing date in string format
	ConfirmedNeedByDate *DateStringType `json:"ConfirmedNeedByDate,omitempty"`

	// DestinationFulfillmentCenterId An Amazon fulfillment center identifier created by Amazon.
	DestinationFulfillmentCenterId *string `json:"DestinationFulfillmentCenterId,omitempty"`

	// EstimatedBoxContentsFee The manual processing fee per unit and total fee for a shipment.
	EstimatedBoxContentsFee *BoxContentsFeeDetails `json:"EstimatedBoxContentsFee,omitempty"`

	// LabelPrepType The type of label preparation that is required for the inbound shipment.
	LabelPrepType *LabelPrepType `json:"LabelPrepType,omitempty"`

	// ShipFromAddress Specific details to identify a place.
	ShipFromAddress Address `json:"ShipFromAddress"`

	// ShipmentId The shipment identifier submitted in the request.
	ShipmentId *string `json:"ShipmentId,omitempty"`

	// ShipmentName The name for the inbound shipment.
	ShipmentName *string `json:"ShipmentName,omitempty"`

	// ShipmentStatus Indicates the status of the inbound shipment. When used with the createInboundShipment operation, WORKING is the only valid value. When used with the updateInboundShipment operation, possible values are WORKING, SHIPPED or CANCELLED.
	ShipmentStatus *ShipmentStatus `json:"ShipmentStatus,omitempty"`
}

// InboundShipmentItem Item information for an inbound shipment. Submitted with a call to the createInboundShipment or updateInboundShipment operation.
type InboundShipmentItem struct {
	// FulfillmentNetworkSKU Amazon's fulfillment network SKU of the item.
	FulfillmentNetworkSKU *string `json:"FulfillmentNetworkSKU,omitempty"`

	// PrepDetailsList A list of preparation instructions and who is responsible for that preparation.
	PrepDetailsList *PrepDetailsList `json:"PrepDetailsList,omitempty"`

	// QuantityInCase The item quantity.
	QuantityInCase *Quantity `json:"QuantityInCase,omitempty"`

	// QuantityReceived The item quantity.
	QuantityReceived *Quantity `json:"QuantityReceived,omitempty"`

	// QuantityShipped The item quantity.
	QuantityShipped Quantity `json:"QuantityShipped"`

	// ReleaseDate Type containing date in string format
	ReleaseDate *DateStringType `json:"ReleaseDate,omitempty"`

	// SellerSKU The seller SKU of the item.
	SellerSKU string `json:"SellerSKU"`

	// ShipmentId A shipment identifier originally returned by the createInboundShipmentPlan operation.
	ShipmentId *string `json:"ShipmentId,omitempty"`
}

// InboundShipmentItemList A list of inbound shipment item information.
type InboundShipmentItemList = []InboundShipmentItem

// InboundShipmentList A list of inbound shipment information.
type InboundShipmentList = []InboundShipmentInfo

// InvalidASIN Contains details about an invalid ASIN
type InvalidASIN struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN *string `json:"ASIN,omitempty"`

	// ErrorReason The reason that the ASIN is invalid.
	ErrorReason *ErrorReason `json:"ErrorReason,omitempty"`
}

// InvalidASINList A list of invalid ASIN values and the reasons they are invalid.
type InvalidASINList = []InvalidASIN

// InvalidSKU Contains detail about an invalid SKU
type InvalidSKU struct {
	// ErrorReason The reason that the ASIN is invalid.
	ErrorReason *ErrorReason `json:"ErrorReason,omitempty"`

	// SellerSKU The seller SKU of the item.
	SellerSKU *string `json:"SellerSKU,omitempty"`
}

// InvalidSKUList A list of invalid SKU values and the reason they are invalid.
type InvalidSKUList = []InvalidSKU

// LabelDownloadURL Download URL for a label
type LabelDownloadURL struct {
	// DownloadURL URL to download the label for the package. Note: The URL will only be valid for 15 seconds
	DownloadURL *string `json:"DownloadURL,omitempty"`
}

// LabelPrepType The type of label preparation that is required for the inbound shipment.
type LabelPrepType string

// PrepDetails Preparation instructions and who is responsible for the preparation.
type PrepDetails struct {
	// PrepInstruction Preparation instructions for shipping an item to Amazon's fulfillment network. For more information about preparing items for shipment to Amazon's fulfillment network, see the Seller Central Help for your marketplace.
	PrepInstruction PrepInstruction `json:"PrepInstruction"`

	// PrepOwner Indicates who will prepare the item.
	PrepOwner PrepOwner `json:"PrepOwner"`
}

// PrepDetailsList A list of preparation instructions and who is responsible for that preparation.
type PrepDetailsList = []PrepDetails

// PrepGuidance Item preparation instructions.
type PrepGuidance string

// PrepInstruction Preparation instructions for shipping an item to Amazon's fulfillment network. For more information about preparing items for shipment to Amazon's fulfillment network, see the Seller Central Help for your marketplace.
type PrepInstruction string

// PrepInstructionList A list of preparation instructions to help with item sourcing decisions.
type PrepInstructionList = []PrepInstruction

// PrepOwner Indicates who will prepare the item.
type PrepOwner string

// Quantity The item quantity.
type Quantity = int32

// SKUPrepInstructions Labeling requirements and item preparation instructions to help you prepare items for shipment to Amazon's fulfillment network.
type SKUPrepInstructions struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN *string `json:"ASIN,omitempty"`

	// AmazonPrepFeesDetailsList A list of preparation instructions and fees for Amazon to prep goods for shipment.
	AmazonPrepFeesDetailsList *AmazonPrepFeesDetailsList `json:"AmazonPrepFeesDetailsList,omitempty"`

	// BarcodeInstruction Labeling requirements for the item. For more information about FBA labeling requirements, see the Seller Central Help for your marketplace.
	BarcodeInstruction *BarcodeInstruction `json:"BarcodeInstruction,omitempty"`

	// PrepGuidance Item preparation instructions.
	PrepGuidance *PrepGuidance `json:"PrepGuidance,omitempty"`

	// PrepInstructionList A list of preparation instructions to help with item sourcing decisions.
	PrepInstructionList *PrepInstructionList `json:"PrepInstructionList,omitempty"`

	// SellerSKU The seller SKU of the item.
	SellerSKU *string `json:"SellerSKU,omitempty"`
}

// SKUPrepInstructionsList A list of SKU labeling requirements and item preparation instructions.
type SKUPrepInstructionsList = []SKUPrepInstructions

// ShipmentStatus Indicates the status of the inbound shipment. When used with the createInboundShipment operation, WORKING is the only valid value. When used with the updateInboundShipment operation, possible values are WORKING, SHIPPED or CANCELLED.
type ShipmentStatus string

// GetPrepInstructionsParams defines parameters for GetPrepInstructions.
type GetPrepInstructionsParams struct {
	// ShipToCountryCode The country code of the country to which the items will be shipped. Note that labeling requirements and item preparation instructions can vary by country.
	ShipToCountryCode string `form:"ShipToCountryCode" json:"ShipToCountryCode"`

	// SellerSKUList A list of SellerSKU values. Used to identify items for which you want labeling requirements and item preparation instructions for shipment to Amazon's fulfillment network. The SellerSKU is qualified by the Seller ID, which is included with every call to the Seller Partner API.
	//
	// Note: Include seller SKUs that you have used to list items on Amazon's retail website. If you include a seller SKU that you have never used to list an item on Amazon's retail website, the seller SKU is returned in the InvalidSKUList property in the response.
	SellerSKUList *[]string `form:"SellerSKUList,omitempty" json:"SellerSKUList,omitempty"`

	// ASINList A list of ASIN values. Used to identify items for which you want item preparation instructions to help with item sourcing decisions.
	//
	// Note: ASINs must be included in the product catalog for at least one of the marketplaces that the seller  participates in. Any ASIN that is not included in the product catalog for at least one of the marketplaces that the seller participates in is returned in the InvalidASINList property in the response. You can find out which marketplaces a seller participates in by calling the getMarketplaceParticipations operation in the Selling Partner API for Sellers.
	ASINList *[]string `form:"ASINList,omitempty" json:"ASINList,omitempty"`
}

// GetShipmentItemsParams defines parameters for GetShipmentItems.
type GetShipmentItemsParams struct {
	// LastUpdatedAfter A date used for selecting inbound shipment items that were last updated after (or at) a specified time. The selection includes updates made by Amazon and by the seller.
	LastUpdatedAfter *time.Time `form:"LastUpdatedAfter,omitempty" json:"LastUpdatedAfter,omitempty"`

	// LastUpdatedBefore A date used for selecting inbound shipment items that were last updated before (or at) a specified time. The selection includes updates made by Amazon and by the seller.
	LastUpdatedBefore *time.Time `form:"LastUpdatedBefore,omitempty" json:"LastUpdatedBefore,omitempty"`

	// QueryType Indicates whether items are returned using a date range (by providing the LastUpdatedAfter and LastUpdatedBefore parameters), or using NextToken, which continues returning items specified in a previous request.
	QueryType GetShipmentItemsParamsQueryType `form:"QueryType" json:"QueryType"`

	// NextToken A string token returned in the response to your previous request.
	NextToken *string `form:"NextToken,omitempty" json:"NextToken,omitempty"`

	// MarketplaceId A marketplace identifier. Specifies the marketplace where the product would be stored.
	MarketplaceId string `form:"MarketplaceId" json:"MarketplaceId"`
}

// GetShipmentItemsParamsQueryType defines parameters for GetShipmentItems.
type GetShipmentItemsParamsQueryType string

// GetShipmentsParams defines parameters for GetShipments.
type GetShipmentsParams struct {
	// ShipmentStatusList A list of ShipmentStatus values. Used to select shipments with a current status that matches the status values that you specify.
	ShipmentStatusList *[]GetShipmentsParamsShipmentStatusList `form:"ShipmentStatusList,omitempty" json:"ShipmentStatusList,omitempty"`

	// ShipmentIdList A list of shipment IDs used to select the shipments that you want. If both ShipmentStatusList and ShipmentIdList are specified, only shipments that match both parameters are returned.
	ShipmentIdList *[]string `form:"ShipmentIdList,omitempty" json:"ShipmentIdList,omitempty"`

	// LastUpdatedAfter A date used for selecting inbound shipments that were last updated after (or at) a specified time. The selection includes updates made by Amazon and by the seller.
	LastUpdatedAfter *time.Time `form:"LastUpdatedAfter,omitempty" json:"LastUpdatedAfter,omitempty"`

	// LastUpdatedBefore A date used for selecting inbound shipments that were last updated before (or at) a specified time. The selection includes updates made by Amazon and by the seller.
	LastUpdatedBefore *time.Time `form:"LastUpdatedBefore,omitempty" json:"LastUpdatedBefore,omitempty"`

	// QueryType Indicates whether shipments are returned using shipment information (by providing the ShipmentStatusList or ShipmentIdList parameters), using a date range (by providing the LastUpdatedAfter and LastUpdatedBefore parameters), or by using NextToken to continue returning items specified in a previous request.
	QueryType GetShipmentsParamsQueryType `form:"QueryType" json:"QueryType"`

	// NextToken A string token returned in the response to your previous request.
	NextToken *string `form:"NextToken,omitempty" json:"NextToken,omitempty"`

	// MarketplaceId A marketplace identifier. Specifies the marketplace where the product would be stored.
	MarketplaceId string `form:"MarketplaceId" json:"MarketplaceId"`
}

// GetShipmentsParamsShipmentStatusList defines parameters for GetShipments.
type GetShipmentsParamsShipmentStatusList string

// GetShipmentsParamsQueryType defines parameters for GetShipments.
type GetShipmentsParamsQueryType string

// GetShipmentItemsByShipmentIdParams defines parameters for GetShipmentItemsByShipmentId.
type GetShipmentItemsByShipmentIdParams struct {
	// MarketplaceId Deprecated. Do not use.
	MarketplaceId *string `form:"MarketplaceId,omitempty" json:"MarketplaceId,omitempty"`
}

// GetLabelsParams defines parameters for GetLabels.
type GetLabelsParams struct {
	// PageType The page type to use to print the labels. Submitting a PageType value that is not supported in your marketplace returns an error.
	PageType GetLabelsParamsPageType `form:"PageType" json:"PageType"`

	// LabelType The type of labels requested.
	LabelType GetLabelsParamsLabelType `form:"LabelType" json:"LabelType"`

	// NumberOfPackages The number of packages in the shipment.
	NumberOfPackages *int `form:"NumberOfPackages,omitempty" json:"NumberOfPackages,omitempty"`

	// PackageLabelsToPrint A list of identifiers that specify packages for which you want package labels printed.
	//
	// If you provide box content information with the [FBA Inbound Shipment Carton Information Feed](https://developer-docs.amazon.com/sp-api/docs/fulfillment-by-amazon-feed-type-values#fba-inbound-shipment-carton-information-feed), then `PackageLabelsToPrint` must match the `CartonId` values you provide through that feed. If you provide box content information with the Fulfillment Inbound API v2024-03-20, then `PackageLabelsToPrint` must match the `boxID` values from the [`listShipmentBoxes`](https://developer-docs.amazon.com/sp-api/docs/fulfillment-inbound-api-v2024-03-20-reference#listshipmentboxes) response. If these values do not match as required, the operation returns the `IncorrectPackageIdentifier` error code.
	PackageLabelsToPrint *[]string `form:"PackageLabelsToPrint,omitempty" json:"PackageLabelsToPrint,omitempty"`

	// NumberOfPallets The number of pallets in the shipment. This returns four identical labels for each pallet.
	NumberOfPallets *int `form:"NumberOfPallets,omitempty" json:"NumberOfPallets,omitempty"`

	// PageSize The page size for paginating through the total packages' labels. This is a required parameter for Non-Partnered LTL Shipments. Max value:1000.
	PageSize *int `form:"PageSize,omitempty" json:"PageSize,omitempty"`

	// PageStartIndex The page start index for paginating through the total packages' labels. This is a required parameter for Non-Partnered LTL Shipments.
	PageStartIndex *int `form:"PageStartIndex,omitempty" json:"PageStartIndex,omitempty"`
}

// GetLabelsParamsPageType defines parameters for GetLabels.
type GetLabelsParamsPageType string

// GetLabelsParamsLabelType defines parameters for GetLabels.
type GetLabelsParamsLabelType string

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetPrepInstructions request
	GetPrepInstructions(ctx context.Context, params *GetPrepInstructionsParams) (*http.Response, error)

	// GetShipmentItems request
	GetShipmentItems(ctx context.Context, params *GetShipmentItemsParams) (*http.Response, error)

	// GetShipments request
	GetShipments(ctx context.Context, params *GetShipmentsParams) (*http.Response, error)

	// GetBillOfLading request
	GetBillOfLading(ctx context.Context, shipmentId string) (*http.Response, error)

	// GetShipmentItemsByShipmentId request
	GetShipmentItemsByShipmentId(ctx context.Context, shipmentId string, params *GetShipmentItemsByShipmentIdParams) (*http.Response, error)

	// GetLabels request
	GetLabels(ctx context.Context, shipmentId string, params *GetLabelsParams) (*http.Response, error)
}

func (c *Client) GetPrepInstructions(ctx context.Context, params *GetPrepInstructionsParams) (*http.Response, error) {
	req, err := NewGetPrepInstructionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetShipmentItems(ctx context.Context, params *GetShipmentItemsParams) (*http.Response, error) {
	req, err := NewGetShipmentItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetShipments(ctx context.Context, params *GetShipmentsParams) (*http.Response, error) {
	req, err := NewGetShipmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetBillOfLading(ctx context.Context, shipmentId string) (*http.Response, error) {
	req, err := NewGetBillOfLadingRequest(c.Server, shipmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetShipmentItemsByShipmentId(ctx context.Context, shipmentId string, params *GetShipmentItemsByShipmentIdParams) (*http.Response, error) {
	req, err := NewGetShipmentItemsByShipmentIdRequest(c.Server, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetLabels(ctx context.Context, shipmentId string, params *GetLabelsParams) (*http.Response, error) {
	req, err := NewGetLabelsRequest(c.Server, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewGetPrepInstructionsRequest generates requests for GetPrepInstructions
func NewGetPrepInstructionsRequest(server string, params *GetPrepInstructionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/prepInstructions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ShipToCountryCode", runtime.ParamLocationQuery, params.ShipToCountryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.SellerSKUList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SellerSKUList", runtime.ParamLocationQuery, *params.SellerSKUList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ASINList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ASINList", runtime.ParamLocationQuery, *params.ASINList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShipmentItemsRequest generates requests for GetShipmentItems
func NewGetShipmentItemsRequest(server string, params *GetShipmentItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipmentItems")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LastUpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LastUpdatedAfter", runtime.ParamLocationQuery, *params.LastUpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LastUpdatedBefore", runtime.ParamLocationQuery, *params.LastUpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "QueryType", runtime.ParamLocationQuery, params.QueryType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShipmentsRequest generates requests for GetShipments
func NewGetShipmentsRequest(server string, params *GetShipmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShipmentStatusList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ShipmentStatusList", runtime.ParamLocationQuery, *params.ShipmentStatusList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ShipmentIdList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ShipmentIdList", runtime.ParamLocationQuery, *params.ShipmentIdList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LastUpdatedAfter", runtime.ParamLocationQuery, *params.LastUpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LastUpdatedBefore", runtime.ParamLocationQuery, *params.LastUpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "QueryType", runtime.ParamLocationQuery, params.QueryType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillOfLadingRequest generates requests for GetBillOfLading
func NewGetBillOfLadingRequest(server string, shipmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/billOfLading", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShipmentItemsByShipmentIdRequest generates requests for GetShipmentItemsByShipmentId
func NewGetShipmentItemsByShipmentIdRequest(server string, shipmentId string, params *GetShipmentItemsByShipmentIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MarketplaceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, *params.MarketplaceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLabelsRequest generates requests for GetLabels
func NewGetLabelsRequest(server string, shipmentId string, params *GetLabelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "PageType", runtime.ParamLocationQuery, params.PageType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LabelType", runtime.ParamLocationQuery, params.LabelType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.NumberOfPackages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NumberOfPackages", runtime.ParamLocationQuery, *params.NumberOfPackages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PackageLabelsToPrint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "PackageLabelsToPrint", runtime.ParamLocationQuery, *params.PackageLabelsToPrint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NumberOfPallets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NumberOfPallets", runtime.ParamLocationQuery, *params.NumberOfPallets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "PageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageStartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "PageStartIndex", runtime.ParamLocationQuery, *params.PageStartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetPrepInstructionsWithResponse request
	GetPrepInstructionsWithResponse(ctx context.Context, params *GetPrepInstructionsParams) (*GetPrepInstructionsResp, error)

	// GetShipmentItemsWithResponse request
	GetShipmentItemsWithResponse(ctx context.Context, params *GetShipmentItemsParams) (*GetShipmentItemsResp, error)

	// GetShipmentsWithResponse request
	GetShipmentsWithResponse(ctx context.Context, params *GetShipmentsParams) (*GetShipmentsResp, error)

	// GetBillOfLadingWithResponse request
	GetBillOfLadingWithResponse(ctx context.Context, shipmentId string) (*GetBillOfLadingResp, error)

	// GetShipmentItemsByShipmentIdWithResponse request
	GetShipmentItemsByShipmentIdWithResponse(ctx context.Context, shipmentId string, params *GetShipmentItemsByShipmentIdParams) (*GetShipmentItemsByShipmentIdResp, error)

	// GetLabelsWithResponse request
	GetLabelsWithResponse(ctx context.Context, shipmentId string, params *GetLabelsParams) (*GetLabelsResp, error)
}

type GetPrepInstructionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPrepInstructionsResponse
	JSON400      *GetPrepInstructionsResponse
	JSON401      *GetPrepInstructionsResponse
	JSON403      *GetPrepInstructionsResponse
	JSON404      *GetPrepInstructionsResponse
	JSON429      *GetPrepInstructionsResponse
	JSON500      *GetPrepInstructionsResponse
	JSON503      *GetPrepInstructionsResponse
}

// Status returns HTTPResponse.Status
func (r GetPrepInstructionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrepInstructionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShipmentItemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetShipmentItemsResponse
	JSON400      *GetShipmentItemsResponse
	JSON401      *GetShipmentItemsResponse
	JSON403      *GetShipmentItemsResponse
	JSON404      *GetShipmentItemsResponse
	JSON429      *GetShipmentItemsResponse
	JSON500      *GetShipmentItemsResponse
	JSON503      *GetShipmentItemsResponse
}

// Status returns HTTPResponse.Status
func (r GetShipmentItemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShipmentItemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShipmentsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetShipmentsResponse
	JSON400      *GetShipmentsResponse
	JSON401      *GetShipmentsResponse
	JSON403      *GetShipmentsResponse
	JSON404      *GetShipmentsResponse
	JSON429      *GetShipmentsResponse
	JSON500      *GetShipmentsResponse
	JSON503      *GetShipmentsResponse
}

// Status returns HTTPResponse.Status
func (r GetShipmentsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShipmentsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillOfLadingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBillOfLadingResponse
	JSON400      *GetBillOfLadingResponse
	JSON401      *GetBillOfLadingResponse
	JSON403      *GetBillOfLadingResponse
	JSON404      *GetBillOfLadingResponse
	JSON429      *GetBillOfLadingResponse
	JSON500      *GetBillOfLadingResponse
	JSON503      *GetBillOfLadingResponse
}

// Status returns HTTPResponse.Status
func (r GetBillOfLadingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillOfLadingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShipmentItemsByShipmentIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetShipmentItemsResponse
	JSON400      *GetShipmentItemsResponse
	JSON401      *GetShipmentItemsResponse
	JSON403      *GetShipmentItemsResponse
	JSON404      *GetShipmentItemsResponse
	JSON429      *GetShipmentItemsResponse
	JSON500      *GetShipmentItemsResponse
	JSON503      *GetShipmentItemsResponse
}

// Status returns HTTPResponse.Status
func (r GetShipmentItemsByShipmentIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShipmentItemsByShipmentIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLabelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetLabelsResponse
	JSON400      *GetLabelsResponse
	JSON401      *GetLabelsResponse
	JSON403      *GetLabelsResponse
	JSON404      *GetLabelsResponse
	JSON429      *GetLabelsResponse
	JSON500      *GetLabelsResponse
	JSON503      *GetLabelsResponse
}

// Status returns HTTPResponse.Status
func (r GetLabelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetPrepInstructionsWithResponse request returning *GetPrepInstructionsResp
func (c *ClientWithResponses) GetPrepInstructionsWithResponse(ctx context.Context, params *GetPrepInstructionsParams) (*GetPrepInstructionsResp, error) {
	rsp, err := c.GetPrepInstructions(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetPrepInstructionsResp(rsp)
}

// GetShipmentItemsWithResponse request returning *GetShipmentItemsResp
func (c *ClientWithResponses) GetShipmentItemsWithResponse(ctx context.Context, params *GetShipmentItemsParams) (*GetShipmentItemsResp, error) {
	rsp, err := c.GetShipmentItems(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetShipmentItemsResp(rsp)
}

// GetShipmentsWithResponse request returning *GetShipmentsResp
func (c *ClientWithResponses) GetShipmentsWithResponse(ctx context.Context, params *GetShipmentsParams) (*GetShipmentsResp, error) {
	rsp, err := c.GetShipments(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetShipmentsResp(rsp)
}

// GetBillOfLadingWithResponse request returning *GetBillOfLadingResp
func (c *ClientWithResponses) GetBillOfLadingWithResponse(ctx context.Context, shipmentId string) (*GetBillOfLadingResp, error) {
	rsp, err := c.GetBillOfLading(ctx, shipmentId)
	if err != nil {
		return nil, err
	}
	return ParseGetBillOfLadingResp(rsp)
}

// GetShipmentItemsByShipmentIdWithResponse request returning *GetShipmentItemsByShipmentIdResp
func (c *ClientWithResponses) GetShipmentItemsByShipmentIdWithResponse(ctx context.Context, shipmentId string, params *GetShipmentItemsByShipmentIdParams) (*GetShipmentItemsByShipmentIdResp, error) {
	rsp, err := c.GetShipmentItemsByShipmentId(ctx, shipmentId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetShipmentItemsByShipmentIdResp(rsp)
}

// GetLabelsWithResponse request returning *GetLabelsResp
func (c *ClientWithResponses) GetLabelsWithResponse(ctx context.Context, shipmentId string, params *GetLabelsParams) (*GetLabelsResp, error) {
	rsp, err := c.GetLabels(ctx, shipmentId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetLabelsResp(rsp)
}

// ParseGetPrepInstructionsResp parses an HTTP response from a GetPrepInstructionsWithResponse call
func ParseGetPrepInstructionsResp(rsp *http.Response) (*GetPrepInstructionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrepInstructionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetShipmentItemsResp parses an HTTP response from a GetShipmentItemsWithResponse call
func ParseGetShipmentItemsResp(rsp *http.Response) (*GetShipmentItemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShipmentItemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetShipmentsResp parses an HTTP response from a GetShipmentsWithResponse call
func ParseGetShipmentsResp(rsp *http.Response) (*GetShipmentsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShipmentsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetBillOfLadingResp parses an HTTP response from a GetBillOfLadingWithResponse call
func ParseGetBillOfLadingResp(rsp *http.Response) (*GetBillOfLadingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillOfLadingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetShipmentItemsByShipmentIdResp parses an HTTP response from a GetShipmentItemsByShipmentIdWithResponse call
func ParseGetShipmentItemsByShipmentIdResp(rsp *http.Response) (*GetShipmentItemsByShipmentIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShipmentItemsByShipmentIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetLabelsResp parses an HTTP response from a GetLabelsWithResponse call
func ParseGetLabelsResp(rsp *http.Response) (*GetLabelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
