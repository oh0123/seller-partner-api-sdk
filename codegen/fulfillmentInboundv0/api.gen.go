// Package fulfillmentInboundv0 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.3 DO NOT EDIT.
package fulfillmentInboundv0

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

// Defines values for BarcodeInstruction.
const (
	CanUseOriginalBarcode BarcodeInstruction = "CanUseOriginalBarcode"
	MustProvideSellerSKU  BarcodeInstruction = "MustProvideSellerSKU"
	RequiresFNSKULabel    BarcodeInstruction = "RequiresFNSKULabel"
)

// Defines values for BoxContentsSource.
const (
	BoxContentsSourceFEED        BoxContentsSource = "FEED"
	BoxContentsSourceINTERACTIVE BoxContentsSource = "INTERACTIVE"
	BoxContentsSourceN2DBARCODE  BoxContentsSource = "2D_BARCODE"
	BoxContentsSourceNONE        BoxContentsSource = "NONE"
)

// Defines values for Condition.
const (
	Club                    Condition = "Club"
	CollectibleAcceptable   Condition = "CollectibleAcceptable"
	CollectibleGood         Condition = "CollectibleGood"
	CollectibleLikeNew      Condition = "CollectibleLikeNew"
	CollectiblePoor         Condition = "CollectiblePoor"
	CollectibleVeryGood     Condition = "CollectibleVeryGood"
	NewItem                 Condition = "NewItem"
	NewOEM                  Condition = "NewOEM"
	NewOpenBox              Condition = "NewOpenBox"
	NewWithWarranty         Condition = "NewWithWarranty"
	Refurbished             Condition = "Refurbished"
	RefurbishedWithWarranty Condition = "RefurbishedWithWarranty"
	UsedAcceptable          Condition = "UsedAcceptable"
	UsedGood                Condition = "UsedGood"
	UsedLikeNew             Condition = "UsedLikeNew"
	UsedPoor                Condition = "UsedPoor"
	UsedRefurbished         Condition = "UsedRefurbished"
	UsedVeryGood            Condition = "UsedVeryGood"
)

// Defines values for CurrencyCode.
const (
	GBP CurrencyCode = "GBP"
	USD CurrencyCode = "USD"
)

// Defines values for ErrorReason.
const (
	ErrorReasonDoesNotExist ErrorReason = "DoesNotExist"
	ErrorReasonInvalidASIN  ErrorReason = "InvalidASIN"
)

// Defines values for GuidanceReason.
const (
	NoApplicableGuidance GuidanceReason = "NoApplicableGuidance"
	SlowMovingASIN       GuidanceReason = "SlowMovingASIN"
)

// Defines values for InboundGuidance.
const (
	InboundNotRecommended InboundGuidance = "InboundNotRecommended"
	InboundOK             InboundGuidance = "InboundOK"
)

// Defines values for IntendedBoxContentsSource.
const (
	IntendedBoxContentsSourceFEED       IntendedBoxContentsSource = "FEED"
	IntendedBoxContentsSourceN2DBARCODE IntendedBoxContentsSource = "2D_BARCODE"
	IntendedBoxContentsSourceNONE       IntendedBoxContentsSource = "NONE"
)

// Defines values for LabelPrepPreference.
const (
	LabelPrepPreferenceAMAZONLABELONLY      LabelPrepPreference = "AMAZON_LABEL_ONLY"
	LabelPrepPreferenceAMAZONLABELPREFERRED LabelPrepPreference = "AMAZON_LABEL_PREFERRED"
	LabelPrepPreferenceSELLERLABEL          LabelPrepPreference = "SELLER_LABEL"
)

// Defines values for LabelPrepType.
const (
	LabelPrepTypeAMAZONLABEL LabelPrepType = "AMAZON_LABEL"
	LabelPrepTypeNOLABEL     LabelPrepType = "NO_LABEL"
	LabelPrepTypeSELLERLABEL LabelPrepType = "SELLER_LABEL"
)

// Defines values for PackageStatus.
const (
	PackageStatusCHECKEDIN PackageStatus = "CHECKED_IN"
	PackageStatusCLOSED    PackageStatus = "CLOSED"
	PackageStatusDELETED   PackageStatus = "DELETED"
	PackageStatusDELIVERED PackageStatus = "DELIVERED"
	PackageStatusINTRANSIT PackageStatus = "IN_TRANSIT"
	PackageStatusRECEIVING PackageStatus = "RECEIVING"
	PackageStatusSHIPPED   PackageStatus = "SHIPPED"
)

// Defines values for PrepGuidance.
const (
	ConsultHelpDocuments     PrepGuidance = "ConsultHelpDocuments"
	NoAdditionalPrepRequired PrepGuidance = "NoAdditionalPrepRequired"
	SeePrepInstructionsList  PrepGuidance = "SeePrepInstructionsList"
)

// Defines values for PrepInstruction.
const (
	BlackShrinkWrapping   PrepInstruction = "BlackShrinkWrapping"
	BlankStickering       PrepInstruction = "BlankStickering"
	Boxing                PrepInstruction = "Boxing"
	BubbleWrapping        PrepInstruction = "BubbleWrapping"
	CapSealing            PrepInstruction = "CapSealing"
	Debundle              PrepInstruction = "Debundle"
	HangGarment           PrepInstruction = "HangGarment"
	Labeling              PrepInstruction = "Labeling"
	NoPrep                PrepInstruction = "NoPrep"
	Polybagging           PrepInstruction = "Polybagging"
	RemoveFromHanger      PrepInstruction = "RemoveFromHanger"
	SetCreation           PrepInstruction = "SetCreation"
	SetStickering         PrepInstruction = "SetStickering"
	SuffocationStickering PrepInstruction = "SuffocationStickering"
	Taping                PrepInstruction = "Taping"
)

// Defines values for PrepOwner.
const (
	AMAZON PrepOwner = "AMAZON"
	SELLER PrepOwner = "SELLER"
)

// Defines values for SellerFreightClass.
const (
	N100 SellerFreightClass = "100"
	N110 SellerFreightClass = "110"
	N125 SellerFreightClass = "125"
	N150 SellerFreightClass = "150"
	N175 SellerFreightClass = "175"
	N200 SellerFreightClass = "200"
	N250 SellerFreightClass = "250"
	N300 SellerFreightClass = "300"
	N400 SellerFreightClass = "400"
	N50  SellerFreightClass = "50"
	N500 SellerFreightClass = "500"
	N55  SellerFreightClass = "55"
	N60  SellerFreightClass = "60"
	N65  SellerFreightClass = "65"
	N70  SellerFreightClass = "70"
	N775 SellerFreightClass = "77.5"
	N85  SellerFreightClass = "85"
	N925 SellerFreightClass = "92.5"
)

// Defines values for ShipmentStatus.
const (
	ShipmentStatusCANCELLED ShipmentStatus = "CANCELLED"
	ShipmentStatusCHECKEDIN ShipmentStatus = "CHECKED_IN"
	ShipmentStatusCLOSED    ShipmentStatus = "CLOSED"
	ShipmentStatusDELETED   ShipmentStatus = "DELETED"
	ShipmentStatusDELIVERED ShipmentStatus = "DELIVERED"
	ShipmentStatusERROR     ShipmentStatus = "ERROR"
	ShipmentStatusINTRANSIT ShipmentStatus = "IN_TRANSIT"
	ShipmentStatusRECEIVING ShipmentStatus = "RECEIVING"
	ShipmentStatusSHIPPED   ShipmentStatus = "SHIPPED"
	ShipmentStatusWORKING   ShipmentStatus = "WORKING"
)

// Defines values for ShipmentType.
const (
	LTL ShipmentType = "LTL"
	SP  ShipmentType = "SP"
)

// Defines values for TransportStatus.
const (
	TransportStatusCONFIRMED         TransportStatus = "CONFIRMED"
	TransportStatusCONFIRMING        TransportStatus = "CONFIRMING"
	TransportStatusERROR             TransportStatus = "ERROR"
	TransportStatusERRORINVOIDING    TransportStatus = "ERROR_IN_VOIDING"
	TransportStatusERRORONCONFIRMING TransportStatus = "ERROR_ON_CONFIRMING"
	TransportStatusERRORONESTIMATING TransportStatus = "ERROR_ON_ESTIMATING"
	TransportStatusESTIMATED         TransportStatus = "ESTIMATED"
	TransportStatusESTIMATING        TransportStatus = "ESTIMATING"
	TransportStatusVOIDED            TransportStatus = "VOIDED"
	TransportStatusVOIDING           TransportStatus = "VOIDING"
	TransportStatusWORKING           TransportStatus = "WORKING"
)

// Defines values for UnitOfMeasurement.
const (
	Centimeters UnitOfMeasurement = "centimeters"
	Inches      UnitOfMeasurement = "inches"
)

// Defines values for UnitOfWeight.
const (
	Kilograms UnitOfWeight = "kilograms"
	Pounds    UnitOfWeight = "pounds"
)

// Defines values for GetShipmentItemsParamsQueryType.
const (
	GetShipmentItemsParamsQueryTypeDATERANGE GetShipmentItemsParamsQueryType = "DATE_RANGE"
	GetShipmentItemsParamsQueryTypeNEXTTOKEN GetShipmentItemsParamsQueryType = "NEXT_TOKEN"
)

// Defines values for GetShipmentsParamsShipmentStatusList.
const (
	GetShipmentsParamsShipmentStatusListCANCELLED   GetShipmentsParamsShipmentStatusList = "CANCELLED"
	GetShipmentsParamsShipmentStatusListCHECKEDIN   GetShipmentsParamsShipmentStatusList = "CHECKED_IN"
	GetShipmentsParamsShipmentStatusListCLOSED      GetShipmentsParamsShipmentStatusList = "CLOSED"
	GetShipmentsParamsShipmentStatusListDELETED     GetShipmentsParamsShipmentStatusList = "DELETED"
	GetShipmentsParamsShipmentStatusListDELIVERED   GetShipmentsParamsShipmentStatusList = "DELIVERED"
	GetShipmentsParamsShipmentStatusListERROR       GetShipmentsParamsShipmentStatusList = "ERROR"
	GetShipmentsParamsShipmentStatusListINTRANSIT   GetShipmentsParamsShipmentStatusList = "IN_TRANSIT"
	GetShipmentsParamsShipmentStatusListREADYTOSHIP GetShipmentsParamsShipmentStatusList = "READY_TO_SHIP"
	GetShipmentsParamsShipmentStatusListRECEIVING   GetShipmentsParamsShipmentStatusList = "RECEIVING"
	GetShipmentsParamsShipmentStatusListSHIPPED     GetShipmentsParamsShipmentStatusList = "SHIPPED"
	GetShipmentsParamsShipmentStatusListWORKING     GetShipmentsParamsShipmentStatusList = "WORKING"
)

// Defines values for GetShipmentsParamsQueryType.
const (
	GetShipmentsParamsQueryTypeDATERANGE GetShipmentsParamsQueryType = "DATE_RANGE"
	GetShipmentsParamsQueryTypeNEXTTOKEN GetShipmentsParamsQueryType = "NEXT_TOKEN"
	GetShipmentsParamsQueryTypeSHIPMENT  GetShipmentsParamsQueryType = "SHIPMENT"
)

// Defines values for GetLabelsParamsPageType.
const (
	PackageLabelA42                      GetLabelsParamsPageType = "PackageLabel_A4_2"
	PackageLabelA44                      GetLabelsParamsPageType = "PackageLabel_A4_4"
	PackageLabelLetter2                  GetLabelsParamsPageType = "PackageLabel_Letter_2"
	PackageLabelLetter4                  GetLabelsParamsPageType = "PackageLabel_Letter_4"
	PackageLabelLetter6                  GetLabelsParamsPageType = "PackageLabel_Letter_6"
	PackageLabelLetter6CarrierLeft       GetLabelsParamsPageType = "PackageLabel_Letter_6_CarrierLeft"
	PackageLabelPlainPaper               GetLabelsParamsPageType = "PackageLabel_Plain_Paper"
	PackageLabelPlainPaperCarrierBottom  GetLabelsParamsPageType = "PackageLabel_Plain_Paper_CarrierBottom"
	PackageLabelThermal                  GetLabelsParamsPageType = "PackageLabel_Thermal"
	PackageLabelThermalNoCarrierRotation GetLabelsParamsPageType = "PackageLabel_Thermal_No_Carrier_Rotation"
	PackageLabelThermalNonPCP            GetLabelsParamsPageType = "PackageLabel_Thermal_NonPCP"
	PackageLabelThermalUnified           GetLabelsParamsPageType = "PackageLabel_Thermal_Unified"
)

// Defines values for GetLabelsParamsLabelType.
const (
	BARCODE2D GetLabelsParamsLabelType = "BARCODE_2D"
	PALLET    GetLabelsParamsLabelType = "PALLET"
	UNIQUE    GetLabelsParamsLabelType = "UNIQUE"
)

// ASINInboundGuidance Reasons why a given ASIN is not recommended for shipment to Amazon's fulfillment network.
type ASINInboundGuidance struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN string `json:"ASIN"`

	// GuidanceReasonList A list of inbound guidance reason information.
	GuidanceReasonList *GuidanceReasonList `json:"GuidanceReasonList,omitempty"`

	// InboundGuidance Specific inbound guidance for an item.
	InboundGuidance InboundGuidance `json:"InboundGuidance"`
}

// ASINInboundGuidanceList A list of ASINs and their associated inbound guidance.
type ASINInboundGuidanceList = []ASINInboundGuidance

// ASINPrepInstructions Item preparation instructions to help with item sourcing decisions.
type ASINPrepInstructions struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN *string `json:"ASIN,omitempty"`

	// BarcodeInstruction Labeling requirements for the item. For more information about FBA labeling requirements, see the Seller Central Help for your marketplace.
	BarcodeInstruction *BarcodeInstruction `json:"BarcodeInstruction,omitempty"`

	// PrepGuidance Item preparation instructions.
	PrepGuidance *PrepGuidance `json:"PrepGuidance,omitempty"`

	// PrepInstructionList A list of preparation instructions to help with item sourcing decisions.
	PrepInstructionList *PrepInstructionList `json:"PrepInstructionList,omitempty"`
}

// ASINPrepInstructionsList A list of item preparation instructions.
type ASINPrepInstructionsList = []ASINPrepInstructions

// Address defines model for Address.
type Address struct {
	// AddressLine1 The street address information.
	AddressLine1 string `json:"AddressLine1"`

	// AddressLine2 Additional street address information, if required.
	AddressLine2 *string `json:"AddressLine2,omitempty"`

	// City The city.
	City string `json:"City"`

	// CountryCode The country code in two-character ISO 3166-1 alpha-2 format.
	CountryCode string `json:"CountryCode"`

	// DistrictOrCounty The district or county.
	DistrictOrCounty *string `json:"DistrictOrCounty,omitempty"`

	// Name Name of the individual or business.
	Name string `json:"Name"`

	// PostalCode The postal code.
	//
	// If postal codes are used in your marketplace, we recommended that you include one with your request. This helps Amazon select the most appropriate Amazon fulfillment center for the inbound shipment plan.
	PostalCode string `json:"PostalCode"`

	// StateOrProvinceCode The state or province code.
	//
	// If state or province codes are used in your marketplace, it is recommended that you include one with your request. This helps Amazon to select the most appropriate Amazon fulfillment center for your inbound shipment plan.
	StateOrProvinceCode string `json:"StateOrProvinceCode"`
}

// AmazonPrepFeesDetails The fees for Amazon to prep goods for shipment.
type AmazonPrepFeesDetails struct {
	// FeePerUnit The monetary value.
	FeePerUnit *Amount `json:"FeePerUnit,omitempty"`

	// PrepInstruction Preparation instructions for shipping an item to Amazon's fulfillment network. For more information about preparing items for shipment to Amazon's fulfillment network, see the Seller Central Help for your marketplace.
	PrepInstruction *PrepInstruction `json:"PrepInstruction,omitempty"`
}

// AmazonPrepFeesDetailsList A list of preparation instructions and fees for Amazon to prep goods for shipment.
type AmazonPrepFeesDetailsList = []AmazonPrepFeesDetails

// Amount The monetary value.
type Amount struct {
	// CurrencyCode The currency code.
	CurrencyCode CurrencyCode   `json:"CurrencyCode"`
	Value        BigDecimalType `json:"Value"`
}

// BarcodeInstruction Labeling requirements for the item. For more information about FBA labeling requirements, see the Seller Central Help for your marketplace.
type BarcodeInstruction string

// BigDecimalType defines model for BigDecimalType.
type BigDecimalType = float64

// BillOfLadingDownloadURL defines model for BillOfLadingDownloadURL.
type BillOfLadingDownloadURL struct {
	// DownloadURL URL to download the bill of lading for the package. Note: The URL will only be valid for 15 seconds
	DownloadURL *string `json:"DownloadURL,omitempty"`
}

// BoxContentsFeeDetails The manual processing fee per unit and total fee for a shipment.
type BoxContentsFeeDetails struct {
	// FeePerUnit The monetary value.
	FeePerUnit *Amount `json:"FeePerUnit,omitempty"`

	// TotalFee The monetary value.
	TotalFee *Amount `json:"TotalFee,omitempty"`

	// TotalUnits The item quantity.
	TotalUnits *Quantity `json:"TotalUnits,omitempty"`
}

// BoxContentsSource Where the seller provided box contents information for a shipment.
type BoxContentsSource string

// CommonTransportResult defines model for CommonTransportResult.
type CommonTransportResult struct {
	// TransportResult The workflow status for a shipment with an Amazon-partnered carrier.
	TransportResult *TransportResult `json:"TransportResult,omitempty"`
}

// Condition The condition of the item.
type Condition string

// ConfirmPreorderResponse The response schema for the confirmPreorder operation.
type ConfirmPreorderResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList             `json:"errors,omitempty"`
	Payload *ConfirmPreorderResult `json:"payload,omitempty"`
}

// ConfirmPreorderResult defines model for ConfirmPreorderResult.
type ConfirmPreorderResult struct {
	ConfirmedFulfillableDate *DateStringType `json:"ConfirmedFulfillableDate,omitempty"`
	ConfirmedNeedByDate      *DateStringType `json:"ConfirmedNeedByDate,omitempty"`
}

// ConfirmTransportResponse The response schema for the confirmTransport operation.
type ConfirmTransportResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList             `json:"errors,omitempty"`
	Payload *CommonTransportResult `json:"payload,omitempty"`
}

// Contact Contact information for the person in the seller's organization who is responsible for a Less Than Truckload/Full Truckload (LTL/FTL) shipment.
type Contact struct {
	// Email The email address of the contact person.
	Email string `json:"Email"`

	// Fax The fax number of the contact person.
	Fax *string `json:"Fax,omitempty"`

	// Name The name of the contact person.
	Name string `json:"Name"`

	// Phone The phone number of the contact person.
	Phone string `json:"Phone"`
}

// CreateInboundShipmentPlanRequest The request schema for the createInboundShipmentPlan operation.
type CreateInboundShipmentPlanRequest struct {
	InboundShipmentPlanRequestItems InboundShipmentPlanRequestItemList `json:"InboundShipmentPlanRequestItems"`

	// LabelPrepPreference The preference for label preparation for an inbound shipment.
	LabelPrepPreference LabelPrepPreference `json:"LabelPrepPreference"`
	ShipFromAddress     Address             `json:"ShipFromAddress"`

	// ShipToCountryCode The two-character country code for the country where the inbound shipment is to be sent.
	//
	// Note: Not required. Specifying both ShipToCountryCode and ShipToCountrySubdivisionCode returns an error.
	//
	//  Values:
	//
	//  ShipToCountryCode values for North America:
	//  * CA – Canada
	//  * MX - Mexico
	//  * US - United States
	//
	// ShipToCountryCode values for MCI sellers in Europe:
	//  * DE – Germany
	//  * ES – Spain
	//  * FR – France
	//  * GB – United Kingdom
	//  * IT – Italy
	//
	// Default: The country code for the seller's home marketplace.
	ShipToCountryCode *string `json:"ShipToCountryCode,omitempty"`

	// ShipToCountrySubdivisionCode The two-character country code, followed by a dash and then up to three characters that represent the subdivision of the country where the inbound shipment is to be sent. For example, "IN-MH". In full ISO 3166-2 format.
	//
	// Note: Not required. Specifying both ShipToCountryCode and ShipToCountrySubdivisionCode returns an error.
	ShipToCountrySubdivisionCode *string `json:"ShipToCountrySubdivisionCode,omitempty"`
}

// CreateInboundShipmentPlanResponse The response schema for the createInboundShipmentPlan operation.
type CreateInboundShipmentPlanResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList                       `json:"errors,omitempty"`
	Payload *CreateInboundShipmentPlanResult `json:"payload,omitempty"`
}

// CreateInboundShipmentPlanResult defines model for CreateInboundShipmentPlanResult.
type CreateInboundShipmentPlanResult struct {
	// InboundShipmentPlans A list of inbound shipment plan information
	InboundShipmentPlans *InboundShipmentPlanList `json:"InboundShipmentPlans,omitempty"`
}

// CurrencyCode The currency code.
type CurrencyCode string

// DateStringType defines model for DateStringType.
type DateStringType = openapi_types.Date

// Dimensions The dimension values and unit of measurement.
type Dimensions struct {
	Height BigDecimalType `json:"Height"`
	Length BigDecimalType `json:"Length"`

	// Unit Indicates the unit of measurement.
	Unit  UnitOfMeasurement `json:"Unit"`
	Width BigDecimalType    `json:"Width"`
}

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occured.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition in a human-readable form.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// ErrorReason The reason that the ASIN is invalid.
type ErrorReason string

// EstimateTransportResponse The response schema for the estimateTransport operation.
type EstimateTransportResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList             `json:"errors,omitempty"`
	Payload *CommonTransportResult `json:"payload,omitempty"`
}

// GetBillOfLadingResponse The response schema for the getBillOfLading operation.
type GetBillOfLadingResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList               `json:"errors,omitempty"`
	Payload *BillOfLadingDownloadURL `json:"payload,omitempty"`
}

// GetInboundGuidanceResponse The response schema for the getInboundGuidance operation.
type GetInboundGuidanceResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList                `json:"errors,omitempty"`
	Payload *GetInboundGuidanceResult `json:"payload,omitempty"`
}

// GetInboundGuidanceResult defines model for GetInboundGuidanceResult.
type GetInboundGuidanceResult struct {
	// ASINInboundGuidanceList A list of ASINs and their associated inbound guidance.
	ASINInboundGuidanceList *ASINInboundGuidanceList `json:"ASINInboundGuidanceList,omitempty"`

	// InvalidASINList A list of invalid ASIN values and the reasons they are invalid.
	InvalidASINList *InvalidASINList `json:"InvalidASINList,omitempty"`

	// InvalidSKUList A list of invalid SKU values and the reason they are invalid.
	InvalidSKUList *InvalidSKUList `json:"InvalidSKUList,omitempty"`

	// SKUInboundGuidanceList A list of SKU inbound guidance information.
	SKUInboundGuidanceList *SKUInboundGuidanceList `json:"SKUInboundGuidanceList,omitempty"`
}

// GetLabelsResponse The response schema for the getLabels operation.
type GetLabelsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList        `json:"errors,omitempty"`
	Payload *LabelDownloadURL `json:"payload,omitempty"`
}

// GetPreorderInfoResponse The response schema for the getPreorderInfo operation.
type GetPreorderInfoResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList             `json:"errors,omitempty"`
	Payload *GetPreorderInfoResult `json:"payload,omitempty"`
}

// GetPreorderInfoResult defines model for GetPreorderInfoResult.
type GetPreorderInfoResult struct {
	ConfirmedFulfillableDate *DateStringType `json:"ConfirmedFulfillableDate,omitempty"`
	NeedByDate               *DateStringType `json:"NeedByDate,omitempty"`

	// ShipmentConfirmedForPreorder Indicates whether this shipment has been confirmed for pre-order.
	ShipmentConfirmedForPreorder *bool `json:"ShipmentConfirmedForPreorder,omitempty"`

	// ShipmentContainsPreorderableItems Indicates whether the shipment contains items that have been enabled for pre-order. For more information about enabling items for pre-order, see the Seller Central Help.
	ShipmentContainsPreorderableItems *bool `json:"ShipmentContainsPreorderableItems,omitempty"`
}

// GetPrepInstructionsResponse The response schema for the getPrepInstructions operation.
type GetPrepInstructionsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList                 `json:"errors,omitempty"`
	Payload *GetPrepInstructionsResult `json:"payload,omitempty"`
}

// GetPrepInstructionsResult defines model for GetPrepInstructionsResult.
type GetPrepInstructionsResult struct {
	// ASINPrepInstructionsList A list of item preparation instructions.
	ASINPrepInstructionsList *ASINPrepInstructionsList `json:"ASINPrepInstructionsList,omitempty"`

	// InvalidASINList A list of invalid ASIN values and the reasons they are invalid.
	InvalidASINList *InvalidASINList `json:"InvalidASINList,omitempty"`

	// InvalidSKUList A list of invalid SKU values and the reason they are invalid.
	InvalidSKUList *InvalidSKUList `json:"InvalidSKUList,omitempty"`

	// SKUPrepInstructionsList A list of SKU labeling requirements and item preparation instructions.
	SKUPrepInstructionsList *SKUPrepInstructionsList `json:"SKUPrepInstructionsList,omitempty"`
}

// GetShipmentItemsResponse The response schema for the getShipmentItems operation.
type GetShipmentItemsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList              `json:"errors,omitempty"`
	Payload *GetShipmentItemsResult `json:"payload,omitempty"`
}

// GetShipmentItemsResult defines model for GetShipmentItemsResult.
type GetShipmentItemsResult struct {
	// ItemData A list of inbound shipment item information.
	ItemData *InboundShipmentItemList `json:"ItemData,omitempty"`

	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"NextToken,omitempty"`
}

// GetShipmentsResponse The response schema for the getShipments operation.
type GetShipmentsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList          `json:"errors,omitempty"`
	Payload *GetShipmentsResult `json:"payload,omitempty"`
}

// GetShipmentsResult defines model for GetShipmentsResult.
type GetShipmentsResult struct {
	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"NextToken,omitempty"`

	// ShipmentData A list of inbound shipment information.
	ShipmentData *InboundShipmentList `json:"ShipmentData,omitempty"`
}

// GetTransportDetailsResponse The response schema for the getTransportDetails operation.
type GetTransportDetailsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList                 `json:"errors,omitempty"`
	Payload *GetTransportDetailsResult `json:"payload,omitempty"`
}

// GetTransportDetailsResult defines model for GetTransportDetailsResult.
type GetTransportDetailsResult struct {
	// TransportContent Inbound shipment information, including carrier details, shipment status, and the workflow status for a request for shipment with an Amazon-partnered carrier.
	TransportContent *TransportContent `json:"TransportContent,omitempty"`
}

// GuidanceReason A reason for the current inbound guidance for an item.
type GuidanceReason string

// GuidanceReasonList A list of inbound guidance reason information.
type GuidanceReasonList = []GuidanceReason

// InboundGuidance Specific inbound guidance for an item.
type InboundGuidance string

// InboundShipmentHeader Inbound shipment information used to create and update inbound shipments.
type InboundShipmentHeader struct {
	// AreCasesRequired Indicates whether or not an inbound shipment contains case-packed boxes. Note: A shipment must contain either all case-packed boxes or all individually packed boxes.
	//
	// Possible values:
	//
	// true - All boxes in the shipment must be case packed.
	//
	// false - All boxes in the shipment must be individually packed.
	//
	// Note: If AreCasesRequired = true for an inbound shipment, then the value of QuantityInCase must be greater than zero for every item in the shipment. Otherwise the service returns an error.
	AreCasesRequired *bool `json:"AreCasesRequired,omitempty"`

	// DestinationFulfillmentCenterId The identifier for the fulfillment center to which the shipment will be shipped. Get this value from the InboundShipmentPlan object in the response returned by the createInboundShipmentPlan operation.
	DestinationFulfillmentCenterId string `json:"DestinationFulfillmentCenterId"`

	// IntendedBoxContentsSource How the seller intends to provide box contents information for a shipment. Leaving this field blank is equivalent to selecting `NONE`, which will incur a fee if the seller does not provide box contents information.
	IntendedBoxContentsSource *IntendedBoxContentsSource `json:"IntendedBoxContentsSource,omitempty"`

	// LabelPrepPreference The preference for label preparation for an inbound shipment.
	LabelPrepPreference LabelPrepPreference `json:"LabelPrepPreference"`
	ShipFromAddress     Address             `json:"ShipFromAddress"`

	// ShipmentName The name for the shipment. Use a naming convention that helps distinguish between shipments over time, such as the date the shipment was created.
	ShipmentName string `json:"ShipmentName"`

	// ShipmentStatus Indicates the status of the inbound shipment. When used with the createInboundShipment operation, WORKING is the only valid value. When used with the updateInboundShipment operation, possible values are WORKING, SHIPPED or CANCELLED.
	ShipmentStatus ShipmentStatus `json:"ShipmentStatus"`
}

// InboundShipmentInfo Information about the seller's inbound shipments. Returned by the listInboundShipments operation.
type InboundShipmentInfo struct {
	// AreCasesRequired Indicates whether or not an inbound shipment contains case-packed boxes. When AreCasesRequired = true for an inbound shipment, all items in the inbound shipment must be case packed.
	AreCasesRequired bool `json:"AreCasesRequired"`

	// BoxContentsSource Where the seller provided box contents information for a shipment.
	BoxContentsSource   *BoxContentsSource `json:"BoxContentsSource,omitempty"`
	ConfirmedNeedByDate *DateStringType    `json:"ConfirmedNeedByDate,omitempty"`

	// DestinationFulfillmentCenterId An Amazon fulfillment center identifier created by Amazon.
	DestinationFulfillmentCenterId *string `json:"DestinationFulfillmentCenterId,omitempty"`

	// EstimatedBoxContentsFee The manual processing fee per unit and total fee for a shipment.
	EstimatedBoxContentsFee *BoxContentsFeeDetails `json:"EstimatedBoxContentsFee,omitempty"`

	// LabelPrepType The type of label preparation that is required for the inbound shipment.
	LabelPrepType   *LabelPrepType `json:"LabelPrepType,omitempty"`
	ShipFromAddress Address        `json:"ShipFromAddress"`

	// ShipmentId The shipment identifier submitted in the request.
	ShipmentId *string `json:"ShipmentId,omitempty"`

	// ShipmentName The name for the inbound shipment.
	ShipmentName *string `json:"ShipmentName,omitempty"`

	// ShipmentStatus Indicates the status of the inbound shipment. When used with the createInboundShipment operation, WORKING is the only valid value. When used with the updateInboundShipment operation, possible values are WORKING, SHIPPED or CANCELLED.
	ShipmentStatus *ShipmentStatus `json:"ShipmentStatus,omitempty"`
}

// InboundShipmentItem Item information for an inbound shipment. Submitted with a call to the createInboundShipment or updateInboundShipment operation.
type InboundShipmentItem struct {
	// FulfillmentNetworkSKU Amazon's fulfillment network SKU of the item.
	FulfillmentNetworkSKU *string `json:"FulfillmentNetworkSKU,omitempty"`

	// PrepDetailsList A list of preparation instructions and who is responsible for that preparation.
	PrepDetailsList *PrepDetailsList `json:"PrepDetailsList,omitempty"`

	// QuantityInCase The item quantity.
	QuantityInCase *Quantity `json:"QuantityInCase,omitempty"`

	// QuantityReceived The item quantity.
	QuantityReceived *Quantity `json:"QuantityReceived,omitempty"`

	// QuantityShipped The item quantity.
	QuantityShipped Quantity        `json:"QuantityShipped"`
	ReleaseDate     *DateStringType `json:"ReleaseDate,omitempty"`

	// SellerSKU The seller SKU of the item.
	SellerSKU string `json:"SellerSKU"`

	// ShipmentId A shipment identifier originally returned by the createInboundShipmentPlan operation.
	ShipmentId *string `json:"ShipmentId,omitempty"`
}

// InboundShipmentItemList A list of inbound shipment item information.
type InboundShipmentItemList = []InboundShipmentItem

// InboundShipmentList A list of inbound shipment information.
type InboundShipmentList = []InboundShipmentInfo

// InboundShipmentPlan Inbound shipment information used to create an inbound shipment. Returned by the createInboundShipmentPlan operation.
type InboundShipmentPlan struct {
	// DestinationFulfillmentCenterId An Amazon fulfillment center identifier created by Amazon.
	DestinationFulfillmentCenterId string `json:"DestinationFulfillmentCenterId"`

	// EstimatedBoxContentsFee The manual processing fee per unit and total fee for a shipment.
	EstimatedBoxContentsFee *BoxContentsFeeDetails `json:"EstimatedBoxContentsFee,omitempty"`

	// Items A list of inbound shipment plan item information.
	Items InboundShipmentPlanItemList `json:"Items"`

	// LabelPrepType The type of label preparation that is required for the inbound shipment.
	LabelPrepType LabelPrepType `json:"LabelPrepType"`
	ShipToAddress Address       `json:"ShipToAddress"`

	// ShipmentId A shipment identifier originally returned by the createInboundShipmentPlan operation.
	ShipmentId string `json:"ShipmentId"`
}

// InboundShipmentPlanItem Item information used to create an inbound shipment. Returned by the createInboundShipmentPlan operation.
type InboundShipmentPlanItem struct {
	// FulfillmentNetworkSKU Amazon's fulfillment network SKU of the item.
	FulfillmentNetworkSKU string `json:"FulfillmentNetworkSKU"`

	// PrepDetailsList A list of preparation instructions and who is responsible for that preparation.
	PrepDetailsList *PrepDetailsList `json:"PrepDetailsList,omitempty"`

	// Quantity The item quantity.
	Quantity Quantity `json:"Quantity"`

	// SellerSKU The seller SKU of the item.
	SellerSKU string `json:"SellerSKU"`
}

// InboundShipmentPlanItemList A list of inbound shipment plan item information.
type InboundShipmentPlanItemList = []InboundShipmentPlanItem

// InboundShipmentPlanList A list of inbound shipment plan information
type InboundShipmentPlanList = []InboundShipmentPlan

// InboundShipmentPlanRequestItem Item information for creating an inbound shipment plan. Submitted with a call to the createInboundShipmentPlan operation.
type InboundShipmentPlanRequestItem struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN string `json:"ASIN"`

	// Condition The condition of the item.
	Condition Condition `json:"Condition"`

	// PrepDetailsList A list of preparation instructions and who is responsible for that preparation.
	PrepDetailsList *PrepDetailsList `json:"PrepDetailsList,omitempty"`

	// Quantity The item quantity.
	Quantity Quantity `json:"Quantity"`

	// QuantityInCase The item quantity.
	QuantityInCase *Quantity `json:"QuantityInCase,omitempty"`

	// SellerSKU The seller SKU of the item.
	SellerSKU string `json:"SellerSKU"`
}

// InboundShipmentPlanRequestItemList defines model for InboundShipmentPlanRequestItemList.
type InboundShipmentPlanRequestItemList = []InboundShipmentPlanRequestItem

// InboundShipmentRequest The request schema for an inbound shipment.
type InboundShipmentRequest struct {
	// InboundShipmentHeader Inbound shipment information used to create and update inbound shipments.
	InboundShipmentHeader InboundShipmentHeader `json:"InboundShipmentHeader"`

	// InboundShipmentItems A list of inbound shipment item information.
	InboundShipmentItems InboundShipmentItemList `json:"InboundShipmentItems"`

	// MarketplaceId A marketplace identifier. Specifies the marketplace where the product would be stored.
	MarketplaceId string `json:"MarketplaceId"`
}

// InboundShipmentResponse The response schema for this operation.
type InboundShipmentResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList             `json:"errors,omitempty"`
	Payload *InboundShipmentResult `json:"payload,omitempty"`
}

// InboundShipmentResult defines model for InboundShipmentResult.
type InboundShipmentResult struct {
	// ShipmentId The shipment identifier submitted in the request.
	ShipmentId string `json:"ShipmentId"`
}

// IntendedBoxContentsSource How the seller intends to provide box contents information for a shipment. Leaving this field blank is equivalent to selecting `NONE`, which will incur a fee if the seller does not provide box contents information.
type IntendedBoxContentsSource string

// InvalidASIN defines model for InvalidASIN.
type InvalidASIN struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN *string `json:"ASIN,omitempty"`

	// ErrorReason The reason that the ASIN is invalid.
	ErrorReason *ErrorReason `json:"ErrorReason,omitempty"`
}

// InvalidASINList A list of invalid ASIN values and the reasons they are invalid.
type InvalidASINList = []InvalidASIN

// InvalidSKU defines model for InvalidSKU.
type InvalidSKU struct {
	// ErrorReason The reason that the ASIN is invalid.
	ErrorReason *ErrorReason `json:"ErrorReason,omitempty"`

	// SellerSKU The seller SKU of the item.
	SellerSKU *string `json:"SellerSKU,omitempty"`
}

// InvalidSKUList A list of invalid SKU values and the reason they are invalid.
type InvalidSKUList = []InvalidSKU

// LabelDownloadURL defines model for LabelDownloadURL.
type LabelDownloadURL struct {
	// DownloadURL URL to download the label for the package. Note: The URL will only be valid for 15 seconds
	DownloadURL *string `json:"DownloadURL,omitempty"`
}

// LabelPrepPreference The preference for label preparation for an inbound shipment.
type LabelPrepPreference string

// LabelPrepType The type of label preparation that is required for the inbound shipment.
type LabelPrepType string

// NonPartneredLtlDataInput Information that you provide to Amazon about a Less Than Truckload/Full Truckload (LTL/FTL) shipment by a carrier that has not partnered with Amazon.
type NonPartneredLtlDataInput struct {
	// CarrierName The carrier that you are using for the inbound shipment.
	CarrierName string `json:"CarrierName"`

	// ProNumber The PRO number ("progressive number" or "progressive ID") assigned to the shipment by the carrier.
	ProNumber ProNumber `json:"ProNumber"`
}

// NonPartneredLtlDataOutput Information returned by Amazon about a Less Than Truckload/Full Truckload (LTL/FTL) shipment shipped by a carrier that has not partnered with Amazon.
type NonPartneredLtlDataOutput struct {
	// CarrierName The carrier that you are using for the inbound shipment.
	CarrierName string `json:"CarrierName"`

	// ProNumber The PRO number ("progressive number" or "progressive ID") assigned to the shipment by the carrier.
	ProNumber ProNumber `json:"ProNumber"`
}

// NonPartneredSmallParcelDataInput Information that you provide to Amazon about a Small Parcel shipment shipped by a carrier that has not partnered with Amazon.
type NonPartneredSmallParcelDataInput struct {
	// CarrierName The carrier that you are using for the inbound shipment.
	CarrierName string `json:"CarrierName"`

	// PackageList A list of package tracking information.
	PackageList NonPartneredSmallParcelPackageInputList `json:"PackageList"`
}

// NonPartneredSmallParcelDataOutput Information returned by Amazon about a Small Parcel shipment by a carrier that has not partnered with Amazon.
type NonPartneredSmallParcelDataOutput struct {
	// PackageList A list of packages, including carrier, tracking number, and status information for each package.
	PackageList NonPartneredSmallParcelPackageOutputList `json:"PackageList"`
}

// NonPartneredSmallParcelPackageInput The tracking number of the package, provided by the carrier.
type NonPartneredSmallParcelPackageInput struct {
	// TrackingId The tracking number of the package, provided by the carrier.
	TrackingId TrackingId `json:"TrackingId"`
}

// NonPartneredSmallParcelPackageInputList A list of package tracking information.
type NonPartneredSmallParcelPackageInputList = []NonPartneredSmallParcelPackageInput

// NonPartneredSmallParcelPackageOutput Carrier, tracking number, and status information for the package.
type NonPartneredSmallParcelPackageOutput struct {
	// CarrierName The carrier that you are using for the inbound shipment.
	CarrierName string `json:"CarrierName"`

	// PackageStatus The shipment status of the package.
	PackageStatus PackageStatus `json:"PackageStatus"`

	// TrackingId The tracking number of the package, provided by the carrier.
	TrackingId TrackingId `json:"TrackingId"`
}

// NonPartneredSmallParcelPackageOutputList A list of packages, including carrier, tracking number, and status information for each package.
type NonPartneredSmallParcelPackageOutputList = []NonPartneredSmallParcelPackageOutput

// PackageStatus The shipment status of the package.
type PackageStatus string

// Pallet Pallet information.
type Pallet struct {
	// Dimensions The dimension values and unit of measurement.
	Dimensions Dimensions `json:"Dimensions"`

	// IsStacked Indicates whether pallets will be stacked when carrier arrives for pick-up.
	IsStacked bool `json:"IsStacked"`

	// Weight The weight of the package.
	Weight *Weight `json:"Weight,omitempty"`
}

// PalletList A list of pallet information.
type PalletList = []Pallet

// PartneredEstimate The estimated shipping cost for a shipment using an Amazon-partnered carrier.
type PartneredEstimate struct {
	// Amount The monetary value.
	Amount          Amount               `json:"Amount"`
	ConfirmDeadline *TimeStampStringType `json:"ConfirmDeadline,omitempty"`
	VoidDeadline    *TimeStampStringType `json:"VoidDeadline,omitempty"`
}

// PartneredLtlDataInput Information that is required by an Amazon-partnered carrier to ship a Less Than Truckload/Full Truckload (LTL/FTL) inbound shipment.
type PartneredLtlDataInput struct {
	BoxCount *UnsignedIntType `json:"BoxCount,omitempty"`

	// Contact Contact information for the person in the seller's organization who is responsible for a Less Than Truckload/Full Truckload (LTL/FTL) shipment.
	Contact          *Contact        `json:"Contact,omitempty"`
	FreightReadyDate *DateStringType `json:"FreightReadyDate,omitempty"`

	// PalletList A list of pallet information.
	PalletList *PalletList `json:"PalletList,omitempty"`

	// SellerDeclaredValue The monetary value.
	SellerDeclaredValue *Amount `json:"SellerDeclaredValue,omitempty"`

	// SellerFreightClass The freight class of the shipment. For information about determining the freight class, contact the carrier.
	SellerFreightClass *SellerFreightClass `json:"SellerFreightClass,omitempty"`

	// TotalWeight The weight of the package.
	TotalWeight *Weight `json:"TotalWeight,omitempty"`
}

// PartneredLtlDataOutput Information returned by Amazon about a Less Than Truckload/Full Truckload (LTL/FTL) shipment by an Amazon-partnered carrier.
type PartneredLtlDataOutput struct {
	// AmazonCalculatedValue The monetary value.
	AmazonCalculatedValue *Amount `json:"AmazonCalculatedValue,omitempty"`

	// AmazonReferenceId A unique identifier created by Amazon that identifies this Amazon-partnered, Less Than Truckload/Full Truckload (LTL/FTL) shipment.
	AmazonReferenceId string          `json:"AmazonReferenceId"`
	BoxCount          UnsignedIntType `json:"BoxCount"`

	// CarrierName The carrier for the inbound shipment.
	CarrierName string `json:"CarrierName"`

	// Contact Contact information for the person in the seller's organization who is responsible for a Less Than Truckload/Full Truckload (LTL/FTL) shipment.
	Contact          Contact        `json:"Contact"`
	FreightReadyDate DateStringType `json:"FreightReadyDate"`

	// IsBillOfLadingAvailable Indicates whether the bill of lading for the shipment is available.
	IsBillOfLadingAvailable bool `json:"IsBillOfLadingAvailable"`

	// PalletList A list of pallet information.
	PalletList PalletList `json:"PalletList"`

	// PartneredEstimate The estimated shipping cost for a shipment using an Amazon-partnered carrier.
	PartneredEstimate   *PartneredEstimate `json:"PartneredEstimate,omitempty"`
	PreviewDeliveryDate DateStringType     `json:"PreviewDeliveryDate"`

	// PreviewFreightClass The freight class of the shipment. For information about determining the freight class, contact the carrier.
	PreviewFreightClass SellerFreightClass `json:"PreviewFreightClass"`
	PreviewPickupDate   DateStringType     `json:"PreviewPickupDate"`

	// SellerDeclaredValue The monetary value.
	SellerDeclaredValue *Amount `json:"SellerDeclaredValue,omitempty"`

	// SellerFreightClass The freight class of the shipment. For information about determining the freight class, contact the carrier.
	SellerFreightClass *SellerFreightClass `json:"SellerFreightClass,omitempty"`

	// TotalWeight The weight of the package.
	TotalWeight Weight `json:"TotalWeight"`
}

// PartneredSmallParcelDataInput Information that is required by an Amazon-partnered carrier to ship a Small Parcel inbound shipment.
type PartneredSmallParcelDataInput struct {
	// CarrierName The Amazon-partnered carrier to use for the inbound shipment. **`CarrierName`** values in France (FR), Italy (IT), Spain (ES), the United Kingdom (UK), and the United States (US): `UNITED_PARCEL_SERVICE_INC`. <br> **`CarrierName`** values in Germany (DE): `DHL_STANDARD`,`UNITED_PARCEL_SERVICE_INC`. <br>Default: `UNITED_PARCEL_SERVICE_INC`.
	CarrierName *string `json:"CarrierName,omitempty"`

	// PackageList A list of dimensions and weight information for packages.
	PackageList *PartneredSmallParcelPackageInputList `json:"PackageList,omitempty"`
}

// PartneredSmallParcelDataOutput Information returned by Amazon about a Small Parcel shipment by an Amazon-partnered carrier.
type PartneredSmallParcelDataOutput struct {
	// PackageList A list of packages, including shipping information from the Amazon-partnered carrier.
	PackageList PartneredSmallParcelPackageOutputList `json:"PackageList"`

	// PartneredEstimate The estimated shipping cost for a shipment using an Amazon-partnered carrier.
	PartneredEstimate *PartneredEstimate `json:"PartneredEstimate,omitempty"`
}

// PartneredSmallParcelPackageInput Dimension and weight information for the package.
type PartneredSmallParcelPackageInput struct {
	// Dimensions The dimension values and unit of measurement.
	Dimensions Dimensions `json:"Dimensions"`

	// Weight The weight of the package.
	Weight Weight `json:"Weight"`
}

// PartneredSmallParcelPackageInputList A list of dimensions and weight information for packages.
type PartneredSmallParcelPackageInputList = []PartneredSmallParcelPackageInput

// PartneredSmallParcelPackageOutput Dimension, weight, and shipping information for the package.
type PartneredSmallParcelPackageOutput struct {
	// CarrierName The carrier specified with a previous call to putTransportDetails.
	CarrierName string `json:"CarrierName"`

	// Dimensions The dimension values and unit of measurement.
	Dimensions Dimensions `json:"Dimensions"`

	// PackageStatus The shipment status of the package.
	PackageStatus PackageStatus `json:"PackageStatus"`

	// TrackingId The tracking number of the package, provided by the carrier.
	TrackingId TrackingId `json:"TrackingId"`

	// Weight The weight of the package.
	Weight Weight `json:"Weight"`
}

// PartneredSmallParcelPackageOutputList A list of packages, including shipping information from the Amazon-partnered carrier.
type PartneredSmallParcelPackageOutputList = []PartneredSmallParcelPackageOutput

// PrepDetails Preparation instructions and who is responsible for the preparation.
type PrepDetails struct {
	// PrepInstruction Preparation instructions for shipping an item to Amazon's fulfillment network. For more information about preparing items for shipment to Amazon's fulfillment network, see the Seller Central Help for your marketplace.
	PrepInstruction PrepInstruction `json:"PrepInstruction"`

	// PrepOwner Indicates who will prepare the item.
	PrepOwner PrepOwner `json:"PrepOwner"`
}

// PrepDetailsList A list of preparation instructions and who is responsible for that preparation.
type PrepDetailsList = []PrepDetails

// PrepGuidance Item preparation instructions.
type PrepGuidance string

// PrepInstruction Preparation instructions for shipping an item to Amazon's fulfillment network. For more information about preparing items for shipment to Amazon's fulfillment network, see the Seller Central Help for your marketplace.
type PrepInstruction string

// PrepInstructionList A list of preparation instructions to help with item sourcing decisions.
type PrepInstructionList = []PrepInstruction

// PrepOwner Indicates who will prepare the item.
type PrepOwner string

// ProNumber The PRO number ("progressive number" or "progressive ID") assigned to the shipment by the carrier.
type ProNumber = string

// PutTransportDetailsRequest The request schema for a putTransportDetails operation.
type PutTransportDetailsRequest struct {
	// IsPartnered Indicates whether a putTransportDetails request is for an Amazon-partnered carrier.
	IsPartnered bool `json:"IsPartnered"`

	// ShipmentType Specifies the carrier shipment type in a putTransportDetails request.
	ShipmentType ShipmentType `json:"ShipmentType"`

	// TransportDetails Information required to create an Amazon-partnered carrier shipping estimate, or to alert the Amazon fulfillment center to the arrival of an inbound shipment by a non-Amazon-partnered carrier.
	TransportDetails TransportDetailInput `json:"TransportDetails"`
}

// PutTransportDetailsResponse Workflow status for a shipment with an Amazon-partnered carrier.
type PutTransportDetailsResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList             `json:"errors,omitempty"`
	Payload *CommonTransportResult `json:"payload,omitempty"`
}

// Quantity The item quantity.
type Quantity = int32

// SKUInboundGuidance Reasons why a given seller SKU is not recommended for shipment to Amazon's fulfillment network.
type SKUInboundGuidance struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN string `json:"ASIN"`

	// GuidanceReasonList A list of inbound guidance reason information.
	GuidanceReasonList *GuidanceReasonList `json:"GuidanceReasonList,omitempty"`

	// InboundGuidance Specific inbound guidance for an item.
	InboundGuidance InboundGuidance `json:"InboundGuidance"`

	// SellerSKU The seller SKU of the item.
	SellerSKU string `json:"SellerSKU"`
}

// SKUInboundGuidanceList A list of SKU inbound guidance information.
type SKUInboundGuidanceList = []SKUInboundGuidance

// SKUPrepInstructions Labeling requirements and item preparation instructions to help you prepare items for shipment to Amazon's fulfillment network.
type SKUPrepInstructions struct {
	// ASIN The Amazon Standard Identification Number (ASIN) of the item.
	ASIN *string `json:"ASIN,omitempty"`

	// AmazonPrepFeesDetailsList A list of preparation instructions and fees for Amazon to prep goods for shipment.
	AmazonPrepFeesDetailsList *AmazonPrepFeesDetailsList `json:"AmazonPrepFeesDetailsList,omitempty"`

	// BarcodeInstruction Labeling requirements for the item. For more information about FBA labeling requirements, see the Seller Central Help for your marketplace.
	BarcodeInstruction *BarcodeInstruction `json:"BarcodeInstruction,omitempty"`

	// PrepGuidance Item preparation instructions.
	PrepGuidance *PrepGuidance `json:"PrepGuidance,omitempty"`

	// PrepInstructionList A list of preparation instructions to help with item sourcing decisions.
	PrepInstructionList *PrepInstructionList `json:"PrepInstructionList,omitempty"`

	// SellerSKU The seller SKU of the item.
	SellerSKU *string `json:"SellerSKU,omitempty"`
}

// SKUPrepInstructionsList A list of SKU labeling requirements and item preparation instructions.
type SKUPrepInstructionsList = []SKUPrepInstructions

// SellerFreightClass The freight class of the shipment. For information about determining the freight class, contact the carrier.
type SellerFreightClass string

// ShipmentStatus Indicates the status of the inbound shipment. When used with the createInboundShipment operation, WORKING is the only valid value. When used with the updateInboundShipment operation, possible values are WORKING, SHIPPED or CANCELLED.
type ShipmentStatus string

// ShipmentType Specifies the carrier shipment type in a putTransportDetails request.
type ShipmentType string

// TimeStampStringType defines model for TimeStampStringType.
type TimeStampStringType = time.Time

// TrackingId The tracking number of the package, provided by the carrier.
type TrackingId = string

// TransportContent Inbound shipment information, including carrier details, shipment status, and the workflow status for a request for shipment with an Amazon-partnered carrier.
type TransportContent struct {
	// TransportDetails Inbound shipment information, including carrier details and shipment status.
	TransportDetails TransportDetailOutput `json:"TransportDetails"`

	// TransportHeader The shipping identifier, information about whether the shipment is by an Amazon-partnered carrier, and information about whether the shipment is Small Parcel or Less Than Truckload/Full Truckload (LTL/FTL).
	TransportHeader TransportHeader `json:"TransportHeader"`

	// TransportResult The workflow status for a shipment with an Amazon-partnered carrier.
	TransportResult TransportResult `json:"TransportResult"`
}

// TransportDetailInput Information required to create an Amazon-partnered carrier shipping estimate, or to alert the Amazon fulfillment center to the arrival of an inbound shipment by a non-Amazon-partnered carrier.
type TransportDetailInput struct {
	// NonPartneredLtlData Information that you provide to Amazon about a Less Than Truckload/Full Truckload (LTL/FTL) shipment by a carrier that has not partnered with Amazon.
	NonPartneredLtlData *NonPartneredLtlDataInput `json:"NonPartneredLtlData,omitempty"`

	// NonPartneredSmallParcelData Information that you provide to Amazon about a Small Parcel shipment shipped by a carrier that has not partnered with Amazon.
	NonPartneredSmallParcelData *NonPartneredSmallParcelDataInput `json:"NonPartneredSmallParcelData,omitempty"`

	// PartneredLtlData Information that is required by an Amazon-partnered carrier to ship a Less Than Truckload/Full Truckload (LTL/FTL) inbound shipment.
	PartneredLtlData *PartneredLtlDataInput `json:"PartneredLtlData,omitempty"`

	// PartneredSmallParcelData Information that is required by an Amazon-partnered carrier to ship a Small Parcel inbound shipment.
	PartneredSmallParcelData *PartneredSmallParcelDataInput `json:"PartneredSmallParcelData,omitempty"`
}

// TransportDetailOutput Inbound shipment information, including carrier details and shipment status.
type TransportDetailOutput struct {
	// NonPartneredLtlData Information returned by Amazon about a Less Than Truckload/Full Truckload (LTL/FTL) shipment shipped by a carrier that has not partnered with Amazon.
	NonPartneredLtlData *NonPartneredLtlDataOutput `json:"NonPartneredLtlData,omitempty"`

	// NonPartneredSmallParcelData Information returned by Amazon about a Small Parcel shipment by a carrier that has not partnered with Amazon.
	NonPartneredSmallParcelData *NonPartneredSmallParcelDataOutput `json:"NonPartneredSmallParcelData,omitempty"`

	// PartneredLtlData Information returned by Amazon about a Less Than Truckload/Full Truckload (LTL/FTL) shipment by an Amazon-partnered carrier.
	PartneredLtlData *PartneredLtlDataOutput `json:"PartneredLtlData,omitempty"`

	// PartneredSmallParcelData Information returned by Amazon about a Small Parcel shipment by an Amazon-partnered carrier.
	PartneredSmallParcelData *PartneredSmallParcelDataOutput `json:"PartneredSmallParcelData,omitempty"`
}

// TransportHeader The shipping identifier, information about whether the shipment is by an Amazon-partnered carrier, and information about whether the shipment is Small Parcel or Less Than Truckload/Full Truckload (LTL/FTL).
type TransportHeader struct {
	// IsPartnered Indicates whether a putTransportDetails request is for a partnered carrier.
	//
	// Possible values:
	//
	// * true – Request is for an Amazon-partnered carrier.
	//
	// * false – Request is for a non-Amazon-partnered carrier.
	IsPartnered bool `json:"IsPartnered"`

	// SellerId The Amazon seller identifier.
	SellerId string `json:"SellerId"`

	// ShipmentId A shipment identifier originally returned by the createInboundShipmentPlan operation.
	ShipmentId string `json:"ShipmentId"`

	// ShipmentType Specifies the carrier shipment type in a putTransportDetails request.
	ShipmentType ShipmentType `json:"ShipmentType"`
}

// TransportResult The workflow status for a shipment with an Amazon-partnered carrier.
type TransportResult struct {
	// ErrorCode An error code that identifies the type of error that occured.
	ErrorCode *string `json:"ErrorCode,omitempty"`

	// ErrorDescription A message that describes the error condition.
	ErrorDescription *string `json:"ErrorDescription,omitempty"`

	// TransportStatus Indicates the status of the Amazon-partnered carrier shipment.
	TransportStatus TransportStatus `json:"TransportStatus"`
}

// TransportStatus Indicates the status of the Amazon-partnered carrier shipment.
type TransportStatus string

// UnitOfMeasurement Indicates the unit of measurement.
type UnitOfMeasurement string

// UnitOfWeight Indicates the unit of weight.
type UnitOfWeight string

// UnsignedIntType defines model for UnsignedIntType.
type UnsignedIntType = int64

// VoidTransportResponse The response schema for the voidTransport operation.
type VoidTransportResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList             `json:"errors,omitempty"`
	Payload *CommonTransportResult `json:"payload,omitempty"`
}

// Weight The weight of the package.
type Weight struct {
	// Unit Indicates the unit of weight.
	Unit  UnitOfWeight   `json:"Unit"`
	Value BigDecimalType `json:"Value"`
}

// GetInboundGuidanceParams defines parameters for GetInboundGuidance.
type GetInboundGuidanceParams struct {
	// MarketplaceId A marketplace identifier. Specifies the marketplace where the product would be stored.
	MarketplaceId string `form:"MarketplaceId" json:"MarketplaceId"`

	// SellerSKUList A list of SellerSKU values. Used to identify items for which you want inbound guidance for shipment to Amazon's fulfillment network. Note: SellerSKU is qualified by the SellerId, which is included with every Selling Partner API operation that you submit. If you specify a SellerSKU that identifies a variation parent ASIN, this operation returns an error. A variation parent ASIN represents a generic product that cannot be sold. Variation child ASINs represent products that have specific characteristics (such as size and color) and can be sold.
	SellerSKUList *[]string `form:"SellerSKUList,omitempty" json:"SellerSKUList,omitempty"`

	// ASINList A list of ASIN values. Used to identify items for which you want inbound guidance for shipment to Amazon's fulfillment network. Note: If you specify a ASIN that identifies a variation parent ASIN, this operation returns an error. A variation parent ASIN represents a generic product that cannot be sold. Variation child ASINs represent products that have specific characteristics (such as size and color) and can be sold.
	ASINList *[]string `form:"ASINList,omitempty" json:"ASINList,omitempty"`
}

// GetPrepInstructionsParams defines parameters for GetPrepInstructions.
type GetPrepInstructionsParams struct {
	// ShipToCountryCode The country code of the country to which the items will be shipped. Note that labeling requirements and item preparation instructions can vary by country.
	ShipToCountryCode string `form:"ShipToCountryCode" json:"ShipToCountryCode"`

	// SellerSKUList A list of SellerSKU values. Used to identify items for which you want labeling requirements and item preparation instructions for shipment to Amazon's fulfillment network. The SellerSKU is qualified by the Seller ID, which is included with every call to the Seller Partner API.
	//
	// Note: Include seller SKUs that you have used to list items on Amazon's retail website. If you include a seller SKU that you have never used to list an item on Amazon's retail website, the seller SKU is returned in the InvalidSKUList property in the response.
	SellerSKUList *[]string `form:"SellerSKUList,omitempty" json:"SellerSKUList,omitempty"`

	// ASINList A list of ASIN values. Used to identify items for which you want item preparation instructions to help with item sourcing decisions.
	//
	// Note: ASINs must be included in the product catalog for at least one of the marketplaces that the seller  participates in. Any ASIN that is not included in the product catalog for at least one of the marketplaces that the seller participates in is returned in the InvalidASINList property in the response. You can find out which marketplaces a seller participates in by calling the getMarketplaceParticipations operation in the Selling Partner API for Sellers.
	ASINList *[]string `form:"ASINList,omitempty" json:"ASINList,omitempty"`
}

// GetShipmentItemsParams defines parameters for GetShipmentItems.
type GetShipmentItemsParams struct {
	// LastUpdatedAfter A date used for selecting inbound shipment items that were last updated after (or at) a specified time. The selection includes updates made by Amazon and by the seller.
	LastUpdatedAfter *time.Time `form:"LastUpdatedAfter,omitempty" json:"LastUpdatedAfter,omitempty"`

	// LastUpdatedBefore A date used for selecting inbound shipment items that were last updated before (or at) a specified time. The selection includes updates made by Amazon and by the seller.
	LastUpdatedBefore *time.Time `form:"LastUpdatedBefore,omitempty" json:"LastUpdatedBefore,omitempty"`

	// QueryType Indicates whether items are returned using a date range (by providing the LastUpdatedAfter and LastUpdatedBefore parameters), or using NextToken, which continues returning items specified in a previous request.
	QueryType GetShipmentItemsParamsQueryType `form:"QueryType" json:"QueryType"`

	// NextToken A string token returned in the response to your previous request.
	NextToken *string `form:"NextToken,omitempty" json:"NextToken,omitempty"`

	// MarketplaceId A marketplace identifier. Specifies the marketplace where the product would be stored.
	MarketplaceId string `form:"MarketplaceId" json:"MarketplaceId"`
}

// GetShipmentItemsParamsQueryType defines parameters for GetShipmentItems.
type GetShipmentItemsParamsQueryType string

// GetShipmentsParams defines parameters for GetShipments.
type GetShipmentsParams struct {
	// ShipmentStatusList A list of ShipmentStatus values. Used to select shipments with a current status that matches the status values that you specify.
	ShipmentStatusList *[]GetShipmentsParamsShipmentStatusList `form:"ShipmentStatusList,omitempty" json:"ShipmentStatusList,omitempty"`

	// ShipmentIdList A list of shipment IDs used to select the shipments that you want. If both ShipmentStatusList and ShipmentIdList are specified, only shipments that match both parameters are returned.
	ShipmentIdList *[]string `form:"ShipmentIdList,omitempty" json:"ShipmentIdList,omitempty"`

	// LastUpdatedAfter A date used for selecting inbound shipments that were last updated after (or at) a specified time. The selection includes updates made by Amazon and by the seller.
	LastUpdatedAfter *time.Time `form:"LastUpdatedAfter,omitempty" json:"LastUpdatedAfter,omitempty"`

	// LastUpdatedBefore A date used for selecting inbound shipments that were last updated before (or at) a specified time. The selection includes updates made by Amazon and by the seller.
	LastUpdatedBefore *time.Time `form:"LastUpdatedBefore,omitempty" json:"LastUpdatedBefore,omitempty"`

	// QueryType Indicates whether shipments are returned using shipment information (by providing the ShipmentStatusList or ShipmentIdList parameters), using a date range (by providing the LastUpdatedAfter and LastUpdatedBefore parameters), or by using NextToken to continue returning items specified in a previous request.
	QueryType GetShipmentsParamsQueryType `form:"QueryType" json:"QueryType"`

	// NextToken A string token returned in the response to your previous request.
	NextToken *string `form:"NextToken,omitempty" json:"NextToken,omitempty"`

	// MarketplaceId A marketplace identifier. Specifies the marketplace where the product would be stored.
	MarketplaceId string `form:"MarketplaceId" json:"MarketplaceId"`
}

// GetShipmentsParamsShipmentStatusList defines parameters for GetShipments.
type GetShipmentsParamsShipmentStatusList string

// GetShipmentsParamsQueryType defines parameters for GetShipments.
type GetShipmentsParamsQueryType string

// GetShipmentItemsByShipmentIdParams defines parameters for GetShipmentItemsByShipmentId.
type GetShipmentItemsByShipmentIdParams struct {
	// MarketplaceId A marketplace identifier. Specifies the marketplace where the product would be stored.
	MarketplaceId string `form:"MarketplaceId" json:"MarketplaceId"`
}

// GetLabelsParams defines parameters for GetLabels.
type GetLabelsParams struct {
	// PageType The page type to use to print the labels. Submitting a PageType value that is not supported in your marketplace returns an error.
	PageType GetLabelsParamsPageType `form:"PageType" json:"PageType"`

	// LabelType The type of labels requested.
	LabelType GetLabelsParamsLabelType `form:"LabelType" json:"LabelType"`

	// NumberOfPackages The number of packages in the shipment.
	NumberOfPackages *int `form:"NumberOfPackages,omitempty" json:"NumberOfPackages,omitempty"`

	// PackageLabelsToPrint A list of identifiers that specify packages for which you want package labels printed.
	//
	// Must match CartonId values previously passed using the FBA Inbound Shipment Carton Information Feed. If not, the operation returns the IncorrectPackageIdentifier error code.
	PackageLabelsToPrint *[]string `form:"PackageLabelsToPrint,omitempty" json:"PackageLabelsToPrint,omitempty"`

	// NumberOfPallets The number of pallets in the shipment. This returns four identical labels for each pallet.
	NumberOfPallets *int `form:"NumberOfPallets,omitempty" json:"NumberOfPallets,omitempty"`

	// PageSize The page size for paginating through the total packages' labels. This is a required parameter for Non-Partnered LTL Shipments. Max value:1000.
	PageSize *int `form:"PageSize,omitempty" json:"PageSize,omitempty"`

	// PageStartIndex The page start index for paginating through the total packages' labels. This is a required parameter for Non-Partnered LTL Shipments.
	PageStartIndex *int `form:"PageStartIndex,omitempty" json:"PageStartIndex,omitempty"`
}

// GetLabelsParamsPageType defines parameters for GetLabels.
type GetLabelsParamsPageType string

// GetLabelsParamsLabelType defines parameters for GetLabels.
type GetLabelsParamsLabelType string

// GetPreorderInfoParams defines parameters for GetPreorderInfo.
type GetPreorderInfoParams struct {
	// MarketplaceId A marketplace identifier. Specifies the marketplace the shipment is tied to.
	MarketplaceId string `form:"MarketplaceId" json:"MarketplaceId"`
}

// ConfirmPreorderParams defines parameters for ConfirmPreorder.
type ConfirmPreorderParams struct {
	// NeedByDate Date that the shipment must arrive at the Amazon fulfillment center to avoid delivery promise breaks for pre-ordered items. Must be in YYYY-MM-DD format. The response to the getPreorderInfo operation returns this value.
	NeedByDate openapi_types.Date `form:"NeedByDate" json:"NeedByDate"`

	// MarketplaceId A marketplace identifier. Specifies the marketplace the shipment is tied to.
	MarketplaceId string `form:"MarketplaceId" json:"MarketplaceId"`
}

// CreateInboundShipmentPlanJSONRequestBody defines body for CreateInboundShipmentPlan for application/json ContentType.
type CreateInboundShipmentPlanJSONRequestBody = CreateInboundShipmentPlanRequest

// CreateInboundShipmentJSONRequestBody defines body for CreateInboundShipment for application/json ContentType.
type CreateInboundShipmentJSONRequestBody = InboundShipmentRequest

// UpdateInboundShipmentJSONRequestBody defines body for UpdateInboundShipment for application/json ContentType.
type UpdateInboundShipmentJSONRequestBody = InboundShipmentRequest

// PutTransportDetailsJSONRequestBody defines body for PutTransportDetails for application/json ContentType.
type PutTransportDetailsJSONRequestBody = PutTransportDetailsRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetInboundGuidance request
	GetInboundGuidance(ctx context.Context, params *GetInboundGuidanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInboundShipmentPlanWithBody request with any body
	CreateInboundShipmentPlanWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInboundShipmentPlan(ctx context.Context, body CreateInboundShipmentPlanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrepInstructions request
	GetPrepInstructions(ctx context.Context, params *GetPrepInstructionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShipmentItems request
	GetShipmentItems(ctx context.Context, params *GetShipmentItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShipments request
	GetShipments(ctx context.Context, params *GetShipmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInboundShipmentWithBody request with any body
	CreateInboundShipmentWithBody(ctx context.Context, shipmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInboundShipment(ctx context.Context, shipmentId string, body CreateInboundShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateInboundShipmentWithBody request with any body
	UpdateInboundShipmentWithBody(ctx context.Context, shipmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInboundShipment(ctx context.Context, shipmentId string, body UpdateInboundShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillOfLading request
	GetBillOfLading(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShipmentItemsByShipmentId request
	GetShipmentItemsByShipmentId(ctx context.Context, shipmentId string, params *GetShipmentItemsByShipmentIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLabels request
	GetLabels(ctx context.Context, shipmentId string, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPreorderInfo request
	GetPreorderInfo(ctx context.Context, shipmentId string, params *GetPreorderInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmPreorder request
	ConfirmPreorder(ctx context.Context, shipmentId string, params *ConfirmPreorderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransportDetails request
	GetTransportDetails(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutTransportDetailsWithBody request with any body
	PutTransportDetailsWithBody(ctx context.Context, shipmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutTransportDetails(ctx context.Context, shipmentId string, body PutTransportDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmTransport request
	ConfirmTransport(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EstimateTransport request
	EstimateTransport(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VoidTransport request
	VoidTransport(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetInboundGuidance(ctx context.Context, params *GetInboundGuidanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInboundGuidanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInboundShipmentPlanWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInboundShipmentPlanRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInboundShipmentPlan(ctx context.Context, body CreateInboundShipmentPlanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInboundShipmentPlanRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrepInstructions(ctx context.Context, params *GetPrepInstructionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrepInstructionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShipmentItems(ctx context.Context, params *GetShipmentItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShipmentItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShipments(ctx context.Context, params *GetShipmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShipmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInboundShipmentWithBody(ctx context.Context, shipmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInboundShipmentRequestWithBody(c.Server, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInboundShipment(ctx context.Context, shipmentId string, body CreateInboundShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInboundShipmentRequest(c.Server, shipmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInboundShipmentWithBody(ctx context.Context, shipmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInboundShipmentRequestWithBody(c.Server, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInboundShipment(ctx context.Context, shipmentId string, body UpdateInboundShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInboundShipmentRequest(c.Server, shipmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillOfLading(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillOfLadingRequest(c.Server, shipmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShipmentItemsByShipmentId(ctx context.Context, shipmentId string, params *GetShipmentItemsByShipmentIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShipmentItemsByShipmentIdRequest(c.Server, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLabels(ctx context.Context, shipmentId string, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLabelsRequest(c.Server, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPreorderInfo(ctx context.Context, shipmentId string, params *GetPreorderInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPreorderInfoRequest(c.Server, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmPreorder(ctx context.Context, shipmentId string, params *ConfirmPreorderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmPreorderRequest(c.Server, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransportDetails(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransportDetailsRequest(c.Server, shipmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTransportDetailsWithBody(ctx context.Context, shipmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTransportDetailsRequestWithBody(c.Server, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTransportDetails(ctx context.Context, shipmentId string, body PutTransportDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTransportDetailsRequest(c.Server, shipmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmTransport(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmTransportRequest(c.Server, shipmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EstimateTransport(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEstimateTransportRequest(c.Server, shipmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VoidTransport(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVoidTransportRequest(c.Server, shipmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetInboundGuidanceRequest generates requests for GetInboundGuidance
func NewGetInboundGuidanceRequest(server string, params *GetInboundGuidanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/itemsGuidance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.SellerSKUList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SellerSKUList", runtime.ParamLocationQuery, *params.SellerSKUList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ASINList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ASINList", runtime.ParamLocationQuery, *params.ASINList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInboundShipmentPlanRequest calls the generic CreateInboundShipmentPlan builder with application/json body
func NewCreateInboundShipmentPlanRequest(server string, body CreateInboundShipmentPlanJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInboundShipmentPlanRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateInboundShipmentPlanRequestWithBody generates requests for CreateInboundShipmentPlan with any type of body
func NewCreateInboundShipmentPlanRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPrepInstructionsRequest generates requests for GetPrepInstructions
func NewGetPrepInstructionsRequest(server string, params *GetPrepInstructionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/prepInstructions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ShipToCountryCode", runtime.ParamLocationQuery, params.ShipToCountryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.SellerSKUList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SellerSKUList", runtime.ParamLocationQuery, *params.SellerSKUList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ASINList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ASINList", runtime.ParamLocationQuery, *params.ASINList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShipmentItemsRequest generates requests for GetShipmentItems
func NewGetShipmentItemsRequest(server string, params *GetShipmentItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipmentItems")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LastUpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LastUpdatedAfter", runtime.ParamLocationQuery, *params.LastUpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LastUpdatedBefore", runtime.ParamLocationQuery, *params.LastUpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "QueryType", runtime.ParamLocationQuery, params.QueryType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShipmentsRequest generates requests for GetShipments
func NewGetShipmentsRequest(server string, params *GetShipmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShipmentStatusList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ShipmentStatusList", runtime.ParamLocationQuery, *params.ShipmentStatusList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ShipmentIdList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ShipmentIdList", runtime.ParamLocationQuery, *params.ShipmentIdList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LastUpdatedAfter", runtime.ParamLocationQuery, *params.LastUpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.LastUpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LastUpdatedBefore", runtime.ParamLocationQuery, *params.LastUpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "QueryType", runtime.ParamLocationQuery, params.QueryType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInboundShipmentRequest calls the generic CreateInboundShipment builder with application/json body
func NewCreateInboundShipmentRequest(server string, shipmentId string, body CreateInboundShipmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInboundShipmentRequestWithBody(server, shipmentId, "application/json", bodyReader)
}

// NewCreateInboundShipmentRequestWithBody generates requests for CreateInboundShipment with any type of body
func NewCreateInboundShipmentRequestWithBody(server string, shipmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateInboundShipmentRequest calls the generic UpdateInboundShipment builder with application/json body
func NewUpdateInboundShipmentRequest(server string, shipmentId string, body UpdateInboundShipmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInboundShipmentRequestWithBody(server, shipmentId, "application/json", bodyReader)
}

// NewUpdateInboundShipmentRequestWithBody generates requests for UpdateInboundShipment with any type of body
func NewUpdateInboundShipmentRequestWithBody(server string, shipmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBillOfLadingRequest generates requests for GetBillOfLading
func NewGetBillOfLadingRequest(server string, shipmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/billOfLading", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShipmentItemsByShipmentIdRequest generates requests for GetShipmentItemsByShipmentId
func NewGetShipmentItemsByShipmentIdRequest(server string, shipmentId string, params *GetShipmentItemsByShipmentIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLabelsRequest generates requests for GetLabels
func NewGetLabelsRequest(server string, shipmentId string, params *GetLabelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "PageType", runtime.ParamLocationQuery, params.PageType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "LabelType", runtime.ParamLocationQuery, params.LabelType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.NumberOfPackages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NumberOfPackages", runtime.ParamLocationQuery, *params.NumberOfPackages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PackageLabelsToPrint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "PackageLabelsToPrint", runtime.ParamLocationQuery, *params.PackageLabelsToPrint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NumberOfPallets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NumberOfPallets", runtime.ParamLocationQuery, *params.NumberOfPallets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "PageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageStartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "PageStartIndex", runtime.ParamLocationQuery, *params.PageStartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPreorderInfoRequest generates requests for GetPreorderInfo
func NewGetPreorderInfoRequest(server string, shipmentId string, params *GetPreorderInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/preorder", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfirmPreorderRequest generates requests for ConfirmPreorder
func NewConfirmPreorderRequest(server string, shipmentId string, params *ConfirmPreorderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/preorder/confirm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "NeedByDate", runtime.ParamLocationQuery, params.NeedByDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "MarketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransportDetailsRequest generates requests for GetTransportDetails
func NewGetTransportDetailsRequest(server string, shipmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/transport", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutTransportDetailsRequest calls the generic PutTransportDetails builder with application/json body
func NewPutTransportDetailsRequest(server string, shipmentId string, body PutTransportDetailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutTransportDetailsRequestWithBody(server, shipmentId, "application/json", bodyReader)
}

// NewPutTransportDetailsRequestWithBody generates requests for PutTransportDetails with any type of body
func NewPutTransportDetailsRequestWithBody(server string, shipmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/transport", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConfirmTransportRequest generates requests for ConfirmTransport
func NewConfirmTransportRequest(server string, shipmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/transport/confirm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEstimateTransportRequest generates requests for EstimateTransport
func NewEstimateTransportRequest(server string, shipmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/transport/estimate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVoidTransportRequest generates requests for VoidTransport
func NewVoidTransportRequest(server string, shipmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inbound/v0/shipments/%s/transport/void", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetInboundGuidanceWithResponse request
	GetInboundGuidanceWithResponse(ctx context.Context, params *GetInboundGuidanceParams, reqEditors ...RequestEditorFn) (*GetInboundGuidanceResp, error)

	// CreateInboundShipmentPlanWithBodyWithResponse request with any body
	CreateInboundShipmentPlanWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInboundShipmentPlanResp, error)

	CreateInboundShipmentPlanWithResponse(ctx context.Context, body CreateInboundShipmentPlanJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInboundShipmentPlanResp, error)

	// GetPrepInstructionsWithResponse request
	GetPrepInstructionsWithResponse(ctx context.Context, params *GetPrepInstructionsParams, reqEditors ...RequestEditorFn) (*GetPrepInstructionsResp, error)

	// GetShipmentItemsWithResponse request
	GetShipmentItemsWithResponse(ctx context.Context, params *GetShipmentItemsParams, reqEditors ...RequestEditorFn) (*GetShipmentItemsResp, error)

	// GetShipmentsWithResponse request
	GetShipmentsWithResponse(ctx context.Context, params *GetShipmentsParams, reqEditors ...RequestEditorFn) (*GetShipmentsResp, error)

	// CreateInboundShipmentWithBodyWithResponse request with any body
	CreateInboundShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInboundShipmentResp, error)

	CreateInboundShipmentWithResponse(ctx context.Context, shipmentId string, body CreateInboundShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInboundShipmentResp, error)

	// UpdateInboundShipmentWithBodyWithResponse request with any body
	UpdateInboundShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInboundShipmentResp, error)

	UpdateInboundShipmentWithResponse(ctx context.Context, shipmentId string, body UpdateInboundShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInboundShipmentResp, error)

	// GetBillOfLadingWithResponse request
	GetBillOfLadingWithResponse(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*GetBillOfLadingResp, error)

	// GetShipmentItemsByShipmentIdWithResponse request
	GetShipmentItemsByShipmentIdWithResponse(ctx context.Context, shipmentId string, params *GetShipmentItemsByShipmentIdParams, reqEditors ...RequestEditorFn) (*GetShipmentItemsByShipmentIdResp, error)

	// GetLabelsWithResponse request
	GetLabelsWithResponse(ctx context.Context, shipmentId string, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*GetLabelsResp, error)

	// GetPreorderInfoWithResponse request
	GetPreorderInfoWithResponse(ctx context.Context, shipmentId string, params *GetPreorderInfoParams, reqEditors ...RequestEditorFn) (*GetPreorderInfoResp, error)

	// ConfirmPreorderWithResponse request
	ConfirmPreorderWithResponse(ctx context.Context, shipmentId string, params *ConfirmPreorderParams, reqEditors ...RequestEditorFn) (*ConfirmPreorderResp, error)

	// GetTransportDetailsWithResponse request
	GetTransportDetailsWithResponse(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*GetTransportDetailsResp, error)

	// PutTransportDetailsWithBodyWithResponse request with any body
	PutTransportDetailsWithBodyWithResponse(ctx context.Context, shipmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTransportDetailsResp, error)

	PutTransportDetailsWithResponse(ctx context.Context, shipmentId string, body PutTransportDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTransportDetailsResp, error)

	// ConfirmTransportWithResponse request
	ConfirmTransportWithResponse(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*ConfirmTransportResp, error)

	// EstimateTransportWithResponse request
	EstimateTransportWithResponse(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*EstimateTransportResp, error)

	// VoidTransportWithResponse request
	VoidTransportWithResponse(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*VoidTransportResp, error)
}

type GetInboundGuidanceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInboundGuidanceResponse
	JSON400      *GetInboundGuidanceResponse
	JSON401      *GetInboundGuidanceResponse
	JSON403      *GetInboundGuidanceResponse
	JSON404      *GetInboundGuidanceResponse
	JSON429      *GetInboundGuidanceResponse
	JSON500      *GetInboundGuidanceResponse
	JSON503      *GetInboundGuidanceResponse
}

// Status returns HTTPResponse.Status
func (r GetInboundGuidanceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInboundGuidanceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInboundShipmentPlanResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateInboundShipmentPlanResponse
	JSON400      *CreateInboundShipmentPlanResponse
	JSON401      *CreateInboundShipmentPlanResponse
	JSON403      *CreateInboundShipmentPlanResponse
	JSON404      *CreateInboundShipmentPlanResponse
	JSON429      *CreateInboundShipmentPlanResponse
	JSON500      *CreateInboundShipmentPlanResponse
	JSON503      *CreateInboundShipmentPlanResponse
}

// Status returns HTTPResponse.Status
func (r CreateInboundShipmentPlanResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInboundShipmentPlanResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPrepInstructionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPrepInstructionsResponse
	JSON400      *GetPrepInstructionsResponse
	JSON401      *GetPrepInstructionsResponse
	JSON403      *GetPrepInstructionsResponse
	JSON404      *GetPrepInstructionsResponse
	JSON429      *GetPrepInstructionsResponse
	JSON500      *GetPrepInstructionsResponse
	JSON503      *GetPrepInstructionsResponse
}

// Status returns HTTPResponse.Status
func (r GetPrepInstructionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrepInstructionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShipmentItemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetShipmentItemsResponse
	JSON400      *GetShipmentItemsResponse
	JSON401      *GetShipmentItemsResponse
	JSON403      *GetShipmentItemsResponse
	JSON404      *GetShipmentItemsResponse
	JSON429      *GetShipmentItemsResponse
	JSON500      *GetShipmentItemsResponse
	JSON503      *GetShipmentItemsResponse
}

// Status returns HTTPResponse.Status
func (r GetShipmentItemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShipmentItemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShipmentsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetShipmentsResponse
	JSON400      *GetShipmentsResponse
	JSON401      *GetShipmentsResponse
	JSON403      *GetShipmentsResponse
	JSON404      *GetShipmentsResponse
	JSON429      *GetShipmentsResponse
	JSON500      *GetShipmentsResponse
	JSON503      *GetShipmentsResponse
}

// Status returns HTTPResponse.Status
func (r GetShipmentsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShipmentsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInboundShipmentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InboundShipmentResponse
	JSON400      *InboundShipmentResponse
	JSON401      *InboundShipmentResponse
	JSON403      *InboundShipmentResponse
	JSON404      *InboundShipmentResponse
	JSON429      *InboundShipmentResponse
	JSON500      *InboundShipmentResponse
	JSON503      *InboundShipmentResponse
}

// Status returns HTTPResponse.Status
func (r CreateInboundShipmentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInboundShipmentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInboundShipmentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InboundShipmentResponse
	JSON400      *InboundShipmentResponse
	JSON401      *InboundShipmentResponse
	JSON403      *InboundShipmentResponse
	JSON404      *InboundShipmentResponse
	JSON429      *InboundShipmentResponse
	JSON500      *InboundShipmentResponse
	JSON503      *InboundShipmentResponse
}

// Status returns HTTPResponse.Status
func (r UpdateInboundShipmentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInboundShipmentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillOfLadingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBillOfLadingResponse
	JSON400      *GetBillOfLadingResponse
	JSON401      *GetBillOfLadingResponse
	JSON403      *GetBillOfLadingResponse
	JSON404      *GetBillOfLadingResponse
	JSON429      *GetBillOfLadingResponse
	JSON500      *GetBillOfLadingResponse
	JSON503      *GetBillOfLadingResponse
}

// Status returns HTTPResponse.Status
func (r GetBillOfLadingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillOfLadingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShipmentItemsByShipmentIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetShipmentItemsResponse
	JSON400      *GetShipmentItemsResponse
	JSON401      *GetShipmentItemsResponse
	JSON403      *GetShipmentItemsResponse
	JSON404      *GetShipmentItemsResponse
	JSON429      *GetShipmentItemsResponse
	JSON500      *GetShipmentItemsResponse
	JSON503      *GetShipmentItemsResponse
}

// Status returns HTTPResponse.Status
func (r GetShipmentItemsByShipmentIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShipmentItemsByShipmentIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLabelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetLabelsResponse
	JSON400      *GetLabelsResponse
	JSON401      *GetLabelsResponse
	JSON403      *GetLabelsResponse
	JSON404      *GetLabelsResponse
	JSON429      *GetLabelsResponse
	JSON500      *GetLabelsResponse
	JSON503      *GetLabelsResponse
}

// Status returns HTTPResponse.Status
func (r GetLabelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPreorderInfoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPreorderInfoResponse
	JSON400      *GetPreorderInfoResponse
	JSON401      *GetPreorderInfoResponse
	JSON403      *GetPreorderInfoResponse
	JSON404      *GetPreorderInfoResponse
	JSON429      *GetPreorderInfoResponse
	JSON500      *GetPreorderInfoResponse
	JSON503      *GetPreorderInfoResponse
}

// Status returns HTTPResponse.Status
func (r GetPreorderInfoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPreorderInfoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmPreorderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfirmPreorderResponse
	JSON400      *ConfirmPreorderResponse
	JSON401      *ConfirmPreorderResponse
	JSON403      *ConfirmPreorderResponse
	JSON404      *ConfirmPreorderResponse
	JSON429      *ConfirmPreorderResponse
	JSON500      *ConfirmPreorderResponse
	JSON503      *ConfirmPreorderResponse
}

// Status returns HTTPResponse.Status
func (r ConfirmPreorderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmPreorderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransportDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTransportDetailsResponse
	JSON400      *GetTransportDetailsResponse
	JSON401      *GetTransportDetailsResponse
	JSON403      *GetTransportDetailsResponse
	JSON404      *GetTransportDetailsResponse
	JSON429      *GetTransportDetailsResponse
	JSON500      *GetTransportDetailsResponse
	JSON503      *GetTransportDetailsResponse
}

// Status returns HTTPResponse.Status
func (r GetTransportDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransportDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutTransportDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PutTransportDetailsResponse
	JSON400      *PutTransportDetailsResponse
	JSON401      *PutTransportDetailsResponse
	JSON403      *PutTransportDetailsResponse
	JSON404      *PutTransportDetailsResponse
	JSON429      *PutTransportDetailsResponse
	JSON500      *PutTransportDetailsResponse
	JSON503      *PutTransportDetailsResponse
}

// Status returns HTTPResponse.Status
func (r PutTransportDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutTransportDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmTransportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfirmTransportResponse
	JSON400      *ConfirmTransportResponse
	JSON401      *ConfirmTransportResponse
	JSON403      *ConfirmTransportResponse
	JSON404      *ConfirmTransportResponse
	JSON429      *ConfirmTransportResponse
	JSON500      *ConfirmTransportResponse
	JSON503      *ConfirmTransportResponse
}

// Status returns HTTPResponse.Status
func (r ConfirmTransportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmTransportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EstimateTransportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EstimateTransportResponse
	JSON400      *EstimateTransportResponse
	JSON401      *EstimateTransportResponse
	JSON403      *EstimateTransportResponse
	JSON404      *EstimateTransportResponse
	JSON429      *EstimateTransportResponse
	JSON500      *EstimateTransportResponse
	JSON503      *EstimateTransportResponse
}

// Status returns HTTPResponse.Status
func (r EstimateTransportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EstimateTransportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VoidTransportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoidTransportResponse
	JSON400      *VoidTransportResponse
	JSON401      *VoidTransportResponse
	JSON403      *VoidTransportResponse
	JSON404      *VoidTransportResponse
	JSON429      *VoidTransportResponse
	JSON500      *VoidTransportResponse
	JSON503      *VoidTransportResponse
}

// Status returns HTTPResponse.Status
func (r VoidTransportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VoidTransportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetInboundGuidanceWithResponse request returning *GetInboundGuidanceResp
func (c *ClientWithResponses) GetInboundGuidanceWithResponse(ctx context.Context, params *GetInboundGuidanceParams, reqEditors ...RequestEditorFn) (*GetInboundGuidanceResp, error) {
	rsp, err := c.GetInboundGuidance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInboundGuidanceResp(rsp)
}

// CreateInboundShipmentPlanWithBodyWithResponse request with arbitrary body returning *CreateInboundShipmentPlanResp
func (c *ClientWithResponses) CreateInboundShipmentPlanWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInboundShipmentPlanResp, error) {
	rsp, err := c.CreateInboundShipmentPlanWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInboundShipmentPlanResp(rsp)
}

func (c *ClientWithResponses) CreateInboundShipmentPlanWithResponse(ctx context.Context, body CreateInboundShipmentPlanJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInboundShipmentPlanResp, error) {
	rsp, err := c.CreateInboundShipmentPlan(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInboundShipmentPlanResp(rsp)
}

// GetPrepInstructionsWithResponse request returning *GetPrepInstructionsResp
func (c *ClientWithResponses) GetPrepInstructionsWithResponse(ctx context.Context, params *GetPrepInstructionsParams, reqEditors ...RequestEditorFn) (*GetPrepInstructionsResp, error) {
	rsp, err := c.GetPrepInstructions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrepInstructionsResp(rsp)
}

// GetShipmentItemsWithResponse request returning *GetShipmentItemsResp
func (c *ClientWithResponses) GetShipmentItemsWithResponse(ctx context.Context, params *GetShipmentItemsParams, reqEditors ...RequestEditorFn) (*GetShipmentItemsResp, error) {
	rsp, err := c.GetShipmentItems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShipmentItemsResp(rsp)
}

// GetShipmentsWithResponse request returning *GetShipmentsResp
func (c *ClientWithResponses) GetShipmentsWithResponse(ctx context.Context, params *GetShipmentsParams, reqEditors ...RequestEditorFn) (*GetShipmentsResp, error) {
	rsp, err := c.GetShipments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShipmentsResp(rsp)
}

// CreateInboundShipmentWithBodyWithResponse request with arbitrary body returning *CreateInboundShipmentResp
func (c *ClientWithResponses) CreateInboundShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInboundShipmentResp, error) {
	rsp, err := c.CreateInboundShipmentWithBody(ctx, shipmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInboundShipmentResp(rsp)
}

func (c *ClientWithResponses) CreateInboundShipmentWithResponse(ctx context.Context, shipmentId string, body CreateInboundShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInboundShipmentResp, error) {
	rsp, err := c.CreateInboundShipment(ctx, shipmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInboundShipmentResp(rsp)
}

// UpdateInboundShipmentWithBodyWithResponse request with arbitrary body returning *UpdateInboundShipmentResp
func (c *ClientWithResponses) UpdateInboundShipmentWithBodyWithResponse(ctx context.Context, shipmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInboundShipmentResp, error) {
	rsp, err := c.UpdateInboundShipmentWithBody(ctx, shipmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInboundShipmentResp(rsp)
}

func (c *ClientWithResponses) UpdateInboundShipmentWithResponse(ctx context.Context, shipmentId string, body UpdateInboundShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInboundShipmentResp, error) {
	rsp, err := c.UpdateInboundShipment(ctx, shipmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInboundShipmentResp(rsp)
}

// GetBillOfLadingWithResponse request returning *GetBillOfLadingResp
func (c *ClientWithResponses) GetBillOfLadingWithResponse(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*GetBillOfLadingResp, error) {
	rsp, err := c.GetBillOfLading(ctx, shipmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillOfLadingResp(rsp)
}

// GetShipmentItemsByShipmentIdWithResponse request returning *GetShipmentItemsByShipmentIdResp
func (c *ClientWithResponses) GetShipmentItemsByShipmentIdWithResponse(ctx context.Context, shipmentId string, params *GetShipmentItemsByShipmentIdParams, reqEditors ...RequestEditorFn) (*GetShipmentItemsByShipmentIdResp, error) {
	rsp, err := c.GetShipmentItemsByShipmentId(ctx, shipmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShipmentItemsByShipmentIdResp(rsp)
}

// GetLabelsWithResponse request returning *GetLabelsResp
func (c *ClientWithResponses) GetLabelsWithResponse(ctx context.Context, shipmentId string, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*GetLabelsResp, error) {
	rsp, err := c.GetLabels(ctx, shipmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLabelsResp(rsp)
}

// GetPreorderInfoWithResponse request returning *GetPreorderInfoResp
func (c *ClientWithResponses) GetPreorderInfoWithResponse(ctx context.Context, shipmentId string, params *GetPreorderInfoParams, reqEditors ...RequestEditorFn) (*GetPreorderInfoResp, error) {
	rsp, err := c.GetPreorderInfo(ctx, shipmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPreorderInfoResp(rsp)
}

// ConfirmPreorderWithResponse request returning *ConfirmPreorderResp
func (c *ClientWithResponses) ConfirmPreorderWithResponse(ctx context.Context, shipmentId string, params *ConfirmPreorderParams, reqEditors ...RequestEditorFn) (*ConfirmPreorderResp, error) {
	rsp, err := c.ConfirmPreorder(ctx, shipmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmPreorderResp(rsp)
}

// GetTransportDetailsWithResponse request returning *GetTransportDetailsResp
func (c *ClientWithResponses) GetTransportDetailsWithResponse(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*GetTransportDetailsResp, error) {
	rsp, err := c.GetTransportDetails(ctx, shipmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransportDetailsResp(rsp)
}

// PutTransportDetailsWithBodyWithResponse request with arbitrary body returning *PutTransportDetailsResp
func (c *ClientWithResponses) PutTransportDetailsWithBodyWithResponse(ctx context.Context, shipmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTransportDetailsResp, error) {
	rsp, err := c.PutTransportDetailsWithBody(ctx, shipmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTransportDetailsResp(rsp)
}

func (c *ClientWithResponses) PutTransportDetailsWithResponse(ctx context.Context, shipmentId string, body PutTransportDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTransportDetailsResp, error) {
	rsp, err := c.PutTransportDetails(ctx, shipmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTransportDetailsResp(rsp)
}

// ConfirmTransportWithResponse request returning *ConfirmTransportResp
func (c *ClientWithResponses) ConfirmTransportWithResponse(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*ConfirmTransportResp, error) {
	rsp, err := c.ConfirmTransport(ctx, shipmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmTransportResp(rsp)
}

// EstimateTransportWithResponse request returning *EstimateTransportResp
func (c *ClientWithResponses) EstimateTransportWithResponse(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*EstimateTransportResp, error) {
	rsp, err := c.EstimateTransport(ctx, shipmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEstimateTransportResp(rsp)
}

// VoidTransportWithResponse request returning *VoidTransportResp
func (c *ClientWithResponses) VoidTransportWithResponse(ctx context.Context, shipmentId string, reqEditors ...RequestEditorFn) (*VoidTransportResp, error) {
	rsp, err := c.VoidTransport(ctx, shipmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVoidTransportResp(rsp)
}

// ParseGetInboundGuidanceResp parses an HTTP response from a GetInboundGuidanceWithResponse call
func ParseGetInboundGuidanceResp(rsp *http.Response) (*GetInboundGuidanceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInboundGuidanceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInboundGuidanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetInboundGuidanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetInboundGuidanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetInboundGuidanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetInboundGuidanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetInboundGuidanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetInboundGuidanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetInboundGuidanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateInboundShipmentPlanResp parses an HTTP response from a CreateInboundShipmentPlanWithResponse call
func ParseCreateInboundShipmentPlanResp(rsp *http.Response) (*CreateInboundShipmentPlanResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInboundShipmentPlanResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateInboundShipmentPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreateInboundShipmentPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreateInboundShipmentPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreateInboundShipmentPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreateInboundShipmentPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest CreateInboundShipmentPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CreateInboundShipmentPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest CreateInboundShipmentPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPrepInstructionsResp parses an HTTP response from a GetPrepInstructionsWithResponse call
func ParseGetPrepInstructionsResp(rsp *http.Response) (*GetPrepInstructionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrepInstructionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetPrepInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetShipmentItemsResp parses an HTTP response from a GetShipmentItemsWithResponse call
func ParseGetShipmentItemsResp(rsp *http.Response) (*GetShipmentItemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShipmentItemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetShipmentsResp parses an HTTP response from a GetShipmentsWithResponse call
func ParseGetShipmentsResp(rsp *http.Response) (*GetShipmentsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShipmentsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetShipmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateInboundShipmentResp parses an HTTP response from a CreateInboundShipmentWithResponse call
func ParseCreateInboundShipmentResp(rsp *http.Response) (*CreateInboundShipmentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInboundShipmentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateInboundShipmentResp parses an HTTP response from a UpdateInboundShipmentWithResponse call
func ParseUpdateInboundShipmentResp(rsp *http.Response) (*UpdateInboundShipmentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInboundShipmentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest InboundShipmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetBillOfLadingResp parses an HTTP response from a GetBillOfLadingWithResponse call
func ParseGetBillOfLadingResp(rsp *http.Response) (*GetBillOfLadingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillOfLadingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetBillOfLadingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetShipmentItemsByShipmentIdResp parses an HTTP response from a GetShipmentItemsByShipmentIdWithResponse call
func ParseGetShipmentItemsByShipmentIdResp(rsp *http.Response) (*GetShipmentItemsByShipmentIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShipmentItemsByShipmentIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetLabelsResp parses an HTTP response from a GetLabelsWithResponse call
func ParseGetLabelsResp(rsp *http.Response) (*GetLabelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPreorderInfoResp parses an HTTP response from a GetPreorderInfoWithResponse call
func ParseGetPreorderInfoResp(rsp *http.Response) (*GetPreorderInfoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPreorderInfoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPreorderInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPreorderInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPreorderInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPreorderInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPreorderInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetPreorderInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetPreorderInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetPreorderInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConfirmPreorderResp parses an HTTP response from a ConfirmPreorderWithResponse call
func ParseConfirmPreorderResp(rsp *http.Response) (*ConfirmPreorderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmPreorderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfirmPreorderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ConfirmPreorderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ConfirmPreorderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ConfirmPreorderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ConfirmPreorderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ConfirmPreorderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ConfirmPreorderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ConfirmPreorderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetTransportDetailsResp parses an HTTP response from a GetTransportDetailsWithResponse call
func ParseGetTransportDetailsResp(rsp *http.Response) (*GetTransportDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransportDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePutTransportDetailsResp parses an HTTP response from a PutTransportDetailsWithResponse call
func ParsePutTransportDetailsResp(rsp *http.Response) (*PutTransportDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutTransportDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PutTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PutTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest PutTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PutTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest PutTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest PutTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest PutTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest PutTransportDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConfirmTransportResp parses an HTTP response from a ConfirmTransportWithResponse call
func ParseConfirmTransportResp(rsp *http.Response) (*ConfirmTransportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmTransportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfirmTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ConfirmTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ConfirmTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ConfirmTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ConfirmTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ConfirmTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ConfirmTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ConfirmTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseEstimateTransportResp parses an HTTP response from a EstimateTransportWithResponse call
func ParseEstimateTransportResp(rsp *http.Response) (*EstimateTransportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EstimateTransportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EstimateTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest EstimateTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest EstimateTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest EstimateTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest EstimateTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest EstimateTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest EstimateTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest EstimateTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseVoidTransportResp parses an HTTP response from a VoidTransportWithResponse call
func ParseVoidTransportResp(rsp *http.Response) (*VoidTransportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VoidTransportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoidTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest VoidTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest VoidTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest VoidTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest VoidTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest VoidTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest VoidTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest VoidTransportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
