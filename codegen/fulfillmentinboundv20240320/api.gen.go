// Package fulfillmentinboundv20240320 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package fulfillmentinboundv20240320

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for AllOwnersConstraint.
const (
	MUSTMATCH AllOwnersConstraint = "MUST_MATCH"
)

// Defines values for BoxContentInformationSource.
const (
	BARCODE2D          BoxContentInformationSource = "BARCODE_2D"
	BOXCONTENTPROVIDED BoxContentInformationSource = "BOX_CONTENT_PROVIDED"
	MANUALPROCESS      BoxContentInformationSource = "MANUAL_PROCESS"
)

// Defines values for ItemLabelPageType.
const (
	A421      ItemLabelPageType = "A4_21"
	A424      ItemLabelPageType = "A4_24"
	A42464x33 ItemLabelPageType = "A4_24_64x33"
	A42466x35 ItemLabelPageType = "A4_24_66x35"
	A42470x36 ItemLabelPageType = "A4_24_70x36"
	A42470x37 ItemLabelPageType = "A4_24_70x37"
	A424i     ItemLabelPageType = "A4_24i"
	A427      ItemLabelPageType = "A4_27"
	A44052x29 ItemLabelPageType = "A4_40_52x29"
	A44448x25 ItemLabelPageType = "A4_44_48x25"
	Letter30  ItemLabelPageType = "Letter_30"
)

// Defines values for LabelOwner.
const (
	LabelOwnerAMAZON LabelOwner = "AMAZON"
	LabelOwnerNONE   LabelOwner = "NONE"
	LabelOwnerSELLER LabelOwner = "SELLER"
)

// Defines values for LabelPrintType.
const (
	STANDARDFORMAT  LabelPrintType = "STANDARD_FORMAT"
	THERMALPRINTING LabelPrintType = "THERMAL_PRINTING"
)

// Defines values for OperationStatus.
const (
	FAILED     OperationStatus = "FAILED"
	INPROGRESS OperationStatus = "IN_PROGRESS"
	SUCCESS    OperationStatus = "SUCCESS"
)

// Defines values for OwnerConstraint.
const (
	AMAZONONLY OwnerConstraint = "AMAZON_ONLY"
	NONEONLY   OwnerConstraint = "NONE_ONLY"
	SELLERONLY OwnerConstraint = "SELLER_ONLY"
)

// Defines values for PrepCategory.
const (
	PrepCategoryADULT      PrepCategory = "ADULT"
	PrepCategoryBABY       PrepCategory = "BABY"
	PrepCategoryFCPROVIDED PrepCategory = "FC_PROVIDED"
	PrepCategoryFRAGILE    PrepCategory = "FRAGILE"
	PrepCategoryGRANULAR   PrepCategory = "GRANULAR"
	PrepCategoryHANGER     PrepCategory = "HANGER"
	PrepCategoryLIQUID     PrepCategory = "LIQUID"
	PrepCategoryNONE       PrepCategory = "NONE"
	PrepCategoryPERFORATED PrepCategory = "PERFORATED"
	PrepCategorySET        PrepCategory = "SET"
	PrepCategorySHARP      PrepCategory = "SHARP"
	PrepCategorySMALL      PrepCategory = "SMALL"
	PrepCategoryTEXTILE    PrepCategory = "TEXTILE"
	PrepCategoryUNKNOWN    PrepCategory = "UNKNOWN"
)

// Defines values for PrepOwner.
const (
	AMAZON PrepOwner = "AMAZON"
	NONE   PrepOwner = "NONE"
	SELLER PrepOwner = "SELLER"
)

// Defines values for PrepType.
const (
	ITEMBLACKSHRINKWRAP PrepType = "ITEM_BLACK_SHRINKWRAP"
	ITEMBLANKSTK        PrepType = "ITEM_BLANKSTK"
	ITEMBOXING          PrepType = "ITEM_BOXING"
	ITEMBUBBLEWRAP      PrepType = "ITEM_BUBBLEWRAP"
	ITEMCAPSEALING      PrepType = "ITEM_CAP_SEALING"
	ITEMDEBUNDLE        PrepType = "ITEM_DEBUNDLE"
	ITEMHANGGARMENT     PrepType = "ITEM_HANG_GARMENT"
	ITEMLABELING        PrepType = "ITEM_LABELING"
	ITEMNOPREP          PrepType = "ITEM_NO_PREP"
	ITEMPOLYBAGGING     PrepType = "ITEM_POLYBAGGING"
	ITEMRMOVHANG        PrepType = "ITEM_RMOVHANG"
	ITEMSETCREAT        PrepType = "ITEM_SETCREAT"
	ITEMSETSTK          PrepType = "ITEM_SETSTK"
	ITEMSIOC            PrepType = "ITEM_SIOC"
	ITEMSUFFOSTK        PrepType = "ITEM_SUFFOSTK"
	ITEMTAPING          PrepType = "ITEM_TAPING"
)

// Defines values for ReasonComment.
const (
	APPOINTMENTREQUESTEDBYMISTAKE  ReasonComment = "APPOINTMENT_REQUESTED_BY_MISTAKE"
	INCREASEDQUANTITY              ReasonComment = "INCREASED_QUANTITY"
	OTHER                          ReasonComment = "OTHER"
	OUTSIDECARRIERBUSINESSHOURS    ReasonComment = "OUTSIDE_CARRIER_BUSINESS_HOURS"
	PROCUREMENTDELAY               ReasonComment = "PROCUREMENT_DELAY"
	SHIPPINGPLANCHANGED            ReasonComment = "SHIPPING_PLAN_CHANGED"
	SLOTNOTSUITABLE                ReasonComment = "SLOT_NOT_SUITABLE"
	UNFAVOURABLEEXTERNALCONDITIONS ReasonComment = "UNFAVOURABLE_EXTERNAL_CONDITIONS"
	VEHICLEDELAY                   ReasonComment = "VEHICLE_DELAY"
)

// Defines values for Stackability.
const (
	NONSTACKABLE Stackability = "NON_STACKABLE"
	STACKABLE    Stackability = "STACKABLE"
)

// Defines values for UnitOfMeasurement.
const (
	CM UnitOfMeasurement = "CM"
	IN UnitOfMeasurement = "IN"
)

// Defines values for UnitOfWeight.
const (
	KG UnitOfWeight = "KG"
	LB UnitOfWeight = "LB"
)

// Defines values for ListInboundPlansParamsStatus.
const (
	ACTIVE  ListInboundPlansParamsStatus = "ACTIVE"
	SHIPPED ListInboundPlansParamsStatus = "SHIPPED"
	VOIDED  ListInboundPlansParamsStatus = "VOIDED"
)

// Defines values for ListInboundPlansParamsSortBy.
const (
	CREATIONTIME    ListInboundPlansParamsSortBy = "CREATION_TIME"
	LASTUPDATEDTIME ListInboundPlansParamsSortBy = "LAST_UPDATED_TIME"
)

// Defines values for ListInboundPlansParamsSortOrder.
const (
	ASC  ListInboundPlansParamsSortOrder = "ASC"
	DESC ListInboundPlansParamsSortOrder = "DESC"
)

// Address Specific details to identify a place.
type Address struct {
	// AddressLine1 Street address information.
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Additional street address information.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// City The city.
	City string `json:"city"`

	// CompanyName The name of the business.
	CompanyName *string `json:"companyName,omitempty"`

	// CountryCode The country code in two-character ISO 3166-1 alpha-2 format.
	CountryCode string `json:"countryCode"`

	// Email The email address.
	Email *string `json:"email,omitempty"`

	// Name The name of the individual who is the primary contact.
	Name string `json:"name"`

	// PhoneNumber The phone number.
	PhoneNumber *string `json:"phoneNumber,omitempty"`

	// PostalCode The postal code.
	PostalCode string `json:"postalCode"`

	// StateOrProvinceCode The state or province code.
	StateOrProvinceCode *string `json:"stateOrProvinceCode,omitempty"`
}

// AddressInput Specific details to identify a place.
type AddressInput struct {
	// AddressLine1 Street address information.
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Additional street address information.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// City The city.
	City string `json:"city"`

	// CompanyName The name of the business.
	CompanyName *string `json:"companyName,omitempty"`

	// CountryCode The country code in two-character ISO 3166-1 alpha-2 format.
	CountryCode string `json:"countryCode"`

	// Email The email address.
	Email *string `json:"email,omitempty"`

	// Name The name of the individual who is the primary contact.
	Name string `json:"name"`

	// PhoneNumber The phone number.
	PhoneNumber string `json:"phoneNumber"`

	// PostalCode The postal code.
	PostalCode string `json:"postalCode"`

	// StateOrProvinceCode The state or province code.
	StateOrProvinceCode *string `json:"stateOrProvinceCode,omitempty"`
}

// AllOwnersConstraint A constraint that applies to all owners. If no constraint is specified, defer to any individual owner constraints.
type AllOwnersConstraint string

// AppointmentSlot The fulfillment center appointment slot for the transportation option.
type AppointmentSlot struct {
	// SlotId An identifier to a self-ship appointment slot.
	SlotId string `json:"slotId"`

	// SlotTime An appointment slot time with start and end.
	SlotTime AppointmentSlotTime `json:"slotTime"`
}

// AppointmentSlotTime An appointment slot time with start and end.
type AppointmentSlotTime struct {
	// EndTime The end timestamp of the appointment in UTC.
	EndTime time.Time `json:"endTime"`

	// StartTime The start timestamp of the appointment in UTC.
	StartTime time.Time `json:"startTime"`
}

// Box Contains information about a box that is used in the inbound plan. The box is a container that holds multiple items.
type Box struct {
	// BoxId The ID provided by Amazon that identifies a given box. This ID is comprised of the external shipment ID (which is generated after transportation has been confirmed) and the index of the box.
	BoxId *string `json:"boxId,omitempty"`

	// ContentInformationSource Indication of how box content is meant to be provided.
	ContentInformationSource *BoxContentInformationSource `json:"contentInformationSource,omitempty"`

	// DestinationRegion Representation of a location used within the inbounding experience.
	DestinationRegion *Region `json:"destinationRegion,omitempty"`

	// Dimensions Measurement of a package's dimensions.
	Dimensions *Dimensions `json:"dimensions,omitempty"`

	// ExternalContainerIdentifier The external identifier for this container / box.
	ExternalContainerIdentifier *string `json:"externalContainerIdentifier,omitempty"`

	// ExternalContainerIdentifierType Type of the external identifier used. Can be: `AMAZON`, `SSCC`.
	ExternalContainerIdentifierType *string `json:"externalContainerIdentifierType,omitempty"`

	// Items Items contained within the box.
	Items *[]Item `json:"items,omitempty"`

	// PackageId Primary key to uniquely identify a Package (Box or Pallet).
	PackageId string `json:"packageId"`

	// Quantity The number of containers where all other properties like weight or dimensions are identical.
	Quantity *int `json:"quantity,omitempty"`

	// TemplateName Template name of the box.
	TemplateName *string `json:"templateName,omitempty"`

	// Weight The weight of a package.
	Weight *Weight `json:"weight,omitempty"`
}

// BoxContentInformationSource Indication of how box content is meant to be provided.
type BoxContentInformationSource string

// BoxInput Input information for a given box.
type BoxInput struct {
	// ContentInformationSource Indication of how box content is meant to be provided.
	ContentInformationSource BoxContentInformationSource `json:"contentInformationSource"`

	// Dimensions Measurement of a package's dimensions.
	Dimensions Dimensions `json:"dimensions"`

	// Items The items and their quantity in the box. This must be empty if the box `contentInformationSource` is `BARCODE_2D` or `MANUAL_PROCESS`.
	Items *[]ItemInput `json:"items,omitempty"`

	// Quantity The number of containers where all other properties like weight or dimensions are identical.
	Quantity int `json:"quantity"`

	// Weight The weight of a package.
	Weight Weight `json:"weight"`
}

// BoxRequirements The requirements for a box in the packing option.
type BoxRequirements struct {
	// Weight The range of weights that are allowed for a package.
	Weight WeightRange `json:"weight"`
}

// BoxUpdateInput Input information for updating a box
type BoxUpdateInput struct {
	// ContentInformationSource Indication of how box content is meant to be provided.
	ContentInformationSource BoxContentInformationSource `json:"contentInformationSource"`

	// Dimensions Measurement of a package's dimensions.
	Dimensions Dimensions `json:"dimensions"`

	// Items The items and their quantity in the box. This must be empty if the box `contentInformationSource` is `BARCODE_2D` or `MANUAL_PROCESS`.
	Items *[]ItemInput `json:"items,omitempty"`

	// PackageId Primary key to uniquely identify a Box Package. PackageId must be provided if the intent is to update an existing box. Adding a new box will not require providing this value. Any existing PackageIds not provided will be treated as to-be-removed
	PackageId *string `json:"packageId,omitempty"`

	// Quantity The number of containers where all other properties like weight or dimensions are identical.
	Quantity int `json:"quantity"`

	// Weight The weight of a package.
	Weight Weight `json:"weight"`
}

// CancelInboundPlanResponse The `cancelInboundPlan` response.
type CancelInboundPlanResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// CancelSelfShipAppointmentRequest The `cancelSelfShipAppointment` request.
type CancelSelfShipAppointmentRequest struct {
	// ReasonComment Reason for cancelling or rescheduling a self-ship appointment.
	ReasonComment *ReasonComment `json:"reasonComment,omitempty"`
}

// CancelSelfShipAppointmentResponse The `CancelSelfShipAppointment` response.
type CancelSelfShipAppointmentResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// Carrier The carrier for the inbound shipment.
type Carrier struct {
	// AlphaCode The carrier code. For example, USPS or DHLEX.
	AlphaCode *string `json:"alphaCode,omitempty"`

	// Name The name of the carrier.
	Name *string `json:"name,omitempty"`
}

// CarrierAppointment Contains details for a transportation carrier appointment. This appointment is vended out by Amazon and is an indicator for when a transportation carrier is accepting shipments to be picked up.
type CarrierAppointment struct {
	// EndTime The end timestamp of the appointment in UTC.
	EndTime time.Time `json:"endTime"`

	// StartTime The start timestamp of the appointment in UTC.
	StartTime time.Time `json:"startTime"`
}

// ComplianceDetail Contains item identifiers and related tax information.
type ComplianceDetail struct {
	// Asin The Amazon Standard Identification Number, which identifies the detail page identifier.
	Asin *string `json:"asin,omitempty"`

	// Fnsku The Fulfillment Network SKU, which identifies a real fulfillable item with catalog data and condition.
	Fnsku *string `json:"fnsku,omitempty"`

	// Msku The merchant SKU, a merchant-supplied identifier for a specific SKU.
	Msku *string `json:"msku,omitempty"`

	// TaxDetails Information used to determine the tax compliance.
	TaxDetails *TaxDetails `json:"taxDetails,omitempty"`
}

// ConfirmDeliveryWindowOptionsResponse The `confirmDeliveryWindowOptions` response.
type ConfirmDeliveryWindowOptionsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// ConfirmPackingOptionResponse The `confirmPackingOption` response.
type ConfirmPackingOptionResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// ConfirmPlacementOptionResponse The `confirmPlacementOption` response.
type ConfirmPlacementOptionResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// ConfirmShipmentContentUpdatePreviewResponse The `confirmShipmentContentUpdatePreview` response.
type ConfirmShipmentContentUpdatePreviewResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// ConfirmTransportationOptionsRequest The `confirmTransportationOptions` request.
type ConfirmTransportationOptionsRequest struct {
	// TransportationSelections Information needed to confirm one of the available transportation options.
	TransportationSelections []TransportationSelection `json:"transportationSelections"`
}

// ConfirmTransportationOptionsResponse The `confirmTransportationOptions` response.
type ConfirmTransportationOptionsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// ContactInformation The seller's contact information.
type ContactInformation struct {
	// Email The email address.
	Email *string `json:"email,omitempty"`

	// Name The contact's name.
	Name string `json:"name"`

	// PhoneNumber The phone number.
	PhoneNumber string `json:"phoneNumber"`
}

// ContentUpdatePreview Preview of the changes that will be applied to the shipment.
type ContentUpdatePreview struct {
	// ContentUpdatePreviewId Identifier of a content update preview.
	ContentUpdatePreviewId string `json:"contentUpdatePreviewId"`

	// Expiration The time at which the content update expires. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	Expiration time.Time `json:"expiration"`

	// RequestedUpdates Objects that were included in the update request.
	RequestedUpdates RequestedUpdates `json:"requestedUpdates"`

	// TransportationOption Contains information pertaining to a transportation option and the related carrier.
	TransportationOption TransportationOption `json:"transportationOption"`
}

// CreateInboundPlanRequest The `createInboundPlan` request.
type CreateInboundPlanRequest struct {
	// DestinationMarketplaces Marketplaces where the items need to be shipped to. Currently only one marketplace can be selected in this request.
	DestinationMarketplaces []string `json:"destinationMarketplaces"`

	// Items Items included in this plan.
	Items []ItemInput `json:"items"`

	// Name Name for the Inbound Plan. If one isn't provided, a default name will be provided.
	Name *string `json:"name,omitempty"`

	// SourceAddress Specific details to identify a place.
	SourceAddress AddressInput `json:"sourceAddress"`
}

// CreateInboundPlanResponse The `createInboundPlan` response.
type CreateInboundPlanResponse struct {
	// InboundPlanId Identifier of an inbound plan.
	InboundPlanId string `json:"inboundPlanId"`

	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// CreateMarketplaceItemLabelsRequest The `createMarketplaceItemLabels` request.
type CreateMarketplaceItemLabelsRequest struct {
	// Height The height of the item label.
	Height *float32 `json:"height,omitempty"`

	// LabelType Indicates the type of print type for a given label.
	LabelType LabelPrintType `json:"labelType"`

	// LocaleCode The locale code constructed from ISO 639 language code and ISO 3166-1 alpha-2 standard of country codes separated by an underscore character.
	LocaleCode *string `json:"localeCode,omitempty"`

	// MarketplaceId The Marketplace ID. For a list of possible values, refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids).
	MarketplaceId string `json:"marketplaceId"`

	// MskuQuantities Represents the quantity of an MSKU to print item labels for.
	MskuQuantities []MskuQuantity `json:"mskuQuantities"`

	// PageType The page type to use to print the labels. Possible values: 'A4_21', 'A4_24', 'A4_24_64x33', 'A4_24_66x35', 'A4_24_70x36', 'A4_24_70x37', 'A4_24i', 'A4_27', 'A4_40_52x29', 'A4_44_48x25', 'Letter_30'.
	PageType *ItemLabelPageType `json:"pageType,omitempty"`

	// Width The width of the item label.
	Width *float32 `json:"width,omitempty"`
}

// CreateMarketplaceItemLabelsResponse The `createMarketplaceItemLabels` response.
type CreateMarketplaceItemLabelsResponse struct {
	// DocumentDownloads Resources to download the requested document.
	DocumentDownloads []DocumentDownload `json:"documentDownloads"`
}

// Currency The type and amount of currency.
type Currency struct {
	// Amount Decimal value of the currency.
	Amount float32 `json:"amount"`

	// Code ISO 4217 standard of a currency code.
	Code string `json:"code"`
}

// CustomPlacementInput Provide units going to the warehouse.
type CustomPlacementInput struct {
	// Items Items included while creating Inbound Plan.
	Items []ItemInput `json:"items"`

	// WarehouseId Warehouse Id.
	WarehouseId string `json:"warehouseId"`
}

// Dates Specifies the date that the seller expects their shipment will be shipped.
type Dates struct {
	// ReadyToShipWindow Contains a start and end DateTime representing a time range.
	ReadyToShipWindow *Window `json:"readyToShipWindow,omitempty"`
}

// DeliveryWindowOption Contains information pertaining to a delivery window option.
type DeliveryWindowOption struct {
	// AvailabilityType Identifies type of Delivery Window Availability. Values: `AVAILABLE`, `CONGESTED`
	AvailabilityType string `json:"availabilityType"`

	// DeliveryWindowOptionId Identifier of a delivery window option. A delivery window option represent one option for when a shipment is expected to be delivered.
	DeliveryWindowOptionId string `json:"deliveryWindowOptionId"`

	// EndDate The time at which this delivery window option ends. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with pattern `yyyy-MM-ddTHH:mmZ`.
	EndDate time.Time `json:"endDate"`

	// StartDate The time at which this delivery window option starts. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with pattern `yyyy-MM-ddTHH:mmZ`.
	StartDate time.Time `json:"startDate"`

	// ValidUntil The time at which this window delivery option is no longer valid. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with pattern `yyyy-MM-ddTHH:mmZ`.
	ValidUntil time.Time `json:"validUntil"`
}

// Dimensions Measurement of a package's dimensions.
type Dimensions struct {
	// Height The height of a package.
	Height float32 `json:"height"`

	// Length The length of a package.
	Length float32 `json:"length"`

	// UnitOfMeasurement Unit of linear measure.
	UnitOfMeasurement UnitOfMeasurement `json:"unitOfMeasurement"`

	// Width The width of a package.
	Width float32 `json:"width"`
}

// DocumentDownload Resource to download the requested document.
type DocumentDownload struct {
	// DownloadType The type of download. Possible values: `URL`.
	DownloadType string `json:"downloadType"`

	// Expiration The URI's expiration time. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	Expiration *time.Time `json:"expiration,omitempty"`

	// Uri Uniform resource identifier to identify where the document is located.
	Uri string `json:"uri"`
}

// Error Error object containing information about what went wrong.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	// Errors List of errors.
	Errors []Error `json:"errors"`
}

// FreightInformation Freight information describes the skus being transported. Freight carrier options and quotes will only be returned if the freight information is provided.
type FreightInformation struct {
	// DeclaredValue The type and amount of currency.
	DeclaredValue *Currency `json:"declaredValue,omitempty"`

	// FreightClass Freight class.
	//
	// Possible values: `NONE`, `FC_50`, `FC_55`, `FC_60`, `FC_65`, `FC_70`, `FC_77_5`, `FC_85`, `FC_92_5`, `FC_100`, `FC_110`, `FC_125`, `FC_150`, `FC_175`, `FC_200`, `FC_250`, `FC_300`, `FC_400`, `FC_500`.
	FreightClass *string `json:"freightClass,omitempty"`
}

// GenerateDeliveryWindowOptionsResponse The `generateDeliveryWindowOptions` response.
type GenerateDeliveryWindowOptionsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// GeneratePackingOptionsResponse The `generatePackingOptions` response.
type GeneratePackingOptionsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// GeneratePlacementOptionsRequest The `generatePlacementOptions` request.
type GeneratePlacementOptionsRequest struct {
	// CustomPlacement Custom placement options you want to add to the plan. This is only used for the India (IN - A21TJRUUN4KGV) marketplace.
	CustomPlacement *[]CustomPlacementInput `json:"customPlacement,omitempty"`
}

// GeneratePlacementOptionsResponse The `generatePlacementOptions` response.
type GeneratePlacementOptionsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// GenerateSelfShipAppointmentSlotsRequest The `generateSelfShipAppointmentSlots` request.
type GenerateSelfShipAppointmentSlotsRequest struct {
	// DesiredEndDate The desired end date. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format.
	DesiredEndDate *time.Time `json:"desiredEndDate,omitempty"`

	// DesiredStartDate The desired start date. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format.
	DesiredStartDate *time.Time `json:"desiredStartDate,omitempty"`
}

// GenerateSelfShipAppointmentSlotsResponse The `generateSelfShipAppointmentSlots` response.
type GenerateSelfShipAppointmentSlotsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// GenerateShipmentContentUpdatePreviewsRequest The `GenerateShipmentContentUpdatePreviews` request.
type GenerateShipmentContentUpdatePreviewsRequest struct {
	// Boxes A list of boxes that will be present in the shipment after the update.
	Boxes []BoxUpdateInput `json:"boxes"`

	// Items A list of all items that will be present in the shipment after the update.
	Items []ItemInput `json:"items"`
}

// GenerateShipmentContentUpdatePreviewsResponse The `GenerateShipmentContentUpdatePreviews` response.
type GenerateShipmentContentUpdatePreviewsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// GenerateTransportationOptionsRequest The `generateTransportationOptions` request.
type GenerateTransportationOptionsRequest struct {
	// PlacementOptionId The placement option to generate transportation options for.
	PlacementOptionId string `json:"placementOptionId"`

	// ShipmentTransportationConfigurations List of shipment transportation configurations.
	ShipmentTransportationConfigurations []ShipmentTransportationConfiguration `json:"shipmentTransportationConfigurations"`
}

// GenerateTransportationOptionsResponse The `generateTransportationOptions` response.
type GenerateTransportationOptionsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// GetDeliveryChallanDocumentResponse The `getDeliveryChallanDocumentResponse` response.
type GetDeliveryChallanDocumentResponse struct {
	// DocumentDownload Resource to download the requested document.
	DocumentDownload DocumentDownload `json:"documentDownload"`
}

// GetSelfShipAppointmentSlotsResponse The `getSelfShipAppointmentSlots` response.
type GetSelfShipAppointmentSlotsResponse struct {
	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`

	// SelfShipAppointmentSlotsAvailability The self ship appointment time slots availability and an expiration date for which the slots can be scheduled.
	SelfShipAppointmentSlotsAvailability SelfShipAppointmentSlotsAvailability `json:"selfShipAppointmentSlotsAvailability"`
}

// InboundOperationStatus GetInboundOperationStatus response.
type InboundOperationStatus struct {
	// Operation The name of the operation in the asynchronous API call.
	Operation string `json:"operation"`

	// OperationId The operation ID returned by the asynchronous API call.
	OperationId string `json:"operationId"`

	// OperationProblems The problems in the processing of the asynchronous operation.
	OperationProblems []OperationProblem `json:"operationProblems"`

	// OperationStatus The status of an operation.
	OperationStatus OperationStatus `json:"operationStatus"`
}

// InboundPlan Inbound plan containing details of the inbound workflow.
type InboundPlan struct {
	// CreatedAt The time at which the inbound plan was created. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime with pattern `yyyy-MM-ddTHH:mm:ssZ`.
	CreatedAt time.Time `json:"createdAt"`

	// InboundPlanId Identifier of an inbound plan.
	InboundPlanId string `json:"inboundPlanId"`

	// LastUpdatedAt The time at which the inbound plan was last updated. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with pattern `yyyy-MM-ddTHH:mm:ssZ`.
	LastUpdatedAt time.Time `json:"lastUpdatedAt"`

	// MarketplaceIds A list of marketplace IDs.
	MarketplaceIds []string `json:"marketplaceIds"`

	// Name Human-readable name of the inbound plan.
	Name string `json:"name"`

	// PackingOptions Packing options for the inbound plan. This property will be populated when it has been generated via the corresponding operation. If there is a chosen placement option, only packing options for that placement option will be returned. If there are confirmed shipments, only packing options for those shipments will be returned. Query the packing option for more details.
	PackingOptions *[]PackingOptionSummary `json:"packingOptions,omitempty"`

	// PlacementOptions Placement options for the inbound plan. This property will be populated when it has been generated via the corresponding operation. If there is a chosen placement option, that will be the only returned option. Query the placement option for more details.
	PlacementOptions *[]PlacementOptionSummary `json:"placementOptions,omitempty"`

	// Shipments A list of shipment IDs for the inbound plan. This property is populated when it has been generated with the `confirmPlacementOptions` operation. Only shipments from the chosen placement option are returned. Query the shipment for more details.
	Shipments *[]ShipmentSummary `json:"shipments,omitempty"`

	// SourceAddress Specific details to identify a place.
	SourceAddress Address `json:"sourceAddress"`

	// Status Current status of the inbound plan. Possible values: `ACTIVE`, `VOIDED`, `SHIPPED`, `ERRORED`.
	Status string `json:"status"`
}

// InboundPlanSummary A light-weight inbound plan.
type InboundPlanSummary struct {
	// CreatedAt The time at which the inbound plan was created. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with pattern `yyyy-MM-ddTHH:mm:ssZ`.
	CreatedAt time.Time `json:"createdAt"`

	// InboundPlanId Identifier of an inbound plan.
	InboundPlanId string `json:"inboundPlanId"`

	// LastUpdatedAt The time at which the inbound plan was last updated. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with pattern `yyyy-MM-ddTHH:mm:ssZ`.
	LastUpdatedAt time.Time `json:"lastUpdatedAt"`

	// MarketplaceIds A list of marketplace IDs.
	MarketplaceIds []string `json:"marketplaceIds"`

	// Name Human-readable name of the inbound plan.
	Name string `json:"name"`

	// SourceAddress Specific details to identify a place.
	SourceAddress Address `json:"sourceAddress"`

	// Status The current status of the inbound plan. Possible values: `ACTIVE`, `VOIDED`, `SHIPPED`, `ERRORED`.
	Status string `json:"status"`
}

// Incentive Contains details about cost related modifications to the placement cost.
type Incentive struct {
	// Description Description of the incentive.
	Description string `json:"description"`

	// Target Target of the incentive. Possible values: 'Placement Services', 'Fulfillment Fee Discount'.
	Target string `json:"target"`

	// Type Type of incentive. Possible values: `FEE`, `DISCOUNT`.
	Type string `json:"type"`

	// Value The type and amount of currency.
	Value Currency `json:"value"`
}

// Item Information associated with a single SKU in the seller's catalog.
type Item struct {
	// Asin The Amazon Standard Identification Number (ASIN) of the item.
	Asin string `json:"asin"`

	// Expiration The expiration date of the MSKU. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with pattern`YYYY-MM-DD`. The same MSKU with different expiration dates cannot go into the same box.
	Expiration *string `json:"expiration,omitempty"`

	// Fnsku A unique identifier assigned by Amazon to products stored in and fulfilled from an Amazon fulfillment center.
	Fnsku string `json:"fnsku"`

	// LabelOwner Specifies who will label the items. Options include `AMAZON`, `SELLER`, and `NONE`.
	LabelOwner string `json:"labelOwner"`

	// ManufacturingLotCode The manufacturing lot code.
	ManufacturingLotCode *string `json:"manufacturingLotCode,omitempty"`

	// Msku The merchant SKU, a merchant-supplied identifier of a specific SKU.
	Msku string `json:"msku"`

	// PrepInstructions Special preparations that are required for an item.
	PrepInstructions []PrepInstruction `json:"prepInstructions"`

	// Quantity The number of the specified MSKU.
	Quantity int `json:"quantity"`
}

// ItemInput Defines an item's input parameters.
type ItemInput struct {
	// Expiration The expiration date of the MSKU. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with pattern `YYYY-MM-DD`. Items with the same MSKU but different expiration dates cannot go into the same box.
	Expiration *string `json:"expiration,omitempty"`

	// LabelOwner Specifies who will label the items. Options include `AMAZON`, `SELLER` or `NONE`.
	LabelOwner LabelOwner `json:"labelOwner"`

	// ManufacturingLotCode The manufacturing lot code.
	ManufacturingLotCode *string `json:"manufacturingLotCode,omitempty"`

	// Msku The merchant SKU, a merchant-supplied identifier of a specific SKU.
	Msku string `json:"msku"`

	// PrepOwner The owner of the preparations, if special preparations are required.
	PrepOwner PrepOwner `json:"prepOwner"`

	// Quantity The number of units of the specified MSKU that will be shipped.
	Quantity int `json:"quantity"`
}

// ItemLabelPageType The page type to use to print the labels. Possible values: 'A4_21', 'A4_24', 'A4_24_64x33', 'A4_24_66x35', 'A4_24_70x36', 'A4_24_70x37', 'A4_24i', 'A4_27', 'A4_40_52x29', 'A4_44_48x25', 'Letter_30'.
type ItemLabelPageType string

// LabelOwner Specifies who will label the items. Options include `AMAZON`, `SELLER` or `NONE`.
type LabelOwner string

// LabelPrintType Indicates the type of print type for a given label.
type LabelPrintType string

// ListDeliveryWindowOptionsResponse The `listDeliveryWindowOptions` response.
type ListDeliveryWindowOptionsResponse struct {
	// DeliveryWindowOptions Delivery window options generated for the placement option.
	DeliveryWindowOptions []DeliveryWindowOption `json:"deliveryWindowOptions"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListInboundPlanBoxesResponse The `listInboundPlanBoxes` response.
type ListInboundPlanBoxesResponse struct {
	// Boxes A list of boxes in an inbound plan.
	Boxes []Box `json:"boxes"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListInboundPlanItemsResponse The `listInboundPlanItems` response.
type ListInboundPlanItemsResponse struct {
	// Items The items in an inbound plan.
	Items []Item `json:"items"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListInboundPlanPalletsResponse The `listInboundPlanPallets` response.
type ListInboundPlanPalletsResponse struct {
	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`

	// Pallets The pallets in an inbound plan.
	Pallets []Pallet `json:"pallets"`
}

// ListInboundPlansResponse The `listInboundPlans` response.
type ListInboundPlansResponse struct {
	// InboundPlans A list of inbound plans with minimal information.
	InboundPlans *[]InboundPlanSummary `json:"inboundPlans,omitempty"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListItemComplianceDetailsResponse The `listItemComplianceDetails` response.
type ListItemComplianceDetailsResponse struct {
	// ComplianceDetails List of compliance details.
	ComplianceDetails *[]ComplianceDetail `json:"complianceDetails,omitempty"`
}

// ListPackingGroupBoxesResponse The `listPackingGroupBoxes` response.
type ListPackingGroupBoxesResponse struct {
	// Boxes Provides the information about the list of boxes in the packing group.
	Boxes []Box `json:"boxes"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListPackingGroupItemsResponse The `listPackingGroupItems` response.
type ListPackingGroupItemsResponse struct {
	// Items Provides the information about the list of items in the packing group.
	Items []Item `json:"items"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListPackingOptionsResponse The `listPlacementOptions` response.
type ListPackingOptionsResponse struct {
	// PackingOptions List of packing options.
	PackingOptions []PackingOption `json:"packingOptions"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListPlacementOptionsResponse The `listPlacementOptions` response.
type ListPlacementOptionsResponse struct {
	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`

	// PlacementOptions Placement options generated for the inbound plan.
	PlacementOptions []PlacementOption `json:"placementOptions"`
}

// ListPrepDetailsResponse The response to the `listPrepDetails` operation.
type ListPrepDetailsResponse struct {
	// MskuPrepDetails A list of MSKUs and related prep details.
	MskuPrepDetails []MskuPrepDetail `json:"mskuPrepDetails"`
}

// ListShipmentBoxesResponse The `listShipmentBoxes` response.
type ListShipmentBoxesResponse struct {
	// Boxes A list of boxes in a shipment.
	Boxes []Box `json:"boxes"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListShipmentContentUpdatePreviewsResponse The `ListShipmentContentUpdatePreviews` response.
type ListShipmentContentUpdatePreviewsResponse struct {
	// ContentUpdatePreviews A list of content update previews in a shipment.
	ContentUpdatePreviews []ContentUpdatePreview `json:"contentUpdatePreviews"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListShipmentItemsResponse The `listShipmentItems` response.
type ListShipmentItemsResponse struct {
	// Items The items in a shipment.
	Items []Item `json:"items"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListShipmentPalletsResponse The `listShipmentPallets` response.
type ListShipmentPalletsResponse struct {
	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`

	// Pallets The pallets in a shipment.
	Pallets []Pallet `json:"pallets"`
}

// ListTransportationOptionsResponse The `listTransportationOptions` response.
type ListTransportationOptionsResponse struct {
	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`

	// TransportationOptions Transportation options generated for the placement option.
	TransportationOptions []TransportationOption `json:"transportationOptions"`
}

// LtlTrackingDetail Contains information related to Less-Than-Truckload (LTL) shipment tracking.
type LtlTrackingDetail struct {
	// BillOfLadingNumber The number of the carrier shipment acknowledgement document.
	BillOfLadingNumber *string `json:"billOfLadingNumber,omitempty"`

	// FreightBillNumber The number associated with the freight bill.
	FreightBillNumber *[]string `json:"freightBillNumber,omitempty"`
}

// LtlTrackingDetailInput Contains input information to update Less-Than-Truckload (LTL) tracking information.
type LtlTrackingDetailInput struct {
	// BillOfLadingNumber The number of the carrier shipment acknowledgement document.
	BillOfLadingNumber *string `json:"billOfLadingNumber,omitempty"`

	// FreightBillNumber Number associated with the freight bill.
	FreightBillNumber []string `json:"freightBillNumber"`
}

// MskuPrepDetail An MSKU and its related prep details.
type MskuPrepDetail struct {
	// AllOwnersConstraint A constraint that applies to all owners. If no constraint is specified, defer to any individual owner constraints.
	AllOwnersConstraint *AllOwnersConstraint `json:"allOwnersConstraint,omitempty"`

	// LabelOwnerConstraint A constraint that can apply to an individual owner. If no constraint is specified, both `AMAZON` and `SELLER` are acceptable.
	LabelOwnerConstraint *OwnerConstraint `json:"labelOwnerConstraint,omitempty"`

	// Msku The merchant SKU, a merchant-supplied identifier for a specific SKU.
	Msku string `json:"msku"`

	// PrepCategory The preparation category for shipping an item to Amazon's fulfillment network.
	PrepCategory PrepCategory `json:"prepCategory"`

	// PrepOwnerConstraint A constraint that can apply to an individual owner. If no constraint is specified, both `AMAZON` and `SELLER` are acceptable.
	PrepOwnerConstraint *OwnerConstraint `json:"prepOwnerConstraint,omitempty"`

	// PrepTypes A list of preparation types associated with a preparation category.
	PrepTypes []PrepType `json:"prepTypes"`
}

// MskuPrepDetailInput An MSKU and its related prep details.
type MskuPrepDetailInput struct {
	// Msku The merchant SKU, a merchant-supplied identifier for a specific SKU.
	Msku string `json:"msku"`

	// PrepCategory The preparation category for shipping an item to Amazon's fulfillment network.
	PrepCategory PrepCategory `json:"prepCategory"`

	// PrepTypes A list of preparation types associated with a preparation category.
	PrepTypes []PrepType `json:"prepTypes"`
}

// MskuQuantity Represents an MSKU and the related quantity.
type MskuQuantity struct {
	// Msku The merchant SKU, a merchant-supplied identifier for a specific SKU.
	Msku string `json:"msku"`

	// Quantity A positive integer.
	Quantity int `json:"quantity"`
}

// OperationProblem A problem with additional properties persisted to an operation.
type OperationProblem struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`

	// Severity The severity of the problem. Possible values: `WARNING`, `ERROR`.
	Severity string `json:"severity"`
}

// OperationStatus The status of an operation.
type OperationStatus string

// OwnerConstraint A constraint that can apply to an individual owner. If no constraint is specified, both `AMAZON` and `SELLER` are acceptable.
type OwnerConstraint string

// PackageGroupingInput Packing information for the inbound plan.
type PackageGroupingInput struct {
	// Boxes Box level information being provided.
	Boxes []BoxInput `json:"boxes"`

	// PackingGroupId The ID of the `packingGroup` that packages are grouped according to. The `PackingGroupId` can only be provided before placement confirmation, and it must belong to the confirmed `PackingOption`. One of `ShipmentId` or `PackingGroupId` must be provided with every request.
	PackingGroupId *string `json:"packingGroupId,omitempty"`

	// ShipmentId The ID of the shipment that packages are grouped according to. The `ShipmentId` can only be provided after placement confirmation, and the shipment must belong to the confirmed placement option. One of `ShipmentId` or `PackingGroupId` must be provided with every request.
	ShipmentId *string `json:"shipmentId,omitempty"`
}

// PackingConfiguration A way to configure this packing option. Some box content information sources might not be allowed. Non-standard minimum and maximum box weights might be enforced.
type PackingConfiguration struct {
	// BoxPackingMethods The box content information sources that are allowed.
	BoxPackingMethods *[]BoxContentInformationSource `json:"boxPackingMethods,omitempty"`

	// BoxRequirements The requirements for a box in the packing option.
	BoxRequirements *BoxRequirements `json:"boxRequirements,omitempty"`

	// ShippingRequirements A list of supported shipping requirements for this packing configuration.
	ShippingRequirements *[]ShippingRequirements `json:"shippingRequirements,omitempty"`
}

// PackingOption A packing option contains a set of pack groups plus additional information about the packing option, such as any discounts or fees if it's selected.
type PackingOption struct {
	// Discounts Discount for the offered option.
	Discounts []Incentive `json:"discounts"`

	// Expiration The time at which this packing option is no longer valid. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	Expiration *time.Time `json:"expiration,omitempty"`

	// Fees Fee for the offered option.
	Fees []Incentive `json:"fees"`

	// PackingGroups Packing group IDs.
	PackingGroups []string `json:"packingGroups"`

	// PackingOptionId Identifier of a packing option.
	PackingOptionId string `json:"packingOptionId"`

	// Status The status of the packing option. Possible values: `OFFERED`, `ACCEPTED`, `EXPIRED`.
	Status string `json:"status"`

	// SupportedConfigurations A list of possible configurations for this option.
	SupportedConfigurations []PackingConfiguration `json:"supportedConfigurations"`

	// SupportedShippingConfigurations **This field is deprecated**. Use the `shippingRequirements` property under `supportedConfigurations` instead. List of supported shipping modes.
	SupportedShippingConfigurations []ShippingConfiguration `json:"supportedShippingConfigurations"`
}

// PackingOptionSummary Summary information about a packing option.
type PackingOptionSummary struct {
	// PackingOptionId Identifier of a packing option.
	PackingOptionId string `json:"packingOptionId"`

	// Status The status of a packing option. Possible values: 'OFFERED', 'ACCEPTED', 'EXPIRED'.
	Status string `json:"status"`
}

// Pagination Contains tokens to fetch from a certain page.
type Pagination struct {
	// NextToken When present, pass this string token in the next request to return the next response page.
	NextToken *string `json:"nextToken,omitempty"`
}

// Pallet Contains information about a pallet that is used in the inbound plan. The pallet is a container that holds multiple items or boxes.
type Pallet struct {
	// Dimensions Measurement of a package's dimensions.
	Dimensions *Dimensions `json:"dimensions,omitempty"`

	// PackageId Primary key to uniquely identify a Package (Box or Pallet).
	PackageId string `json:"packageId"`

	// Quantity The number of containers where all other properties like weight or dimensions are identical.
	Quantity *int `json:"quantity,omitempty"`

	// Stackability Indicates whether pallets will be stacked when carrier arrives for pick-up.
	Stackability *Stackability `json:"stackability,omitempty"`

	// Weight The weight of a package.
	Weight *Weight `json:"weight,omitempty"`
}

// PalletInput Contains input information about a pallet to be used in the inbound plan.
type PalletInput struct {
	// Dimensions Measurement of a package's dimensions.
	Dimensions *Dimensions `json:"dimensions,omitempty"`

	// Quantity The number of containers where all other properties like weight or dimensions are identical.
	Quantity int `json:"quantity"`

	// Stackability Indicates whether pallets will be stacked when carrier arrives for pick-up.
	Stackability *Stackability `json:"stackability,omitempty"`

	// Weight The weight of a package.
	Weight *Weight `json:"weight,omitempty"`
}

// PlacementOption Contains information pertaining to the placement of the contents of an inbound plan and the related costs.
type PlacementOption struct {
	// Discounts Discount for the offered option.
	Discounts []Incentive `json:"discounts"`

	// Expiration The expiration date of the placement option. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	Expiration *time.Time `json:"expiration,omitempty"`

	// Fees The fee for the offered option.
	Fees []Incentive `json:"fees"`

	// PlacementOptionId The identifier of a placement option. A placement option represents the shipment splits and destinations of SKUs.
	PlacementOptionId string `json:"placementOptionId"`

	// ShipmentIds Shipment ids.
	ShipmentIds []string `json:"shipmentIds"`

	// Status The status of a placement option. Possible values: `OFFERED`, `ACCEPTED`, `EXPIRED`.
	Status string `json:"status"`
}

// PlacementOptionSummary Summary information about a placement option.
type PlacementOptionSummary struct {
	// PlacementOptionId The identifier of a placement option. A placement option represents the shipment splits and destinations of SKUs.
	PlacementOptionId string `json:"placementOptionId"`

	// Status The status of a placement option. Possible values: `OFFERED`, `ACCEPTED`.
	Status string `json:"status"`
}

// PrepCategory The preparation category for shipping an item to Amazon's fulfillment network.
type PrepCategory string

// PrepInstruction Information pertaining to the preparation of inbound goods.
type PrepInstruction struct {
	// Fee The type and amount of currency.
	Fee *Currency `json:"fee,omitempty"`

	// PrepOwner In some situations, special preparations are required for items and this field reflects the owner of the preparations. Options include `AMAZON`, `SELLER` or `NONE`.
	PrepOwner *string `json:"prepOwner,omitempty"`

	// PrepType Type of preparation that should be done.
	//
	// Possible values: `ITEM_LABELING`, `ITEM_BUBBLEWRAP`, `ITEM_POLYBAGGING`, `ITEM_TAPING`, `ITEM_BLACK_SHRINKWRAP`, `ITEM_HANG_GARMENT`, `ITEM_BOXING`, `ITEM_SETCREAT`, `ITEM_RMOVHANG`, `ITEM_SUFFOSTK`, `ITEM_CAP_SEALING`, `ITEM_DEBUNDLE`, `ITEM_SETSTK`, `ITEM_SIOC`, `ITEM_NO_PREP`, `ADULT`, `BABY`, `TEXTILE`, `HANGER`, `FRAGILE`, `LIQUID`, `SHARP`, `SMALL`, `PERFORATED`, `GRANULAR`, `SET`, `FC_PROVIDED`, `UNKNOWN`, `NONE`.
	PrepType *string `json:"prepType,omitempty"`
}

// PrepOwner The owner of the preparations, if special preparations are required.
type PrepOwner string

// PrepType Preparation instructions for shipping an item to Amazon's fulfillment network. For more information about preparing items for shipment to Amazon's fulfillment network, refer to [Seller Central Help for your marketplace](https://developer-docs.amazon.com/sp-api/docs/seller-central-urls).
type PrepType string

// Quote The estimated shipping cost associated with the transportation option.
type Quote struct {
	// Cost The type and amount of currency.
	Cost Currency `json:"cost"`

	// Expiration The time at which this transportation option quote expires. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	Expiration *time.Time `json:"expiration,omitempty"`

	// VoidableUntil Voidable until timestamp.
	VoidableUntil *time.Time `json:"voidableUntil,omitempty"`
}

// ReasonComment Reason for cancelling or rescheduling a self-ship appointment.
type ReasonComment string

// Region Representation of a location used within the inbounding experience.
type Region struct {
	// CountryCode ISO 3166 standard alpha-2 country code.
	CountryCode *string `json:"countryCode,omitempty"`

	// State State.
	State *string `json:"state,omitempty"`

	// WarehouseId An identifier for a warehouse, such as a FC, IXD, upstream storage.
	WarehouseId *string `json:"warehouseId,omitempty"`
}

// RequestedUpdates Objects that were included in the update request.
type RequestedUpdates struct {
	// Boxes A list of boxes that will be present in the shipment after the update.
	Boxes *[]BoxUpdateInput `json:"boxes,omitempty"`

	// Items A list of all items that will be present in the shipment after the update.
	Items *[]ItemInput `json:"items,omitempty"`
}

// ScheduleSelfShipAppointmentRequest The `scheduleSelfShipAppointment` request.
type ScheduleSelfShipAppointmentRequest struct {
	// ReasonComment Reason for cancelling or rescheduling a self-ship appointment.
	ReasonComment *ReasonComment `json:"reasonComment,omitempty"`
}

// ScheduleSelfShipAppointmentResponse The `scheduleSelfShipAppointment` response.
type ScheduleSelfShipAppointmentResponse struct {
	// SelfShipAppointmentDetails Appointment details for carrier pickup or fulfillment center appointments.
	SelfShipAppointmentDetails SelfShipAppointmentDetails `json:"selfShipAppointmentDetails"`
}

// SelectedDeliveryWindow Selected delivery window attributes.
type SelectedDeliveryWindow struct {
	// AvailabilityType Identifies type of Delivery Window Availability. Values: `AVAILABLE`, `CONGESTED`
	AvailabilityType string `json:"availabilityType"`

	// DeliveryWindowOptionId Identifier of a delivery window option. A delivery window option represent one option for when a shipment is expected to be delivered.
	DeliveryWindowOptionId string `json:"deliveryWindowOptionId"`

	// EditableUntil The timestamp at which this Window can no longer be edited.
	EditableUntil *time.Time `json:"editableUntil,omitempty"`

	// EndDate The end timestamp of the window.
	EndDate time.Time `json:"endDate"`

	// StartDate The start timestamp of the window.
	StartDate time.Time `json:"startDate"`
}

// SelfShipAppointmentDetails Appointment details for carrier pickup or fulfillment center appointments.
type SelfShipAppointmentDetails struct {
	// AppointmentId Identifier for appointment.
	AppointmentId *float32 `json:"appointmentId,omitempty"`

	// AppointmentSlotTime An appointment slot time with start and end.
	AppointmentSlotTime *AppointmentSlotTime `json:"appointmentSlotTime,omitempty"`

	// AppointmentStatus Status of the appointment.
	AppointmentStatus *string `json:"appointmentStatus,omitempty"`
}

// SelfShipAppointmentSlotsAvailability The self ship appointment time slots availability and an expiration date for which the slots can be scheduled.
type SelfShipAppointmentSlotsAvailability struct {
	// ExpiresAt The time at which the self ship appointment slot expires. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Slots A list of appointment slots.
	Slots *[]AppointmentSlot `json:"slots,omitempty"`
}

// SetPackingInformationRequest The `setPackingInformation` request.
type SetPackingInformationRequest struct {
	// PackageGroupings List of packing information for the inbound plan.
	PackageGroupings []PackageGroupingInput `json:"packageGroupings"`
}

// SetPackingInformationResponse The `setPackingInformation` response.
type SetPackingInformationResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// SetPrepDetailsRequest The `setPrepDetails` request.
type SetPrepDetailsRequest struct {
	// MarketplaceId The marketplace ID. For a list of possible values, refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids).
	MarketplaceId string `json:"marketplaceId"`

	// MskuPrepDetails A list of MSKUs and related prep details.
	MskuPrepDetails []MskuPrepDetailInput `json:"mskuPrepDetails"`
}

// SetPrepDetailsResponse The `setPrepDetails` response.
type SetPrepDetailsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// Shipment Contains information pertaining to a shipment in an inbound plan.
type Shipment struct {
	// AmazonReferenceId A unique identifier created by Amazon that identifies this Amazon-partnered, Less Than Truckload/Full Truckload (LTL/FTL) shipment.
	AmazonReferenceId *string `json:"amazonReferenceId,omitempty"`

	// ContactInformation The seller's contact information.
	ContactInformation *ContactInformation `json:"contactInformation,omitempty"`

	// Dates Specifies the date that the seller expects their shipment will be shipped.
	Dates *Dates `json:"dates,omitempty"`

	// Destination The Amazon fulfillment center address and warehouse ID.
	Destination ShipmentDestination `json:"destination"`

	// FreightInformation Freight information describes the skus being transported. Freight carrier options and quotes will only be returned if the freight information is provided.
	FreightInformation *FreightInformation `json:"freightInformation,omitempty"`

	// Name The name of the shipment.
	Name *string `json:"name,omitempty"`

	// PlacementOptionId The identifier of a placement option. A placement option represents the shipment splits and destinations of SKUs.
	PlacementOptionId string `json:"placementOptionId"`

	// SelectedDeliveryWindow Selected delivery window attributes.
	SelectedDeliveryWindow *SelectedDeliveryWindow `json:"selectedDeliveryWindow,omitempty"`

	// SelectedTransportationOptionId Identifier of a transportation option. A transportation option represent one option for how to send a shipment.
	SelectedTransportationOptionId *string `json:"selectedTransportationOptionId,omitempty"`

	// SelfShipAppointmentDetails List of self ship appointment details.
	SelfShipAppointmentDetails *[]SelfShipAppointmentDetails `json:"selfShipAppointmentDetails,omitempty"`

	// ShipmentConfirmationId The confirmed shipment ID which shows up on labels (for example, `FBA1234ABCD`).
	ShipmentConfirmationId *string `json:"shipmentConfirmationId,omitempty"`

	// ShipmentId Identifier of a shipment. A shipment contains the boxes and units being inbounded.
	ShipmentId string `json:"shipmentId"`

	// Source Specifies the 'ship from' address for the shipment.
	Source ShipmentSource `json:"source"`

	// Status The status of a shipment. The state of the shipment will typically start as `UNCONFIRMED`, then transition to `WORKING` after a placement option has been confirmed, and then to `READY_TO_SHIP` once labels are generated.
	//
	// Possible values: `ABANDONED`, `CANCELLED`, `CHECKED_IN`, `CLOSED`, `DELETED`, `DELIVERED`, `IN_TRANSIT`, `MIXED`, `READY_TO_SHIP`, `RECEIVING`, `SHIPPED`, `UNCONFIRMED`, `WORKING`
	Status *string `json:"status,omitempty"`

	// TrackingDetails Tracking information for Less-Than-Truckload (LTL) and Small Parcel Delivery (SPD) shipments.
	TrackingDetails *TrackingDetails `json:"trackingDetails,omitempty"`
}

// ShipmentDestination The Amazon fulfillment center address and warehouse ID.
type ShipmentDestination struct {
	// Address Specific details to identify a place.
	Address *Address `json:"address,omitempty"`

	// DestinationType The type of destination for this shipment. Possible values: `AMAZON_OPTIMIZED`, `AMAZON_WAREHOUSE`.
	DestinationType string `json:"destinationType"`

	// WarehouseId The warehouse that the shipment should be sent to. Empty if the destination type is `AMAZON_OPTIMIZED`.
	WarehouseId *string `json:"warehouseId,omitempty"`
}

// ShipmentSource Specifies the 'ship from' address for the shipment.
type ShipmentSource struct {
	// Address Specific details to identify a place.
	Address *Address `json:"address,omitempty"`

	// SourceType The type of source for this shipment. Possible values: `SELLER_FACILITY`.
	SourceType string `json:"sourceType"`
}

// ShipmentSummary Summary information about a shipment.
type ShipmentSummary struct {
	// ShipmentId Identifier of a shipment. A shipment contains the boxes and units being inbounded.
	ShipmentId string `json:"shipmentId"`

	// Status The status of a shipment. The state of the shipment will typically start as `UNCONFIRMED`, then transition to `WORKING` after a placement option has been confirmed, and then to `READY_TO_SHIP` once labels are generated.
	//
	// Possible values: `ABANDONED`, `CANCELLED`, `CHECKED_IN`, `CLOSED`, `DELETED`, `DELIVERED`, `IN_TRANSIT`, `MIXED`, `READY_TO_SHIP`, `RECEIVING`, `SHIPPED`, `UNCONFIRMED`, `WORKING`
	Status string `json:"status"`
}

// ShipmentTransportationConfiguration Details needed to generate the transportation options.
type ShipmentTransportationConfiguration struct {
	// ContactInformation The seller's contact information.
	ContactInformation *ContactInformation `json:"contactInformation,omitempty"`

	// FreightInformation Freight information describes the skus being transported. Freight carrier options and quotes will only be returned if the freight information is provided.
	FreightInformation *FreightInformation `json:"freightInformation,omitempty"`

	// Pallets List of pallet configuration inputs.
	Pallets *[]PalletInput `json:"pallets,omitempty"`

	// ReadyToShipWindow Contains only a starting DateTime.
	ReadyToShipWindow WindowInput `json:"readyToShipWindow"`

	// ShipmentId Identifier of a shipment. A shipment contains the boxes and units being inbounded.
	ShipmentId string `json:"shipmentId"`
}

// ShippingConfiguration The shipping configurations supported for the packing option. Available modes are ground small parcel, freight less-than-truckload (LTL), freight full-truckload (FTL) palletized, freight FTL non-palletized, ocean less-than-container-load (LCL), ocean full-container load (FCL), air small parcel, and air small parcel express.
type ShippingConfiguration struct {
	// ShippingMode Mode of shipment transportation that this option will provide.
	//
	// Possible values: `GROUND_SMALL_PARCEL`, `FREIGHT_LTL`, `FREIGHT_FTL_PALLET`, `FREIGHT_FTL_NONPALLET`, `OCEAN_LCL`, `OCEAN_FCL`, `AIR_SMALL_PARCEL`, `AIR_SMALL_PARCEL_EXPRESS`.
	ShippingMode *string `json:"shippingMode,omitempty"`

	// ShippingSolution Shipping program for the option. Possible values: `AMAZON_PARTNERED_CARRIER`, `USE_YOUR_OWN_CARRIER`.
	ShippingSolution *string `json:"shippingSolution,omitempty"`
}

// ShippingRequirements The possible shipping modes for the packing option for a given shipping solution or program. Available solutions are Amazon-Partnered Carrier and Use Your Own Carrier. Available modes are ground small parcel, freight less-than-truckload (LTL), freight full-truckload (FTL) palletized, freight FTL non-palletized, ocean less-than-container-load (LCL), ocean full-container load (FCL), air small parcel, and air small parcel express.
type ShippingRequirements struct {
	// Modes Available shipment modes for this shipping program.
	Modes []string `json:"modes"`

	// Solution Shipping program for the option. Can be: `AMAZON_PARTNERED_CARRIER`, `USE_YOUR_OWN_CARRIER`.
	Solution string `json:"solution"`
}

// SpdTrackingDetail Contains information related to Small Parcel Delivery (SPD) shipment tracking.
type SpdTrackingDetail struct {
	// SpdTrackingItems List of Small Parcel Delivery (SPD) tracking items.
	SpdTrackingItems *[]SpdTrackingItem `json:"spdTrackingItems,omitempty"`
}

// SpdTrackingDetailInput Contains input information to update Small Parcel Delivery (SPD) tracking information.
type SpdTrackingDetailInput struct {
	// SpdTrackingItems List of Small Parcel Delivery (SPD) tracking items input.
	SpdTrackingItems []SpdTrackingItemInput `json:"spdTrackingItems"`
}

// SpdTrackingItem Contains information used to track and identify a Small Parcel Delivery (SPD) item.
type SpdTrackingItem struct {
	// BoxId The ID provided by Amazon that identifies a given box. This ID is comprised of the external shipment ID (which is generated after transportation has been confirmed) and the index of the box.
	BoxId *string `json:"boxId,omitempty"`

	// TrackingId The tracking ID associated with each box in a non-Amazon partnered Small Parcel Delivery (SPD) shipment.
	TrackingId *string `json:"trackingId,omitempty"`

	// TrackingNumberValidationStatus Whether or not Amazon has validated the tracking number. If more than 24 hours have passed and the status is not yet 'VALIDATED', please verify the number and update if necessary. Possible values: `VALIDATED`, `NOT_VALIDATED`.
	TrackingNumberValidationStatus *string `json:"trackingNumberValidationStatus,omitempty"`
}

// SpdTrackingItemInput Small Parcel Delivery (SPD) tracking items input information.
type SpdTrackingItemInput struct {
	// BoxId The ID provided by Amazon that identifies a given box. This ID is comprised of the external shipment ID (which is generated after transportation has been confirmed) and the index of the box.
	BoxId string `json:"boxId"`

	// TrackingId The tracking Id associated with each box in a non-Amazon partnered Small Parcel Delivery (SPD) shipment. The seller must provide this information.
	TrackingId string `json:"trackingId"`
}

// Stackability Indicates whether pallets will be stacked when carrier arrives for pick-up.
type Stackability string

// TaxDetails Information used to determine the tax compliance.
type TaxDetails struct {
	// DeclaredValue The type and amount of currency.
	DeclaredValue *Currency `json:"declaredValue,omitempty"`

	// HsnCode Harmonized System of Nomenclature code.
	HsnCode *string `json:"hsnCode,omitempty"`

	// TaxRates List of tax rates.
	TaxRates *[]TaxRate `json:"taxRates,omitempty"`
}

// TaxRate Contains the type and rate of tax.
type TaxRate struct {
	// CessRate Rate of cess tax.
	CessRate *float32 `json:"cessRate,omitempty"`

	// GstRate Rate of gst tax.
	GstRate *float32 `json:"gstRate,omitempty"`

	// TaxType Type of tax. Possible values: `CGST`, `SGST`, `IGST`, `TOTAL_TAX`.
	TaxType *string `json:"taxType,omitempty"`
}

// TrackingDetails Tracking information for Less-Than-Truckload (LTL) and Small Parcel Delivery (SPD) shipments.
type TrackingDetails struct {
	// LtlTrackingDetail Contains information related to Less-Than-Truckload (LTL) shipment tracking.
	LtlTrackingDetail *LtlTrackingDetail `json:"ltlTrackingDetail,omitempty"`

	// SpdTrackingDetail Contains information related to Small Parcel Delivery (SPD) shipment tracking.
	SpdTrackingDetail *SpdTrackingDetail `json:"spdTrackingDetail,omitempty"`
}

// TrackingDetailsInput Tracking information input for Less-Than-Truckload (LTL) and Small Parcel Delivery (SPD) shipments.
type TrackingDetailsInput struct {
	// LtlTrackingDetail Contains input information to update Less-Than-Truckload (LTL) tracking information.
	LtlTrackingDetail *LtlTrackingDetailInput `json:"ltlTrackingDetail,omitempty"`

	// SpdTrackingDetail Contains input information to update Small Parcel Delivery (SPD) tracking information.
	SpdTrackingDetail *SpdTrackingDetailInput `json:"spdTrackingDetail,omitempty"`
}

// TransportationOption Contains information pertaining to a transportation option and the related carrier.
type TransportationOption struct {
	// Carrier The carrier for the inbound shipment.
	Carrier Carrier `json:"carrier"`

	// CarrierAppointment Contains details for a transportation carrier appointment. This appointment is vended out by Amazon and is an indicator for when a transportation carrier is accepting shipments to be picked up.
	CarrierAppointment *CarrierAppointment `json:"carrierAppointment,omitempty"`

	// Preconditions Identifies a list of preconditions for confirming the transportation option.
	Preconditions []string `json:"preconditions"`

	// Quote The estimated shipping cost associated with the transportation option.
	Quote *Quote `json:"quote,omitempty"`

	// ShipmentId Identifier of a shipment. A shipment contains the boxes and units being inbounded.
	ShipmentId string `json:"shipmentId"`

	// ShippingMode Mode of shipment transportation that this option will provide.
	//
	// Possible values: `GROUND_SMALL_PARCEL`, `FREIGHT_LTL`, `FREIGHT_FTL_PALLET`, `FREIGHT_FTL_NONPALLET`, `OCEAN_LCL`, `OCEAN_FCL`, `AIR_SMALL_PARCEL`, `AIR_SMALL_PARCEL_EXPRESS`.
	ShippingMode string `json:"shippingMode"`

	// ShippingSolution Shipping program for the option. Possible values: `AMAZON_PARTNERED_CARRIER`, `USE_YOUR_OWN_CARRIER`.
	ShippingSolution string `json:"shippingSolution"`

	// TransportationOptionId Identifier of a transportation option. A transportation option represent one option for how to send a shipment.
	TransportationOptionId string `json:"transportationOptionId"`
}

// TransportationSelection The transportation option selected to confirm.
type TransportationSelection struct {
	// ContactInformation The seller's contact information.
	ContactInformation *ContactInformation `json:"contactInformation,omitempty"`

	// ShipmentId Shipment ID that the transportation Option is for.
	ShipmentId string `json:"shipmentId"`

	// TransportationOptionId Transportation option being selected for the provided shipment.
	TransportationOptionId string `json:"transportationOptionId"`
}

// UnitOfMeasurement Unit of linear measure.
type UnitOfMeasurement string

// UnitOfWeight Unit of the weight being measured.
type UnitOfWeight string

// UpdateInboundPlanNameRequest The `updateInboundPlanName` request.
type UpdateInboundPlanNameRequest struct {
	// Name A human-readable name to update the inbound plan name to.
	Name string `json:"name"`
}

// UpdateItemComplianceDetailsRequest The `updateItemComplianceDetails` request.
type UpdateItemComplianceDetailsRequest struct {
	// Msku The merchant SKU, a merchant-supplied identifier for a specific SKU.
	Msku string `json:"msku"`

	// TaxDetails Information used to determine the tax compliance.
	TaxDetails TaxDetails `json:"taxDetails"`
}

// UpdateItemComplianceDetailsResponse The `updateItemComplianceDetails` response.
type UpdateItemComplianceDetailsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// UpdateShipmentNameRequest The `updateShipmentName` request.
type UpdateShipmentNameRequest struct {
	// Name A human-readable name to update the shipment name to.
	Name string `json:"name"`
}

// UpdateShipmentSourceAddressRequest The `UpdateShipmentSourceAddress` request.
type UpdateShipmentSourceAddressRequest struct {
	// Address Specific details to identify a place.
	Address AddressInput `json:"address"`
}

// UpdateShipmentSourceAddressResponse The `UpdateShipmentSourceAddress` response.
type UpdateShipmentSourceAddressResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// UpdateShipmentTrackingDetailsRequest The `updateShipmentTrackingDetails` request.
type UpdateShipmentTrackingDetailsRequest struct {
	// TrackingDetails Tracking information input for Less-Than-Truckload (LTL) and Small Parcel Delivery (SPD) shipments.
	TrackingDetails TrackingDetailsInput `json:"trackingDetails"`
}

// UpdateShipmentTrackingDetailsResponse The `updateShipmentTrackingDetails` response.
type UpdateShipmentTrackingDetailsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// Weight The weight of a package.
type Weight struct {
	// Unit Unit of the weight being measured.
	Unit UnitOfWeight `json:"unit"`

	// Value Value of a weight.
	Value float32 `json:"value"`
}

// WeightRange The range of weights that are allowed for a package.
type WeightRange struct {
	// Maximum Maximum allowed weight.
	Maximum float32 `json:"maximum"`

	// Minimum Minimum allowed weight.
	Minimum float32 `json:"minimum"`

	// Unit Unit of the weight being measured.
	Unit UnitOfWeight `json:"unit"`
}

// Window Contains a start and end DateTime representing a time range.
type Window struct {
	// EditableUntil The timestamp at which this Window can no longer be edited.
	EditableUntil *time.Time `json:"editableUntil,omitempty"`

	// End The end timestamp of the window.
	End time.Time `json:"end"`

	// Start The start timestamp of the window.
	Start time.Time `json:"start"`
}

// WindowInput Contains only a starting DateTime.
type WindowInput struct {
	// Start The start date of the window. In [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) datetime format with minute precision. Supports patterns `yyyy-MM-ddTHH:mmZ`, `yyyy-MM-ddTHH:mm:ssZ`, or `yyyy-MM-ddTHH:mm:ss.sssZ`. Note that non-zero second and millisecond components are removed.
	Start time.Time `json:"start"`
}

// ListInboundPlansParams defines parameters for ListInboundPlans.
type ListInboundPlansParams struct {
	// PageSize The number of inbound plans to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`

	// Status The status of an inbound plan.
	Status *ListInboundPlansParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// SortBy Sort by field.
	SortBy *ListInboundPlansParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder The sort order.
	SortOrder *ListInboundPlansParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// ListInboundPlansParamsStatus defines parameters for ListInboundPlans.
type ListInboundPlansParamsStatus string

// ListInboundPlansParamsSortBy defines parameters for ListInboundPlans.
type ListInboundPlansParamsSortBy string

// ListInboundPlansParamsSortOrder defines parameters for ListInboundPlans.
type ListInboundPlansParamsSortOrder string

// ListInboundPlanBoxesParams defines parameters for ListInboundPlanBoxes.
type ListInboundPlanBoxesParams struct {
	// PageSize The number of boxes to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListInboundPlanItemsParams defines parameters for ListInboundPlanItems.
type ListInboundPlanItemsParams struct {
	// PageSize The number of items to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListPackingGroupBoxesParams defines parameters for ListPackingGroupBoxes.
type ListPackingGroupBoxesParams struct {
	// PageSize The number of packing group boxes to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListPackingGroupItemsParams defines parameters for ListPackingGroupItems.
type ListPackingGroupItemsParams struct {
	// PageSize The number of packing group items to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListPackingOptionsParams defines parameters for ListPackingOptions.
type ListPackingOptionsParams struct {
	// PageSize The number of packing options to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListInboundPlanPalletsParams defines parameters for ListInboundPlanPallets.
type ListInboundPlanPalletsParams struct {
	// PageSize The number of pallets to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListPlacementOptionsParams defines parameters for ListPlacementOptions.
type ListPlacementOptionsParams struct {
	// PageSize The number of placement options to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListShipmentBoxesParams defines parameters for ListShipmentBoxes.
type ListShipmentBoxesParams struct {
	// PageSize The number of boxes to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListShipmentContentUpdatePreviewsParams defines parameters for ListShipmentContentUpdatePreviews.
type ListShipmentContentUpdatePreviewsParams struct {
	// PageSize The number of content update previews to return.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListDeliveryWindowOptionsParams defines parameters for ListDeliveryWindowOptions.
type ListDeliveryWindowOptionsParams struct {
	// PageSize The number of delivery window options to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListShipmentItemsParams defines parameters for ListShipmentItems.
type ListShipmentItemsParams struct {
	// PageSize The number of items to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListShipmentPalletsParams defines parameters for ListShipmentPallets.
type ListShipmentPalletsParams struct {
	// PageSize The number of pallets to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// GetSelfShipAppointmentSlotsParams defines parameters for GetSelfShipAppointmentSlots.
type GetSelfShipAppointmentSlotsParams struct {
	// PageSize The number of self ship appointment slots to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListTransportationOptionsParams defines parameters for ListTransportationOptions.
type ListTransportationOptionsParams struct {
	// PageSize The number of transportation options to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`

	// PlacementOptionId The placement option to get transportation options for. Either `placementOptionId` or `shipmentId` must be specified.
	PlacementOptionId *string `form:"placementOptionId,omitempty" json:"placementOptionId,omitempty"`

	// ShipmentId The shipment to get transportation options for. Either `placementOptionId` or `shipmentId` must be specified.
	ShipmentId *string `form:"shipmentId,omitempty" json:"shipmentId,omitempty"`
}

// ListItemComplianceDetailsParams defines parameters for ListItemComplianceDetails.
type ListItemComplianceDetailsParams struct {
	// Mskus A list of merchant SKUs, a merchant-supplied identifier of a specific SKU.
	Mskus []string `form:"mskus" json:"mskus"`

	// MarketplaceId The Marketplace ID. For a list of possible values, refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids).
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// UpdateItemComplianceDetailsParams defines parameters for UpdateItemComplianceDetails.
type UpdateItemComplianceDetailsParams struct {
	// MarketplaceId The Marketplace ID. For a list of possible values, refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids).
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// ListPrepDetailsParams defines parameters for ListPrepDetails.
type ListPrepDetailsParams struct {
	// MarketplaceId The marketplace ID. For a list of possible values, refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids).
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`

	// Mskus A list of merchant SKUs, a merchant-supplied identifier of a specific SKU.
	Mskus []string `form:"mskus" json:"mskus"`
}

// CreateInboundPlanJSONRequestBody defines body for CreateInboundPlan for application/json ContentType.
type CreateInboundPlanJSONRequestBody = CreateInboundPlanRequest

// UpdateInboundPlanNameJSONRequestBody defines body for UpdateInboundPlanName for application/json ContentType.
type UpdateInboundPlanNameJSONRequestBody = UpdateInboundPlanNameRequest

// SetPackingInformationJSONRequestBody defines body for SetPackingInformation for application/json ContentType.
type SetPackingInformationJSONRequestBody = SetPackingInformationRequest

// GeneratePlacementOptionsJSONRequestBody defines body for GeneratePlacementOptions for application/json ContentType.
type GeneratePlacementOptionsJSONRequestBody = GeneratePlacementOptionsRequest

// GenerateShipmentContentUpdatePreviewsJSONRequestBody defines body for GenerateShipmentContentUpdatePreviews for application/json ContentType.
type GenerateShipmentContentUpdatePreviewsJSONRequestBody = GenerateShipmentContentUpdatePreviewsRequest

// UpdateShipmentNameJSONRequestBody defines body for UpdateShipmentName for application/json ContentType.
type UpdateShipmentNameJSONRequestBody = UpdateShipmentNameRequest

// CancelSelfShipAppointmentJSONRequestBody defines body for CancelSelfShipAppointment for application/json ContentType.
type CancelSelfShipAppointmentJSONRequestBody = CancelSelfShipAppointmentRequest

// GenerateSelfShipAppointmentSlotsJSONRequestBody defines body for GenerateSelfShipAppointmentSlots for application/json ContentType.
type GenerateSelfShipAppointmentSlotsJSONRequestBody = GenerateSelfShipAppointmentSlotsRequest

// ScheduleSelfShipAppointmentJSONRequestBody defines body for ScheduleSelfShipAppointment for application/json ContentType.
type ScheduleSelfShipAppointmentJSONRequestBody = ScheduleSelfShipAppointmentRequest

// UpdateShipmentSourceAddressJSONRequestBody defines body for UpdateShipmentSourceAddress for application/json ContentType.
type UpdateShipmentSourceAddressJSONRequestBody = UpdateShipmentSourceAddressRequest

// UpdateShipmentTrackingDetailsJSONRequestBody defines body for UpdateShipmentTrackingDetails for application/json ContentType.
type UpdateShipmentTrackingDetailsJSONRequestBody = UpdateShipmentTrackingDetailsRequest

// GenerateTransportationOptionsJSONRequestBody defines body for GenerateTransportationOptions for application/json ContentType.
type GenerateTransportationOptionsJSONRequestBody = GenerateTransportationOptionsRequest

// ConfirmTransportationOptionsJSONRequestBody defines body for ConfirmTransportationOptions for application/json ContentType.
type ConfirmTransportationOptionsJSONRequestBody = ConfirmTransportationOptionsRequest

// UpdateItemComplianceDetailsJSONRequestBody defines body for UpdateItemComplianceDetails for application/json ContentType.
type UpdateItemComplianceDetailsJSONRequestBody = UpdateItemComplianceDetailsRequest

// CreateMarketplaceItemLabelsJSONRequestBody defines body for CreateMarketplaceItemLabels for application/json ContentType.
type CreateMarketplaceItemLabelsJSONRequestBody = CreateMarketplaceItemLabelsRequest

// SetPrepDetailsJSONRequestBody defines body for SetPrepDetails for application/json ContentType.
type SetPrepDetailsJSONRequestBody = SetPrepDetailsRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListInboundPlans request
	ListInboundPlans(ctx context.Context, params *ListInboundPlansParams) (*http.Response, error)

	// CreateInboundPlanWithBody request with any body
	CreateInboundPlanWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateInboundPlan(ctx context.Context, body CreateInboundPlanJSONRequestBody) (*http.Response, error)

	// GetInboundPlan request
	GetInboundPlan(ctx context.Context, inboundPlanId string) (*http.Response, error)

	// ListInboundPlanBoxes request
	ListInboundPlanBoxes(ctx context.Context, inboundPlanId string, params *ListInboundPlanBoxesParams) (*http.Response, error)

	// CancelInboundPlan request
	CancelInboundPlan(ctx context.Context, inboundPlanId string) (*http.Response, error)

	// ListInboundPlanItems request
	ListInboundPlanItems(ctx context.Context, inboundPlanId string, params *ListInboundPlanItemsParams) (*http.Response, error)

	// UpdateInboundPlanNameWithBody request with any body
	UpdateInboundPlanNameWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error)

	UpdateInboundPlanName(ctx context.Context, inboundPlanId string, body UpdateInboundPlanNameJSONRequestBody) (*http.Response, error)

	// ListPackingGroupBoxes request
	ListPackingGroupBoxes(ctx context.Context, inboundPlanId string, packingGroupId string, params *ListPackingGroupBoxesParams) (*http.Response, error)

	// ListPackingGroupItems request
	ListPackingGroupItems(ctx context.Context, inboundPlanId string, packingGroupId string, params *ListPackingGroupItemsParams) (*http.Response, error)

	// SetPackingInformationWithBody request with any body
	SetPackingInformationWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error)

	SetPackingInformation(ctx context.Context, inboundPlanId string, body SetPackingInformationJSONRequestBody) (*http.Response, error)

	// ListPackingOptions request
	ListPackingOptions(ctx context.Context, inboundPlanId string, params *ListPackingOptionsParams) (*http.Response, error)

	// GeneratePackingOptions request
	GeneratePackingOptions(ctx context.Context, inboundPlanId string) (*http.Response, error)

	// ConfirmPackingOption request
	ConfirmPackingOption(ctx context.Context, inboundPlanId string, packingOptionId string) (*http.Response, error)

	// ListInboundPlanPallets request
	ListInboundPlanPallets(ctx context.Context, inboundPlanId string, params *ListInboundPlanPalletsParams) (*http.Response, error)

	// ListPlacementOptions request
	ListPlacementOptions(ctx context.Context, inboundPlanId string, params *ListPlacementOptionsParams) (*http.Response, error)

	// GeneratePlacementOptionsWithBody request with any body
	GeneratePlacementOptionsWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error)

	GeneratePlacementOptions(ctx context.Context, inboundPlanId string, body GeneratePlacementOptionsJSONRequestBody) (*http.Response, error)

	// ConfirmPlacementOption request
	ConfirmPlacementOption(ctx context.Context, inboundPlanId string, placementOptionId string) (*http.Response, error)

	// GetShipment request
	GetShipment(ctx context.Context, inboundPlanId string, shipmentId string) (*http.Response, error)

	// ListShipmentBoxes request
	ListShipmentBoxes(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentBoxesParams) (*http.Response, error)

	// ListShipmentContentUpdatePreviews request
	ListShipmentContentUpdatePreviews(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentContentUpdatePreviewsParams) (*http.Response, error)

	// GenerateShipmentContentUpdatePreviewsWithBody request with any body
	GenerateShipmentContentUpdatePreviewsWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error)

	GenerateShipmentContentUpdatePreviews(ctx context.Context, inboundPlanId string, shipmentId string, body GenerateShipmentContentUpdatePreviewsJSONRequestBody) (*http.Response, error)

	// GetShipmentContentUpdatePreview request
	GetShipmentContentUpdatePreview(ctx context.Context, inboundPlanId string, shipmentId string, contentUpdatePreviewId string) (*http.Response, error)

	// ConfirmShipmentContentUpdatePreview request
	ConfirmShipmentContentUpdatePreview(ctx context.Context, inboundPlanId string, shipmentId string, contentUpdatePreviewId string) (*http.Response, error)

	// GetDeliveryChallanDocument request
	GetDeliveryChallanDocument(ctx context.Context, inboundPlanId string, shipmentId string) (*http.Response, error)

	// ListDeliveryWindowOptions request
	ListDeliveryWindowOptions(ctx context.Context, inboundPlanId string, shipmentId string, params *ListDeliveryWindowOptionsParams) (*http.Response, error)

	// GenerateDeliveryWindowOptions request
	GenerateDeliveryWindowOptions(ctx context.Context, inboundPlanId string, shipmentId string) (*http.Response, error)

	// ConfirmDeliveryWindowOptions request
	ConfirmDeliveryWindowOptions(ctx context.Context, inboundPlanId string, shipmentId string, deliveryWindowOptionId string) (*http.Response, error)

	// ListShipmentItems request
	ListShipmentItems(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentItemsParams) (*http.Response, error)

	// UpdateShipmentNameWithBody request with any body
	UpdateShipmentNameWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error)

	UpdateShipmentName(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentNameJSONRequestBody) (*http.Response, error)

	// ListShipmentPallets request
	ListShipmentPallets(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentPalletsParams) (*http.Response, error)

	// CancelSelfShipAppointmentWithBody request with any body
	CancelSelfShipAppointmentWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error)

	CancelSelfShipAppointment(ctx context.Context, inboundPlanId string, shipmentId string, body CancelSelfShipAppointmentJSONRequestBody) (*http.Response, error)

	// GetSelfShipAppointmentSlots request
	GetSelfShipAppointmentSlots(ctx context.Context, inboundPlanId string, shipmentId string, params *GetSelfShipAppointmentSlotsParams) (*http.Response, error)

	// GenerateSelfShipAppointmentSlotsWithBody request with any body
	GenerateSelfShipAppointmentSlotsWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error)

	GenerateSelfShipAppointmentSlots(ctx context.Context, inboundPlanId string, shipmentId string, body GenerateSelfShipAppointmentSlotsJSONRequestBody) (*http.Response, error)

	// ScheduleSelfShipAppointmentWithBody request with any body
	ScheduleSelfShipAppointmentWithBody(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*http.Response, error)

	ScheduleSelfShipAppointment(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, body ScheduleSelfShipAppointmentJSONRequestBody) (*http.Response, error)

	// UpdateShipmentSourceAddressWithBody request with any body
	UpdateShipmentSourceAddressWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error)

	UpdateShipmentSourceAddress(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentSourceAddressJSONRequestBody) (*http.Response, error)

	// UpdateShipmentTrackingDetailsWithBody request with any body
	UpdateShipmentTrackingDetailsWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error)

	UpdateShipmentTrackingDetails(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentTrackingDetailsJSONRequestBody) (*http.Response, error)

	// ListTransportationOptions request
	ListTransportationOptions(ctx context.Context, inboundPlanId string, params *ListTransportationOptionsParams) (*http.Response, error)

	// GenerateTransportationOptionsWithBody request with any body
	GenerateTransportationOptionsWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error)

	GenerateTransportationOptions(ctx context.Context, inboundPlanId string, body GenerateTransportationOptionsJSONRequestBody) (*http.Response, error)

	// ConfirmTransportationOptionsWithBody request with any body
	ConfirmTransportationOptionsWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error)

	ConfirmTransportationOptions(ctx context.Context, inboundPlanId string, body ConfirmTransportationOptionsJSONRequestBody) (*http.Response, error)

	// ListItemComplianceDetails request
	ListItemComplianceDetails(ctx context.Context, params *ListItemComplianceDetailsParams) (*http.Response, error)

	// UpdateItemComplianceDetailsWithBody request with any body
	UpdateItemComplianceDetailsWithBody(ctx context.Context, params *UpdateItemComplianceDetailsParams, contentType string, body io.Reader) (*http.Response, error)

	UpdateItemComplianceDetails(ctx context.Context, params *UpdateItemComplianceDetailsParams, body UpdateItemComplianceDetailsJSONRequestBody) (*http.Response, error)

	// CreateMarketplaceItemLabelsWithBody request with any body
	CreateMarketplaceItemLabelsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateMarketplaceItemLabels(ctx context.Context, body CreateMarketplaceItemLabelsJSONRequestBody) (*http.Response, error)

	// ListPrepDetails request
	ListPrepDetails(ctx context.Context, params *ListPrepDetailsParams) (*http.Response, error)

	// SetPrepDetailsWithBody request with any body
	SetPrepDetailsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	SetPrepDetails(ctx context.Context, body SetPrepDetailsJSONRequestBody) (*http.Response, error)

	// GetInboundOperationStatus request
	GetInboundOperationStatus(ctx context.Context, operationId string) (*http.Response, error)
}

func (c *Client) ListInboundPlans(ctx context.Context, params *ListInboundPlansParams) (*http.Response, error) {
	req, err := NewListInboundPlansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateInboundPlanWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateInboundPlanRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateInboundPlan(ctx context.Context, body CreateInboundPlanJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateInboundPlanRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInboundPlan(ctx context.Context, inboundPlanId string) (*http.Response, error) {
	req, err := NewGetInboundPlanRequest(c.Server, inboundPlanId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListInboundPlanBoxes(ctx context.Context, inboundPlanId string, params *ListInboundPlanBoxesParams) (*http.Response, error) {
	req, err := NewListInboundPlanBoxesRequest(c.Server, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CancelInboundPlan(ctx context.Context, inboundPlanId string) (*http.Response, error) {
	req, err := NewCancelInboundPlanRequest(c.Server, inboundPlanId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListInboundPlanItems(ctx context.Context, inboundPlanId string, params *ListInboundPlanItemsParams) (*http.Response, error) {
	req, err := NewListInboundPlanItemsRequest(c.Server, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateInboundPlanNameWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateInboundPlanNameRequestWithBody(c.Server, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateInboundPlanName(ctx context.Context, inboundPlanId string, body UpdateInboundPlanNameJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateInboundPlanNameRequest(c.Server, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListPackingGroupBoxes(ctx context.Context, inboundPlanId string, packingGroupId string, params *ListPackingGroupBoxesParams) (*http.Response, error) {
	req, err := NewListPackingGroupBoxesRequest(c.Server, inboundPlanId, packingGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListPackingGroupItems(ctx context.Context, inboundPlanId string, packingGroupId string, params *ListPackingGroupItemsParams) (*http.Response, error) {
	req, err := NewListPackingGroupItemsRequest(c.Server, inboundPlanId, packingGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SetPackingInformationWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSetPackingInformationRequestWithBody(c.Server, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SetPackingInformation(ctx context.Context, inboundPlanId string, body SetPackingInformationJSONRequestBody) (*http.Response, error) {
	req, err := NewSetPackingInformationRequest(c.Server, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListPackingOptions(ctx context.Context, inboundPlanId string, params *ListPackingOptionsParams) (*http.Response, error) {
	req, err := NewListPackingOptionsRequest(c.Server, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GeneratePackingOptions(ctx context.Context, inboundPlanId string) (*http.Response, error) {
	req, err := NewGeneratePackingOptionsRequest(c.Server, inboundPlanId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ConfirmPackingOption(ctx context.Context, inboundPlanId string, packingOptionId string) (*http.Response, error) {
	req, err := NewConfirmPackingOptionRequest(c.Server, inboundPlanId, packingOptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListInboundPlanPallets(ctx context.Context, inboundPlanId string, params *ListInboundPlanPalletsParams) (*http.Response, error) {
	req, err := NewListInboundPlanPalletsRequest(c.Server, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListPlacementOptions(ctx context.Context, inboundPlanId string, params *ListPlacementOptionsParams) (*http.Response, error) {
	req, err := NewListPlacementOptionsRequest(c.Server, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GeneratePlacementOptionsWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGeneratePlacementOptionsRequestWithBody(c.Server, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GeneratePlacementOptions(ctx context.Context, inboundPlanId string, body GeneratePlacementOptionsJSONRequestBody) (*http.Response, error) {
	req, err := NewGeneratePlacementOptionsRequest(c.Server, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ConfirmPlacementOption(ctx context.Context, inboundPlanId string, placementOptionId string) (*http.Response, error) {
	req, err := NewConfirmPlacementOptionRequest(c.Server, inboundPlanId, placementOptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetShipment(ctx context.Context, inboundPlanId string, shipmentId string) (*http.Response, error) {
	req, err := NewGetShipmentRequest(c.Server, inboundPlanId, shipmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListShipmentBoxes(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentBoxesParams) (*http.Response, error) {
	req, err := NewListShipmentBoxesRequest(c.Server, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListShipmentContentUpdatePreviews(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentContentUpdatePreviewsParams) (*http.Response, error) {
	req, err := NewListShipmentContentUpdatePreviewsRequest(c.Server, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GenerateShipmentContentUpdatePreviewsWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGenerateShipmentContentUpdatePreviewsRequestWithBody(c.Server, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GenerateShipmentContentUpdatePreviews(ctx context.Context, inboundPlanId string, shipmentId string, body GenerateShipmentContentUpdatePreviewsJSONRequestBody) (*http.Response, error) {
	req, err := NewGenerateShipmentContentUpdatePreviewsRequest(c.Server, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetShipmentContentUpdatePreview(ctx context.Context, inboundPlanId string, shipmentId string, contentUpdatePreviewId string) (*http.Response, error) {
	req, err := NewGetShipmentContentUpdatePreviewRequest(c.Server, inboundPlanId, shipmentId, contentUpdatePreviewId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ConfirmShipmentContentUpdatePreview(ctx context.Context, inboundPlanId string, shipmentId string, contentUpdatePreviewId string) (*http.Response, error) {
	req, err := NewConfirmShipmentContentUpdatePreviewRequest(c.Server, inboundPlanId, shipmentId, contentUpdatePreviewId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetDeliveryChallanDocument(ctx context.Context, inboundPlanId string, shipmentId string) (*http.Response, error) {
	req, err := NewGetDeliveryChallanDocumentRequest(c.Server, inboundPlanId, shipmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListDeliveryWindowOptions(ctx context.Context, inboundPlanId string, shipmentId string, params *ListDeliveryWindowOptionsParams) (*http.Response, error) {
	req, err := NewListDeliveryWindowOptionsRequest(c.Server, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GenerateDeliveryWindowOptions(ctx context.Context, inboundPlanId string, shipmentId string) (*http.Response, error) {
	req, err := NewGenerateDeliveryWindowOptionsRequest(c.Server, inboundPlanId, shipmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ConfirmDeliveryWindowOptions(ctx context.Context, inboundPlanId string, shipmentId string, deliveryWindowOptionId string) (*http.Response, error) {
	req, err := NewConfirmDeliveryWindowOptionsRequest(c.Server, inboundPlanId, shipmentId, deliveryWindowOptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListShipmentItems(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentItemsParams) (*http.Response, error) {
	req, err := NewListShipmentItemsRequest(c.Server, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateShipmentNameWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateShipmentNameRequestWithBody(c.Server, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateShipmentName(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentNameJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateShipmentNameRequest(c.Server, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListShipmentPallets(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentPalletsParams) (*http.Response, error) {
	req, err := NewListShipmentPalletsRequest(c.Server, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CancelSelfShipAppointmentWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCancelSelfShipAppointmentRequestWithBody(c.Server, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CancelSelfShipAppointment(ctx context.Context, inboundPlanId string, shipmentId string, body CancelSelfShipAppointmentJSONRequestBody) (*http.Response, error) {
	req, err := NewCancelSelfShipAppointmentRequest(c.Server, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetSelfShipAppointmentSlots(ctx context.Context, inboundPlanId string, shipmentId string, params *GetSelfShipAppointmentSlotsParams) (*http.Response, error) {
	req, err := NewGetSelfShipAppointmentSlotsRequest(c.Server, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GenerateSelfShipAppointmentSlotsWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGenerateSelfShipAppointmentSlotsRequestWithBody(c.Server, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GenerateSelfShipAppointmentSlots(ctx context.Context, inboundPlanId string, shipmentId string, body GenerateSelfShipAppointmentSlotsJSONRequestBody) (*http.Response, error) {
	req, err := NewGenerateSelfShipAppointmentSlotsRequest(c.Server, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ScheduleSelfShipAppointmentWithBody(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewScheduleSelfShipAppointmentRequestWithBody(c.Server, inboundPlanId, shipmentId, slotId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ScheduleSelfShipAppointment(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, body ScheduleSelfShipAppointmentJSONRequestBody) (*http.Response, error) {
	req, err := NewScheduleSelfShipAppointmentRequest(c.Server, inboundPlanId, shipmentId, slotId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateShipmentSourceAddressWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateShipmentSourceAddressRequestWithBody(c.Server, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateShipmentSourceAddress(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentSourceAddressJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateShipmentSourceAddressRequest(c.Server, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateShipmentTrackingDetailsWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateShipmentTrackingDetailsRequestWithBody(c.Server, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateShipmentTrackingDetails(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentTrackingDetailsJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateShipmentTrackingDetailsRequest(c.Server, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListTransportationOptions(ctx context.Context, inboundPlanId string, params *ListTransportationOptionsParams) (*http.Response, error) {
	req, err := NewListTransportationOptionsRequest(c.Server, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GenerateTransportationOptionsWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGenerateTransportationOptionsRequestWithBody(c.Server, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GenerateTransportationOptions(ctx context.Context, inboundPlanId string, body GenerateTransportationOptionsJSONRequestBody) (*http.Response, error) {
	req, err := NewGenerateTransportationOptionsRequest(c.Server, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ConfirmTransportationOptionsWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewConfirmTransportationOptionsRequestWithBody(c.Server, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ConfirmTransportationOptions(ctx context.Context, inboundPlanId string, body ConfirmTransportationOptionsJSONRequestBody) (*http.Response, error) {
	req, err := NewConfirmTransportationOptionsRequest(c.Server, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListItemComplianceDetails(ctx context.Context, params *ListItemComplianceDetailsParams) (*http.Response, error) {
	req, err := NewListItemComplianceDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateItemComplianceDetailsWithBody(ctx context.Context, params *UpdateItemComplianceDetailsParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateItemComplianceDetailsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateItemComplianceDetails(ctx context.Context, params *UpdateItemComplianceDetailsParams, body UpdateItemComplianceDetailsJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateItemComplianceDetailsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateMarketplaceItemLabelsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateMarketplaceItemLabelsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateMarketplaceItemLabels(ctx context.Context, body CreateMarketplaceItemLabelsJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateMarketplaceItemLabelsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListPrepDetails(ctx context.Context, params *ListPrepDetailsParams) (*http.Response, error) {
	req, err := NewListPrepDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SetPrepDetailsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSetPrepDetailsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SetPrepDetails(ctx context.Context, body SetPrepDetailsJSONRequestBody) (*http.Response, error) {
	req, err := NewSetPrepDetailsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInboundOperationStatus(ctx context.Context, operationId string) (*http.Response, error) {
	req, err := NewGetInboundOperationStatusRequest(c.Server, operationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewListInboundPlansRequest generates requests for ListInboundPlans
func NewListInboundPlansRequest(server string, params *ListInboundPlansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInboundPlanRequest calls the generic CreateInboundPlan builder with application/json body
func NewCreateInboundPlanRequest(server string, body CreateInboundPlanJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInboundPlanRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateInboundPlanRequestWithBody generates requests for CreateInboundPlan with any type of body
func NewCreateInboundPlanRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInboundPlanRequest generates requests for GetInboundPlan
func NewGetInboundPlanRequest(server string, inboundPlanId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInboundPlanBoxesRequest generates requests for ListInboundPlanBoxes
func NewListInboundPlanBoxesRequest(server string, inboundPlanId string, params *ListInboundPlanBoxesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/boxes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelInboundPlanRequest generates requests for CancelInboundPlan
func NewCancelInboundPlanRequest(server string, inboundPlanId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/cancellation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInboundPlanItemsRequest generates requests for ListInboundPlanItems
func NewListInboundPlanItemsRequest(server string, inboundPlanId string, params *ListInboundPlanItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateInboundPlanNameRequest calls the generic UpdateInboundPlanName builder with application/json body
func NewUpdateInboundPlanNameRequest(server string, inboundPlanId string, body UpdateInboundPlanNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInboundPlanNameRequestWithBody(server, inboundPlanId, "application/json", bodyReader)
}

// NewUpdateInboundPlanNameRequestWithBody generates requests for UpdateInboundPlanName with any type of body
func NewUpdateInboundPlanNameRequestWithBody(server string, inboundPlanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/name", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPackingGroupBoxesRequest generates requests for ListPackingGroupBoxes
func NewListPackingGroupBoxesRequest(server string, inboundPlanId string, packingGroupId string, params *ListPackingGroupBoxesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packingGroupId", runtime.ParamLocationPath, packingGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/packingGroups/%s/boxes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPackingGroupItemsRequest generates requests for ListPackingGroupItems
func NewListPackingGroupItemsRequest(server string, inboundPlanId string, packingGroupId string, params *ListPackingGroupItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packingGroupId", runtime.ParamLocationPath, packingGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/packingGroups/%s/items", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPackingInformationRequest calls the generic SetPackingInformation builder with application/json body
func NewSetPackingInformationRequest(server string, inboundPlanId string, body SetPackingInformationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPackingInformationRequestWithBody(server, inboundPlanId, "application/json", bodyReader)
}

// NewSetPackingInformationRequestWithBody generates requests for SetPackingInformation with any type of body
func NewSetPackingInformationRequestWithBody(server string, inboundPlanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/packingInformation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPackingOptionsRequest generates requests for ListPackingOptions
func NewListPackingOptionsRequest(server string, inboundPlanId string, params *ListPackingOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/packingOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneratePackingOptionsRequest generates requests for GeneratePackingOptions
func NewGeneratePackingOptionsRequest(server string, inboundPlanId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/packingOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfirmPackingOptionRequest generates requests for ConfirmPackingOption
func NewConfirmPackingOptionRequest(server string, inboundPlanId string, packingOptionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packingOptionId", runtime.ParamLocationPath, packingOptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/packingOptions/%s/confirmation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInboundPlanPalletsRequest generates requests for ListInboundPlanPallets
func NewListInboundPlanPalletsRequest(server string, inboundPlanId string, params *ListInboundPlanPalletsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/pallets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPlacementOptionsRequest generates requests for ListPlacementOptions
func NewListPlacementOptionsRequest(server string, inboundPlanId string, params *ListPlacementOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/placementOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneratePlacementOptionsRequest calls the generic GeneratePlacementOptions builder with application/json body
func NewGeneratePlacementOptionsRequest(server string, inboundPlanId string, body GeneratePlacementOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGeneratePlacementOptionsRequestWithBody(server, inboundPlanId, "application/json", bodyReader)
}

// NewGeneratePlacementOptionsRequestWithBody generates requests for GeneratePlacementOptions with any type of body
func NewGeneratePlacementOptionsRequestWithBody(server string, inboundPlanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/placementOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConfirmPlacementOptionRequest generates requests for ConfirmPlacementOption
func NewConfirmPlacementOptionRequest(server string, inboundPlanId string, placementOptionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "placementOptionId", runtime.ParamLocationPath, placementOptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/placementOptions/%s/confirmation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShipmentRequest generates requests for GetShipment
func NewGetShipmentRequest(server string, inboundPlanId string, shipmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListShipmentBoxesRequest generates requests for ListShipmentBoxes
func NewListShipmentBoxesRequest(server string, inboundPlanId string, shipmentId string, params *ListShipmentBoxesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/boxes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListShipmentContentUpdatePreviewsRequest generates requests for ListShipmentContentUpdatePreviews
func NewListShipmentContentUpdatePreviewsRequest(server string, inboundPlanId string, shipmentId string, params *ListShipmentContentUpdatePreviewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/contentUpdatePreviews", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateShipmentContentUpdatePreviewsRequest calls the generic GenerateShipmentContentUpdatePreviews builder with application/json body
func NewGenerateShipmentContentUpdatePreviewsRequest(server string, inboundPlanId string, shipmentId string, body GenerateShipmentContentUpdatePreviewsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateShipmentContentUpdatePreviewsRequestWithBody(server, inboundPlanId, shipmentId, "application/json", bodyReader)
}

// NewGenerateShipmentContentUpdatePreviewsRequestWithBody generates requests for GenerateShipmentContentUpdatePreviews with any type of body
func NewGenerateShipmentContentUpdatePreviewsRequestWithBody(server string, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/contentUpdatePreviews", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetShipmentContentUpdatePreviewRequest generates requests for GetShipmentContentUpdatePreview
func NewGetShipmentContentUpdatePreviewRequest(server string, inboundPlanId string, shipmentId string, contentUpdatePreviewId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "contentUpdatePreviewId", runtime.ParamLocationPath, contentUpdatePreviewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/contentUpdatePreviews/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfirmShipmentContentUpdatePreviewRequest generates requests for ConfirmShipmentContentUpdatePreview
func NewConfirmShipmentContentUpdatePreviewRequest(server string, inboundPlanId string, shipmentId string, contentUpdatePreviewId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "contentUpdatePreviewId", runtime.ParamLocationPath, contentUpdatePreviewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/contentUpdatePreviews/%s/confirmation", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeliveryChallanDocumentRequest generates requests for GetDeliveryChallanDocument
func NewGetDeliveryChallanDocumentRequest(server string, inboundPlanId string, shipmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/deliveryChallanDocument", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDeliveryWindowOptionsRequest generates requests for ListDeliveryWindowOptions
func NewListDeliveryWindowOptionsRequest(server string, inboundPlanId string, shipmentId string, params *ListDeliveryWindowOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/deliveryWindowOptions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateDeliveryWindowOptionsRequest generates requests for GenerateDeliveryWindowOptions
func NewGenerateDeliveryWindowOptionsRequest(server string, inboundPlanId string, shipmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/deliveryWindowOptions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfirmDeliveryWindowOptionsRequest generates requests for ConfirmDeliveryWindowOptions
func NewConfirmDeliveryWindowOptionsRequest(server string, inboundPlanId string, shipmentId string, deliveryWindowOptionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "deliveryWindowOptionId", runtime.ParamLocationPath, deliveryWindowOptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/deliveryWindowOptions/%s/confirmation", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListShipmentItemsRequest generates requests for ListShipmentItems
func NewListShipmentItemsRequest(server string, inboundPlanId string, shipmentId string, params *ListShipmentItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/items", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateShipmentNameRequest calls the generic UpdateShipmentName builder with application/json body
func NewUpdateShipmentNameRequest(server string, inboundPlanId string, shipmentId string, body UpdateShipmentNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShipmentNameRequestWithBody(server, inboundPlanId, shipmentId, "application/json", bodyReader)
}

// NewUpdateShipmentNameRequestWithBody generates requests for UpdateShipmentName with any type of body
func NewUpdateShipmentNameRequestWithBody(server string, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/name", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListShipmentPalletsRequest generates requests for ListShipmentPallets
func NewListShipmentPalletsRequest(server string, inboundPlanId string, shipmentId string, params *ListShipmentPalletsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/pallets", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelSelfShipAppointmentRequest calls the generic CancelSelfShipAppointment builder with application/json body
func NewCancelSelfShipAppointmentRequest(server string, inboundPlanId string, shipmentId string, body CancelSelfShipAppointmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelSelfShipAppointmentRequestWithBody(server, inboundPlanId, shipmentId, "application/json", bodyReader)
}

// NewCancelSelfShipAppointmentRequestWithBody generates requests for CancelSelfShipAppointment with any type of body
func NewCancelSelfShipAppointmentRequestWithBody(server string, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/selfShipAppointmentCancellation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSelfShipAppointmentSlotsRequest generates requests for GetSelfShipAppointmentSlots
func NewGetSelfShipAppointmentSlotsRequest(server string, inboundPlanId string, shipmentId string, params *GetSelfShipAppointmentSlotsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/selfShipAppointmentSlots", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateSelfShipAppointmentSlotsRequest calls the generic GenerateSelfShipAppointmentSlots builder with application/json body
func NewGenerateSelfShipAppointmentSlotsRequest(server string, inboundPlanId string, shipmentId string, body GenerateSelfShipAppointmentSlotsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateSelfShipAppointmentSlotsRequestWithBody(server, inboundPlanId, shipmentId, "application/json", bodyReader)
}

// NewGenerateSelfShipAppointmentSlotsRequestWithBody generates requests for GenerateSelfShipAppointmentSlots with any type of body
func NewGenerateSelfShipAppointmentSlotsRequestWithBody(server string, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/selfShipAppointmentSlots", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScheduleSelfShipAppointmentRequest calls the generic ScheduleSelfShipAppointment builder with application/json body
func NewScheduleSelfShipAppointmentRequest(server string, inboundPlanId string, shipmentId string, slotId string, body ScheduleSelfShipAppointmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScheduleSelfShipAppointmentRequestWithBody(server, inboundPlanId, shipmentId, slotId, "application/json", bodyReader)
}

// NewScheduleSelfShipAppointmentRequestWithBody generates requests for ScheduleSelfShipAppointment with any type of body
func NewScheduleSelfShipAppointmentRequestWithBody(server string, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "slotId", runtime.ParamLocationPath, slotId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/selfShipAppointmentSlots/%s/schedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateShipmentSourceAddressRequest calls the generic UpdateShipmentSourceAddress builder with application/json body
func NewUpdateShipmentSourceAddressRequest(server string, inboundPlanId string, shipmentId string, body UpdateShipmentSourceAddressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShipmentSourceAddressRequestWithBody(server, inboundPlanId, shipmentId, "application/json", bodyReader)
}

// NewUpdateShipmentSourceAddressRequestWithBody generates requests for UpdateShipmentSourceAddress with any type of body
func NewUpdateShipmentSourceAddressRequestWithBody(server string, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/sourceAddress", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateShipmentTrackingDetailsRequest calls the generic UpdateShipmentTrackingDetails builder with application/json body
func NewUpdateShipmentTrackingDetailsRequest(server string, inboundPlanId string, shipmentId string, body UpdateShipmentTrackingDetailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShipmentTrackingDetailsRequestWithBody(server, inboundPlanId, shipmentId, "application/json", bodyReader)
}

// NewUpdateShipmentTrackingDetailsRequestWithBody generates requests for UpdateShipmentTrackingDetails with any type of body
func NewUpdateShipmentTrackingDetailsRequestWithBody(server string, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/trackingDetails", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTransportationOptionsRequest generates requests for ListTransportationOptions
func NewListTransportationOptionsRequest(server string, inboundPlanId string, params *ListTransportationOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/transportationOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PlacementOptionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "placementOptionId", runtime.ParamLocationQuery, *params.PlacementOptionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ShipmentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipmentId", runtime.ParamLocationQuery, *params.ShipmentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateTransportationOptionsRequest calls the generic GenerateTransportationOptions builder with application/json body
func NewGenerateTransportationOptionsRequest(server string, inboundPlanId string, body GenerateTransportationOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateTransportationOptionsRequestWithBody(server, inboundPlanId, "application/json", bodyReader)
}

// NewGenerateTransportationOptionsRequestWithBody generates requests for GenerateTransportationOptions with any type of body
func NewGenerateTransportationOptionsRequestWithBody(server string, inboundPlanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/transportationOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConfirmTransportationOptionsRequest calls the generic ConfirmTransportationOptions builder with application/json body
func NewConfirmTransportationOptionsRequest(server string, inboundPlanId string, body ConfirmTransportationOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfirmTransportationOptionsRequestWithBody(server, inboundPlanId, "application/json", bodyReader)
}

// NewConfirmTransportationOptionsRequestWithBody generates requests for ConfirmTransportationOptions with any type of body
func NewConfirmTransportationOptionsRequestWithBody(server string, inboundPlanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/transportationOptions/confirmation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListItemComplianceDetailsRequest generates requests for ListItemComplianceDetails
func NewListItemComplianceDetailsRequest(server string, params *ListItemComplianceDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/items/compliance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mskus", runtime.ParamLocationQuery, params.Mskus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateItemComplianceDetailsRequest calls the generic UpdateItemComplianceDetails builder with application/json body
func NewUpdateItemComplianceDetailsRequest(server string, params *UpdateItemComplianceDetailsParams, body UpdateItemComplianceDetailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateItemComplianceDetailsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateItemComplianceDetailsRequestWithBody generates requests for UpdateItemComplianceDetails with any type of body
func NewUpdateItemComplianceDetailsRequestWithBody(server string, params *UpdateItemComplianceDetailsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/items/compliance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateMarketplaceItemLabelsRequest calls the generic CreateMarketplaceItemLabels builder with application/json body
func NewCreateMarketplaceItemLabelsRequest(server string, body CreateMarketplaceItemLabelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMarketplaceItemLabelsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMarketplaceItemLabelsRequestWithBody generates requests for CreateMarketplaceItemLabels with any type of body
func NewCreateMarketplaceItemLabelsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/items/labels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPrepDetailsRequest generates requests for ListPrepDetails
func NewListPrepDetailsRequest(server string, params *ListPrepDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/items/prepDetails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mskus", runtime.ParamLocationQuery, params.Mskus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPrepDetailsRequest calls the generic SetPrepDetails builder with application/json body
func NewSetPrepDetailsRequest(server string, body SetPrepDetailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPrepDetailsRequestWithBody(server, "application/json", bodyReader)
}

// NewSetPrepDetailsRequestWithBody generates requests for SetPrepDetails with any type of body
func NewSetPrepDetailsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/items/prepDetails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInboundOperationStatusRequest generates requests for GetInboundOperationStatus
func NewGetInboundOperationStatusRequest(server string, operationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "operationId", runtime.ParamLocationPath, operationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/operations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListInboundPlansWithResponse request
	ListInboundPlansWithResponse(ctx context.Context, params *ListInboundPlansParams) (*ListInboundPlansResp, error)

	// CreateInboundPlanWithBodyWithResponse request with any body
	CreateInboundPlanWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateInboundPlanResp, error)

	CreateInboundPlanWithResponse(ctx context.Context, body CreateInboundPlanJSONRequestBody) (*CreateInboundPlanResp, error)

	// GetInboundPlanWithResponse request
	GetInboundPlanWithResponse(ctx context.Context, inboundPlanId string) (*GetInboundPlanResp, error)

	// ListInboundPlanBoxesWithResponse request
	ListInboundPlanBoxesWithResponse(ctx context.Context, inboundPlanId string, params *ListInboundPlanBoxesParams) (*ListInboundPlanBoxesResp, error)

	// CancelInboundPlanWithResponse request
	CancelInboundPlanWithResponse(ctx context.Context, inboundPlanId string) (*CancelInboundPlanResp, error)

	// ListInboundPlanItemsWithResponse request
	ListInboundPlanItemsWithResponse(ctx context.Context, inboundPlanId string, params *ListInboundPlanItemsParams) (*ListInboundPlanItemsResp, error)

	// UpdateInboundPlanNameWithBodyWithResponse request with any body
	UpdateInboundPlanNameWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*UpdateInboundPlanNameResp, error)

	UpdateInboundPlanNameWithResponse(ctx context.Context, inboundPlanId string, body UpdateInboundPlanNameJSONRequestBody) (*UpdateInboundPlanNameResp, error)

	// ListPackingGroupBoxesWithResponse request
	ListPackingGroupBoxesWithResponse(ctx context.Context, inboundPlanId string, packingGroupId string, params *ListPackingGroupBoxesParams) (*ListPackingGroupBoxesResp, error)

	// ListPackingGroupItemsWithResponse request
	ListPackingGroupItemsWithResponse(ctx context.Context, inboundPlanId string, packingGroupId string, params *ListPackingGroupItemsParams) (*ListPackingGroupItemsResp, error)

	// SetPackingInformationWithBodyWithResponse request with any body
	SetPackingInformationWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*SetPackingInformationResp, error)

	SetPackingInformationWithResponse(ctx context.Context, inboundPlanId string, body SetPackingInformationJSONRequestBody) (*SetPackingInformationResp, error)

	// ListPackingOptionsWithResponse request
	ListPackingOptionsWithResponse(ctx context.Context, inboundPlanId string, params *ListPackingOptionsParams) (*ListPackingOptionsResp, error)

	// GeneratePackingOptionsWithResponse request
	GeneratePackingOptionsWithResponse(ctx context.Context, inboundPlanId string) (*GeneratePackingOptionsResp, error)

	// ConfirmPackingOptionWithResponse request
	ConfirmPackingOptionWithResponse(ctx context.Context, inboundPlanId string, packingOptionId string) (*ConfirmPackingOptionResp, error)

	// ListInboundPlanPalletsWithResponse request
	ListInboundPlanPalletsWithResponse(ctx context.Context, inboundPlanId string, params *ListInboundPlanPalletsParams) (*ListInboundPlanPalletsResp, error)

	// ListPlacementOptionsWithResponse request
	ListPlacementOptionsWithResponse(ctx context.Context, inboundPlanId string, params *ListPlacementOptionsParams) (*ListPlacementOptionsResp, error)

	// GeneratePlacementOptionsWithBodyWithResponse request with any body
	GeneratePlacementOptionsWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*GeneratePlacementOptionsResp, error)

	GeneratePlacementOptionsWithResponse(ctx context.Context, inboundPlanId string, body GeneratePlacementOptionsJSONRequestBody) (*GeneratePlacementOptionsResp, error)

	// ConfirmPlacementOptionWithResponse request
	ConfirmPlacementOptionWithResponse(ctx context.Context, inboundPlanId string, placementOptionId string) (*ConfirmPlacementOptionResp, error)

	// GetShipmentWithResponse request
	GetShipmentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string) (*GetShipmentResp, error)

	// ListShipmentBoxesWithResponse request
	ListShipmentBoxesWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentBoxesParams) (*ListShipmentBoxesResp, error)

	// ListShipmentContentUpdatePreviewsWithResponse request
	ListShipmentContentUpdatePreviewsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentContentUpdatePreviewsParams) (*ListShipmentContentUpdatePreviewsResp, error)

	// GenerateShipmentContentUpdatePreviewsWithBodyWithResponse request with any body
	GenerateShipmentContentUpdatePreviewsWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*GenerateShipmentContentUpdatePreviewsResp, error)

	GenerateShipmentContentUpdatePreviewsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body GenerateShipmentContentUpdatePreviewsJSONRequestBody) (*GenerateShipmentContentUpdatePreviewsResp, error)

	// GetShipmentContentUpdatePreviewWithResponse request
	GetShipmentContentUpdatePreviewWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentUpdatePreviewId string) (*GetShipmentContentUpdatePreviewResp, error)

	// ConfirmShipmentContentUpdatePreviewWithResponse request
	ConfirmShipmentContentUpdatePreviewWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentUpdatePreviewId string) (*ConfirmShipmentContentUpdatePreviewResp, error)

	// GetDeliveryChallanDocumentWithResponse request
	GetDeliveryChallanDocumentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string) (*GetDeliveryChallanDocumentResp, error)

	// ListDeliveryWindowOptionsWithResponse request
	ListDeliveryWindowOptionsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *ListDeliveryWindowOptionsParams) (*ListDeliveryWindowOptionsResp, error)

	// GenerateDeliveryWindowOptionsWithResponse request
	GenerateDeliveryWindowOptionsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string) (*GenerateDeliveryWindowOptionsResp, error)

	// ConfirmDeliveryWindowOptionsWithResponse request
	ConfirmDeliveryWindowOptionsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, deliveryWindowOptionId string) (*ConfirmDeliveryWindowOptionsResp, error)

	// ListShipmentItemsWithResponse request
	ListShipmentItemsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentItemsParams) (*ListShipmentItemsResp, error)

	// UpdateShipmentNameWithBodyWithResponse request with any body
	UpdateShipmentNameWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*UpdateShipmentNameResp, error)

	UpdateShipmentNameWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentNameJSONRequestBody) (*UpdateShipmentNameResp, error)

	// ListShipmentPalletsWithResponse request
	ListShipmentPalletsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentPalletsParams) (*ListShipmentPalletsResp, error)

	// CancelSelfShipAppointmentWithBodyWithResponse request with any body
	CancelSelfShipAppointmentWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*CancelSelfShipAppointmentResp, error)

	CancelSelfShipAppointmentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body CancelSelfShipAppointmentJSONRequestBody) (*CancelSelfShipAppointmentResp, error)

	// GetSelfShipAppointmentSlotsWithResponse request
	GetSelfShipAppointmentSlotsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *GetSelfShipAppointmentSlotsParams) (*GetSelfShipAppointmentSlotsResp, error)

	// GenerateSelfShipAppointmentSlotsWithBodyWithResponse request with any body
	GenerateSelfShipAppointmentSlotsWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*GenerateSelfShipAppointmentSlotsResp, error)

	GenerateSelfShipAppointmentSlotsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body GenerateSelfShipAppointmentSlotsJSONRequestBody) (*GenerateSelfShipAppointmentSlotsResp, error)

	// ScheduleSelfShipAppointmentWithBodyWithResponse request with any body
	ScheduleSelfShipAppointmentWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*ScheduleSelfShipAppointmentResp, error)

	ScheduleSelfShipAppointmentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, body ScheduleSelfShipAppointmentJSONRequestBody) (*ScheduleSelfShipAppointmentResp, error)

	// UpdateShipmentSourceAddressWithBodyWithResponse request with any body
	UpdateShipmentSourceAddressWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*UpdateShipmentSourceAddressResp, error)

	UpdateShipmentSourceAddressWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentSourceAddressJSONRequestBody) (*UpdateShipmentSourceAddressResp, error)

	// UpdateShipmentTrackingDetailsWithBodyWithResponse request with any body
	UpdateShipmentTrackingDetailsWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*UpdateShipmentTrackingDetailsResp, error)

	UpdateShipmentTrackingDetailsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentTrackingDetailsJSONRequestBody) (*UpdateShipmentTrackingDetailsResp, error)

	// ListTransportationOptionsWithResponse request
	ListTransportationOptionsWithResponse(ctx context.Context, inboundPlanId string, params *ListTransportationOptionsParams) (*ListTransportationOptionsResp, error)

	// GenerateTransportationOptionsWithBodyWithResponse request with any body
	GenerateTransportationOptionsWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*GenerateTransportationOptionsResp, error)

	GenerateTransportationOptionsWithResponse(ctx context.Context, inboundPlanId string, body GenerateTransportationOptionsJSONRequestBody) (*GenerateTransportationOptionsResp, error)

	// ConfirmTransportationOptionsWithBodyWithResponse request with any body
	ConfirmTransportationOptionsWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*ConfirmTransportationOptionsResp, error)

	ConfirmTransportationOptionsWithResponse(ctx context.Context, inboundPlanId string, body ConfirmTransportationOptionsJSONRequestBody) (*ConfirmTransportationOptionsResp, error)

	// ListItemComplianceDetailsWithResponse request
	ListItemComplianceDetailsWithResponse(ctx context.Context, params *ListItemComplianceDetailsParams) (*ListItemComplianceDetailsResp, error)

	// UpdateItemComplianceDetailsWithBodyWithResponse request with any body
	UpdateItemComplianceDetailsWithBodyWithResponse(ctx context.Context, params *UpdateItemComplianceDetailsParams, contentType string, body io.Reader) (*UpdateItemComplianceDetailsResp, error)

	UpdateItemComplianceDetailsWithResponse(ctx context.Context, params *UpdateItemComplianceDetailsParams, body UpdateItemComplianceDetailsJSONRequestBody) (*UpdateItemComplianceDetailsResp, error)

	// CreateMarketplaceItemLabelsWithBodyWithResponse request with any body
	CreateMarketplaceItemLabelsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateMarketplaceItemLabelsResp, error)

	CreateMarketplaceItemLabelsWithResponse(ctx context.Context, body CreateMarketplaceItemLabelsJSONRequestBody) (*CreateMarketplaceItemLabelsResp, error)

	// ListPrepDetailsWithResponse request
	ListPrepDetailsWithResponse(ctx context.Context, params *ListPrepDetailsParams) (*ListPrepDetailsResp, error)

	// SetPrepDetailsWithBodyWithResponse request with any body
	SetPrepDetailsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SetPrepDetailsResp, error)

	SetPrepDetailsWithResponse(ctx context.Context, body SetPrepDetailsJSONRequestBody) (*SetPrepDetailsResp, error)

	// GetInboundOperationStatusWithResponse request
	GetInboundOperationStatusWithResponse(ctx context.Context, operationId string) (*GetInboundOperationStatusResp, error)
}

type ListInboundPlansResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInboundPlansResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListInboundPlansResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboundPlansResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInboundPlanResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateInboundPlanResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CreateInboundPlanResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInboundPlanResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInboundPlanResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InboundPlan
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetInboundPlanResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInboundPlanResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInboundPlanBoxesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInboundPlanBoxesResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListInboundPlanBoxesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboundPlanBoxesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelInboundPlanResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CancelInboundPlanResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CancelInboundPlanResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelInboundPlanResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInboundPlanItemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInboundPlanItemsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListInboundPlanItemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboundPlanItemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInboundPlanNameResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateInboundPlanNameResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInboundPlanNameResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPackingGroupBoxesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPackingGroupBoxesResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListPackingGroupBoxesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPackingGroupBoxesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPackingGroupItemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPackingGroupItemsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListPackingGroupItemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPackingGroupItemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPackingInformationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SetPackingInformationResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r SetPackingInformationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPackingInformationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPackingOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPackingOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListPackingOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPackingOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneratePackingOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *GeneratePackingOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GeneratePackingOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneratePackingOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmPackingOptionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ConfirmPackingOptionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ConfirmPackingOptionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmPackingOptionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInboundPlanPalletsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInboundPlanPalletsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListInboundPlanPalletsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboundPlanPalletsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlacementOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPlacementOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListPlacementOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlacementOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneratePlacementOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *GeneratePlacementOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GeneratePlacementOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneratePlacementOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmPlacementOptionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ConfirmPlacementOptionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ConfirmPlacementOptionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmPlacementOptionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShipmentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Shipment
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetShipmentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShipmentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListShipmentBoxesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListShipmentBoxesResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListShipmentBoxesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListShipmentBoxesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListShipmentContentUpdatePreviewsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListShipmentContentUpdatePreviewsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListShipmentContentUpdatePreviewsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListShipmentContentUpdatePreviewsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateShipmentContentUpdatePreviewsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *GenerateShipmentContentUpdatePreviewsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GenerateShipmentContentUpdatePreviewsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateShipmentContentUpdatePreviewsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShipmentContentUpdatePreviewResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentUpdatePreview
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetShipmentContentUpdatePreviewResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShipmentContentUpdatePreviewResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmShipmentContentUpdatePreviewResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ConfirmShipmentContentUpdatePreviewResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ConfirmShipmentContentUpdatePreviewResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmShipmentContentUpdatePreviewResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeliveryChallanDocumentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDeliveryChallanDocumentResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetDeliveryChallanDocumentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeliveryChallanDocumentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDeliveryWindowOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListDeliveryWindowOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListDeliveryWindowOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDeliveryWindowOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateDeliveryWindowOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *GenerateDeliveryWindowOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GenerateDeliveryWindowOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateDeliveryWindowOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmDeliveryWindowOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ConfirmDeliveryWindowOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ConfirmDeliveryWindowOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmDeliveryWindowOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListShipmentItemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListShipmentItemsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListShipmentItemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListShipmentItemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShipmentNameResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateShipmentNameResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShipmentNameResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListShipmentPalletsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListShipmentPalletsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListShipmentPalletsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListShipmentPalletsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelSelfShipAppointmentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CancelSelfShipAppointmentResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CancelSelfShipAppointmentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelSelfShipAppointmentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelfShipAppointmentSlotsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSelfShipAppointmentSlotsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetSelfShipAppointmentSlotsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelfShipAppointmentSlotsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateSelfShipAppointmentSlotsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GenerateSelfShipAppointmentSlotsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GenerateSelfShipAppointmentSlotsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateSelfShipAppointmentSlotsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScheduleSelfShipAppointmentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScheduleSelfShipAppointmentResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ScheduleSelfShipAppointmentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScheduleSelfShipAppointmentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShipmentSourceAddressResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *UpdateShipmentSourceAddressResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateShipmentSourceAddressResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShipmentSourceAddressResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShipmentTrackingDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *UpdateShipmentTrackingDetailsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateShipmentTrackingDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShipmentTrackingDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransportationOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTransportationOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListTransportationOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransportationOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTransportationOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *GenerateTransportationOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GenerateTransportationOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTransportationOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmTransportationOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ConfirmTransportationOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ConfirmTransportationOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmTransportationOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListItemComplianceDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListItemComplianceDetailsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListItemComplianceDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListItemComplianceDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateItemComplianceDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *UpdateItemComplianceDetailsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateItemComplianceDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateItemComplianceDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMarketplaceItemLabelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateMarketplaceItemLabelsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CreateMarketplaceItemLabelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMarketplaceItemLabelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPrepDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPrepDetailsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListPrepDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPrepDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPrepDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SetPrepDetailsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r SetPrepDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPrepDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInboundOperationStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InboundOperationStatus
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetInboundOperationStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInboundOperationStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListInboundPlansWithResponse request returning *ListInboundPlansResp
func (c *ClientWithResponses) ListInboundPlansWithResponse(ctx context.Context, params *ListInboundPlansParams) (*ListInboundPlansResp, error) {
	rsp, err := c.ListInboundPlans(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListInboundPlansResp(rsp)
}

// CreateInboundPlanWithBodyWithResponse request with arbitrary body returning *CreateInboundPlanResp
func (c *ClientWithResponses) CreateInboundPlanWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateInboundPlanResp, error) {
	rsp, err := c.CreateInboundPlanWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateInboundPlanResp(rsp)
}

func (c *ClientWithResponses) CreateInboundPlanWithResponse(ctx context.Context, body CreateInboundPlanJSONRequestBody) (*CreateInboundPlanResp, error) {
	rsp, err := c.CreateInboundPlan(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateInboundPlanResp(rsp)
}

// GetInboundPlanWithResponse request returning *GetInboundPlanResp
func (c *ClientWithResponses) GetInboundPlanWithResponse(ctx context.Context, inboundPlanId string) (*GetInboundPlanResp, error) {
	rsp, err := c.GetInboundPlan(ctx, inboundPlanId)
	if err != nil {
		return nil, err
	}
	return ParseGetInboundPlanResp(rsp)
}

// ListInboundPlanBoxesWithResponse request returning *ListInboundPlanBoxesResp
func (c *ClientWithResponses) ListInboundPlanBoxesWithResponse(ctx context.Context, inboundPlanId string, params *ListInboundPlanBoxesParams) (*ListInboundPlanBoxesResp, error) {
	rsp, err := c.ListInboundPlanBoxes(ctx, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	return ParseListInboundPlanBoxesResp(rsp)
}

// CancelInboundPlanWithResponse request returning *CancelInboundPlanResp
func (c *ClientWithResponses) CancelInboundPlanWithResponse(ctx context.Context, inboundPlanId string) (*CancelInboundPlanResp, error) {
	rsp, err := c.CancelInboundPlan(ctx, inboundPlanId)
	if err != nil {
		return nil, err
	}
	return ParseCancelInboundPlanResp(rsp)
}

// ListInboundPlanItemsWithResponse request returning *ListInboundPlanItemsResp
func (c *ClientWithResponses) ListInboundPlanItemsWithResponse(ctx context.Context, inboundPlanId string, params *ListInboundPlanItemsParams) (*ListInboundPlanItemsResp, error) {
	rsp, err := c.ListInboundPlanItems(ctx, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	return ParseListInboundPlanItemsResp(rsp)
}

// UpdateInboundPlanNameWithBodyWithResponse request with arbitrary body returning *UpdateInboundPlanNameResp
func (c *ClientWithResponses) UpdateInboundPlanNameWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*UpdateInboundPlanNameResp, error) {
	rsp, err := c.UpdateInboundPlanNameWithBody(ctx, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInboundPlanNameResp(rsp)
}

func (c *ClientWithResponses) UpdateInboundPlanNameWithResponse(ctx context.Context, inboundPlanId string, body UpdateInboundPlanNameJSONRequestBody) (*UpdateInboundPlanNameResp, error) {
	rsp, err := c.UpdateInboundPlanName(ctx, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInboundPlanNameResp(rsp)
}

// ListPackingGroupBoxesWithResponse request returning *ListPackingGroupBoxesResp
func (c *ClientWithResponses) ListPackingGroupBoxesWithResponse(ctx context.Context, inboundPlanId string, packingGroupId string, params *ListPackingGroupBoxesParams) (*ListPackingGroupBoxesResp, error) {
	rsp, err := c.ListPackingGroupBoxes(ctx, inboundPlanId, packingGroupId, params)
	if err != nil {
		return nil, err
	}
	return ParseListPackingGroupBoxesResp(rsp)
}

// ListPackingGroupItemsWithResponse request returning *ListPackingGroupItemsResp
func (c *ClientWithResponses) ListPackingGroupItemsWithResponse(ctx context.Context, inboundPlanId string, packingGroupId string, params *ListPackingGroupItemsParams) (*ListPackingGroupItemsResp, error) {
	rsp, err := c.ListPackingGroupItems(ctx, inboundPlanId, packingGroupId, params)
	if err != nil {
		return nil, err
	}
	return ParseListPackingGroupItemsResp(rsp)
}

// SetPackingInformationWithBodyWithResponse request with arbitrary body returning *SetPackingInformationResp
func (c *ClientWithResponses) SetPackingInformationWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*SetPackingInformationResp, error) {
	rsp, err := c.SetPackingInformationWithBody(ctx, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSetPackingInformationResp(rsp)
}

func (c *ClientWithResponses) SetPackingInformationWithResponse(ctx context.Context, inboundPlanId string, body SetPackingInformationJSONRequestBody) (*SetPackingInformationResp, error) {
	rsp, err := c.SetPackingInformation(ctx, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	return ParseSetPackingInformationResp(rsp)
}

// ListPackingOptionsWithResponse request returning *ListPackingOptionsResp
func (c *ClientWithResponses) ListPackingOptionsWithResponse(ctx context.Context, inboundPlanId string, params *ListPackingOptionsParams) (*ListPackingOptionsResp, error) {
	rsp, err := c.ListPackingOptions(ctx, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	return ParseListPackingOptionsResp(rsp)
}

// GeneratePackingOptionsWithResponse request returning *GeneratePackingOptionsResp
func (c *ClientWithResponses) GeneratePackingOptionsWithResponse(ctx context.Context, inboundPlanId string) (*GeneratePackingOptionsResp, error) {
	rsp, err := c.GeneratePackingOptions(ctx, inboundPlanId)
	if err != nil {
		return nil, err
	}
	return ParseGeneratePackingOptionsResp(rsp)
}

// ConfirmPackingOptionWithResponse request returning *ConfirmPackingOptionResp
func (c *ClientWithResponses) ConfirmPackingOptionWithResponse(ctx context.Context, inboundPlanId string, packingOptionId string) (*ConfirmPackingOptionResp, error) {
	rsp, err := c.ConfirmPackingOption(ctx, inboundPlanId, packingOptionId)
	if err != nil {
		return nil, err
	}
	return ParseConfirmPackingOptionResp(rsp)
}

// ListInboundPlanPalletsWithResponse request returning *ListInboundPlanPalletsResp
func (c *ClientWithResponses) ListInboundPlanPalletsWithResponse(ctx context.Context, inboundPlanId string, params *ListInboundPlanPalletsParams) (*ListInboundPlanPalletsResp, error) {
	rsp, err := c.ListInboundPlanPallets(ctx, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	return ParseListInboundPlanPalletsResp(rsp)
}

// ListPlacementOptionsWithResponse request returning *ListPlacementOptionsResp
func (c *ClientWithResponses) ListPlacementOptionsWithResponse(ctx context.Context, inboundPlanId string, params *ListPlacementOptionsParams) (*ListPlacementOptionsResp, error) {
	rsp, err := c.ListPlacementOptions(ctx, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	return ParseListPlacementOptionsResp(rsp)
}

// GeneratePlacementOptionsWithBodyWithResponse request with arbitrary body returning *GeneratePlacementOptionsResp
func (c *ClientWithResponses) GeneratePlacementOptionsWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*GeneratePlacementOptionsResp, error) {
	rsp, err := c.GeneratePlacementOptionsWithBody(ctx, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGeneratePlacementOptionsResp(rsp)
}

func (c *ClientWithResponses) GeneratePlacementOptionsWithResponse(ctx context.Context, inboundPlanId string, body GeneratePlacementOptionsJSONRequestBody) (*GeneratePlacementOptionsResp, error) {
	rsp, err := c.GeneratePlacementOptions(ctx, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	return ParseGeneratePlacementOptionsResp(rsp)
}

// ConfirmPlacementOptionWithResponse request returning *ConfirmPlacementOptionResp
func (c *ClientWithResponses) ConfirmPlacementOptionWithResponse(ctx context.Context, inboundPlanId string, placementOptionId string) (*ConfirmPlacementOptionResp, error) {
	rsp, err := c.ConfirmPlacementOption(ctx, inboundPlanId, placementOptionId)
	if err != nil {
		return nil, err
	}
	return ParseConfirmPlacementOptionResp(rsp)
}

// GetShipmentWithResponse request returning *GetShipmentResp
func (c *ClientWithResponses) GetShipmentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string) (*GetShipmentResp, error) {
	rsp, err := c.GetShipment(ctx, inboundPlanId, shipmentId)
	if err != nil {
		return nil, err
	}
	return ParseGetShipmentResp(rsp)
}

// ListShipmentBoxesWithResponse request returning *ListShipmentBoxesResp
func (c *ClientWithResponses) ListShipmentBoxesWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentBoxesParams) (*ListShipmentBoxesResp, error) {
	rsp, err := c.ListShipmentBoxes(ctx, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	return ParseListShipmentBoxesResp(rsp)
}

// ListShipmentContentUpdatePreviewsWithResponse request returning *ListShipmentContentUpdatePreviewsResp
func (c *ClientWithResponses) ListShipmentContentUpdatePreviewsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentContentUpdatePreviewsParams) (*ListShipmentContentUpdatePreviewsResp, error) {
	rsp, err := c.ListShipmentContentUpdatePreviews(ctx, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	return ParseListShipmentContentUpdatePreviewsResp(rsp)
}

// GenerateShipmentContentUpdatePreviewsWithBodyWithResponse request with arbitrary body returning *GenerateShipmentContentUpdatePreviewsResp
func (c *ClientWithResponses) GenerateShipmentContentUpdatePreviewsWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*GenerateShipmentContentUpdatePreviewsResp, error) {
	rsp, err := c.GenerateShipmentContentUpdatePreviewsWithBody(ctx, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGenerateShipmentContentUpdatePreviewsResp(rsp)
}

func (c *ClientWithResponses) GenerateShipmentContentUpdatePreviewsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body GenerateShipmentContentUpdatePreviewsJSONRequestBody) (*GenerateShipmentContentUpdatePreviewsResp, error) {
	rsp, err := c.GenerateShipmentContentUpdatePreviews(ctx, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	return ParseGenerateShipmentContentUpdatePreviewsResp(rsp)
}

// GetShipmentContentUpdatePreviewWithResponse request returning *GetShipmentContentUpdatePreviewResp
func (c *ClientWithResponses) GetShipmentContentUpdatePreviewWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentUpdatePreviewId string) (*GetShipmentContentUpdatePreviewResp, error) {
	rsp, err := c.GetShipmentContentUpdatePreview(ctx, inboundPlanId, shipmentId, contentUpdatePreviewId)
	if err != nil {
		return nil, err
	}
	return ParseGetShipmentContentUpdatePreviewResp(rsp)
}

// ConfirmShipmentContentUpdatePreviewWithResponse request returning *ConfirmShipmentContentUpdatePreviewResp
func (c *ClientWithResponses) ConfirmShipmentContentUpdatePreviewWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentUpdatePreviewId string) (*ConfirmShipmentContentUpdatePreviewResp, error) {
	rsp, err := c.ConfirmShipmentContentUpdatePreview(ctx, inboundPlanId, shipmentId, contentUpdatePreviewId)
	if err != nil {
		return nil, err
	}
	return ParseConfirmShipmentContentUpdatePreviewResp(rsp)
}

// GetDeliveryChallanDocumentWithResponse request returning *GetDeliveryChallanDocumentResp
func (c *ClientWithResponses) GetDeliveryChallanDocumentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string) (*GetDeliveryChallanDocumentResp, error) {
	rsp, err := c.GetDeliveryChallanDocument(ctx, inboundPlanId, shipmentId)
	if err != nil {
		return nil, err
	}
	return ParseGetDeliveryChallanDocumentResp(rsp)
}

// ListDeliveryWindowOptionsWithResponse request returning *ListDeliveryWindowOptionsResp
func (c *ClientWithResponses) ListDeliveryWindowOptionsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *ListDeliveryWindowOptionsParams) (*ListDeliveryWindowOptionsResp, error) {
	rsp, err := c.ListDeliveryWindowOptions(ctx, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	return ParseListDeliveryWindowOptionsResp(rsp)
}

// GenerateDeliveryWindowOptionsWithResponse request returning *GenerateDeliveryWindowOptionsResp
func (c *ClientWithResponses) GenerateDeliveryWindowOptionsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string) (*GenerateDeliveryWindowOptionsResp, error) {
	rsp, err := c.GenerateDeliveryWindowOptions(ctx, inboundPlanId, shipmentId)
	if err != nil {
		return nil, err
	}
	return ParseGenerateDeliveryWindowOptionsResp(rsp)
}

// ConfirmDeliveryWindowOptionsWithResponse request returning *ConfirmDeliveryWindowOptionsResp
func (c *ClientWithResponses) ConfirmDeliveryWindowOptionsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, deliveryWindowOptionId string) (*ConfirmDeliveryWindowOptionsResp, error) {
	rsp, err := c.ConfirmDeliveryWindowOptions(ctx, inboundPlanId, shipmentId, deliveryWindowOptionId)
	if err != nil {
		return nil, err
	}
	return ParseConfirmDeliveryWindowOptionsResp(rsp)
}

// ListShipmentItemsWithResponse request returning *ListShipmentItemsResp
func (c *ClientWithResponses) ListShipmentItemsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentItemsParams) (*ListShipmentItemsResp, error) {
	rsp, err := c.ListShipmentItems(ctx, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	return ParseListShipmentItemsResp(rsp)
}

// UpdateShipmentNameWithBodyWithResponse request with arbitrary body returning *UpdateShipmentNameResp
func (c *ClientWithResponses) UpdateShipmentNameWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*UpdateShipmentNameResp, error) {
	rsp, err := c.UpdateShipmentNameWithBody(ctx, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentNameResp(rsp)
}

func (c *ClientWithResponses) UpdateShipmentNameWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentNameJSONRequestBody) (*UpdateShipmentNameResp, error) {
	rsp, err := c.UpdateShipmentName(ctx, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentNameResp(rsp)
}

// ListShipmentPalletsWithResponse request returning *ListShipmentPalletsResp
func (c *ClientWithResponses) ListShipmentPalletsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *ListShipmentPalletsParams) (*ListShipmentPalletsResp, error) {
	rsp, err := c.ListShipmentPallets(ctx, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	return ParseListShipmentPalletsResp(rsp)
}

// CancelSelfShipAppointmentWithBodyWithResponse request with arbitrary body returning *CancelSelfShipAppointmentResp
func (c *ClientWithResponses) CancelSelfShipAppointmentWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*CancelSelfShipAppointmentResp, error) {
	rsp, err := c.CancelSelfShipAppointmentWithBody(ctx, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCancelSelfShipAppointmentResp(rsp)
}

func (c *ClientWithResponses) CancelSelfShipAppointmentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body CancelSelfShipAppointmentJSONRequestBody) (*CancelSelfShipAppointmentResp, error) {
	rsp, err := c.CancelSelfShipAppointment(ctx, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	return ParseCancelSelfShipAppointmentResp(rsp)
}

// GetSelfShipAppointmentSlotsWithResponse request returning *GetSelfShipAppointmentSlotsResp
func (c *ClientWithResponses) GetSelfShipAppointmentSlotsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *GetSelfShipAppointmentSlotsParams) (*GetSelfShipAppointmentSlotsResp, error) {
	rsp, err := c.GetSelfShipAppointmentSlots(ctx, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetSelfShipAppointmentSlotsResp(rsp)
}

// GenerateSelfShipAppointmentSlotsWithBodyWithResponse request with arbitrary body returning *GenerateSelfShipAppointmentSlotsResp
func (c *ClientWithResponses) GenerateSelfShipAppointmentSlotsWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*GenerateSelfShipAppointmentSlotsResp, error) {
	rsp, err := c.GenerateSelfShipAppointmentSlotsWithBody(ctx, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGenerateSelfShipAppointmentSlotsResp(rsp)
}

func (c *ClientWithResponses) GenerateSelfShipAppointmentSlotsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body GenerateSelfShipAppointmentSlotsJSONRequestBody) (*GenerateSelfShipAppointmentSlotsResp, error) {
	rsp, err := c.GenerateSelfShipAppointmentSlots(ctx, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	return ParseGenerateSelfShipAppointmentSlotsResp(rsp)
}

// ScheduleSelfShipAppointmentWithBodyWithResponse request with arbitrary body returning *ScheduleSelfShipAppointmentResp
func (c *ClientWithResponses) ScheduleSelfShipAppointmentWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*ScheduleSelfShipAppointmentResp, error) {
	rsp, err := c.ScheduleSelfShipAppointmentWithBody(ctx, inboundPlanId, shipmentId, slotId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseScheduleSelfShipAppointmentResp(rsp)
}

func (c *ClientWithResponses) ScheduleSelfShipAppointmentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, body ScheduleSelfShipAppointmentJSONRequestBody) (*ScheduleSelfShipAppointmentResp, error) {
	rsp, err := c.ScheduleSelfShipAppointment(ctx, inboundPlanId, shipmentId, slotId, body)
	if err != nil {
		return nil, err
	}
	return ParseScheduleSelfShipAppointmentResp(rsp)
}

// UpdateShipmentSourceAddressWithBodyWithResponse request with arbitrary body returning *UpdateShipmentSourceAddressResp
func (c *ClientWithResponses) UpdateShipmentSourceAddressWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*UpdateShipmentSourceAddressResp, error) {
	rsp, err := c.UpdateShipmentSourceAddressWithBody(ctx, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentSourceAddressResp(rsp)
}

func (c *ClientWithResponses) UpdateShipmentSourceAddressWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentSourceAddressJSONRequestBody) (*UpdateShipmentSourceAddressResp, error) {
	rsp, err := c.UpdateShipmentSourceAddress(ctx, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentSourceAddressResp(rsp)
}

// UpdateShipmentTrackingDetailsWithBodyWithResponse request with arbitrary body returning *UpdateShipmentTrackingDetailsResp
func (c *ClientWithResponses) UpdateShipmentTrackingDetailsWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*UpdateShipmentTrackingDetailsResp, error) {
	rsp, err := c.UpdateShipmentTrackingDetailsWithBody(ctx, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentTrackingDetailsResp(rsp)
}

func (c *ClientWithResponses) UpdateShipmentTrackingDetailsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentTrackingDetailsJSONRequestBody) (*UpdateShipmentTrackingDetailsResp, error) {
	rsp, err := c.UpdateShipmentTrackingDetails(ctx, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentTrackingDetailsResp(rsp)
}

// ListTransportationOptionsWithResponse request returning *ListTransportationOptionsResp
func (c *ClientWithResponses) ListTransportationOptionsWithResponse(ctx context.Context, inboundPlanId string, params *ListTransportationOptionsParams) (*ListTransportationOptionsResp, error) {
	rsp, err := c.ListTransportationOptions(ctx, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	return ParseListTransportationOptionsResp(rsp)
}

// GenerateTransportationOptionsWithBodyWithResponse request with arbitrary body returning *GenerateTransportationOptionsResp
func (c *ClientWithResponses) GenerateTransportationOptionsWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*GenerateTransportationOptionsResp, error) {
	rsp, err := c.GenerateTransportationOptionsWithBody(ctx, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTransportationOptionsResp(rsp)
}

func (c *ClientWithResponses) GenerateTransportationOptionsWithResponse(ctx context.Context, inboundPlanId string, body GenerateTransportationOptionsJSONRequestBody) (*GenerateTransportationOptionsResp, error) {
	rsp, err := c.GenerateTransportationOptions(ctx, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTransportationOptionsResp(rsp)
}

// ConfirmTransportationOptionsWithBodyWithResponse request with arbitrary body returning *ConfirmTransportationOptionsResp
func (c *ClientWithResponses) ConfirmTransportationOptionsWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*ConfirmTransportationOptionsResp, error) {
	rsp, err := c.ConfirmTransportationOptionsWithBody(ctx, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseConfirmTransportationOptionsResp(rsp)
}

func (c *ClientWithResponses) ConfirmTransportationOptionsWithResponse(ctx context.Context, inboundPlanId string, body ConfirmTransportationOptionsJSONRequestBody) (*ConfirmTransportationOptionsResp, error) {
	rsp, err := c.ConfirmTransportationOptions(ctx, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	return ParseConfirmTransportationOptionsResp(rsp)
}

// ListItemComplianceDetailsWithResponse request returning *ListItemComplianceDetailsResp
func (c *ClientWithResponses) ListItemComplianceDetailsWithResponse(ctx context.Context, params *ListItemComplianceDetailsParams) (*ListItemComplianceDetailsResp, error) {
	rsp, err := c.ListItemComplianceDetails(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListItemComplianceDetailsResp(rsp)
}

// UpdateItemComplianceDetailsWithBodyWithResponse request with arbitrary body returning *UpdateItemComplianceDetailsResp
func (c *ClientWithResponses) UpdateItemComplianceDetailsWithBodyWithResponse(ctx context.Context, params *UpdateItemComplianceDetailsParams, contentType string, body io.Reader) (*UpdateItemComplianceDetailsResp, error) {
	rsp, err := c.UpdateItemComplianceDetailsWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemComplianceDetailsResp(rsp)
}

func (c *ClientWithResponses) UpdateItemComplianceDetailsWithResponse(ctx context.Context, params *UpdateItemComplianceDetailsParams, body UpdateItemComplianceDetailsJSONRequestBody) (*UpdateItemComplianceDetailsResp, error) {
	rsp, err := c.UpdateItemComplianceDetails(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemComplianceDetailsResp(rsp)
}

// CreateMarketplaceItemLabelsWithBodyWithResponse request with arbitrary body returning *CreateMarketplaceItemLabelsResp
func (c *ClientWithResponses) CreateMarketplaceItemLabelsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateMarketplaceItemLabelsResp, error) {
	rsp, err := c.CreateMarketplaceItemLabelsWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMarketplaceItemLabelsResp(rsp)
}

func (c *ClientWithResponses) CreateMarketplaceItemLabelsWithResponse(ctx context.Context, body CreateMarketplaceItemLabelsJSONRequestBody) (*CreateMarketplaceItemLabelsResp, error) {
	rsp, err := c.CreateMarketplaceItemLabels(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateMarketplaceItemLabelsResp(rsp)
}

// ListPrepDetailsWithResponse request returning *ListPrepDetailsResp
func (c *ClientWithResponses) ListPrepDetailsWithResponse(ctx context.Context, params *ListPrepDetailsParams) (*ListPrepDetailsResp, error) {
	rsp, err := c.ListPrepDetails(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListPrepDetailsResp(rsp)
}

// SetPrepDetailsWithBodyWithResponse request with arbitrary body returning *SetPrepDetailsResp
func (c *ClientWithResponses) SetPrepDetailsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SetPrepDetailsResp, error) {
	rsp, err := c.SetPrepDetailsWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSetPrepDetailsResp(rsp)
}

func (c *ClientWithResponses) SetPrepDetailsWithResponse(ctx context.Context, body SetPrepDetailsJSONRequestBody) (*SetPrepDetailsResp, error) {
	rsp, err := c.SetPrepDetails(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseSetPrepDetailsResp(rsp)
}

// GetInboundOperationStatusWithResponse request returning *GetInboundOperationStatusResp
func (c *ClientWithResponses) GetInboundOperationStatusWithResponse(ctx context.Context, operationId string) (*GetInboundOperationStatusResp, error) {
	rsp, err := c.GetInboundOperationStatus(ctx, operationId)
	if err != nil {
		return nil, err
	}
	return ParseGetInboundOperationStatusResp(rsp)
}

// ParseListInboundPlansResp parses an HTTP response from a ListInboundPlansWithResponse call
func ParseListInboundPlansResp(rsp *http.Response) (*ListInboundPlansResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboundPlansResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInboundPlansResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateInboundPlanResp parses an HTTP response from a CreateInboundPlanWithResponse call
func ParseCreateInboundPlanResp(rsp *http.Response) (*CreateInboundPlanResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInboundPlanResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateInboundPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetInboundPlanResp parses an HTTP response from a GetInboundPlanWithResponse call
func ParseGetInboundPlanResp(rsp *http.Response) (*GetInboundPlanResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInboundPlanResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InboundPlan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListInboundPlanBoxesResp parses an HTTP response from a ListInboundPlanBoxesWithResponse call
func ParseListInboundPlanBoxesResp(rsp *http.Response) (*ListInboundPlanBoxesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboundPlanBoxesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInboundPlanBoxesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCancelInboundPlanResp parses an HTTP response from a CancelInboundPlanWithResponse call
func ParseCancelInboundPlanResp(rsp *http.Response) (*CancelInboundPlanResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelInboundPlanResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CancelInboundPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListInboundPlanItemsResp parses an HTTP response from a ListInboundPlanItemsWithResponse call
func ParseListInboundPlanItemsResp(rsp *http.Response) (*ListInboundPlanItemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboundPlanItemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInboundPlanItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateInboundPlanNameResp parses an HTTP response from a UpdateInboundPlanNameWithResponse call
func ParseUpdateInboundPlanNameResp(rsp *http.Response) (*UpdateInboundPlanNameResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInboundPlanNameResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListPackingGroupBoxesResp parses an HTTP response from a ListPackingGroupBoxesWithResponse call
func ParseListPackingGroupBoxesResp(rsp *http.Response) (*ListPackingGroupBoxesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPackingGroupBoxesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPackingGroupBoxesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListPackingGroupItemsResp parses an HTTP response from a ListPackingGroupItemsWithResponse call
func ParseListPackingGroupItemsResp(rsp *http.Response) (*ListPackingGroupItemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPackingGroupItemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPackingGroupItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSetPackingInformationResp parses an HTTP response from a SetPackingInformationWithResponse call
func ParseSetPackingInformationResp(rsp *http.Response) (*SetPackingInformationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPackingInformationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SetPackingInformationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListPackingOptionsResp parses an HTTP response from a ListPackingOptionsWithResponse call
func ParseListPackingOptionsResp(rsp *http.Response) (*ListPackingOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPackingOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPackingOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGeneratePackingOptionsResp parses an HTTP response from a GeneratePackingOptionsWithResponse call
func ParseGeneratePackingOptionsResp(rsp *http.Response) (*GeneratePackingOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneratePackingOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest GeneratePackingOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConfirmPackingOptionResp parses an HTTP response from a ConfirmPackingOptionWithResponse call
func ParseConfirmPackingOptionResp(rsp *http.Response) (*ConfirmPackingOptionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmPackingOptionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ConfirmPackingOptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListInboundPlanPalletsResp parses an HTTP response from a ListInboundPlanPalletsWithResponse call
func ParseListInboundPlanPalletsResp(rsp *http.Response) (*ListInboundPlanPalletsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboundPlanPalletsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInboundPlanPalletsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListPlacementOptionsResp parses an HTTP response from a ListPlacementOptionsWithResponse call
func ParseListPlacementOptionsResp(rsp *http.Response) (*ListPlacementOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlacementOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPlacementOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGeneratePlacementOptionsResp parses an HTTP response from a GeneratePlacementOptionsWithResponse call
func ParseGeneratePlacementOptionsResp(rsp *http.Response) (*GeneratePlacementOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneratePlacementOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest GeneratePlacementOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConfirmPlacementOptionResp parses an HTTP response from a ConfirmPlacementOptionWithResponse call
func ParseConfirmPlacementOptionResp(rsp *http.Response) (*ConfirmPlacementOptionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmPlacementOptionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ConfirmPlacementOptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetShipmentResp parses an HTTP response from a GetShipmentWithResponse call
func ParseGetShipmentResp(rsp *http.Response) (*GetShipmentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShipmentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Shipment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListShipmentBoxesResp parses an HTTP response from a ListShipmentBoxesWithResponse call
func ParseListShipmentBoxesResp(rsp *http.Response) (*ListShipmentBoxesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListShipmentBoxesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListShipmentBoxesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListShipmentContentUpdatePreviewsResp parses an HTTP response from a ListShipmentContentUpdatePreviewsWithResponse call
func ParseListShipmentContentUpdatePreviewsResp(rsp *http.Response) (*ListShipmentContentUpdatePreviewsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListShipmentContentUpdatePreviewsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListShipmentContentUpdatePreviewsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGenerateShipmentContentUpdatePreviewsResp parses an HTTP response from a GenerateShipmentContentUpdatePreviewsWithResponse call
func ParseGenerateShipmentContentUpdatePreviewsResp(rsp *http.Response) (*GenerateShipmentContentUpdatePreviewsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateShipmentContentUpdatePreviewsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest GenerateShipmentContentUpdatePreviewsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetShipmentContentUpdatePreviewResp parses an HTTP response from a GetShipmentContentUpdatePreviewWithResponse call
func ParseGetShipmentContentUpdatePreviewResp(rsp *http.Response) (*GetShipmentContentUpdatePreviewResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShipmentContentUpdatePreviewResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentUpdatePreview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConfirmShipmentContentUpdatePreviewResp parses an HTTP response from a ConfirmShipmentContentUpdatePreviewWithResponse call
func ParseConfirmShipmentContentUpdatePreviewResp(rsp *http.Response) (*ConfirmShipmentContentUpdatePreviewResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmShipmentContentUpdatePreviewResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ConfirmShipmentContentUpdatePreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetDeliveryChallanDocumentResp parses an HTTP response from a GetDeliveryChallanDocumentWithResponse call
func ParseGetDeliveryChallanDocumentResp(rsp *http.Response) (*GetDeliveryChallanDocumentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeliveryChallanDocumentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDeliveryChallanDocumentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListDeliveryWindowOptionsResp parses an HTTP response from a ListDeliveryWindowOptionsWithResponse call
func ParseListDeliveryWindowOptionsResp(rsp *http.Response) (*ListDeliveryWindowOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDeliveryWindowOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListDeliveryWindowOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGenerateDeliveryWindowOptionsResp parses an HTTP response from a GenerateDeliveryWindowOptionsWithResponse call
func ParseGenerateDeliveryWindowOptionsResp(rsp *http.Response) (*GenerateDeliveryWindowOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateDeliveryWindowOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest GenerateDeliveryWindowOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConfirmDeliveryWindowOptionsResp parses an HTTP response from a ConfirmDeliveryWindowOptionsWithResponse call
func ParseConfirmDeliveryWindowOptionsResp(rsp *http.Response) (*ConfirmDeliveryWindowOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmDeliveryWindowOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ConfirmDeliveryWindowOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListShipmentItemsResp parses an HTTP response from a ListShipmentItemsWithResponse call
func ParseListShipmentItemsResp(rsp *http.Response) (*ListShipmentItemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListShipmentItemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListShipmentItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateShipmentNameResp parses an HTTP response from a UpdateShipmentNameWithResponse call
func ParseUpdateShipmentNameResp(rsp *http.Response) (*UpdateShipmentNameResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShipmentNameResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListShipmentPalletsResp parses an HTTP response from a ListShipmentPalletsWithResponse call
func ParseListShipmentPalletsResp(rsp *http.Response) (*ListShipmentPalletsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListShipmentPalletsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListShipmentPalletsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCancelSelfShipAppointmentResp parses an HTTP response from a CancelSelfShipAppointmentWithResponse call
func ParseCancelSelfShipAppointmentResp(rsp *http.Response) (*CancelSelfShipAppointmentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelSelfShipAppointmentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CancelSelfShipAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetSelfShipAppointmentSlotsResp parses an HTTP response from a GetSelfShipAppointmentSlotsWithResponse call
func ParseGetSelfShipAppointmentSlotsResp(rsp *http.Response) (*GetSelfShipAppointmentSlotsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSelfShipAppointmentSlotsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSelfShipAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGenerateSelfShipAppointmentSlotsResp parses an HTTP response from a GenerateSelfShipAppointmentSlotsWithResponse call
func ParseGenerateSelfShipAppointmentSlotsResp(rsp *http.Response) (*GenerateSelfShipAppointmentSlotsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateSelfShipAppointmentSlotsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GenerateSelfShipAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseScheduleSelfShipAppointmentResp parses an HTTP response from a ScheduleSelfShipAppointmentWithResponse call
func ParseScheduleSelfShipAppointmentResp(rsp *http.Response) (*ScheduleSelfShipAppointmentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScheduleSelfShipAppointmentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScheduleSelfShipAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateShipmentSourceAddressResp parses an HTTP response from a UpdateShipmentSourceAddressWithResponse call
func ParseUpdateShipmentSourceAddressResp(rsp *http.Response) (*UpdateShipmentSourceAddressResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShipmentSourceAddressResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UpdateShipmentSourceAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateShipmentTrackingDetailsResp parses an HTTP response from a UpdateShipmentTrackingDetailsWithResponse call
func ParseUpdateShipmentTrackingDetailsResp(rsp *http.Response) (*UpdateShipmentTrackingDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShipmentTrackingDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UpdateShipmentTrackingDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListTransportationOptionsResp parses an HTTP response from a ListTransportationOptionsWithResponse call
func ParseListTransportationOptionsResp(rsp *http.Response) (*ListTransportationOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransportationOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTransportationOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGenerateTransportationOptionsResp parses an HTTP response from a GenerateTransportationOptionsWithResponse call
func ParseGenerateTransportationOptionsResp(rsp *http.Response) (*GenerateTransportationOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateTransportationOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest GenerateTransportationOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConfirmTransportationOptionsResp parses an HTTP response from a ConfirmTransportationOptionsWithResponse call
func ParseConfirmTransportationOptionsResp(rsp *http.Response) (*ConfirmTransportationOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmTransportationOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ConfirmTransportationOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListItemComplianceDetailsResp parses an HTTP response from a ListItemComplianceDetailsWithResponse call
func ParseListItemComplianceDetailsResp(rsp *http.Response) (*ListItemComplianceDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListItemComplianceDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListItemComplianceDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateItemComplianceDetailsResp parses an HTTP response from a UpdateItemComplianceDetailsWithResponse call
func ParseUpdateItemComplianceDetailsResp(rsp *http.Response) (*UpdateItemComplianceDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateItemComplianceDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UpdateItemComplianceDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateMarketplaceItemLabelsResp parses an HTTP response from a CreateMarketplaceItemLabelsWithResponse call
func ParseCreateMarketplaceItemLabelsResp(rsp *http.Response) (*CreateMarketplaceItemLabelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMarketplaceItemLabelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateMarketplaceItemLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListPrepDetailsResp parses an HTTP response from a ListPrepDetailsWithResponse call
func ParseListPrepDetailsResp(rsp *http.Response) (*ListPrepDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPrepDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPrepDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSetPrepDetailsResp parses an HTTP response from a SetPrepDetailsWithResponse call
func ParseSetPrepDetailsResp(rsp *http.Response) (*SetPrepDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPrepDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SetPrepDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetInboundOperationStatusResp parses an HTTP response from a GetInboundOperationStatusWithResponse call
func ParseGetInboundOperationStatusResp(rsp *http.Response) (*GetInboundOperationStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInboundOperationStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InboundOperationStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
