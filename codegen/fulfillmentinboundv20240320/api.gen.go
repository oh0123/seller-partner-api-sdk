// Package fulfillmentinboundv20240320 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package fulfillmentinboundv20240320

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/bytedance/sonic"
	"github.com/oapi-codegen/runtime"
)

// Defines values for BoxContentInformationSource.
const (
	BARCODE2D          BoxContentInformationSource = "BARCODE_2D"
	BOXCONTENTPROVIDED BoxContentInformationSource = "BOX_CONTENT_PROVIDED"
	MANUALPROCESS      BoxContentInformationSource = "MANUAL_PROCESS"
)

// Defines values for LabelOwner.
const (
	LabelOwnerAMAZON LabelOwner = "AMAZON"
	LabelOwnerSELLER LabelOwner = "SELLER"
)

// Defines values for OperationStatus.
const (
	FAILED     OperationStatus = "FAILED"
	INPROGRESS OperationStatus = "IN_PROGRESS"
	SUCCESS    OperationStatus = "SUCCESS"
)

// Defines values for PrepOwner.
const (
	PrepOwnerAMAZON PrepOwner = "AMAZON"
	PrepOwnerSELLER PrepOwner = "SELLER"
)

// Defines values for ReasonComment.
const (
	APPOINTMENTREQUESTEDBYMISTAKE  ReasonComment = "APPOINTMENT_REQUESTED_BY_MISTAKE"
	INCREASEDQUANTITY              ReasonComment = "INCREASED_QUANTITY"
	OTHER                          ReasonComment = "OTHER"
	OUTSIDECARRIERBUSINESSHOURS    ReasonComment = "OUTSIDE_CARRIER_BUSINESS_HOURS"
	PROCUREMENTDELAY               ReasonComment = "PROCUREMENT_DELAY"
	SHIPPINGPLANCHANGED            ReasonComment = "SHIPPING_PLAN_CHANGED"
	SLOTNOTSUITABLE                ReasonComment = "SLOT_NOT_SUITABLE"
	UNFAVOURABLEEXTERNALCONDITIONS ReasonComment = "UNFAVOURABLE_EXTERNAL_CONDITIONS"
	VEHICLEDELAY                   ReasonComment = "VEHICLE_DELAY"
)

// Defines values for Stackability.
const (
	NONSTACKABLE Stackability = "NON_STACKABLE"
	STACKABLE    Stackability = "STACKABLE"
)

// Defines values for UnitOfMeasurement.
const (
	CM UnitOfMeasurement = "CM"
	IN UnitOfMeasurement = "IN"
)

// Defines values for UnitOfWeight.
const (
	KG UnitOfWeight = "KG"
	LB UnitOfWeight = "LB"
)

// Defines values for ListInboundPlansParamsStatus.
const (
	ACTIVE  ListInboundPlansParamsStatus = "ACTIVE"
	SHIPPED ListInboundPlansParamsStatus = "SHIPPED"
	VOIDED  ListInboundPlansParamsStatus = "VOIDED"
)

// Defines values for ListInboundPlansParamsSortBy.
const (
	CREATIONTIME    ListInboundPlansParamsSortBy = "CREATION_TIME"
	LASTUPDATEDTIME ListInboundPlansParamsSortBy = "LAST_UPDATED_TIME"
)

// Defines values for ListInboundPlansParamsSortOrder.
const (
	ASC  ListInboundPlansParamsSortOrder = "ASC"
	DESC ListInboundPlansParamsSortOrder = "DESC"
)

// Address Specific details to identify a place.
type Address struct {
	// AddressLine1 Street address information.
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Additional street address information.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// City The city.
	City string `json:"city"`

	// CompanyName The name of the business.
	CompanyName *string `json:"companyName,omitempty"`

	// CountryCode The country code in two-character ISO 3166-1 alpha-2 format.
	CountryCode string `json:"countryCode"`

	// Name The name of the individual or business.
	Name string `json:"name"`

	// PostalCode The postal code.
	PostalCode string `json:"postalCode"`

	// StateOrProvinceCode The state or province code.
	StateOrProvinceCode *string `json:"stateOrProvinceCode,omitempty"`
}

// AppointmentSlot The fulfillment center appointment slot for the transportation option.
type AppointmentSlot struct {
	// SlotId An identifier to a self-ship appointment slot.
	SlotId string `json:"slotId"`

	// SlotTime An appointment slot time with a start and end.
	SlotTime AppointmentSlotTime `json:"slotTime"`
}

// AppointmentSlotTime An appointment slot time with a start and end.
type AppointmentSlotTime struct {
	// EndTime The end timestamp of the appointment in UTC.
	EndTime time.Time `json:"endTime"`

	// StartTime The start timestamp of the appointment in UTC.
	StartTime time.Time `json:"startTime"`
}

// Box Contains information about a box that is used in the inbound plan. The box may contain an item and metadata about the box itself.
type Box struct {
	// BoxId The ID provided by Amazon that identifies a given box. This ID is comprised of the external shipment ID (which
	//         is generated after transportation has been confirmed) and the index of the box.
	BoxId *string `json:"boxId,omitempty"`

	// DestinationRegion Representation of a location used within the inbounding experience.
	DestinationRegion *Region `json:"destinationRegion,omitempty"`

	// Dimensions Measurement of a package dimensions.
	Dimensions *Dimensions `json:"dimensions,omitempty"`

	// Items Items contained within the box.
	Items *[]Item `json:"items,omitempty"`

	// PackageId Primary key to uniquely identify a Package (Box or Pallet).
	PackageId string `json:"packageId"`

	// Quantity The number of containers where all other properties like weight or dimensions are identical.
	Quantity *int `json:"quantity,omitempty"`

	// TemplateName Template name of the box.
	TemplateName *string `json:"templateName,omitempty"`

	// Weight The weight of a package.
	Weight *Weight `json:"weight,omitempty"`
}

// BoxContent Specifies contents in a box. Each `BoxContent` minimally contains a mapping of an MSKU to the prep owner, label owner and its quantity in the box. It also contains the MSKU expiration date and manufacturing lot code if applicable.
type BoxContent struct {
	// Expiration The date in ISO 8601 format for when the MSKU expires.
	Expiration *string `json:"expiration,omitempty"`

	// LabelOwner Specifies who will label the items. Options include `AMAZON` and `SELLER`.
	LabelOwner LabelOwner `json:"labelOwner"`

	// ManufacturingLotCode The manufacturing lot code.
	ManufacturingLotCode *string `json:"manufacturingLotCode,omitempty"`

	// Msku The merchant SKU, a merchant-supplied identifier for a specific SKU.
	Msku string `json:"msku"`

	// PrepOwner In some situations, special preparations are required for items and this field reflects the owner of the preparations. Options include `AMAZON` or `SELLER`.
	PrepOwner PrepOwner `json:"prepOwner"`

	// QuantityInBox The number of units of the given MSKU in the box.
	QuantityInBox int `json:"quantityInBox"`
}

// BoxContentInformationSource Indication of how box content is meant to be provided.
type BoxContentInformationSource string

// BoxInput Input information for a given box.
type BoxInput struct {
	// BoxId The ID of the box to update that was provided by Amazon. This ID is comprised of the external shipment ID
	//         (which is generated after transportation has been confirmed) and the index of the box.
	BoxId *string `json:"boxId,omitempty"`

	// ContentInformationSource Indication of how box content is meant to be provided.
	ContentInformationSource BoxContentInformationSource `json:"contentInformationSource"`

	// Contents The Contents of the box containing a list of MSKUs and their quantity. If `boxAttribute` is `BARCODE_2D` or `MANUAL_PROCESS`, user should provide ALL of the items that could be in the box, without specifying item quantities.
	Contents *[]BoxContent `json:"contents,omitempty"`

	// Dimensions Measurement of a package dimensions.
	Dimensions Dimensions `json:"dimensions"`

	// Quantity The number of containers where all other properties like weight or dimensions are identical.
	Quantity int `json:"quantity"`

	// TemplateName The seller-provided name for a 'type' of box (or a group of boxes with the same contents), which will be used to identify all created boxes of that type. When providing bulk box information, this value must be unique from the other box types. When providing individual boxes with existing IDs, this value can be shared between many boxes that have the same contents.
	TemplateName string `json:"templateName"`

	// Weight The weight of a package.
	Weight Weight `json:"weight"`
}

// CancelInboundPlanResponse The `cancelInboundPlan` response.
type CancelInboundPlanResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// CancelSelfShipAppointmentRequest The `cancelSelfShipAppointment` request.
type CancelSelfShipAppointmentRequest struct {
	// ReasonComment Reason for cancelling or rescheduling a self-ship appointment.
	ReasonComment *ReasonComment `json:"reasonComment,omitempty"`
}

// CancelSelfShipAppointmentResponse The `cancelSelfShipAppointment` response.
type CancelSelfShipAppointmentResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// Carrier The carrier for the inbound shipment.
type Carrier struct {
	// AlphaCode The carrier code. For example, USPS or DHLEX.
	AlphaCode *string `json:"alphaCode,omitempty"`

	// Name The name of the carrier.
	Name *string `json:"name,omitempty"`
}

// ComplianceDetail Contains item identifiers and related tax information.
type ComplianceDetail struct {
	// Asin The Amazon Standard Identification Number, which identifies the detail page identifier.
	Asin *string `json:"asin,omitempty"`

	// Fnsku The Fulfillment Network SKU, which identifies a real fulfillable item with catalog data and condition.
	Fnsku *string `json:"fnsku,omitempty"`

	// Msku The merchant SKU, a merchant-supplied identifier for a specific SKU.
	Msku *string `json:"msku,omitempty"`

	// TaxDetails Information used to determine the tax compliance.
	TaxDetails *TaxDetails `json:"taxDetails,omitempty"`
}

// ConfirmPackingOptionResponse The `confirmPackingOption` response.
type ConfirmPackingOptionResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// ConfirmPlacementOptionResponse The `confirmPlacementOption` response.
type ConfirmPlacementOptionResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// ConfirmTransportationOptionsRequest The `confirmTransportationOptions` request.
type ConfirmTransportationOptionsRequest struct {
	// TransportationSelections Information needed to confirm one of the available transportation options.
	TransportationSelections []TransportationSelection `json:"transportationSelections"`
}

// ConfirmTransportationOptionsResponse The `confirmTransportationOptions` response.
type ConfirmTransportationOptionsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// ContactInformation The seller's contact information.
type ContactInformation struct {
	// Email Email address.
	Email *string `json:"email,omitempty"`

	// Name The name belonging to the contact. This field is required when contact information is being provided for
	//         Less-Than-Truckload (LTL) carrier shipments.
	Name *string `json:"name,omitempty"`

	// PhoneNumber The phone number of the seller.
	PhoneNumber string `json:"phoneNumber"`
}

// CreateInboundPlanRequest The `createInboundPlan` request.
type CreateInboundPlanRequest struct {
	// ContactInformation The seller's contact information.
	ContactInformation ContactInformation `json:"contactInformation"`

	// DestinationMarketplaces Marketplaces where the items need to be shipped to. Currently only one marketplace can be selected in this request.
	DestinationMarketplaces []string `json:"destinationMarketplaces"`

	// Items Items included in this plan.
	Items []ItemInput `json:"items"`

	// Name Name for the Inbound Plan. If one isn't provided, a default name will be provided.
	Name *string `json:"name,omitempty"`

	// SourceAddress Specific details to identify a place.
	SourceAddress Address `json:"sourceAddress"`
}

// CreateInboundPlanResponse The `createInboundPlan` response.
type CreateInboundPlanResponse struct {
	// InboundPlanId Identifier to an inbound plan.
	InboundPlanId string `json:"inboundPlanId"`

	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// Currency Currency definition.
type Currency struct {
	// Amount Decimal value of the currency.
	Amount float32 `json:"amount"`

	// Code ISO 4217 standard of a currency code.
	Code string `json:"code"`
}

// CustomPlacementInput Provide units going to the warehouse.
type CustomPlacementInput struct {
	// Items Items included while creating Inbound Plan.
	Items []ItemInput `json:"items"`

	// WarehouseId Warehouse Id.
	WarehouseId string `json:"warehouseId"`
}

// Dates Specifies the dates that the seller expects their shipment will be shipped and delivered.
type Dates struct {
	// DeliveryWindow Contains a start and end DateTime representing a time range.
	DeliveryWindow *Window `json:"deliveryWindow,omitempty"`

	// ReadyToShipWindow Contains a start and end DateTime representing a time range.
	ReadyToShipWindow *Window `json:"readyToShipWindow,omitempty"`
}

// Dimensions Measurement of a package dimensions.
type Dimensions struct {
	// Height Height.
	Height float64 `json:"height"`

	// Length Length.
	Length float64 `json:"length"`

	// UnitOfMeasurement Unit of linear measure.
	UnitOfMeasurement UnitOfMeasurement `json:"unitOfMeasurement"`

	// Width Width.
	Width float64 `json:"width"`
}

// DocumentDownload Resource to download the requested document.
type DocumentDownload struct {
	// DownloadType The type of download. Can be `URL` or `PDF_BASE64`.
	DownloadType string `json:"downloadType"`

	// Expiration The timestamp of expiration of the URI. This is in ISO 8601 datetime format with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	Expiration *time.Time `json:"expiration,omitempty"`

	// Uri Uniform resource identifier to identify where the document is located.
	Uri string `json:"uri"`
}

// Error Error object containing information about what went wrong.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	// Errors List of errors.
	Errors []Error `json:"errors"`
}

// GeneratePackingOptionsResponse The `generatePackingOptions` response.
type GeneratePackingOptionsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// GeneratePlacementOptionsRequest The `generatePlacementOptions` request.
type GeneratePlacementOptionsRequest struct {
	// CustomPlacement Custom placements options to be added to the plan.
	CustomPlacement *[]CustomPlacementInput `json:"customPlacement,omitempty"`
}

// GeneratePlacementOptionsResponse The `generatePlacementOptions` response.
type GeneratePlacementOptionsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// GenerateSelfShipAppointmentSlotsRequest The `generateSelfShipAppointmentSlots` request.
type GenerateSelfShipAppointmentSlotsRequest struct {
	// DesiredEndDate The ISO 8601 datetime with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	DesiredEndDate *time.Time `json:"desiredEndDate,omitempty"`

	// DesiredStartDate The ISO 8601 datetime with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	DesiredStartDate *time.Time `json:"desiredStartDate,omitempty"`
}

// GenerateSelfShipAppointmentSlotsResponse The `generateSelfShipAppointmentSlots` response.
type GenerateSelfShipAppointmentSlotsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// GenerateTransportationOptionsRequest The `generateTransportationOptions` request.
type GenerateTransportationOptionsRequest struct {
	// PlacementOptionId The placement option to generate transportation options for.
	PlacementOptionId string `json:"placementOptionId"`

	// ShipmentTransportationConfigurations List of shipment transportation configurations.
	ShipmentTransportationConfigurations []ShipmentTransportationConfiguration `json:"shipmentTransportationConfigurations"`
}

// GenerateTransportationOptionsResponse The `generateTransportationOptions` response.
type GenerateTransportationOptionsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// GetDeliveryChallanDocumentResponse The `getDeliveryChallanDocumentResponse` response.
type GetDeliveryChallanDocumentResponse struct {
	// DocumentDownload Resource to download the requested document.
	DocumentDownload DocumentDownload `json:"documentDownload"`
}

// GetSelfShipAppointmentSlotsResponse The `getSelfShipAppointmentSlots` response.
type GetSelfShipAppointmentSlotsResponse struct {
	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`

	// SelfShipAppointmentSlotsAvailability The self ship appointment time slots availability and an expiration date for which the slots can be scheduled.
	SelfShipAppointmentSlotsAvailability SelfShipAppointmentSlotsAvailability `json:"selfShipAppointmentSlotsAvailability"`
}

// InboundOperationStatus The `getInboundOperationStatus` response.
type InboundOperationStatus struct {
	// Operation The name of the operation that was executed in the asynchronous API call.
	Operation string `json:"operation"`

	// OperationId The operation Id returned by the asynchronous API call.
	OperationId string `json:"operationId"`

	// OperationProblems The problems in the processing of the asynchronous operation.
	OperationProblems []OperationProblem `json:"operationProblems"`

	// OperationStatus The status of an operation.
	OperationStatus OperationStatus `json:"operationStatus"`
}

// InboundPlan Inbound plan containing details of the inbound workflow.
type InboundPlan struct {
	// ContactInformation The seller's contact information.
	ContactInformation ContactInformation `json:"contactInformation"`

	// CreatedAt The ISO 8601 datetime with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	CreatedAt time.Time `json:"createdAt"`

	// InboundPlanId Identifier to an inbound plan.
	InboundPlanId string `json:"inboundPlanId"`

	// LastUpdatedAt The ISO 8601 datetime with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	LastUpdatedAt time.Time `json:"lastUpdatedAt"`

	// MarketplaceIds Marketplace IDs.
	MarketplaceIds []string `json:"marketplaceIds"`

	// Name The human-readable name of the inbound plan.
	Name string `json:"name"`

	// PackingOptions Packing options for the inbound plan. This property will be populated when it has been generated via the corresponding endpoint. If there is a chosen placement option, only packing options for that placement option will be returned. If there are confirmed shipments, only packing options for those shipments will be returned. Query the packing option for more details.
	PackingOptions *[]PackingOptionSummary `json:"packingOptions,omitempty"`

	// PlacementOptions Placement options for the inbound plan. This property will be populated when it has been generated via the corresponding endpoint. If there is a chosen placement option, that will be the only returned option. Query the placement option for more details.
	PlacementOptions *[]PlacementOptionSummary `json:"placementOptions,omitempty"`

	// Shipments Shipment IDs for the inbound plan. This property will be populated when it has been generated via the corresponding endpoint. If there is a chosen placement option, only shipments for that option will be returned. If there are confirmed shipments, only those shipments will be returned. Query the shipment for more details.
	Shipments *[]ShipmentSummary `json:"shipments,omitempty"`

	// SourceAddress Specific details to identify a place.
	SourceAddress Address `json:"sourceAddress"`

	// Status Current status of the inbound plan. Can be `ACTIVE`, `VOIDED`, or `SHIPPED`.
	Status string `json:"status"`
}

// InboundPlanSummary A light-weight inbound plan.
type InboundPlanSummary struct {
	// ContactInformation The seller's contact information.
	ContactInformation ContactInformation `json:"contactInformation"`

	// CreatedAt The ISO 8601 datetime with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	CreatedAt time.Time `json:"createdAt"`

	// InboundPlanId Identifier to an inbound plan.
	InboundPlanId string `json:"inboundPlanId"`

	// LastUpdatedAt ISO 8601 datetime with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	LastUpdatedAt time.Time `json:"lastUpdatedAt"`

	// MarketplaceIds Marketplace IDs.
	MarketplaceIds []string `json:"marketplaceIds"`

	// Name Human-readable name of the inbound plan.
	Name string `json:"name"`

	// SourceAddress Specific details to identify a place.
	SourceAddress Address `json:"sourceAddress"`

	// Status Current status of the inbound plan. Can be 'ACTIVE', 'VOIDED', or 'SHIPPED'.
	Status string `json:"status"`
}

// Incentive Contains details about cost related modifications to the placement cost.
type Incentive struct {
	// Description Description of the incentive.
	Description string `json:"description"`

	// Target Target of the incentive. Can be 'Placement Services' or 'Fulfillment Fee Discount'.
	Target string `json:"target"`

	// Type Type of incentive. Can be `FEE` or `DISCOUNT`.
	Type string `json:"type"`

	// Value Currency definition.
	Value Currency `json:"value"`
}

// Item Information associated with a single SKU in the seller's catalog.
type Item struct {
	// Asin The Amazon Standard Identification Number (ASIN) of the item.
	Asin string `json:"asin"`

	// Expiration The expiration date of the MSKU in ISO 8601 format. The same MSKU with different expiration dates cannot go into the same box.
	Expiration *string `json:"expiration,omitempty"`

	// Fnsku A unique identifier assigned by Amazon to products stored in and fulfilled from an Amazon fulfillment center.
	Fnsku string `json:"fnsku"`

	// LabelOwner Specifies who will label the items. Options include `AMAZON` and `SELLER`.
	LabelOwner string `json:"labelOwner"`

	// ManufacturingLotCode The manufacturing lot code.
	ManufacturingLotCode *string `json:"manufacturingLotCode,omitempty"`

	// Msku The merchant defined SKU ID.
	Msku string `json:"msku"`

	// PrepInstructions Special preparations that are required for an item.
	PrepInstructions []PrepInstruction `json:"prepInstructions"`

	// Quantity The number of the specified MSKU.
	Quantity int `json:"quantity"`
}

// ItemInput Defines an item's input parameters.
type ItemInput struct {
	// Expiration The expiration date of the MSKU in ISO 8601 format. The same MSKU with different expiration dates cannot go into the same box.
	Expiration *string `json:"expiration,omitempty"`

	// LabelOwner Specifies who will label the items. Options include `AMAZON` and `SELLER`.
	LabelOwner LabelOwner `json:"labelOwner"`

	// ManufacturingLotCode The manufacturing lot code.
	ManufacturingLotCode *string `json:"manufacturingLotCode,omitempty"`

	// Msku The merchant SKU.
	Msku string `json:"msku"`

	// PrepOwner In some situations, special preparations are required for items and this field reflects the owner of the preparations. Options include `AMAZON` or `SELLER`.
	PrepOwner PrepOwner `json:"prepOwner"`

	// Quantity The number of units of the specified MSKU that will be shipped.
	Quantity int `json:"quantity"`
}

// LabelOwner Specifies who will label the items. Options include `AMAZON` and `SELLER`.
type LabelOwner string

// ListInboundPlanBoxesResponse `listInboundPlanBoxes` response.
type ListInboundPlanBoxesResponse struct {
	// Boxes A list of boxes in an inbound plan.
	Boxes []Box `json:"boxes"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListInboundPlanItemsResponse `listInboundPlanItems` response.
type ListInboundPlanItemsResponse struct {
	// Items The items in an inbound plan.
	Items []Item `json:"items"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListInboundPlanPalletsResponse `listInboundPlanPallets` response.
type ListInboundPlanPalletsResponse struct {
	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`

	// Pallets The pallets in an inbound plan.
	Pallets []Pallet `json:"pallets"`
}

// ListInboundPlansResponse `listInboundPlans` response.
type ListInboundPlansResponse struct {
	// InboundPlans A list of inbound plans with minimal information.
	InboundPlans *[]InboundPlanSummary `json:"inboundPlans,omitempty"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListItemComplianceDetailsResponse `listItemComplianceDetails` response.
type ListItemComplianceDetailsResponse struct {
	// ComplianceDetails List of compliance details.
	ComplianceDetails *[]ComplianceDetail `json:"complianceDetails,omitempty"`
}

// ListPackingGroupItemsResponse `listPackingGroupItems` response.
type ListPackingGroupItemsResponse struct {
	// Items Provides the information about the list of items in the inbound plan.
	Items []Item `json:"items"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListPackingOptionsResponse `listPackingOptions` response.
type ListPackingOptionsResponse struct {
	// PackingOptions List of packing options.
	PackingOptions []PackingOption `json:"packingOptions"`

	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListPlacementOptionsResponse `listPlacementOptions` response.
type ListPlacementOptionsResponse struct {
	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`

	// PlacementOptions Placement options generated for the inbound plan.
	PlacementOptions []PlacementOption `json:"placementOptions"`
}

// ListTransportationOptionsResponse `listTransportationOptions` response.
type ListTransportationOptionsResponse struct {
	// Pagination Contains tokens to fetch from a certain page.
	Pagination *Pagination `json:"pagination,omitempty"`

	// TransportationOptions Transportation options generated for the placement option.
	TransportationOptions []TransportationOption `json:"transportationOptions"`
}

// LtlTrackingDetail Contains information related to Less-Than-Truckload (LTL) shipment tracking.
type LtlTrackingDetail struct {
	// BillOfLadingNumber The number of the carrier shipment acknowledgement document.
	BillOfLadingNumber *string `json:"billOfLadingNumber,omitempty"`

	// FreightBillNumber The number associated with the freight bill.
	FreightBillNumber *[]string `json:"freightBillNumber,omitempty"`
}

// LtlTrackingDetailInput Contains input information to update Less-Than-Truckload (LTL) tracking information.
type LtlTrackingDetailInput struct {
	// BillOfLadingNumber The number of the carrier shipment acknowledgement document.
	BillOfLadingNumber *string `json:"billOfLadingNumber,omitempty"`

	// FreightBillNumber Number associated with the freight bill.
	FreightBillNumber []string `json:"freightBillNumber"`
}

// OperationProblem A problem with additional properties persisted to an operation.
type OperationProblem struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`

	// Severity The severity of the problem. Can be 'WARNING', or 'ERROR'.
	Severity string `json:"severity"`
}

// OperationStatus The status of an operation.
type OperationStatus string

// PackageGroupingInput Packing information for the inbound plan.
type PackageGroupingInput struct {
	// Boxes Box level information being provided.
	Boxes []BoxInput `json:"boxes"`

	// PackingGroupId The ID of the `packingGroup` that packages are grouped according to. The `PackingGroupId` can only be provided before placement confirmation, and it must belong to the confirmed `PackingOption`. One of `ShipmentId` or `PackingGroupId` must be provided with every request.
	PackingGroupId *string `json:"packingGroupId,omitempty"`

	// ShipmentId The ID of the shipment that packages are grouped according to. The `ShipmentId` can only be provided after placement confirmation, and the shipment must belong to the confirmed placement option. One of `ShipmentId` or `PackingGroupId` must be provided with every request.
	ShipmentId *string `json:"shipmentId,omitempty"`
}

// PackingOption A packing option contains a set of pack groups plus additional information about the packing option, such as any discounts or fees if it's selected.
type PackingOption struct {
	// Discounts Discount for the offered option.
	Discounts []Incentive `json:"discounts"`

	// Expiration The timestamp at which this packing option becomes no longer valid. This is in ISO 8601 datetime format with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	Expiration *time.Time `json:"expiration,omitempty"`

	// Fees Fee for the offered option.
	Fees []Incentive `json:"fees"`

	// InboundPlanId Identifier to an inbound plan.
	InboundPlanId string `json:"inboundPlanId"`

	// PackingGroups Packing group IDs.
	PackingGroups []string `json:"packingGroups"`

	// PackingOptionId Identifier to a packing option.
	PackingOptionId string `json:"packingOptionId"`

	// Status The status of the packing option. Can be `OFFERED`, `ACCEPTED`, or `EXPIRED`.
	Status string `json:"status"`

	// SupportedShippingConfigurations List of supported shipping modes.
	SupportedShippingConfigurations []ShippingConfiguration `json:"supportedShippingConfigurations"`
}

// PackingOptionSummary Summary information about a packing option.
type PackingOptionSummary struct {
	// PackingOptionId Identifier to a packing option.
	PackingOptionId string `json:"packingOptionId"`

	// Status The status of a packing option. Can be 'OFFERED', 'ACCEPTED', or 'EXPIRED'.
	Status string `json:"status"`
}

// Pagination Contains tokens to fetch from a certain page.
type Pagination struct {
	// NextToken When present, pass this string token in the next request to return the next response page.
	NextToken *string `json:"nextToken,omitempty"`
}

// Pallet Contains information about a pallet that is used in the inbound plan. The pallet is a container that holds multiple items or boxes.
type Pallet struct {
	// Dimensions Measurement of a package dimensions.
	Dimensions *Dimensions `json:"dimensions,omitempty"`

	// PackageId Primary key to uniquely identify a Package (Box or Pallet).
	PackageId string `json:"packageId"`

	// Quantity The number of containers where all other properties like weight or dimensions are identical.
	Quantity *int `json:"quantity,omitempty"`

	// Stackability Indicates whether pallets will be stacked when carrier arrives for pick-up.
	Stackability *Stackability `json:"stackability,omitempty"`

	// Weight The weight of a package.
	Weight *Weight `json:"weight,omitempty"`
}

// PalletInformation Pallet information, including weight, dimensions, quantity, stackability, freight class, and declared value.
type PalletInformation struct {
	// DeclaredValue Currency definition.
	DeclaredValue *Currency `json:"declaredValue,omitempty"`

	// FreightClass Freight class. Can be `NONE`, `FC_50`, `FC_55`, `FC_60`, `FC_65`, `FC_70`, `FC_77_5`, `FC_85`, `FC_92_5`, `FC_100`, `FC_110`, `FC_125`, `FC_150`, `FC_175`, `FC_200`, `FC_250`, `FC_300`, `FC_400`, or `FC_500`.
	FreightClass *string `json:"freightClass,omitempty"`

	// Pallets Set pallet configuration for Less-Than-Truckload (LTL).
	Pallets []PalletInput `json:"pallets"`
}

// PalletInput Set pallet configuration for Less-Than-Truckload (LTL).
type PalletInput struct {
	// Dimensions Measurement of a package dimensions.
	Dimensions *Dimensions `json:"dimensions,omitempty"`

	// Quantity The number of containers where all other properties like weight or dimensions are identical.
	Quantity int `json:"quantity"`

	// Stackability Indicates whether pallets will be stacked when carrier arrives for pick-up.
	Stackability *Stackability `json:"stackability,omitempty"`

	// Weight The weight of a package.
	Weight *Weight `json:"weight,omitempty"`
}

// PlacementOption Contains information pertaining to the placement of the contents of an inbound plan and the related costs.
type PlacementOption struct {
	// Discounts Discount for the offered option.
	Discounts []Incentive `json:"discounts"`

	// Expiration The expiration date of the placement option. This is in ISO 8601 datetime format with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	Expiration *time.Time `json:"expiration,omitempty"`

	// Fees Fee for the offered option.
	Fees []Incentive `json:"fees"`

	// PlacementOptionId Identifier to a placement option. A placement option represents the shipment splits and destinations of SKUs.
	PlacementOptionId string `json:"placementOptionId"`

	// ShipmentIds Shipment ids.
	ShipmentIds []string `json:"shipmentIds"`

	// Status The status of a placement option. Can be `OFFERED`, `ACCEPTED`, or `EXPIRED`.
	Status string `json:"status"`
}

// PlacementOptionSummary Summary information about a placement option.
type PlacementOptionSummary struct {
	// PlacementOptionId Identifier to a placement option. A placement option represents the shipment splits and destinations of SKUs.
	PlacementOptionId string `json:"placementOptionId"`

	// Status The status of a placement option. Can be `OFFERED` or `ACCEPTED`.
	Status string `json:"status"`
}

// PrepInstruction Information pertaining to the preparation of inbound goods.
type PrepInstruction struct {
	// Fee Currency definition.
	Fee *Currency `json:"fee,omitempty"`

	// PrepOwner In some situations, special preparations are required for items and this field reflects the owner of the
	//         preparations. Options include `AMAZON` or `SELLER`.
	PrepOwner *string `json:"prepOwner,omitempty"`

	// PrepType Type of preparation that should be done. Can be `ITEM_LABELING`, `ITEM_BUBBLEWRAP`, `ITEM_POLYBAGGING`, `ITEM_TAPING`, `ITEM_BLACK_SHRINKWRAP`, `ITEM_HANG_GARMENT`, `ITEM_BOXING`, `ITEM_SETCREAT`, `ITEM_RMOVHANG`, `ITEM_SUFFOSTK`, `ITEM_CAP_SEALING`, `ITEM_DEBUNDLE`, `ITEM_SETSTK`, `ITEM_SIOC`, `ITEM_NO_PREP`, `ADULT`, `BABY`, `TEXTILE`, `HANGER`, `FRAGILE`, `LIQUID`, `SHARP`, `SMALL`, `PERFORATED`, `GRANULAR`, `SET`, `FC_PROVIDED`, `UNKNOWN`, or `NONE`.
	PrepType *string `json:"prepType,omitempty"`
}

// PrepOwner In some situations, special preparations are required for items and this field reflects the owner of the preparations. Options include `AMAZON` or `SELLER`.
type PrepOwner string

// Quote The estimated shipping cost associated with the transportation option.
type Quote struct {
	// Cost Currency definition.
	Cost Currency `json:"cost"`

	// Expiration The timestamp at which this transportation option quote becomes no longer valid. This is in ISO 8601 datetime format with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	Expiration *time.Time `json:"expiration,omitempty"`

	// VoidableUntil Voidable until timestamp.
	VoidableUntil *time.Time `json:"voidableUntil,omitempty"`
}

// ReasonComment Reason for cancelling or rescheduling a self-ship appointment.
type ReasonComment string

// Region Representation of a location used within the inbounding experience.
type Region struct {
	// CountryCode ISO 3166 standard alpha-2 country code.
	CountryCode *string `json:"countryCode,omitempty"`

	// State State.
	State *string `json:"state,omitempty"`

	// WarehouseId An identifier for a warehouse, such as a FC, IXD, upstream storage.
	WarehouseId *string `json:"warehouseId,omitempty"`
}

// ScheduleSelfShipAppointmentRequest `scheduleSelfShipAppointment` request.
type ScheduleSelfShipAppointmentRequest struct {
	// ReasonComment Reason for cancelling or rescheduling a self-ship appointment.
	ReasonComment *ReasonComment `json:"reasonComment,omitempty"`
}

// ScheduleSelfShipAppointmentResponse `scheduleSelfShipAppointment` response.
type ScheduleSelfShipAppointmentResponse struct {
	// SelfShipAppointmentDetails Appointment details for carrier pickup or fulfillment center appointments.
	SelfShipAppointmentDetails SelfShipAppointmentDetails `json:"selfShipAppointmentDetails"`
}

// SelfShipAppointmentDetails Appointment details for carrier pickup or fulfillment center appointments.
type SelfShipAppointmentDetails struct {
	// AppointmentId Identifier for appointment.
	AppointmentId *float32 `json:"appointmentId,omitempty"`

	// AppointmentSlotTime An appointment slot time with a start and end.
	AppointmentSlotTime *AppointmentSlotTime `json:"appointmentSlotTime,omitempty"`

	// AppointmentStatus Status of the appointment.
	AppointmentStatus *string `json:"appointmentStatus,omitempty"`
}

// SelfShipAppointmentSlotsAvailability The self ship appointment time slots availability and an expiration date for which the slots can be scheduled.
type SelfShipAppointmentSlotsAvailability struct {
	// ExpiresAt ISO 8601 datetime with pattern `yyyy-MM-ddTHH:mm:ss.sssZ`.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Slots List of appointment slots.
	Slots *[]AppointmentSlot `json:"slots,omitempty"`
}

// SetPackingInformationRequest `setPackingInformation` request.
type SetPackingInformationRequest struct {
	// PackageGroupings List of packing information for the inbound plan.
	PackageGroupings *[]PackageGroupingInput `json:"packageGroupings,omitempty"`
}

// SetPackingInformationResponse `setPackingInformation` response.
type SetPackingInformationResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// Shipment Contains information pertaining to a shipment in an inbound plan.
type Shipment struct {
	// AmazonReferenceId A unique identifier created by Amazon that identifies this Amazon-partnered, Less Than Truckload/Full Truckload (LTL/FTL) shipment.
	AmazonReferenceId *string `json:"amazonReferenceId,omitempty"`

	// ContactInformation The seller's contact information.
	ContactInformation *ContactInformation `json:"contactInformation,omitempty"`

	// Dates Specifies the dates that the seller expects their shipment will be shipped and delivered.
	Dates *Dates `json:"dates,omitempty"`

	// Destination The Amazon fulfillment center address and warehouse ID.
	Destination ShipmentDestination `json:"destination"`

	// InboundPlanId Identifier to an inbound plan.
	InboundPlanId string `json:"inboundPlanId"`

	// Name The name of the shipment.
	Name *string `json:"name,omitempty"`

	// PalletInformation Pallet information, including weight, dimensions, quantity, stackability, freight class, and declared value.
	PalletInformation *PalletInformation `json:"palletInformation,omitempty"`

	// PlacementOptionId Identifier to a placement option. A placement option represents the shipment splits and destinations of SKUs.
	PlacementOptionId string `json:"placementOptionId"`

	// SelectedTransportationOptionId Identifier to a transportation option. A transportation option represent one option for how to send a shipment.
	SelectedTransportationOptionId *string `json:"selectedTransportationOptionId,omitempty"`

	// SelfShipAppointmentDetails List of self ship appointment details.
	SelfShipAppointmentDetails *[]SelfShipAppointmentDetails `json:"selfShipAppointmentDetails,omitempty"`

	// ShipmentConfirmationId The confirmed shipment ID which shows up on labels (for example, FBA1234ABCD).
	ShipmentConfirmationId *string `json:"shipmentConfirmationId,omitempty"`

	// ShipmentId Identifier to a shipment. A shipment contains the boxes and units being inbounded.
	ShipmentId string `json:"shipmentId"`

	// Source Specifies the 'ship from' address for the shipment.
	Source ShipmentSource `json:"source"`

	// Status The status of a shipment. The state of the shipment will typically start in `WORKING` and transition to `READY_TO_SHIP` once required actions are complete prior to being picked up or shipped out. Can be `ABANDONED`, `CANCELLED`, `CHECKED_IN`, `CLOSED`, `DELETED`, `DELIVERED`, `IN_TRANSIT`, `MIXED`, `READY_TO_SHIP`, `RECEIVING`, `SHIPPED`, or `WORKING`.
	Status *string `json:"status,omitempty"`

	// TrackingDetails Tracking information for Less-Than-Truckload (LTL) and Small Parcel Delivery (SPD) shipments.
	TrackingDetails *TrackingDetails `json:"trackingDetails,omitempty"`
}

// ShipmentDestination The Amazon fulfillment center address and warehouse ID.
type ShipmentDestination struct {
	// Address Specific details to identify a place.
	Address *Address `json:"address,omitempty"`

	// DestinationType The type of destination for this shipment. Can be `AMAZON_OPTIMIZED`, or `AMAZON_WAREHOUSE`.
	DestinationType string `json:"destinationType"`

	// WarehouseId The warehouse that the shipment should be sent to.  Empty if the destination type is `AMAZON_OPTIMIZED`.
	WarehouseId *string `json:"warehouseId,omitempty"`
}

// ShipmentSource Specifies the 'ship from' address for the shipment.
type ShipmentSource struct {
	// Address Specific details to identify a place.
	Address *Address `json:"address,omitempty"`

	// SourceType The type of source for this shipment. Can be `SELLER_FACILITY`.
	SourceType string `json:"sourceType"`
}

// ShipmentSummary Summary information about a shipment.
type ShipmentSummary struct {
	// ShipmentId Identifier to a shipment. A shipment contains the boxes and units being inbounded.
	ShipmentId string `json:"shipmentId"`

	// Status The status of a shipment. The state of the shipment will typically start in `WORKING` and transition to `READY_TO_SHIP` once required actions are complete prior to being picked up or shipped out. Can be `ABANDONED`, `CANCELLED`, `CHECKED_IN`, `CLOSED`, `DELETED`, `DELIVERED`, `IN_TRANSIT`, `MIXED`, `READY_TO_SHIP`, `RECEIVING`, `SHIPPED`, or `WORKING`.
	Status string `json:"status"`
}

// ShipmentTransportationConfiguration Details needed to generate the transportation options.
type ShipmentTransportationConfiguration struct {
	// ContactInformation The seller's contact information.
	ContactInformation *ContactInformation `json:"contactInformation,omitempty"`

	// PalletInformation Pallet information, including weight, dimensions, quantity, stackability, freight class, and declared value.
	PalletInformation *PalletInformation `json:"palletInformation,omitempty"`

	// ReadyToShipWindow Contains only a starting DateTime.
	ReadyToShipWindow WindowInput `json:"readyToShipWindow"`

	// ShipmentId Identifier to a shipment. A shipment contains the boxes and units being inbounded.
	ShipmentId string `json:"shipmentId"`
}

// ShippingConfiguration The shipping configurations supported for the packing option. Available modes are ground small parcel, freight less-than-truckload (LTL), freight full-truckload (FTL) palletized, freight FTL non-palletized, ocean less-than-container-load (LCL), ocean full-container load (FCL), air small parcel, and air small parcel express.
type ShippingConfiguration struct {
	// ShippingMode Mode of shipment transportation that this option will provide. Can be `GROUND_SMALL_PARCEL`, `FREIGHT_LTL`, `FREIGHT_FTL_PALLET`, `FREIGHT_FTL_NONPALLET`, `OCEAN_LCL`, `OCEAN_FCL`, `AIR_SMALL_PARCEL`, or `AIR_SMALL_PARCEL_EXPRESS`.
	ShippingMode *string `json:"shippingMode,omitempty"`

	// ShippingSolution Shipping program for the option. Can be `AMAZON_PARTNERED_CARRIER` or `USE_YOUR_OWN_CARRIER`.
	ShippingSolution *string `json:"shippingSolution,omitempty"`
}

// SpdTrackingDetail Contains information related to Small Parcel Delivery (SPD) shipment tracking.
type SpdTrackingDetail struct {
	// SpdTrackingItems List of Small Parcel Delivery (SPD) tracking items.
	SpdTrackingItems *[]SpdTrackingItem `json:"spdTrackingItems,omitempty"`
}

// SpdTrackingDetailInput Contains input information to update Small Parcel Delivery (SPD) tracking information.
type SpdTrackingDetailInput struct {
	// SpdTrackingItems List of Small Parcel Delivery (SPD) tracking items input.
	SpdTrackingItems []SpdTrackingItemInput `json:"spdTrackingItems"`
}

// SpdTrackingItem Contains information used to track and identify a Small Parcel Delivery (SPD) item.
type SpdTrackingItem struct {
	// BoxId The ID provided by Amazon that identifies a given box. This ID is comprised of the external shipment ID (which
	//         is generated after transportation has been confirmed) and the index of the box.
	BoxId *string `json:"boxId,omitempty"`

	// TrackingId The tracking ID associated with each box in a non-Amazon partnered Small Parcel Delivery (SPD) shipment.
	TrackingId *string `json:"trackingId,omitempty"`

	// TrackingNumberValidationStatus Whether or not Amazon has validated the tracking number. If more than 24 hours have passed and the status is
	//         not yet 'VALIDATED', please verify the number and update if necessary. Can be `VALIDATED` or `NOT_VALIDATED`.
	TrackingNumberValidationStatus *string `json:"trackingNumberValidationStatus,omitempty"`
}

// SpdTrackingItemInput Small Parcel Delivery (SPD) tracking items input information.
type SpdTrackingItemInput struct {
	// BoxId The ID provided by Amazon that identifies a given box. This ID is comprised of the external shipment ID (which
	//         is generated after transportation has been confirmed) and the index of the box.
	BoxId string `json:"boxId"`

	// TrackingId The tracking Id associated with each box in a non-Amazon partnered Small Parcel Delivery (SPD) shipment. The seller must provide this information.
	TrackingId string `json:"trackingId"`
}

// Stackability Indicates whether pallets will be stacked when carrier arrives for pick-up.
type Stackability string

// TaxDetails Information used to determine the tax compliance.
type TaxDetails struct {
	// DeclaredValue Currency definition.
	DeclaredValue *Currency `json:"declaredValue,omitempty"`

	// HsnCode Harmonized System of Nomenclature code.
	HsnCode *string `json:"hsnCode,omitempty"`

	// TaxRates List of tax rates.
	TaxRates *[]TaxRate `json:"taxRates,omitempty"`
}

// TaxRate Contains the type and rate of tax.
type TaxRate struct {
	// CessRate Rate of cess tax.
	CessRate *float64 `json:"cessRate,omitempty"`

	// GstRate Rate of gst tax.
	GstRate *float64 `json:"gstRate,omitempty"`

	// TaxType Type of tax. Can be `CGST`, `SGST`, `IGST`, or `TOTAL_TAX`.
	TaxType *string `json:"taxType,omitempty"`
}

// TrackingDetails Tracking information for Less-Than-Truckload (LTL) and Small Parcel Delivery (SPD) shipments.
type TrackingDetails struct {
	// LtlTrackingDetail Contains information related to Less-Than-Truckload (LTL) shipment tracking.
	LtlTrackingDetail *LtlTrackingDetail `json:"ltlTrackingDetail,omitempty"`

	// SpdTrackingDetail Contains information related to Small Parcel Delivery (SPD) shipment tracking.
	SpdTrackingDetail *SpdTrackingDetail `json:"spdTrackingDetail,omitempty"`
}

// TrackingDetailsInput Tracking information input for Less-Than-Truckload (LTL) and Small Parcel Delivery (SPD) shipments.
type TrackingDetailsInput struct {
	// LtlTrackingDetail Contains input information to update Less-Than-Truckload (LTL) tracking information.
	LtlTrackingDetail *LtlTrackingDetailInput `json:"ltlTrackingDetail,omitempty"`

	// SpdTrackingDetail Contains input information to update Small Parcel Delivery (SPD) tracking information.
	SpdTrackingDetail *SpdTrackingDetailInput `json:"spdTrackingDetail,omitempty"`
}

// TransportationOption Contains information pertaining to a transportation option and the related carrier.
type TransportationOption struct {
	// AppointmentSlot The fulfillment center appointment slot for the transportation option.
	AppointmentSlot *AppointmentSlot `json:"appointmentSlot,omitempty"`

	// Carrier The carrier for the inbound shipment.
	Carrier Carrier `json:"carrier"`

	// InboundPlanId Identifier to an inbound plan.
	InboundPlanId string `json:"inboundPlanId"`

	// PlacementOptionId The identifier of a placement option. A placement option represents the shipment splits and destinations of SKUs.
	PlacementOptionId string `json:"placementOptionId"`

	// Quote The estimated shipping cost associated with the transportation option.
	Quote *Quote `json:"quote,omitempty"`

	// ShipmentId Identifier to a shipment. A shipment contains the boxes and units being inbounded.
	ShipmentId string `json:"shipmentId"`

	// ShippingMode The shipping mode associated with the transportation option. Available modes are ground small parcel, freight less-than-truckload (LTL), freight full-truckload (FTL) palletized, freight FTL non-palletized, ocean less-than-container-load (LCL), ocean full-container load (FCL), air small parcel, and air small parcel express.
	ShippingMode string `json:"shippingMode"`

	// ShippingSolution The shipping solution associated with the transportation option. Available solutions are Amazon-partnered carrier or 'use your own carrier'.
	ShippingSolution string `json:"shippingSolution"`

	// TransportationOptionId Identifier to a transportation option. A transportation option represent one option for how to send a shipment.
	TransportationOptionId string `json:"transportationOptionId"`
}

// TransportationSelection The transportation option selected to confirm.
type TransportationSelection struct {
	// ContactInformation The seller's contact information.
	ContactInformation *ContactInformation `json:"contactInformation,omitempty"`

	// DeliveryWindow Contains only a starting DateTime.
	DeliveryWindow *WindowInput `json:"deliveryWindow,omitempty"`

	// ShipmentId Shipment ID that the transportation Option is for.
	ShipmentId string `json:"shipmentId"`

	// TransportationOptionId Transportation option being selected for the provided shipment.
	TransportationOptionId string `json:"transportationOptionId"`
}

// UnitOfMeasurement Unit of linear measure.
type UnitOfMeasurement string

// UnitOfWeight Unit of the weight being measured.
type UnitOfWeight string

// UpdateItemComplianceDetailsRequest The `updateItemComplianceDetails` request.
type UpdateItemComplianceDetailsRequest struct {
	// Msku The merchant SKU, a merchant-supplied identifier for a specific SKU.
	Msku string `json:"msku"`

	// TaxDetails Information used to determine the tax compliance.
	TaxDetails TaxDetails `json:"taxDetails"`
}

// UpdateItemComplianceDetailsResponse The `updateItemComplianceDetails` response.
type UpdateItemComplianceDetailsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// UpdateShipmentDeliveryWindowRequest The `updateShipmentDeliveryWindow` request.
type UpdateShipmentDeliveryWindowRequest struct {
	// DeliveryWindow Contains only a starting DateTime.
	DeliveryWindow WindowInput `json:"deliveryWindow"`
}

// UpdateShipmentDeliveryWindowResponse The `updateShipmentDeliveryWindow` response.
type UpdateShipmentDeliveryWindowResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// UpdateShipmentTrackingDetailsRequest The `updateShipmentTrackingDetails` request.
type UpdateShipmentTrackingDetailsRequest struct {
	// TrackingDetails Tracking information input for Less-Than-Truckload (LTL) and Small Parcel Delivery (SPD) shipments.
	TrackingDetails TrackingDetailsInput `json:"trackingDetails"`
}

// UpdateShipmentTrackingDetailsResponse The `updateShipmentTrackingDetails` response.
type UpdateShipmentTrackingDetailsResponse struct {
	// OperationId UUID for the given operation.
	OperationId string `json:"operationId"`
}

// Weight The weight of a package.
type Weight struct {
	// Unit Unit of the weight being measured.
	Unit UnitOfWeight `json:"unit"`

	// Value Value of a weight.
	Value float64 `json:"value"`
}

// Window Contains a start and end DateTime representing a time range.
type Window struct {
	// EditableUntil The timestamp at which this Window can no longer be edited.
	EditableUntil *time.Time `json:"editableUntil,omitempty"`

	// End The end timestamp of the window.
	End time.Time `json:"end"`

	// Start The start timestamp of the window.
	Start time.Time `json:"start"`
}

// WindowInput Contains only a starting DateTime.
type WindowInput struct {
	// Start The start date of the window. The time component must be zero.
	Start time.Time `json:"start"`
}

// ListInboundPlansParams defines parameters for ListInboundPlans.
type ListInboundPlansParams struct {
	// PageSize The number of inbound plans to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`

	// Status The status of an inbound plan.
	Status *ListInboundPlansParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// SortBy Sort by field.
	SortBy *ListInboundPlansParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder The sort order.
	SortOrder *ListInboundPlansParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// ListInboundPlansParamsStatus defines parameters for ListInboundPlans.
type ListInboundPlansParamsStatus string

// ListInboundPlansParamsSortBy defines parameters for ListInboundPlans.
type ListInboundPlansParamsSortBy string

// ListInboundPlansParamsSortOrder defines parameters for ListInboundPlans.
type ListInboundPlansParamsSortOrder string

// ListInboundPlanBoxesParams defines parameters for ListInboundPlanBoxes.
type ListInboundPlanBoxesParams struct {
	// PageSize The number of boxes to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListInboundPlanItemsParams defines parameters for ListInboundPlanItems.
type ListInboundPlanItemsParams struct {
	// PageSize The number of items to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListPackingOptionsParams defines parameters for ListPackingOptions.
type ListPackingOptionsParams struct {
	// PageSize The number of packing options to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListPackingGroupItemsParams defines parameters for ListPackingGroupItems.
type ListPackingGroupItemsParams struct {
	// PageSize The number of packing group items to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListInboundPlanPalletsParams defines parameters for ListInboundPlanPallets.
type ListInboundPlanPalletsParams struct {
	// PageSize The number of pallets to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListPlacementOptionsParams defines parameters for ListPlacementOptions.
type ListPlacementOptionsParams struct {
	// PageSize The number of placement options to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// GetSelfShipAppointmentSlotsParams defines parameters for GetSelfShipAppointmentSlots.
type GetSelfShipAppointmentSlotsParams struct {
	// PageSize The number of self ship appointment slots to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListTransportationOptionsParams defines parameters for ListTransportationOptions.
type ListTransportationOptionsParams struct {
	// PageSize The number of transportation options to return in the response matching the given query.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PaginationToken A token to fetch a certain page when there are multiple pages worth of results. The value of this token is fetched from the `pagination` returned in the API response. In the absence of the token value from the query parameter the API returns the first page of the result.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`

	// PlacementOptionId The placement option to get transportation options for. Either placementOptionId or shipmentId must be specified.
	PlacementOptionId *string `form:"placementOptionId,omitempty" json:"placementOptionId,omitempty"`

	// ShipmentId The shipment to get transportation options for. Either placementOptionId or shipmentId must be specified.
	ShipmentId *string `form:"shipmentId,omitempty" json:"shipmentId,omitempty"`
}

// ListItemComplianceDetailsParams defines parameters for ListItemComplianceDetails.
type ListItemComplianceDetailsParams struct {
	// Mskus List of merchant SKUs, a merchant-supplied identifier for a specific SKU.
	Mskus []string `form:"mskus" json:"mskus"`

	// MarketplaceId The Marketplace ID. Refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids) for a list of possible values.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// UpdateItemComplianceDetailsParams defines parameters for UpdateItemComplianceDetails.
type UpdateItemComplianceDetailsParams struct {
	// MarketplaceId The Marketplace ID. Refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids) for a list of possible values.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// CreateInboundPlanJSONRequestBody defines body for CreateInboundPlan for application/json ContentType.
type CreateInboundPlanJSONRequestBody = CreateInboundPlanRequest

// SetPackingInformationJSONRequestBody defines body for SetPackingInformation for application/json ContentType.
type SetPackingInformationJSONRequestBody = SetPackingInformationRequest

// GeneratePlacementOptionsJSONRequestBody defines body for GeneratePlacementOptions for application/json ContentType.
type GeneratePlacementOptionsJSONRequestBody = GeneratePlacementOptionsRequest

// UpdateShipmentDeliveryWindowJSONRequestBody defines body for UpdateShipmentDeliveryWindow for application/json ContentType.
type UpdateShipmentDeliveryWindowJSONRequestBody = UpdateShipmentDeliveryWindowRequest

// GenerateSelfShipAppointmentSlotsJSONRequestBody defines body for GenerateSelfShipAppointmentSlots for application/json ContentType.
type GenerateSelfShipAppointmentSlotsJSONRequestBody = GenerateSelfShipAppointmentSlotsRequest

// CancelSelfShipAppointmentJSONRequestBody defines body for CancelSelfShipAppointment for application/json ContentType.
type CancelSelfShipAppointmentJSONRequestBody = CancelSelfShipAppointmentRequest

// ScheduleSelfShipAppointmentJSONRequestBody defines body for ScheduleSelfShipAppointment for application/json ContentType.
type ScheduleSelfShipAppointmentJSONRequestBody = ScheduleSelfShipAppointmentRequest

// UpdateShipmentTrackingDetailsJSONRequestBody defines body for UpdateShipmentTrackingDetails for application/json ContentType.
type UpdateShipmentTrackingDetailsJSONRequestBody = UpdateShipmentTrackingDetailsRequest

// GenerateTransportationOptionsJSONRequestBody defines body for GenerateTransportationOptions for application/json ContentType.
type GenerateTransportationOptionsJSONRequestBody = GenerateTransportationOptionsRequest

// ConfirmTransportationOptionsJSONRequestBody defines body for ConfirmTransportationOptions for application/json ContentType.
type ConfirmTransportationOptionsJSONRequestBody = ConfirmTransportationOptionsRequest

// UpdateItemComplianceDetailsJSONRequestBody defines body for UpdateItemComplianceDetails for application/json ContentType.
type UpdateItemComplianceDetailsJSONRequestBody = UpdateItemComplianceDetailsRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListInboundPlans request
	ListInboundPlans(ctx context.Context, params *ListInboundPlansParams) (*http.Response, error)

	// CreateInboundPlanWithBody request with any body
	CreateInboundPlanWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateInboundPlan(ctx context.Context, body CreateInboundPlanJSONRequestBody) (*http.Response, error)

	// GetInboundPlan request
	GetInboundPlan(ctx context.Context, inboundPlanId string) (*http.Response, error)

	// ListInboundPlanBoxes request
	ListInboundPlanBoxes(ctx context.Context, inboundPlanId string, params *ListInboundPlanBoxesParams) (*http.Response, error)

	// CancelInboundPlan request
	CancelInboundPlan(ctx context.Context, inboundPlanId string) (*http.Response, error)

	// ListInboundPlanItems request
	ListInboundPlanItems(ctx context.Context, inboundPlanId string, params *ListInboundPlanItemsParams) (*http.Response, error)

	// SetPackingInformationWithBody request with any body
	SetPackingInformationWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error)

	SetPackingInformation(ctx context.Context, inboundPlanId string, body SetPackingInformationJSONRequestBody) (*http.Response, error)

	// ListPackingOptions request
	ListPackingOptions(ctx context.Context, inboundPlanId string, params *ListPackingOptionsParams) (*http.Response, error)

	// GeneratePackingOptions request
	GeneratePackingOptions(ctx context.Context, inboundPlanId string) (*http.Response, error)

	// ConfirmPackingOption request
	ConfirmPackingOption(ctx context.Context, inboundPlanId string, packingOptionId string) (*http.Response, error)

	// ListPackingGroupItems request
	ListPackingGroupItems(ctx context.Context, inboundPlanId string, packingOptionId string, packingGroupId string, params *ListPackingGroupItemsParams) (*http.Response, error)

	// ListInboundPlanPallets request
	ListInboundPlanPallets(ctx context.Context, inboundPlanId string, params *ListInboundPlanPalletsParams) (*http.Response, error)

	// ListPlacementOptions request
	ListPlacementOptions(ctx context.Context, inboundPlanId string, params *ListPlacementOptionsParams) (*http.Response, error)

	// GeneratePlacementOptionsWithBody request with any body
	GeneratePlacementOptionsWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error)

	GeneratePlacementOptions(ctx context.Context, inboundPlanId string, body GeneratePlacementOptionsJSONRequestBody) (*http.Response, error)

	// ConfirmPlacementOption request
	ConfirmPlacementOption(ctx context.Context, inboundPlanId string, placementOptionId string) (*http.Response, error)

	// GetShipment request
	GetShipment(ctx context.Context, inboundPlanId string, shipmentId string) (*http.Response, error)

	// GetDeliveryChallanDocument request
	GetDeliveryChallanDocument(ctx context.Context, inboundPlanId string, shipmentId string) (*http.Response, error)

	// UpdateShipmentDeliveryWindowWithBody request with any body
	UpdateShipmentDeliveryWindowWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error)

	UpdateShipmentDeliveryWindow(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentDeliveryWindowJSONRequestBody) (*http.Response, error)

	// GetSelfShipAppointmentSlots request
	GetSelfShipAppointmentSlots(ctx context.Context, inboundPlanId string, shipmentId string, params *GetSelfShipAppointmentSlotsParams) (*http.Response, error)

	// GenerateSelfShipAppointmentSlotsWithBody request with any body
	GenerateSelfShipAppointmentSlotsWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error)

	GenerateSelfShipAppointmentSlots(ctx context.Context, inboundPlanId string, shipmentId string, body GenerateSelfShipAppointmentSlotsJSONRequestBody) (*http.Response, error)

	// CancelSelfShipAppointmentWithBody request with any body
	CancelSelfShipAppointmentWithBody(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*http.Response, error)

	CancelSelfShipAppointment(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, body CancelSelfShipAppointmentJSONRequestBody) (*http.Response, error)

	// ScheduleSelfShipAppointmentWithBody request with any body
	ScheduleSelfShipAppointmentWithBody(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*http.Response, error)

	ScheduleSelfShipAppointment(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, body ScheduleSelfShipAppointmentJSONRequestBody) (*http.Response, error)

	// UpdateShipmentTrackingDetailsWithBody request with any body
	UpdateShipmentTrackingDetailsWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error)

	UpdateShipmentTrackingDetails(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentTrackingDetailsJSONRequestBody) (*http.Response, error)

	// ListTransportationOptions request
	ListTransportationOptions(ctx context.Context, inboundPlanId string, params *ListTransportationOptionsParams) (*http.Response, error)

	// GenerateTransportationOptionsWithBody request with any body
	GenerateTransportationOptionsWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error)

	GenerateTransportationOptions(ctx context.Context, inboundPlanId string, body GenerateTransportationOptionsJSONRequestBody) (*http.Response, error)

	// ConfirmTransportationOptionsWithBody request with any body
	ConfirmTransportationOptionsWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error)

	ConfirmTransportationOptions(ctx context.Context, inboundPlanId string, body ConfirmTransportationOptionsJSONRequestBody) (*http.Response, error)

	// ListItemComplianceDetails request
	ListItemComplianceDetails(ctx context.Context, params *ListItemComplianceDetailsParams) (*http.Response, error)

	// UpdateItemComplianceDetailsWithBody request with any body
	UpdateItemComplianceDetailsWithBody(ctx context.Context, params *UpdateItemComplianceDetailsParams, contentType string, body io.Reader) (*http.Response, error)

	UpdateItemComplianceDetails(ctx context.Context, params *UpdateItemComplianceDetailsParams, body UpdateItemComplianceDetailsJSONRequestBody) (*http.Response, error)

	// GetInboundOperationStatus request
	GetInboundOperationStatus(ctx context.Context, operationId string) (*http.Response, error)
}

func (c *Client) ListInboundPlans(ctx context.Context, params *ListInboundPlansParams) (*http.Response, error) {
	req, err := NewListInboundPlansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateInboundPlanWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateInboundPlanRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateInboundPlan(ctx context.Context, body CreateInboundPlanJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateInboundPlanRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInboundPlan(ctx context.Context, inboundPlanId string) (*http.Response, error) {
	req, err := NewGetInboundPlanRequest(c.Server, inboundPlanId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListInboundPlanBoxes(ctx context.Context, inboundPlanId string, params *ListInboundPlanBoxesParams) (*http.Response, error) {
	req, err := NewListInboundPlanBoxesRequest(c.Server, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CancelInboundPlan(ctx context.Context, inboundPlanId string) (*http.Response, error) {
	req, err := NewCancelInboundPlanRequest(c.Server, inboundPlanId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListInboundPlanItems(ctx context.Context, inboundPlanId string, params *ListInboundPlanItemsParams) (*http.Response, error) {
	req, err := NewListInboundPlanItemsRequest(c.Server, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SetPackingInformationWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSetPackingInformationRequestWithBody(c.Server, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SetPackingInformation(ctx context.Context, inboundPlanId string, body SetPackingInformationJSONRequestBody) (*http.Response, error) {
	req, err := NewSetPackingInformationRequest(c.Server, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListPackingOptions(ctx context.Context, inboundPlanId string, params *ListPackingOptionsParams) (*http.Response, error) {
	req, err := NewListPackingOptionsRequest(c.Server, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GeneratePackingOptions(ctx context.Context, inboundPlanId string) (*http.Response, error) {
	req, err := NewGeneratePackingOptionsRequest(c.Server, inboundPlanId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ConfirmPackingOption(ctx context.Context, inboundPlanId string, packingOptionId string) (*http.Response, error) {
	req, err := NewConfirmPackingOptionRequest(c.Server, inboundPlanId, packingOptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListPackingGroupItems(ctx context.Context, inboundPlanId string, packingOptionId string, packingGroupId string, params *ListPackingGroupItemsParams) (*http.Response, error) {
	req, err := NewListPackingGroupItemsRequest(c.Server, inboundPlanId, packingOptionId, packingGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListInboundPlanPallets(ctx context.Context, inboundPlanId string, params *ListInboundPlanPalletsParams) (*http.Response, error) {
	req, err := NewListInboundPlanPalletsRequest(c.Server, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListPlacementOptions(ctx context.Context, inboundPlanId string, params *ListPlacementOptionsParams) (*http.Response, error) {
	req, err := NewListPlacementOptionsRequest(c.Server, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GeneratePlacementOptionsWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGeneratePlacementOptionsRequestWithBody(c.Server, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GeneratePlacementOptions(ctx context.Context, inboundPlanId string, body GeneratePlacementOptionsJSONRequestBody) (*http.Response, error) {
	req, err := NewGeneratePlacementOptionsRequest(c.Server, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ConfirmPlacementOption(ctx context.Context, inboundPlanId string, placementOptionId string) (*http.Response, error) {
	req, err := NewConfirmPlacementOptionRequest(c.Server, inboundPlanId, placementOptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetShipment(ctx context.Context, inboundPlanId string, shipmentId string) (*http.Response, error) {
	req, err := NewGetShipmentRequest(c.Server, inboundPlanId, shipmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetDeliveryChallanDocument(ctx context.Context, inboundPlanId string, shipmentId string) (*http.Response, error) {
	req, err := NewGetDeliveryChallanDocumentRequest(c.Server, inboundPlanId, shipmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateShipmentDeliveryWindowWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateShipmentDeliveryWindowRequestWithBody(c.Server, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateShipmentDeliveryWindow(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentDeliveryWindowJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateShipmentDeliveryWindowRequest(c.Server, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetSelfShipAppointmentSlots(ctx context.Context, inboundPlanId string, shipmentId string, params *GetSelfShipAppointmentSlotsParams) (*http.Response, error) {
	req, err := NewGetSelfShipAppointmentSlotsRequest(c.Server, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GenerateSelfShipAppointmentSlotsWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGenerateSelfShipAppointmentSlotsRequestWithBody(c.Server, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GenerateSelfShipAppointmentSlots(ctx context.Context, inboundPlanId string, shipmentId string, body GenerateSelfShipAppointmentSlotsJSONRequestBody) (*http.Response, error) {
	req, err := NewGenerateSelfShipAppointmentSlotsRequest(c.Server, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CancelSelfShipAppointmentWithBody(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCancelSelfShipAppointmentRequestWithBody(c.Server, inboundPlanId, shipmentId, slotId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CancelSelfShipAppointment(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, body CancelSelfShipAppointmentJSONRequestBody) (*http.Response, error) {
	req, err := NewCancelSelfShipAppointmentRequest(c.Server, inboundPlanId, shipmentId, slotId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ScheduleSelfShipAppointmentWithBody(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewScheduleSelfShipAppointmentRequestWithBody(c.Server, inboundPlanId, shipmentId, slotId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ScheduleSelfShipAppointment(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, body ScheduleSelfShipAppointmentJSONRequestBody) (*http.Response, error) {
	req, err := NewScheduleSelfShipAppointmentRequest(c.Server, inboundPlanId, shipmentId, slotId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateShipmentTrackingDetailsWithBody(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateShipmentTrackingDetailsRequestWithBody(c.Server, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateShipmentTrackingDetails(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentTrackingDetailsJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateShipmentTrackingDetailsRequest(c.Server, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListTransportationOptions(ctx context.Context, inboundPlanId string, params *ListTransportationOptionsParams) (*http.Response, error) {
	req, err := NewListTransportationOptionsRequest(c.Server, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GenerateTransportationOptionsWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGenerateTransportationOptionsRequestWithBody(c.Server, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GenerateTransportationOptions(ctx context.Context, inboundPlanId string, body GenerateTransportationOptionsJSONRequestBody) (*http.Response, error) {
	req, err := NewGenerateTransportationOptionsRequest(c.Server, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ConfirmTransportationOptionsWithBody(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewConfirmTransportationOptionsRequestWithBody(c.Server, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ConfirmTransportationOptions(ctx context.Context, inboundPlanId string, body ConfirmTransportationOptionsJSONRequestBody) (*http.Response, error) {
	req, err := NewConfirmTransportationOptionsRequest(c.Server, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListItemComplianceDetails(ctx context.Context, params *ListItemComplianceDetailsParams) (*http.Response, error) {
	req, err := NewListItemComplianceDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateItemComplianceDetailsWithBody(ctx context.Context, params *UpdateItemComplianceDetailsParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateItemComplianceDetailsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateItemComplianceDetails(ctx context.Context, params *UpdateItemComplianceDetailsParams, body UpdateItemComplianceDetailsJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateItemComplianceDetailsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInboundOperationStatus(ctx context.Context, operationId string) (*http.Response, error) {
	req, err := NewGetInboundOperationStatusRequest(c.Server, operationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewListInboundPlansRequest generates requests for ListInboundPlans
func NewListInboundPlansRequest(server string, params *ListInboundPlansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInboundPlanRequest calls the generic CreateInboundPlan builder with application/json body
func NewCreateInboundPlanRequest(server string, body CreateInboundPlanJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInboundPlanRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateInboundPlanRequestWithBody generates requests for CreateInboundPlan with any type of body
func NewCreateInboundPlanRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInboundPlanRequest generates requests for GetInboundPlan
func NewGetInboundPlanRequest(server string, inboundPlanId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInboundPlanBoxesRequest generates requests for ListInboundPlanBoxes
func NewListInboundPlanBoxesRequest(server string, inboundPlanId string, params *ListInboundPlanBoxesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/boxes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelInboundPlanRequest generates requests for CancelInboundPlan
func NewCancelInboundPlanRequest(server string, inboundPlanId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/cancellation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInboundPlanItemsRequest generates requests for ListInboundPlanItems
func NewListInboundPlanItemsRequest(server string, inboundPlanId string, params *ListInboundPlanItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPackingInformationRequest calls the generic SetPackingInformation builder with application/json body
func NewSetPackingInformationRequest(server string, inboundPlanId string, body SetPackingInformationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPackingInformationRequestWithBody(server, inboundPlanId, "application/json", bodyReader)
}

// NewSetPackingInformationRequestWithBody generates requests for SetPackingInformation with any type of body
func NewSetPackingInformationRequestWithBody(server string, inboundPlanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/packingInformation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPackingOptionsRequest generates requests for ListPackingOptions
func NewListPackingOptionsRequest(server string, inboundPlanId string, params *ListPackingOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/packingOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneratePackingOptionsRequest generates requests for GeneratePackingOptions
func NewGeneratePackingOptionsRequest(server string, inboundPlanId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/packingOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfirmPackingOptionRequest generates requests for ConfirmPackingOption
func NewConfirmPackingOptionRequest(server string, inboundPlanId string, packingOptionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packingOptionId", runtime.ParamLocationPath, packingOptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/packingOptions/%s/confirmation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPackingGroupItemsRequest generates requests for ListPackingGroupItems
func NewListPackingGroupItemsRequest(server string, inboundPlanId string, packingOptionId string, packingGroupId string, params *ListPackingGroupItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packingOptionId", runtime.ParamLocationPath, packingOptionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "packingGroupId", runtime.ParamLocationPath, packingGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/packingOptions/%s/packingGroups/%s/items", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInboundPlanPalletsRequest generates requests for ListInboundPlanPallets
func NewListInboundPlanPalletsRequest(server string, inboundPlanId string, params *ListInboundPlanPalletsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/pallets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPlacementOptionsRequest generates requests for ListPlacementOptions
func NewListPlacementOptionsRequest(server string, inboundPlanId string, params *ListPlacementOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/placementOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeneratePlacementOptionsRequest calls the generic GeneratePlacementOptions builder with application/json body
func NewGeneratePlacementOptionsRequest(server string, inboundPlanId string, body GeneratePlacementOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGeneratePlacementOptionsRequestWithBody(server, inboundPlanId, "application/json", bodyReader)
}

// NewGeneratePlacementOptionsRequestWithBody generates requests for GeneratePlacementOptions with any type of body
func NewGeneratePlacementOptionsRequestWithBody(server string, inboundPlanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/placementOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConfirmPlacementOptionRequest generates requests for ConfirmPlacementOption
func NewConfirmPlacementOptionRequest(server string, inboundPlanId string, placementOptionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "placementOptionId", runtime.ParamLocationPath, placementOptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/placementOptions/%s/confirmation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShipmentRequest generates requests for GetShipment
func NewGetShipmentRequest(server string, inboundPlanId string, shipmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeliveryChallanDocumentRequest generates requests for GetDeliveryChallanDocument
func NewGetDeliveryChallanDocumentRequest(server string, inboundPlanId string, shipmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/deliveryChallanDocument", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateShipmentDeliveryWindowRequest calls the generic UpdateShipmentDeliveryWindow builder with application/json body
func NewUpdateShipmentDeliveryWindowRequest(server string, inboundPlanId string, shipmentId string, body UpdateShipmentDeliveryWindowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShipmentDeliveryWindowRequestWithBody(server, inboundPlanId, shipmentId, "application/json", bodyReader)
}

// NewUpdateShipmentDeliveryWindowRequestWithBody generates requests for UpdateShipmentDeliveryWindow with any type of body
func NewUpdateShipmentDeliveryWindowRequestWithBody(server string, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/deliveryWindow", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSelfShipAppointmentSlotsRequest generates requests for GetSelfShipAppointmentSlots
func NewGetSelfShipAppointmentSlotsRequest(server string, inboundPlanId string, shipmentId string, params *GetSelfShipAppointmentSlotsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/selfShipAppointmentSlots", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateSelfShipAppointmentSlotsRequest calls the generic GenerateSelfShipAppointmentSlots builder with application/json body
func NewGenerateSelfShipAppointmentSlotsRequest(server string, inboundPlanId string, shipmentId string, body GenerateSelfShipAppointmentSlotsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateSelfShipAppointmentSlotsRequestWithBody(server, inboundPlanId, shipmentId, "application/json", bodyReader)
}

// NewGenerateSelfShipAppointmentSlotsRequestWithBody generates requests for GenerateSelfShipAppointmentSlots with any type of body
func NewGenerateSelfShipAppointmentSlotsRequestWithBody(server string, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/selfShipAppointmentSlots", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelSelfShipAppointmentRequest calls the generic CancelSelfShipAppointment builder with application/json body
func NewCancelSelfShipAppointmentRequest(server string, inboundPlanId string, shipmentId string, slotId string, body CancelSelfShipAppointmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelSelfShipAppointmentRequestWithBody(server, inboundPlanId, shipmentId, slotId, "application/json", bodyReader)
}

// NewCancelSelfShipAppointmentRequestWithBody generates requests for CancelSelfShipAppointment with any type of body
func NewCancelSelfShipAppointmentRequestWithBody(server string, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "slotId", runtime.ParamLocationPath, slotId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/selfShipAppointmentSlots/%s/cancellation", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScheduleSelfShipAppointmentRequest calls the generic ScheduleSelfShipAppointment builder with application/json body
func NewScheduleSelfShipAppointmentRequest(server string, inboundPlanId string, shipmentId string, slotId string, body ScheduleSelfShipAppointmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScheduleSelfShipAppointmentRequestWithBody(server, inboundPlanId, shipmentId, slotId, "application/json", bodyReader)
}

// NewScheduleSelfShipAppointmentRequestWithBody generates requests for ScheduleSelfShipAppointment with any type of body
func NewScheduleSelfShipAppointmentRequestWithBody(server string, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "slotId", runtime.ParamLocationPath, slotId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/selfShipAppointmentSlots/%s/schedule", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateShipmentTrackingDetailsRequest calls the generic UpdateShipmentTrackingDetails builder with application/json body
func NewUpdateShipmentTrackingDetailsRequest(server string, inboundPlanId string, shipmentId string, body UpdateShipmentTrackingDetailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShipmentTrackingDetailsRequestWithBody(server, inboundPlanId, shipmentId, "application/json", bodyReader)
}

// NewUpdateShipmentTrackingDetailsRequestWithBody generates requests for UpdateShipmentTrackingDetails with any type of body
func NewUpdateShipmentTrackingDetailsRequestWithBody(server string, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "shipmentId", runtime.ParamLocationPath, shipmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/shipments/%s/trackingDetails", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTransportationOptionsRequest generates requests for ListTransportationOptions
func NewListTransportationOptionsRequest(server string, inboundPlanId string, params *ListTransportationOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/transportationOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PlacementOptionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "placementOptionId", runtime.ParamLocationQuery, *params.PlacementOptionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ShipmentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipmentId", runtime.ParamLocationQuery, *params.ShipmentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateTransportationOptionsRequest calls the generic GenerateTransportationOptions builder with application/json body
func NewGenerateTransportationOptionsRequest(server string, inboundPlanId string, body GenerateTransportationOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateTransportationOptionsRequestWithBody(server, inboundPlanId, "application/json", bodyReader)
}

// NewGenerateTransportationOptionsRequestWithBody generates requests for GenerateTransportationOptions with any type of body
func NewGenerateTransportationOptionsRequestWithBody(server string, inboundPlanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/transportationOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConfirmTransportationOptionsRequest calls the generic ConfirmTransportationOptions builder with application/json body
func NewConfirmTransportationOptionsRequest(server string, inboundPlanId string, body ConfirmTransportationOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfirmTransportationOptionsRequestWithBody(server, inboundPlanId, "application/json", bodyReader)
}

// NewConfirmTransportationOptionsRequestWithBody generates requests for ConfirmTransportationOptions with any type of body
func NewConfirmTransportationOptionsRequestWithBody(server string, inboundPlanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inboundPlanId", runtime.ParamLocationPath, inboundPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/inboundPlans/%s/transportationOptions/confirmation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListItemComplianceDetailsRequest generates requests for ListItemComplianceDetails
func NewListItemComplianceDetailsRequest(server string, params *ListItemComplianceDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/items/compliance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mskus", runtime.ParamLocationQuery, params.Mskus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateItemComplianceDetailsRequest calls the generic UpdateItemComplianceDetails builder with application/json body
func NewUpdateItemComplianceDetailsRequest(server string, params *UpdateItemComplianceDetailsParams, body UpdateItemComplianceDetailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateItemComplianceDetailsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateItemComplianceDetailsRequestWithBody generates requests for UpdateItemComplianceDetails with any type of body
func NewUpdateItemComplianceDetailsRequestWithBody(server string, params *UpdateItemComplianceDetailsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/items/compliance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInboundOperationStatusRequest generates requests for GetInboundOperationStatus
func NewGetInboundOperationStatusRequest(server string, operationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "operationId", runtime.ParamLocationPath, operationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbound/fba/2024-03-20/operations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListInboundPlansWithResponse request
	ListInboundPlansWithResponse(ctx context.Context, params *ListInboundPlansParams) (*ListInboundPlansResp, error)

	// CreateInboundPlanWithBodyWithResponse request with any body
	CreateInboundPlanWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateInboundPlanResp, error)

	CreateInboundPlanWithResponse(ctx context.Context, body CreateInboundPlanJSONRequestBody) (*CreateInboundPlanResp, error)

	// GetInboundPlanWithResponse request
	GetInboundPlanWithResponse(ctx context.Context, inboundPlanId string) (*GetInboundPlanResp, error)

	// ListInboundPlanBoxesWithResponse request
	ListInboundPlanBoxesWithResponse(ctx context.Context, inboundPlanId string, params *ListInboundPlanBoxesParams) (*ListInboundPlanBoxesResp, error)

	// CancelInboundPlanWithResponse request
	CancelInboundPlanWithResponse(ctx context.Context, inboundPlanId string) (*CancelInboundPlanResp, error)

	// ListInboundPlanItemsWithResponse request
	ListInboundPlanItemsWithResponse(ctx context.Context, inboundPlanId string, params *ListInboundPlanItemsParams) (*ListInboundPlanItemsResp, error)

	// SetPackingInformationWithBodyWithResponse request with any body
	SetPackingInformationWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*SetPackingInformationResp, error)

	SetPackingInformationWithResponse(ctx context.Context, inboundPlanId string, body SetPackingInformationJSONRequestBody) (*SetPackingInformationResp, error)

	// ListPackingOptionsWithResponse request
	ListPackingOptionsWithResponse(ctx context.Context, inboundPlanId string, params *ListPackingOptionsParams) (*ListPackingOptionsResp, error)

	// GeneratePackingOptionsWithResponse request
	GeneratePackingOptionsWithResponse(ctx context.Context, inboundPlanId string) (*GeneratePackingOptionsResp, error)

	// ConfirmPackingOptionWithResponse request
	ConfirmPackingOptionWithResponse(ctx context.Context, inboundPlanId string, packingOptionId string) (*ConfirmPackingOptionResp, error)

	// ListPackingGroupItemsWithResponse request
	ListPackingGroupItemsWithResponse(ctx context.Context, inboundPlanId string, packingOptionId string, packingGroupId string, params *ListPackingGroupItemsParams) (*ListPackingGroupItemsResp, error)

	// ListInboundPlanPalletsWithResponse request
	ListInboundPlanPalletsWithResponse(ctx context.Context, inboundPlanId string, params *ListInboundPlanPalletsParams) (*ListInboundPlanPalletsResp, error)

	// ListPlacementOptionsWithResponse request
	ListPlacementOptionsWithResponse(ctx context.Context, inboundPlanId string, params *ListPlacementOptionsParams) (*ListPlacementOptionsResp, error)

	// GeneratePlacementOptionsWithBodyWithResponse request with any body
	GeneratePlacementOptionsWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*GeneratePlacementOptionsResp, error)

	GeneratePlacementOptionsWithResponse(ctx context.Context, inboundPlanId string, body GeneratePlacementOptionsJSONRequestBody) (*GeneratePlacementOptionsResp, error)

	// ConfirmPlacementOptionWithResponse request
	ConfirmPlacementOptionWithResponse(ctx context.Context, inboundPlanId string, placementOptionId string) (*ConfirmPlacementOptionResp, error)

	// GetShipmentWithResponse request
	GetShipmentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string) (*GetShipmentResp, error)

	// GetDeliveryChallanDocumentWithResponse request
	GetDeliveryChallanDocumentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string) (*GetDeliveryChallanDocumentResp, error)

	// UpdateShipmentDeliveryWindowWithBodyWithResponse request with any body
	UpdateShipmentDeliveryWindowWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*UpdateShipmentDeliveryWindowResp, error)

	UpdateShipmentDeliveryWindowWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentDeliveryWindowJSONRequestBody) (*UpdateShipmentDeliveryWindowResp, error)

	// GetSelfShipAppointmentSlotsWithResponse request
	GetSelfShipAppointmentSlotsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *GetSelfShipAppointmentSlotsParams) (*GetSelfShipAppointmentSlotsResp, error)

	// GenerateSelfShipAppointmentSlotsWithBodyWithResponse request with any body
	GenerateSelfShipAppointmentSlotsWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*GenerateSelfShipAppointmentSlotsResp, error)

	GenerateSelfShipAppointmentSlotsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body GenerateSelfShipAppointmentSlotsJSONRequestBody) (*GenerateSelfShipAppointmentSlotsResp, error)

	// CancelSelfShipAppointmentWithBodyWithResponse request with any body
	CancelSelfShipAppointmentWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*CancelSelfShipAppointmentResp, error)

	CancelSelfShipAppointmentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, body CancelSelfShipAppointmentJSONRequestBody) (*CancelSelfShipAppointmentResp, error)

	// ScheduleSelfShipAppointmentWithBodyWithResponse request with any body
	ScheduleSelfShipAppointmentWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*ScheduleSelfShipAppointmentResp, error)

	ScheduleSelfShipAppointmentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, body ScheduleSelfShipAppointmentJSONRequestBody) (*ScheduleSelfShipAppointmentResp, error)

	// UpdateShipmentTrackingDetailsWithBodyWithResponse request with any body
	UpdateShipmentTrackingDetailsWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*UpdateShipmentTrackingDetailsResp, error)

	UpdateShipmentTrackingDetailsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentTrackingDetailsJSONRequestBody) (*UpdateShipmentTrackingDetailsResp, error)

	// ListTransportationOptionsWithResponse request
	ListTransportationOptionsWithResponse(ctx context.Context, inboundPlanId string, params *ListTransportationOptionsParams) (*ListTransportationOptionsResp, error)

	// GenerateTransportationOptionsWithBodyWithResponse request with any body
	GenerateTransportationOptionsWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*GenerateTransportationOptionsResp, error)

	GenerateTransportationOptionsWithResponse(ctx context.Context, inboundPlanId string, body GenerateTransportationOptionsJSONRequestBody) (*GenerateTransportationOptionsResp, error)

	// ConfirmTransportationOptionsWithBodyWithResponse request with any body
	ConfirmTransportationOptionsWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*ConfirmTransportationOptionsResp, error)

	ConfirmTransportationOptionsWithResponse(ctx context.Context, inboundPlanId string, body ConfirmTransportationOptionsJSONRequestBody) (*ConfirmTransportationOptionsResp, error)

	// ListItemComplianceDetailsWithResponse request
	ListItemComplianceDetailsWithResponse(ctx context.Context, params *ListItemComplianceDetailsParams) (*ListItemComplianceDetailsResp, error)

	// UpdateItemComplianceDetailsWithBodyWithResponse request with any body
	UpdateItemComplianceDetailsWithBodyWithResponse(ctx context.Context, params *UpdateItemComplianceDetailsParams, contentType string, body io.Reader) (*UpdateItemComplianceDetailsResp, error)

	UpdateItemComplianceDetailsWithResponse(ctx context.Context, params *UpdateItemComplianceDetailsParams, body UpdateItemComplianceDetailsJSONRequestBody) (*UpdateItemComplianceDetailsResp, error)

	// GetInboundOperationStatusWithResponse request
	GetInboundOperationStatusWithResponse(ctx context.Context, operationId string) (*GetInboundOperationStatusResp, error)
}

type ListInboundPlansResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInboundPlansResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListInboundPlansResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboundPlansResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInboundPlanResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateInboundPlanResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CreateInboundPlanResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInboundPlanResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInboundPlanResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InboundPlan
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetInboundPlanResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInboundPlanResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInboundPlanBoxesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInboundPlanBoxesResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListInboundPlanBoxesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboundPlanBoxesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelInboundPlanResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CancelInboundPlanResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CancelInboundPlanResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelInboundPlanResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInboundPlanItemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInboundPlanItemsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListInboundPlanItemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboundPlanItemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPackingInformationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SetPackingInformationResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r SetPackingInformationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPackingInformationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPackingOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPackingOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListPackingOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPackingOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneratePackingOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *GeneratePackingOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GeneratePackingOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneratePackingOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmPackingOptionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ConfirmPackingOptionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ConfirmPackingOptionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmPackingOptionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPackingGroupItemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPackingGroupItemsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListPackingGroupItemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPackingGroupItemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInboundPlanPalletsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInboundPlanPalletsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListInboundPlanPalletsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboundPlanPalletsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlacementOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPlacementOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListPlacementOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlacementOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeneratePlacementOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *GeneratePlacementOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GeneratePlacementOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeneratePlacementOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmPlacementOptionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ConfirmPlacementOptionResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ConfirmPlacementOptionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmPlacementOptionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShipmentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Shipment
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetShipmentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShipmentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeliveryChallanDocumentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDeliveryChallanDocumentResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetDeliveryChallanDocumentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeliveryChallanDocumentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShipmentDeliveryWindowResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *UpdateShipmentDeliveryWindowResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateShipmentDeliveryWindowResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShipmentDeliveryWindowResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelfShipAppointmentSlotsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSelfShipAppointmentSlotsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetSelfShipAppointmentSlotsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelfShipAppointmentSlotsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateSelfShipAppointmentSlotsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GenerateSelfShipAppointmentSlotsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GenerateSelfShipAppointmentSlotsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateSelfShipAppointmentSlotsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelSelfShipAppointmentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CancelSelfShipAppointmentResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CancelSelfShipAppointmentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelSelfShipAppointmentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScheduleSelfShipAppointmentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScheduleSelfShipAppointmentResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ScheduleSelfShipAppointmentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScheduleSelfShipAppointmentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShipmentTrackingDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *UpdateShipmentTrackingDetailsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateShipmentTrackingDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShipmentTrackingDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransportationOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTransportationOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListTransportationOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransportationOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTransportationOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *GenerateTransportationOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GenerateTransportationOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTransportationOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmTransportationOptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ConfirmTransportationOptionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ConfirmTransportationOptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmTransportationOptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListItemComplianceDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListItemComplianceDetailsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListItemComplianceDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListItemComplianceDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateItemComplianceDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *UpdateItemComplianceDetailsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateItemComplianceDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateItemComplianceDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInboundOperationStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InboundOperationStatus
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetInboundOperationStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInboundOperationStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListInboundPlansWithResponse request returning *ListInboundPlansResp
func (c *ClientWithResponses) ListInboundPlansWithResponse(ctx context.Context, params *ListInboundPlansParams) (*ListInboundPlansResp, error) {
	rsp, err := c.ListInboundPlans(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListInboundPlansResp(rsp)
}

// CreateInboundPlanWithBodyWithResponse request with arbitrary body returning *CreateInboundPlanResp
func (c *ClientWithResponses) CreateInboundPlanWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateInboundPlanResp, error) {
	rsp, err := c.CreateInboundPlanWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateInboundPlanResp(rsp)
}

func (c *ClientWithResponses) CreateInboundPlanWithResponse(ctx context.Context, body CreateInboundPlanJSONRequestBody) (*CreateInboundPlanResp, error) {
	rsp, err := c.CreateInboundPlan(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateInboundPlanResp(rsp)
}

// GetInboundPlanWithResponse request returning *GetInboundPlanResp
func (c *ClientWithResponses) GetInboundPlanWithResponse(ctx context.Context, inboundPlanId string) (*GetInboundPlanResp, error) {
	rsp, err := c.GetInboundPlan(ctx, inboundPlanId)
	if err != nil {
		return nil, err
	}
	return ParseGetInboundPlanResp(rsp)
}

// ListInboundPlanBoxesWithResponse request returning *ListInboundPlanBoxesResp
func (c *ClientWithResponses) ListInboundPlanBoxesWithResponse(ctx context.Context, inboundPlanId string, params *ListInboundPlanBoxesParams) (*ListInboundPlanBoxesResp, error) {
	rsp, err := c.ListInboundPlanBoxes(ctx, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	return ParseListInboundPlanBoxesResp(rsp)
}

// CancelInboundPlanWithResponse request returning *CancelInboundPlanResp
func (c *ClientWithResponses) CancelInboundPlanWithResponse(ctx context.Context, inboundPlanId string) (*CancelInboundPlanResp, error) {
	rsp, err := c.CancelInboundPlan(ctx, inboundPlanId)
	if err != nil {
		return nil, err
	}
	return ParseCancelInboundPlanResp(rsp)
}

// ListInboundPlanItemsWithResponse request returning *ListInboundPlanItemsResp
func (c *ClientWithResponses) ListInboundPlanItemsWithResponse(ctx context.Context, inboundPlanId string, params *ListInboundPlanItemsParams) (*ListInboundPlanItemsResp, error) {
	rsp, err := c.ListInboundPlanItems(ctx, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	return ParseListInboundPlanItemsResp(rsp)
}

// SetPackingInformationWithBodyWithResponse request with arbitrary body returning *SetPackingInformationResp
func (c *ClientWithResponses) SetPackingInformationWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*SetPackingInformationResp, error) {
	rsp, err := c.SetPackingInformationWithBody(ctx, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSetPackingInformationResp(rsp)
}

func (c *ClientWithResponses) SetPackingInformationWithResponse(ctx context.Context, inboundPlanId string, body SetPackingInformationJSONRequestBody) (*SetPackingInformationResp, error) {
	rsp, err := c.SetPackingInformation(ctx, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	return ParseSetPackingInformationResp(rsp)
}

// ListPackingOptionsWithResponse request returning *ListPackingOptionsResp
func (c *ClientWithResponses) ListPackingOptionsWithResponse(ctx context.Context, inboundPlanId string, params *ListPackingOptionsParams) (*ListPackingOptionsResp, error) {
	rsp, err := c.ListPackingOptions(ctx, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	return ParseListPackingOptionsResp(rsp)
}

// GeneratePackingOptionsWithResponse request returning *GeneratePackingOptionsResp
func (c *ClientWithResponses) GeneratePackingOptionsWithResponse(ctx context.Context, inboundPlanId string) (*GeneratePackingOptionsResp, error) {
	rsp, err := c.GeneratePackingOptions(ctx, inboundPlanId)
	if err != nil {
		return nil, err
	}
	return ParseGeneratePackingOptionsResp(rsp)
}

// ConfirmPackingOptionWithResponse request returning *ConfirmPackingOptionResp
func (c *ClientWithResponses) ConfirmPackingOptionWithResponse(ctx context.Context, inboundPlanId string, packingOptionId string) (*ConfirmPackingOptionResp, error) {
	rsp, err := c.ConfirmPackingOption(ctx, inboundPlanId, packingOptionId)
	if err != nil {
		return nil, err
	}
	return ParseConfirmPackingOptionResp(rsp)
}

// ListPackingGroupItemsWithResponse request returning *ListPackingGroupItemsResp
func (c *ClientWithResponses) ListPackingGroupItemsWithResponse(ctx context.Context, inboundPlanId string, packingOptionId string, packingGroupId string, params *ListPackingGroupItemsParams) (*ListPackingGroupItemsResp, error) {
	rsp, err := c.ListPackingGroupItems(ctx, inboundPlanId, packingOptionId, packingGroupId, params)
	if err != nil {
		return nil, err
	}
	return ParseListPackingGroupItemsResp(rsp)
}

// ListInboundPlanPalletsWithResponse request returning *ListInboundPlanPalletsResp
func (c *ClientWithResponses) ListInboundPlanPalletsWithResponse(ctx context.Context, inboundPlanId string, params *ListInboundPlanPalletsParams) (*ListInboundPlanPalletsResp, error) {
	rsp, err := c.ListInboundPlanPallets(ctx, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	return ParseListInboundPlanPalletsResp(rsp)
}

// ListPlacementOptionsWithResponse request returning *ListPlacementOptionsResp
func (c *ClientWithResponses) ListPlacementOptionsWithResponse(ctx context.Context, inboundPlanId string, params *ListPlacementOptionsParams) (*ListPlacementOptionsResp, error) {
	rsp, err := c.ListPlacementOptions(ctx, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	return ParseListPlacementOptionsResp(rsp)
}

// GeneratePlacementOptionsWithBodyWithResponse request with arbitrary body returning *GeneratePlacementOptionsResp
func (c *ClientWithResponses) GeneratePlacementOptionsWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*GeneratePlacementOptionsResp, error) {
	rsp, err := c.GeneratePlacementOptionsWithBody(ctx, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGeneratePlacementOptionsResp(rsp)
}

func (c *ClientWithResponses) GeneratePlacementOptionsWithResponse(ctx context.Context, inboundPlanId string, body GeneratePlacementOptionsJSONRequestBody) (*GeneratePlacementOptionsResp, error) {
	rsp, err := c.GeneratePlacementOptions(ctx, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	return ParseGeneratePlacementOptionsResp(rsp)
}

// ConfirmPlacementOptionWithResponse request returning *ConfirmPlacementOptionResp
func (c *ClientWithResponses) ConfirmPlacementOptionWithResponse(ctx context.Context, inboundPlanId string, placementOptionId string) (*ConfirmPlacementOptionResp, error) {
	rsp, err := c.ConfirmPlacementOption(ctx, inboundPlanId, placementOptionId)
	if err != nil {
		return nil, err
	}
	return ParseConfirmPlacementOptionResp(rsp)
}

// GetShipmentWithResponse request returning *GetShipmentResp
func (c *ClientWithResponses) GetShipmentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string) (*GetShipmentResp, error) {
	rsp, err := c.GetShipment(ctx, inboundPlanId, shipmentId)
	if err != nil {
		return nil, err
	}
	return ParseGetShipmentResp(rsp)
}

// GetDeliveryChallanDocumentWithResponse request returning *GetDeliveryChallanDocumentResp
func (c *ClientWithResponses) GetDeliveryChallanDocumentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string) (*GetDeliveryChallanDocumentResp, error) {
	rsp, err := c.GetDeliveryChallanDocument(ctx, inboundPlanId, shipmentId)
	if err != nil {
		return nil, err
	}
	return ParseGetDeliveryChallanDocumentResp(rsp)
}

// UpdateShipmentDeliveryWindowWithBodyWithResponse request with arbitrary body returning *UpdateShipmentDeliveryWindowResp
func (c *ClientWithResponses) UpdateShipmentDeliveryWindowWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*UpdateShipmentDeliveryWindowResp, error) {
	rsp, err := c.UpdateShipmentDeliveryWindowWithBody(ctx, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentDeliveryWindowResp(rsp)
}

func (c *ClientWithResponses) UpdateShipmentDeliveryWindowWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentDeliveryWindowJSONRequestBody) (*UpdateShipmentDeliveryWindowResp, error) {
	rsp, err := c.UpdateShipmentDeliveryWindow(ctx, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentDeliveryWindowResp(rsp)
}

// GetSelfShipAppointmentSlotsWithResponse request returning *GetSelfShipAppointmentSlotsResp
func (c *ClientWithResponses) GetSelfShipAppointmentSlotsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, params *GetSelfShipAppointmentSlotsParams) (*GetSelfShipAppointmentSlotsResp, error) {
	rsp, err := c.GetSelfShipAppointmentSlots(ctx, inboundPlanId, shipmentId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetSelfShipAppointmentSlotsResp(rsp)
}

// GenerateSelfShipAppointmentSlotsWithBodyWithResponse request with arbitrary body returning *GenerateSelfShipAppointmentSlotsResp
func (c *ClientWithResponses) GenerateSelfShipAppointmentSlotsWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*GenerateSelfShipAppointmentSlotsResp, error) {
	rsp, err := c.GenerateSelfShipAppointmentSlotsWithBody(ctx, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGenerateSelfShipAppointmentSlotsResp(rsp)
}

func (c *ClientWithResponses) GenerateSelfShipAppointmentSlotsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body GenerateSelfShipAppointmentSlotsJSONRequestBody) (*GenerateSelfShipAppointmentSlotsResp, error) {
	rsp, err := c.GenerateSelfShipAppointmentSlots(ctx, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	return ParseGenerateSelfShipAppointmentSlotsResp(rsp)
}

// CancelSelfShipAppointmentWithBodyWithResponse request with arbitrary body returning *CancelSelfShipAppointmentResp
func (c *ClientWithResponses) CancelSelfShipAppointmentWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*CancelSelfShipAppointmentResp, error) {
	rsp, err := c.CancelSelfShipAppointmentWithBody(ctx, inboundPlanId, shipmentId, slotId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCancelSelfShipAppointmentResp(rsp)
}

func (c *ClientWithResponses) CancelSelfShipAppointmentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, body CancelSelfShipAppointmentJSONRequestBody) (*CancelSelfShipAppointmentResp, error) {
	rsp, err := c.CancelSelfShipAppointment(ctx, inboundPlanId, shipmentId, slotId, body)
	if err != nil {
		return nil, err
	}
	return ParseCancelSelfShipAppointmentResp(rsp)
}

// ScheduleSelfShipAppointmentWithBodyWithResponse request with arbitrary body returning *ScheduleSelfShipAppointmentResp
func (c *ClientWithResponses) ScheduleSelfShipAppointmentWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, contentType string, body io.Reader) (*ScheduleSelfShipAppointmentResp, error) {
	rsp, err := c.ScheduleSelfShipAppointmentWithBody(ctx, inboundPlanId, shipmentId, slotId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseScheduleSelfShipAppointmentResp(rsp)
}

func (c *ClientWithResponses) ScheduleSelfShipAppointmentWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, slotId string, body ScheduleSelfShipAppointmentJSONRequestBody) (*ScheduleSelfShipAppointmentResp, error) {
	rsp, err := c.ScheduleSelfShipAppointment(ctx, inboundPlanId, shipmentId, slotId, body)
	if err != nil {
		return nil, err
	}
	return ParseScheduleSelfShipAppointmentResp(rsp)
}

// UpdateShipmentTrackingDetailsWithBodyWithResponse request with arbitrary body returning *UpdateShipmentTrackingDetailsResp
func (c *ClientWithResponses) UpdateShipmentTrackingDetailsWithBodyWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, contentType string, body io.Reader) (*UpdateShipmentTrackingDetailsResp, error) {
	rsp, err := c.UpdateShipmentTrackingDetailsWithBody(ctx, inboundPlanId, shipmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentTrackingDetailsResp(rsp)
}

func (c *ClientWithResponses) UpdateShipmentTrackingDetailsWithResponse(ctx context.Context, inboundPlanId string, shipmentId string, body UpdateShipmentTrackingDetailsJSONRequestBody) (*UpdateShipmentTrackingDetailsResp, error) {
	rsp, err := c.UpdateShipmentTrackingDetails(ctx, inboundPlanId, shipmentId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShipmentTrackingDetailsResp(rsp)
}

// ListTransportationOptionsWithResponse request returning *ListTransportationOptionsResp
func (c *ClientWithResponses) ListTransportationOptionsWithResponse(ctx context.Context, inboundPlanId string, params *ListTransportationOptionsParams) (*ListTransportationOptionsResp, error) {
	rsp, err := c.ListTransportationOptions(ctx, inboundPlanId, params)
	if err != nil {
		return nil, err
	}
	return ParseListTransportationOptionsResp(rsp)
}

// GenerateTransportationOptionsWithBodyWithResponse request with arbitrary body returning *GenerateTransportationOptionsResp
func (c *ClientWithResponses) GenerateTransportationOptionsWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*GenerateTransportationOptionsResp, error) {
	rsp, err := c.GenerateTransportationOptionsWithBody(ctx, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTransportationOptionsResp(rsp)
}

func (c *ClientWithResponses) GenerateTransportationOptionsWithResponse(ctx context.Context, inboundPlanId string, body GenerateTransportationOptionsJSONRequestBody) (*GenerateTransportationOptionsResp, error) {
	rsp, err := c.GenerateTransportationOptions(ctx, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTransportationOptionsResp(rsp)
}

// ConfirmTransportationOptionsWithBodyWithResponse request with arbitrary body returning *ConfirmTransportationOptionsResp
func (c *ClientWithResponses) ConfirmTransportationOptionsWithBodyWithResponse(ctx context.Context, inboundPlanId string, contentType string, body io.Reader) (*ConfirmTransportationOptionsResp, error) {
	rsp, err := c.ConfirmTransportationOptionsWithBody(ctx, inboundPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseConfirmTransportationOptionsResp(rsp)
}

func (c *ClientWithResponses) ConfirmTransportationOptionsWithResponse(ctx context.Context, inboundPlanId string, body ConfirmTransportationOptionsJSONRequestBody) (*ConfirmTransportationOptionsResp, error) {
	rsp, err := c.ConfirmTransportationOptions(ctx, inboundPlanId, body)
	if err != nil {
		return nil, err
	}
	return ParseConfirmTransportationOptionsResp(rsp)
}

// ListItemComplianceDetailsWithResponse request returning *ListItemComplianceDetailsResp
func (c *ClientWithResponses) ListItemComplianceDetailsWithResponse(ctx context.Context, params *ListItemComplianceDetailsParams) (*ListItemComplianceDetailsResp, error) {
	rsp, err := c.ListItemComplianceDetails(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListItemComplianceDetailsResp(rsp)
}

// UpdateItemComplianceDetailsWithBodyWithResponse request with arbitrary body returning *UpdateItemComplianceDetailsResp
func (c *ClientWithResponses) UpdateItemComplianceDetailsWithBodyWithResponse(ctx context.Context, params *UpdateItemComplianceDetailsParams, contentType string, body io.Reader) (*UpdateItemComplianceDetailsResp, error) {
	rsp, err := c.UpdateItemComplianceDetailsWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemComplianceDetailsResp(rsp)
}

func (c *ClientWithResponses) UpdateItemComplianceDetailsWithResponse(ctx context.Context, params *UpdateItemComplianceDetailsParams, body UpdateItemComplianceDetailsJSONRequestBody) (*UpdateItemComplianceDetailsResp, error) {
	rsp, err := c.UpdateItemComplianceDetails(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemComplianceDetailsResp(rsp)
}

// GetInboundOperationStatusWithResponse request returning *GetInboundOperationStatusResp
func (c *ClientWithResponses) GetInboundOperationStatusWithResponse(ctx context.Context, operationId string) (*GetInboundOperationStatusResp, error) {
	rsp, err := c.GetInboundOperationStatus(ctx, operationId)
	if err != nil {
		return nil, err
	}
	return ParseGetInboundOperationStatusResp(rsp)
}

// ParseListInboundPlansResp parses an HTTP response from a ListInboundPlansWithResponse call
func ParseListInboundPlansResp(rsp *http.Response) (*ListInboundPlansResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboundPlansResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInboundPlansResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateInboundPlanResp parses an HTTP response from a CreateInboundPlanWithResponse call
func ParseCreateInboundPlanResp(rsp *http.Response) (*CreateInboundPlanResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInboundPlanResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateInboundPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetInboundPlanResp parses an HTTP response from a GetInboundPlanWithResponse call
func ParseGetInboundPlanResp(rsp *http.Response) (*GetInboundPlanResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInboundPlanResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InboundPlan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListInboundPlanBoxesResp parses an HTTP response from a ListInboundPlanBoxesWithResponse call
func ParseListInboundPlanBoxesResp(rsp *http.Response) (*ListInboundPlanBoxesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboundPlanBoxesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInboundPlanBoxesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCancelInboundPlanResp parses an HTTP response from a CancelInboundPlanWithResponse call
func ParseCancelInboundPlanResp(rsp *http.Response) (*CancelInboundPlanResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelInboundPlanResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CancelInboundPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListInboundPlanItemsResp parses an HTTP response from a ListInboundPlanItemsWithResponse call
func ParseListInboundPlanItemsResp(rsp *http.Response) (*ListInboundPlanItemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboundPlanItemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInboundPlanItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSetPackingInformationResp parses an HTTP response from a SetPackingInformationWithResponse call
func ParseSetPackingInformationResp(rsp *http.Response) (*SetPackingInformationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPackingInformationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SetPackingInformationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListPackingOptionsResp parses an HTTP response from a ListPackingOptionsWithResponse call
func ParseListPackingOptionsResp(rsp *http.Response) (*ListPackingOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPackingOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPackingOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGeneratePackingOptionsResp parses an HTTP response from a GeneratePackingOptionsWithResponse call
func ParseGeneratePackingOptionsResp(rsp *http.Response) (*GeneratePackingOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneratePackingOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest GeneratePackingOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConfirmPackingOptionResp parses an HTTP response from a ConfirmPackingOptionWithResponse call
func ParseConfirmPackingOptionResp(rsp *http.Response) (*ConfirmPackingOptionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmPackingOptionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ConfirmPackingOptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListPackingGroupItemsResp parses an HTTP response from a ListPackingGroupItemsWithResponse call
func ParseListPackingGroupItemsResp(rsp *http.Response) (*ListPackingGroupItemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPackingGroupItemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPackingGroupItemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListInboundPlanPalletsResp parses an HTTP response from a ListInboundPlanPalletsWithResponse call
func ParseListInboundPlanPalletsResp(rsp *http.Response) (*ListInboundPlanPalletsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboundPlanPalletsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInboundPlanPalletsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListPlacementOptionsResp parses an HTTP response from a ListPlacementOptionsWithResponse call
func ParseListPlacementOptionsResp(rsp *http.Response) (*ListPlacementOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlacementOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPlacementOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGeneratePlacementOptionsResp parses an HTTP response from a GeneratePlacementOptionsWithResponse call
func ParseGeneratePlacementOptionsResp(rsp *http.Response) (*GeneratePlacementOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeneratePlacementOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest GeneratePlacementOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConfirmPlacementOptionResp parses an HTTP response from a ConfirmPlacementOptionWithResponse call
func ParseConfirmPlacementOptionResp(rsp *http.Response) (*ConfirmPlacementOptionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmPlacementOptionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ConfirmPlacementOptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetShipmentResp parses an HTTP response from a GetShipmentWithResponse call
func ParseGetShipmentResp(rsp *http.Response) (*GetShipmentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShipmentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Shipment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetDeliveryChallanDocumentResp parses an HTTP response from a GetDeliveryChallanDocumentWithResponse call
func ParseGetDeliveryChallanDocumentResp(rsp *http.Response) (*GetDeliveryChallanDocumentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeliveryChallanDocumentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDeliveryChallanDocumentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateShipmentDeliveryWindowResp parses an HTTP response from a UpdateShipmentDeliveryWindowWithResponse call
func ParseUpdateShipmentDeliveryWindowResp(rsp *http.Response) (*UpdateShipmentDeliveryWindowResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShipmentDeliveryWindowResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UpdateShipmentDeliveryWindowResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetSelfShipAppointmentSlotsResp parses an HTTP response from a GetSelfShipAppointmentSlotsWithResponse call
func ParseGetSelfShipAppointmentSlotsResp(rsp *http.Response) (*GetSelfShipAppointmentSlotsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSelfShipAppointmentSlotsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSelfShipAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGenerateSelfShipAppointmentSlotsResp parses an HTTP response from a GenerateSelfShipAppointmentSlotsWithResponse call
func ParseGenerateSelfShipAppointmentSlotsResp(rsp *http.Response) (*GenerateSelfShipAppointmentSlotsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateSelfShipAppointmentSlotsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GenerateSelfShipAppointmentSlotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCancelSelfShipAppointmentResp parses an HTTP response from a CancelSelfShipAppointmentWithResponse call
func ParseCancelSelfShipAppointmentResp(rsp *http.Response) (*CancelSelfShipAppointmentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelSelfShipAppointmentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CancelSelfShipAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseScheduleSelfShipAppointmentResp parses an HTTP response from a ScheduleSelfShipAppointmentWithResponse call
func ParseScheduleSelfShipAppointmentResp(rsp *http.Response) (*ScheduleSelfShipAppointmentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScheduleSelfShipAppointmentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScheduleSelfShipAppointmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateShipmentTrackingDetailsResp parses an HTTP response from a UpdateShipmentTrackingDetailsWithResponse call
func ParseUpdateShipmentTrackingDetailsResp(rsp *http.Response) (*UpdateShipmentTrackingDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShipmentTrackingDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UpdateShipmentTrackingDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListTransportationOptionsResp parses an HTTP response from a ListTransportationOptionsWithResponse call
func ParseListTransportationOptionsResp(rsp *http.Response) (*ListTransportationOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransportationOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTransportationOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGenerateTransportationOptionsResp parses an HTTP response from a GenerateTransportationOptionsWithResponse call
func ParseGenerateTransportationOptionsResp(rsp *http.Response) (*GenerateTransportationOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateTransportationOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest GenerateTransportationOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConfirmTransportationOptionsResp parses an HTTP response from a ConfirmTransportationOptionsWithResponse call
func ParseConfirmTransportationOptionsResp(rsp *http.Response) (*ConfirmTransportationOptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmTransportationOptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ConfirmTransportationOptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListItemComplianceDetailsResp parses an HTTP response from a ListItemComplianceDetailsWithResponse call
func ParseListItemComplianceDetailsResp(rsp *http.Response) (*ListItemComplianceDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListItemComplianceDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListItemComplianceDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateItemComplianceDetailsResp parses an HTTP response from a UpdateItemComplianceDetailsWithResponse call
func ParseUpdateItemComplianceDetailsResp(rsp *http.Response) (*UpdateItemComplianceDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateItemComplianceDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UpdateItemComplianceDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetInboundOperationStatusResp parses an HTTP response from a GetInboundOperationStatusWithResponse call
func ParseGetInboundOperationStatusResp(rsp *http.Response) (*GetInboundOperationStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInboundOperationStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InboundOperationStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
