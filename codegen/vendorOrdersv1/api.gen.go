// Package vendorOrdersv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.3 DO NOT EDIT.
package vendorOrdersv1

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for ImportDetailsInternationalCommercialTerms.
const (
	CarriageAndInsurancePaidTo ImportDetailsInternationalCommercialTerms = "CarriageAndInsurancePaidTo"
	CarriagePaidTo             ImportDetailsInternationalCommercialTerms = "CarriagePaidTo"
	CostAndFreight             ImportDetailsInternationalCommercialTerms = "CostAndFreight"
	CostInsuranceAndFreight    ImportDetailsInternationalCommercialTerms = "CostInsuranceAndFreight"
	DeliverDutyPaid            ImportDetailsInternationalCommercialTerms = "DeliverDutyPaid"
	DeliveredAtPlace           ImportDetailsInternationalCommercialTerms = "DeliveredAtPlace"
	DeliveredAtTerminal        ImportDetailsInternationalCommercialTerms = "DeliveredAtTerminal"
	ExWorks                    ImportDetailsInternationalCommercialTerms = "ExWorks"
	FreeAlongSideShip          ImportDetailsInternationalCommercialTerms = "FreeAlongSideShip"
	FreeCarrier                ImportDetailsInternationalCommercialTerms = "FreeCarrier"
	FreeOnBoard                ImportDetailsInternationalCommercialTerms = "FreeOnBoard"
)

// Defines values for ImportDetailsMethodOfPayment.
const (
	CollectOnDelivery       ImportDetailsMethodOfPayment = "CollectOnDelivery"
	DefinedByBuyerAndSeller ImportDetailsMethodOfPayment = "DefinedByBuyerAndSeller"
	FOBPortOfCall           ImportDetailsMethodOfPayment = "FOBPortOfCall"
	PaidByBuyer             ImportDetailsMethodOfPayment = "PaidByBuyer"
	PaidBySeller            ImportDetailsMethodOfPayment = "PaidBySeller"
	PrepaidBySeller         ImportDetailsMethodOfPayment = "PrepaidBySeller"
)

// Defines values for ItemQuantityUnitOfMeasure.
const (
	Cases  ItemQuantityUnitOfMeasure = "Cases"
	Eaches ItemQuantityUnitOfMeasure = "Eaches"
)

// Defines values for OrderPurchaseOrderState.
const (
	OrderPurchaseOrderStateAcknowledged OrderPurchaseOrderState = "Acknowledged"
	OrderPurchaseOrderStateClosed       OrderPurchaseOrderState = "Closed"
	OrderPurchaseOrderStateNew          OrderPurchaseOrderState = "New"
)

// Defines values for OrderDetailsPaymentMethod.
const (
	Consignment OrderDetailsPaymentMethod = "Consignment"
	CreditCard  OrderDetailsPaymentMethod = "CreditCard"
	Invoice     OrderDetailsPaymentMethod = "Invoice"
	Prepaid     OrderDetailsPaymentMethod = "Prepaid"
)

// Defines values for OrderDetailsPurchaseOrderType.
const (
	ConsignedOrder         OrderDetailsPurchaseOrderType = "ConsignedOrder"
	NewProductIntroduction OrderDetailsPurchaseOrderType = "NewProductIntroduction"
	RegularOrder           OrderDetailsPurchaseOrderType = "RegularOrder"
	RushOrder              OrderDetailsPurchaseOrderType = "RushOrder"
)

// Defines values for OrderItemAcknowledgementAcknowledgementCode.
const (
	Accepted    OrderItemAcknowledgementAcknowledgementCode = "Accepted"
	Backordered OrderItemAcknowledgementAcknowledgementCode = "Backordered"
	Rejected    OrderItemAcknowledgementAcknowledgementCode = "Rejected"
)

// Defines values for OrderItemAcknowledgementRejectionReason.
const (
	InvalidProductIdentifier OrderItemAcknowledgementRejectionReason = "InvalidProductIdentifier"
	ObsoleteProduct          OrderItemAcknowledgementRejectionReason = "ObsoleteProduct"
	TemporarilyUnavailable   OrderItemAcknowledgementRejectionReason = "TemporarilyUnavailable"
)

// Defines values for OrderItemStatusAcknowledgementStatusConfirmationStatus.
const (
	OrderItemStatusAcknowledgementStatusConfirmationStatusACCEPTED          OrderItemStatusAcknowledgementStatusConfirmationStatus = "ACCEPTED"
	OrderItemStatusAcknowledgementStatusConfirmationStatusPARTIALLYACCEPTED OrderItemStatusAcknowledgementStatusConfirmationStatus = "PARTIALLY_ACCEPTED"
	OrderItemStatusAcknowledgementStatusConfirmationStatusREJECTED          OrderItemStatusAcknowledgementStatusConfirmationStatus = "REJECTED"
	OrderItemStatusAcknowledgementStatusConfirmationStatusUNCONFIRMED       OrderItemStatusAcknowledgementStatusConfirmationStatus = "UNCONFIRMED"
)

// Defines values for OrderItemStatusReceivingStatusReceiveStatus.
const (
	OrderItemStatusReceivingStatusReceiveStatusNOTRECEIVED       OrderItemStatusReceivingStatusReceiveStatus = "NOT_RECEIVED"
	OrderItemStatusReceivingStatusReceiveStatusPARTIALLYRECEIVED OrderItemStatusReceivingStatusReceiveStatus = "PARTIALLY_RECEIVED"
	OrderItemStatusReceivingStatusReceiveStatusRECEIVED          OrderItemStatusReceivingStatusReceiveStatus = "RECEIVED"
)

// Defines values for OrderStatusPurchaseOrderStatus.
const (
	OrderStatusPurchaseOrderStatusCLOSED OrderStatusPurchaseOrderStatus = "CLOSED"
	OrderStatusPurchaseOrderStatusOPEN   OrderStatusPurchaseOrderStatus = "OPEN"
)

// Defines values for TaxRegistrationDetailsTaxRegistrationType.
const (
	GST TaxRegistrationDetailsTaxRegistrationType = "GST"
	VAT TaxRegistrationDetailsTaxRegistrationType = "VAT"
)

// Defines values for GetPurchaseOrdersParamsSortOrder.
const (
	GetPurchaseOrdersParamsSortOrderASC  GetPurchaseOrdersParamsSortOrder = "ASC"
	GetPurchaseOrdersParamsSortOrderDESC GetPurchaseOrdersParamsSortOrder = "DESC"
)

// Defines values for GetPurchaseOrdersParamsPoItemState.
const (
	Cancelled GetPurchaseOrdersParamsPoItemState = "Cancelled"
)

// Defines values for GetPurchaseOrdersParamsPurchaseOrderState.
const (
	GetPurchaseOrdersParamsPurchaseOrderStateAcknowledged GetPurchaseOrdersParamsPurchaseOrderState = "Acknowledged"
	GetPurchaseOrdersParamsPurchaseOrderStateClosed       GetPurchaseOrdersParamsPurchaseOrderState = "Closed"
	GetPurchaseOrdersParamsPurchaseOrderStateNew          GetPurchaseOrdersParamsPurchaseOrderState = "New"
)

// Defines values for GetPurchaseOrdersStatusParamsSortOrder.
const (
	GetPurchaseOrdersStatusParamsSortOrderASC  GetPurchaseOrdersStatusParamsSortOrder = "ASC"
	GetPurchaseOrdersStatusParamsSortOrderDESC GetPurchaseOrdersStatusParamsSortOrder = "DESC"
)

// Defines values for GetPurchaseOrdersStatusParamsPurchaseOrderStatus.
const (
	GetPurchaseOrdersStatusParamsPurchaseOrderStatusCLOSED GetPurchaseOrdersStatusParamsPurchaseOrderStatus = "CLOSED"
	GetPurchaseOrdersStatusParamsPurchaseOrderStatusOPEN   GetPurchaseOrdersStatusParamsPurchaseOrderStatus = "OPEN"
)

// Defines values for GetPurchaseOrdersStatusParamsItemConfirmationStatus.
const (
	GetPurchaseOrdersStatusParamsItemConfirmationStatusACCEPTED          GetPurchaseOrdersStatusParamsItemConfirmationStatus = "ACCEPTED"
	GetPurchaseOrdersStatusParamsItemConfirmationStatusPARTIALLYACCEPTED GetPurchaseOrdersStatusParamsItemConfirmationStatus = "PARTIALLY_ACCEPTED"
	GetPurchaseOrdersStatusParamsItemConfirmationStatusREJECTED          GetPurchaseOrdersStatusParamsItemConfirmationStatus = "REJECTED"
	GetPurchaseOrdersStatusParamsItemConfirmationStatusUNCONFIRMED       GetPurchaseOrdersStatusParamsItemConfirmationStatus = "UNCONFIRMED"
)

// Defines values for GetPurchaseOrdersStatusParamsItemReceiveStatus.
const (
	GetPurchaseOrdersStatusParamsItemReceiveStatusNOTRECEIVED       GetPurchaseOrdersStatusParamsItemReceiveStatus = "NOT_RECEIVED"
	GetPurchaseOrdersStatusParamsItemReceiveStatusPARTIALLYRECEIVED GetPurchaseOrdersStatusParamsItemReceiveStatus = "PARTIALLY_RECEIVED"
	GetPurchaseOrdersStatusParamsItemReceiveStatusRECEIVED          GetPurchaseOrdersStatusParamsItemReceiveStatus = "RECEIVED"
)

// AcknowledgementStatusDetails Details of item quantity ordered
type AcknowledgementStatusDetails struct {
	// AcceptedQuantity Details of quantity ordered.
	AcceptedQuantity *ItemQuantity `json:"acceptedQuantity,omitempty"`

	// AcknowledgementDate The date when the line item was confirmed by vendor. Must be in ISO-8601 date/time format.
	AcknowledgementDate *time.Time `json:"acknowledgementDate,omitempty"`

	// RejectedQuantity Details of quantity ordered.
	RejectedQuantity *ItemQuantity `json:"rejectedQuantity,omitempty"`
}

// Address Address of the party.
type Address struct {
	// AddressLine1 First line of the address.
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Additional address information, if required.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 Additional address information, if required.
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// City The city where the person, business or institution is located.
	City *string `json:"city,omitempty"`

	// CountryCode The two digit country code. In ISO 3166-1 alpha-2 format.
	CountryCode string `json:"countryCode"`

	// County The county where person, business or institution is located.
	County *string `json:"county,omitempty"`

	// District The district where person, business or institution is located.
	District *string `json:"district,omitempty"`

	// Name The name of the person, business or institution at that address.
	Name string `json:"name"`

	// Phone The phone number of the person, business or institution located at that address.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The postal code of that address. It conatins a series of letters or digits or both, sometimes including spaces or punctuation.
	PostalCode *string `json:"postalCode,omitempty"`

	// StateOrRegion The state or region where person, business or institution is located.
	StateOrRegion *string `json:"stateOrRegion,omitempty"`
}

// DateTimeInterval Defines a date time interval according to ISO8601. Interval is separated by double hyphen (--).
type DateTimeInterval = string

// Decimal A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation. <br>**Pattern** : `^-?(0|([1-9]\d*))(\.\d+)?([eE][+-]?\d+)?$`.
type Decimal = string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// GetPurchaseOrderResponse The response schema for the getPurchaseOrder operation.
type GetPurchaseOrderResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList `json:"errors,omitempty"`
	Payload *Order     `json:"payload,omitempty"`
}

// GetPurchaseOrdersResponse The response schema for the getPurchaseOrders operation.
type GetPurchaseOrdersResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList `json:"errors,omitempty"`
	Payload *OrderList `json:"payload,omitempty"`
}

// GetPurchaseOrdersStatusResponse The response schema for the getPurchaseOrdersStatus operation.
type GetPurchaseOrdersStatusResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList       `json:"errors,omitempty"`
	Payload *OrderListStatus `json:"payload,omitempty"`
}

// ImportDetails Import details for an import order.
type ImportDetails struct {
	// ImportContainers Types and numbers of container(s) for import purchase orders. Can be a comma-separated list if the shipment has multiple containers. HC signifies a high-capacity container. Free-text field, limited to 64 characters. The format will be a comma-delimited list containing values of the type: $NUMBER_OF_CONTAINERS_OF_THIS_TYPE-$CONTAINER_TYPE. The list of values for the container type is: 40'(40-foot container), 40'HC (40-foot high-capacity container), 45', 45'HC, 30', 30'HC, 20', 20'HC.
	ImportContainers *string `json:"importContainers,omitempty"`

	// InternationalCommercialTerms Incoterms (International Commercial Terms) are used to divide transaction costs and responsibilities between buyer and seller and reflect state-of-the-art transportation practices. This is for import purchase orders only.
	InternationalCommercialTerms *ImportDetailsInternationalCommercialTerms `json:"internationalCommercialTerms,omitempty"`

	// MethodOfPayment If the recipient requests, contains the shipment method of payment. This is for import PO's only.
	MethodOfPayment *ImportDetailsMethodOfPayment `json:"methodOfPayment,omitempty"`

	// PortOfDelivery The port where goods on an import purchase order must be delivered by the vendor. This should only be specified when the internationalCommercialTerms is FOB.
	PortOfDelivery *string `json:"portOfDelivery,omitempty"`

	// ShippingInstructions Special instructions regarding the shipment. This field is for import purchase orders.
	ShippingInstructions *string `json:"shippingInstructions,omitempty"`
}

// ImportDetailsInternationalCommercialTerms Incoterms (International Commercial Terms) are used to divide transaction costs and responsibilities between buyer and seller and reflect state-of-the-art transportation practices. This is for import purchase orders only.
type ImportDetailsInternationalCommercialTerms string

// ImportDetailsMethodOfPayment If the recipient requests, contains the shipment method of payment. This is for import PO's only.
type ImportDetailsMethodOfPayment string

// ItemQuantity Details of quantity ordered.
type ItemQuantity struct {
	// Amount Acknowledged quantity. This value should not be zero.
	Amount *int `json:"amount,omitempty"`

	// UnitOfMeasure Unit of measure for the acknowledged quantity.
	UnitOfMeasure *ItemQuantityUnitOfMeasure `json:"unitOfMeasure,omitempty"`

	// UnitSize The case size, in the event that we ordered using cases.
	UnitSize *int `json:"unitSize,omitempty"`
}

// ItemQuantityUnitOfMeasure Unit of measure for the acknowledged quantity.
type ItemQuantityUnitOfMeasure string

// ItemStatus Detailed description of items order status.
type ItemStatus = []OrderItemStatus

// Money An amount of money, including units in the form of currency.
type Money struct {
	// Amount A decimal number with no loss of precision. Useful when precision loss is unacceptable, as with currencies. Follows RFC7159 for number representation. <br>**Pattern** : `^-?(0|([1-9]\d*))(\.\d+)?([eE][+-]?\d+)?$`.
	Amount *Decimal `json:"amount,omitempty"`

	// CurrencyCode Three digit currency code in ISO 4217 format. String of length 3.
	CurrencyCode *string `json:"currencyCode,omitempty"`
}

// Order defines model for Order.
type Order struct {
	// OrderDetails Details of an order.
	OrderDetails *OrderDetails `json:"orderDetails,omitempty"`

	// PurchaseOrderNumber The purchase order number for this order. Formatting Notes: 8-character alpha-numeric code.
	PurchaseOrderNumber string `json:"purchaseOrderNumber"`

	// PurchaseOrderState This field will contain the current state of the purchase order.
	PurchaseOrderState OrderPurchaseOrderState `json:"purchaseOrderState"`
}

// OrderPurchaseOrderState This field will contain the current state of the purchase order.
type OrderPurchaseOrderState string

// OrderAcknowledgement defines model for OrderAcknowledgement.
type OrderAcknowledgement struct {
	// AcknowledgementDate The date and time when the purchase order is acknowledged, in ISO-8601 date/time format.
	AcknowledgementDate time.Time `json:"acknowledgementDate"`

	// Items A list of the items being acknowledged with associated details.
	Items []OrderAcknowledgementItem `json:"items"`

	// PurchaseOrderNumber The purchase order number. Formatting Notes: 8-character alpha-numeric code.
	PurchaseOrderNumber string              `json:"purchaseOrderNumber"`
	SellingParty        PartyIdentification `json:"sellingParty"`
}

// OrderAcknowledgementItem Details of the item being acknowledged.
type OrderAcknowledgementItem struct {
	// AmazonProductIdentifier Amazon Standard Identification Number (ASIN) of an item.
	AmazonProductIdentifier *string `json:"amazonProductIdentifier,omitempty"`

	// DiscountMultiplier The discount multiplier that should be applied to the price if a vendor sells books with a list price. This is a multiplier factor to arrive at a final discounted price. A multiplier of .90 would be the factor if a 10% discount is given.
	DiscountMultiplier *string `json:"discountMultiplier,omitempty"`

	// ItemAcknowledgements This is used to indicate acknowledged quantity.
	ItemAcknowledgements []OrderItemAcknowledgement `json:"itemAcknowledgements"`

	// ItemSequenceNumber Line item sequence number for the item.
	ItemSequenceNumber *string `json:"itemSequenceNumber,omitempty"`

	// ListPrice An amount of money, including units in the form of currency.
	ListPrice *Money `json:"listPrice,omitempty"`

	// NetCost An amount of money, including units in the form of currency.
	NetCost *Money `json:"netCost,omitempty"`

	// OrderedQuantity Details of quantity ordered.
	OrderedQuantity ItemQuantity `json:"orderedQuantity"`

	// VendorProductIdentifier The vendor selected product identification of the item. Should be the same as was sent in the purchase order.
	VendorProductIdentifier *string `json:"vendorProductIdentifier,omitempty"`
}

// OrderDetails Details of an order.
type OrderDetails struct {
	BillToParty *PartyIdentification `json:"billToParty,omitempty"`
	BuyingParty *PartyIdentification `json:"buyingParty,omitempty"`

	// DealCode If requested by the recipient, this field will contain a promotional/deal number. The discount code line is optional. It is used to obtain a price discount on items on the order.
	DealCode *string `json:"dealCode,omitempty"`

	// DeliveryWindow Defines a date time interval according to ISO8601. Interval is separated by double hyphen (--).
	DeliveryWindow *DateTimeInterval `json:"deliveryWindow,omitempty"`

	// ImportDetails Import details for an import order.
	ImportDetails *ImportDetails `json:"importDetails,omitempty"`

	// Items A list of items in this purchase order.
	Items []OrderItem `json:"items"`

	// PaymentMethod Payment method used.
	PaymentMethod *OrderDetailsPaymentMethod `json:"paymentMethod,omitempty"`

	// PurchaseOrderChangedDate The date when purchase order was last changed by Amazon after the order was placed. This date will be greater than 'purchaseOrderDate'. This means the PO data was changed on that date and vendors are required to fulfill the  updated PO. The PO changes can be related to Item Quantity, Ship to Location, Ship Window etc. This field will not be present in orders that have not changed after creation. Must be in ISO-8601 date/time format.
	PurchaseOrderChangedDate *time.Time `json:"purchaseOrderChangedDate,omitempty"`

	// PurchaseOrderDate The date the purchase order was placed. Must be in ISO-8601 date/time format.
	PurchaseOrderDate time.Time `json:"purchaseOrderDate"`

	// PurchaseOrderStateChangedDate The date when current purchase order state was changed. Current purchase order state is available in the field 'purchaseOrderState'. Must be in ISO-8601 date/time format.
	PurchaseOrderStateChangedDate time.Time `json:"purchaseOrderStateChangedDate"`

	// PurchaseOrderType Type of purchase order.
	PurchaseOrderType *OrderDetailsPurchaseOrderType `json:"purchaseOrderType,omitempty"`
	SellingParty      *PartyIdentification           `json:"sellingParty,omitempty"`
	ShipToParty       *PartyIdentification           `json:"shipToParty,omitempty"`

	// ShipWindow Defines a date time interval according to ISO8601. Interval is separated by double hyphen (--).
	ShipWindow *DateTimeInterval `json:"shipWindow,omitempty"`
}

// OrderDetailsPaymentMethod Payment method used.
type OrderDetailsPaymentMethod string

// OrderDetailsPurchaseOrderType Type of purchase order.
type OrderDetailsPurchaseOrderType string

// OrderItem defines model for OrderItem.
type OrderItem struct {
	// AmazonProductIdentifier Amazon Standard Identification Number (ASIN) of an item.
	AmazonProductIdentifier *string `json:"amazonProductIdentifier,omitempty"`

	// IsBackOrderAllowed When true, we will accept backorder confirmations for this item.
	IsBackOrderAllowed bool `json:"isBackOrderAllowed"`

	// ItemSequenceNumber Numbering of the item on the purchase order. The first item will be 1, the second 2, and so on.
	ItemSequenceNumber string `json:"itemSequenceNumber"`

	// ListPrice An amount of money, including units in the form of currency.
	ListPrice *Money `json:"listPrice,omitempty"`

	// NetCost An amount of money, including units in the form of currency.
	NetCost *Money `json:"netCost,omitempty"`

	// OrderedQuantity Details of quantity ordered.
	OrderedQuantity ItemQuantity `json:"orderedQuantity"`

	// VendorProductIdentifier The vendor selected product identification of the item.
	VendorProductIdentifier *string `json:"vendorProductIdentifier,omitempty"`
}

// OrderItemAcknowledgement defines model for OrderItemAcknowledgement.
type OrderItemAcknowledgement struct {
	// AcknowledgedQuantity Details of quantity ordered.
	AcknowledgedQuantity ItemQuantity `json:"acknowledgedQuantity"`

	// AcknowledgementCode This indicates the acknowledgement code.
	AcknowledgementCode OrderItemAcknowledgementAcknowledgementCode `json:"acknowledgementCode"`

	// RejectionReason Indicates the reason for rejection.
	RejectionReason *OrderItemAcknowledgementRejectionReason `json:"rejectionReason,omitempty"`

	// ScheduledDeliveryDate Estimated delivery date per line item. Must be in ISO-8601 date/time format.
	ScheduledDeliveryDate *time.Time `json:"scheduledDeliveryDate,omitempty"`

	// ScheduledShipDate Estimated ship date per line item. Must be in ISO-8601 date/time format.
	ScheduledShipDate *time.Time `json:"scheduledShipDate,omitempty"`
}

// OrderItemAcknowledgementAcknowledgementCode This indicates the acknowledgement code.
type OrderItemAcknowledgementAcknowledgementCode string

// OrderItemAcknowledgementRejectionReason Indicates the reason for rejection.
type OrderItemAcknowledgementRejectionReason string

// OrderItemStatus defines model for OrderItemStatus.
type OrderItemStatus struct {
	// AcknowledgementStatus Acknowledgement status information.
	AcknowledgementStatus *struct {
		// AcceptedQuantity Details of quantity ordered.
		AcceptedQuantity *ItemQuantity `json:"acceptedQuantity,omitempty"`

		// AcknowledgementStatusDetails Details of item quantity confirmed.
		AcknowledgementStatusDetails *[]AcknowledgementStatusDetails `json:"acknowledgementStatusDetails,omitempty"`

		// ConfirmationStatus Confirmation status of line item.
		ConfirmationStatus *OrderItemStatusAcknowledgementStatusConfirmationStatus `json:"confirmationStatus,omitempty"`

		// RejectedQuantity Details of quantity ordered.
		RejectedQuantity *ItemQuantity `json:"rejectedQuantity,omitempty"`
	} `json:"acknowledgementStatus,omitempty"`

	// BuyerProductIdentifier Buyer's Standard Identification Number (ASIN) of an item.
	BuyerProductIdentifier *string `json:"buyerProductIdentifier,omitempty"`

	// ItemSequenceNumber Numbering of the item on the purchase order. The first item will be 1, the second 2, and so on.
	ItemSequenceNumber string `json:"itemSequenceNumber"`

	// ListPrice An amount of money, including units in the form of currency.
	ListPrice *Money `json:"listPrice,omitempty"`

	// NetCost An amount of money, including units in the form of currency.
	NetCost *Money `json:"netCost,omitempty"`

	// OrderedQuantity Ordered quantity information.
	OrderedQuantity *struct {
		// OrderedQuantity Details of quantity ordered.
		OrderedQuantity *ItemQuantity `json:"orderedQuantity,omitempty"`

		// OrderedQuantityDetails Details of item quantity ordered.
		OrderedQuantityDetails *[]OrderedQuantityDetails `json:"orderedQuantityDetails,omitempty"`
	} `json:"orderedQuantity,omitempty"`

	// ReceivingStatus Item receive status at the buyer's warehouse.
	ReceivingStatus *struct {
		// LastReceiveDate The date when the most recent item was received at the buyer's warehouse. Must be in ISO-8601 date/time format.
		LastReceiveDate *time.Time `json:"lastReceiveDate,omitempty"`

		// ReceiveStatus Receive status of the line item.
		ReceiveStatus *OrderItemStatusReceivingStatusReceiveStatus `json:"receiveStatus,omitempty"`

		// ReceivedQuantity Details of quantity ordered.
		ReceivedQuantity *ItemQuantity `json:"receivedQuantity,omitempty"`
	} `json:"receivingStatus,omitempty"`

	// VendorProductIdentifier The vendor selected product identification of the item.
	VendorProductIdentifier *string `json:"vendorProductIdentifier,omitempty"`
}

// OrderItemStatusAcknowledgementStatusConfirmationStatus Confirmation status of line item.
type OrderItemStatusAcknowledgementStatusConfirmationStatus string

// OrderItemStatusReceivingStatusReceiveStatus Receive status of the line item.
type OrderItemStatusReceivingStatusReceiveStatus string

// OrderList defines model for OrderList.
type OrderList struct {
	Orders     *[]Order    `json:"orders,omitempty"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

// OrderListStatus defines model for OrderListStatus.
type OrderListStatus struct {
	OrdersStatus *[]OrderStatus `json:"ordersStatus,omitempty"`
	Pagination   *Pagination    `json:"pagination,omitempty"`
}

// OrderStatus Current status of a purchase order.
type OrderStatus struct {
	// ItemStatus Detailed description of items order status.
	ItemStatus ItemStatus `json:"itemStatus"`

	// LastUpdatedDate The date when the purchase order was last updated. Must be in ISO-8601 date/time format.
	LastUpdatedDate *time.Time `json:"lastUpdatedDate,omitempty"`

	// PurchaseOrderDate The date the purchase order was placed. Must be in ISO-8601 date/time format.
	PurchaseOrderDate time.Time `json:"purchaseOrderDate"`

	// PurchaseOrderNumber The buyer's purchase order number for this order. Formatting Notes: 8-character alpha-numeric code.
	PurchaseOrderNumber string `json:"purchaseOrderNumber"`

	// PurchaseOrderStatus The status of the buyer's purchase order for this order.
	PurchaseOrderStatus OrderStatusPurchaseOrderStatus `json:"purchaseOrderStatus"`
	SellingParty        PartyIdentification            `json:"sellingParty"`
	ShipToParty         PartyIdentification            `json:"shipToParty"`
}

// OrderStatusPurchaseOrderStatus The status of the buyer's purchase order for this order.
type OrderStatusPurchaseOrderStatus string

// OrderedQuantityDetails Details of item quantity ordered
type OrderedQuantityDetails struct {
	// CancelledQuantity Details of quantity ordered.
	CancelledQuantity *ItemQuantity `json:"cancelledQuantity,omitempty"`

	// OrderedQuantity Details of quantity ordered.
	OrderedQuantity *ItemQuantity `json:"orderedQuantity,omitempty"`

	// UpdatedDate The date when the line item quantity was updated by buyer. Must be in ISO-8601 date/time format.
	UpdatedDate *time.Time `json:"updatedDate,omitempty"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	// NextToken A generated string used to pass information to your next request. If NextToken is returned, pass the value of NextToken to the next request. If NextToken is not returned, there are no more purchase order items to return.
	NextToken *string `json:"nextToken,omitempty"`
}

// PartyIdentification defines model for PartyIdentification.
type PartyIdentification struct {
	// Address Address of the party.
	Address *Address `json:"address,omitempty"`

	// PartyId Assigned identification for the party. For example, warehouse code or vendor code. Please refer to specific party for more details.
	PartyId string `json:"partyId"`

	// TaxInfo Tax registration details of the entity.
	TaxInfo *TaxRegistrationDetails `json:"taxInfo,omitempty"`
}

// SubmitAcknowledgementRequest The request schema for the submitAcknowledgment operation.
type SubmitAcknowledgementRequest struct {
	Acknowledgements *[]OrderAcknowledgement `json:"acknowledgements,omitempty"`
}

// SubmitAcknowledgementResponse The response schema for the submitAcknowledgement operation
type SubmitAcknowledgementResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors  *ErrorList     `json:"errors,omitempty"`
	Payload *TransactionId `json:"payload,omitempty"`
}

// TaxRegistrationDetails Tax registration details of the entity.
type TaxRegistrationDetails struct {
	// TaxRegistrationNumber Tax registration number for the entity. For example, VAT ID.
	TaxRegistrationNumber string `json:"taxRegistrationNumber"`

	// TaxRegistrationType Tax registration type for the entity.
	TaxRegistrationType TaxRegistrationDetailsTaxRegistrationType `json:"taxRegistrationType"`
}

// TaxRegistrationDetailsTaxRegistrationType Tax registration type for the entity.
type TaxRegistrationDetailsTaxRegistrationType string

// TransactionId defines model for TransactionId.
type TransactionId struct {
	// TransactionId GUID assigned by Amazon to identify this transaction. This value can be used with the Transaction Status API to return the status of this transaction.
	TransactionId *string `json:"transactionId,omitempty"`
}

// GetPurchaseOrdersParams defines parameters for GetPurchaseOrders.
type GetPurchaseOrdersParams struct {
	// Limit The limit to the number of records returned. Default value is 100 records.
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// CreatedAfter Purchase orders that became available after this time will be included in the result. Must be in ISO-8601 date/time format.
	CreatedAfter *time.Time `form:"createdAfter,omitempty" json:"createdAfter,omitempty"`

	// CreatedBefore Purchase orders that became available before this time will be included in the result. Must be in ISO-8601 date/time format.
	CreatedBefore *time.Time `form:"createdBefore,omitempty" json:"createdBefore,omitempty"`

	// SortOrder Sort in ascending or descending order by purchase order creation date.
	SortOrder *GetPurchaseOrdersParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// NextToken Used for pagination when there is more purchase orders than the specified result size limit. The token value is returned in the previous API call
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// IncludeDetails When true, returns purchase orders with complete details. Otherwise, only purchase order numbers are returned. Default value is true.
	IncludeDetails *string `form:"includeDetails,omitempty" json:"includeDetails,omitempty"`

	// ChangedAfter Purchase orders that changed after this timestamp will be included in the result. Must be in ISO-8601 date/time format.
	ChangedAfter *time.Time `form:"changedAfter,omitempty" json:"changedAfter,omitempty"`

	// ChangedBefore Purchase orders that changed before this timestamp will be included in the result. Must be in ISO-8601 date/time format.
	ChangedBefore *time.Time `form:"changedBefore,omitempty" json:"changedBefore,omitempty"`

	// PoItemState Current state of the purchase order item. If this value is Cancelled, this API will return purchase orders which have one or more items cancelled by Amazon with updated item quantity as zero.
	PoItemState *GetPurchaseOrdersParamsPoItemState `form:"poItemState,omitempty" json:"poItemState,omitempty"`

	// IsPOChanged When true, returns purchase orders which were modified after the order was placed. Vendors are required to pull the changed purchase order and fulfill the updated purchase order and not the original one. Default value is false.
	IsPOChanged *string `form:"isPOChanged,omitempty" json:"isPOChanged,omitempty"`

	// PurchaseOrderState Filters purchase orders based on the purchase order state.
	PurchaseOrderState *GetPurchaseOrdersParamsPurchaseOrderState `form:"purchaseOrderState,omitempty" json:"purchaseOrderState,omitempty"`

	// OrderingVendorCode Filters purchase orders based on the specified ordering vendor code. This value should be same as 'sellingParty.partyId' in the purchase order. If not included in the filter, all purchase orders for all of the vendor codes that exist in the vendor group used to authorize the API client application are returned.
	OrderingVendorCode *string `form:"orderingVendorCode,omitempty" json:"orderingVendorCode,omitempty"`
}

// GetPurchaseOrdersParamsSortOrder defines parameters for GetPurchaseOrders.
type GetPurchaseOrdersParamsSortOrder string

// GetPurchaseOrdersParamsPoItemState defines parameters for GetPurchaseOrders.
type GetPurchaseOrdersParamsPoItemState string

// GetPurchaseOrdersParamsPurchaseOrderState defines parameters for GetPurchaseOrders.
type GetPurchaseOrdersParamsPurchaseOrderState string

// GetPurchaseOrdersStatusParams defines parameters for GetPurchaseOrdersStatus.
type GetPurchaseOrdersStatusParams struct {
	// Limit The limit to the number of records returned. Default value is 100 records.
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// SortOrder Sort in ascending or descending order by purchase order creation date.
	SortOrder *GetPurchaseOrdersStatusParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// NextToken Used for pagination when there are more purchase orders than the specified result size limit.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// CreatedAfter Purchase orders that became available after this timestamp will be included in the result. Must be in ISO-8601 date/time format.
	CreatedAfter *time.Time `form:"createdAfter,omitempty" json:"createdAfter,omitempty"`

	// CreatedBefore Purchase orders that became available before this timestamp will be included in the result. Must be in ISO-8601 date/time format.
	CreatedBefore *time.Time `form:"createdBefore,omitempty" json:"createdBefore,omitempty"`

	// UpdatedAfter Purchase orders for which the last purchase order update happened after this timestamp will be included in the result. Must be in ISO-8601 date/time format.
	UpdatedAfter *time.Time `form:"updatedAfter,omitempty" json:"updatedAfter,omitempty"`

	// UpdatedBefore Purchase orders for which the last purchase order update happened before this timestamp will be included in the result. Must be in ISO-8601 date/time format.
	UpdatedBefore *time.Time `form:"updatedBefore,omitempty" json:"updatedBefore,omitempty"`

	// PurchaseOrderNumber Provides purchase order status for the specified purchase order number.
	PurchaseOrderNumber *string `form:"purchaseOrderNumber,omitempty" json:"purchaseOrderNumber,omitempty"`

	// PurchaseOrderStatus Filters purchase orders based on the specified purchase order status. If not included in filter, this will return purchase orders for all statuses.
	PurchaseOrderStatus *GetPurchaseOrdersStatusParamsPurchaseOrderStatus `form:"purchaseOrderStatus,omitempty" json:"purchaseOrderStatus,omitempty"`

	// ItemConfirmationStatus Filters purchase orders based on their item confirmation status. If the item confirmation status is not included in the filter, purchase orders for all confirmation statuses are included.
	ItemConfirmationStatus *GetPurchaseOrdersStatusParamsItemConfirmationStatus `form:"itemConfirmationStatus,omitempty" json:"itemConfirmationStatus,omitempty"`

	// ItemReceiveStatus Filters purchase orders based on the purchase order's item receive status. If the item receive status is not included in the filter, purchase orders for all receive statuses are included.
	ItemReceiveStatus *GetPurchaseOrdersStatusParamsItemReceiveStatus `form:"itemReceiveStatus,omitempty" json:"itemReceiveStatus,omitempty"`

	// OrderingVendorCode Filters purchase orders based on the specified ordering vendor code. This value should be same as 'sellingParty.partyId' in the purchase order. If not included in filter, all purchase orders for all the vendor codes that exist in the vendor group used to authorize API client application are returned.
	OrderingVendorCode *string `form:"orderingVendorCode,omitempty" json:"orderingVendorCode,omitempty"`

	// ShipToPartyId Filters purchase orders for a specific buyer's Fulfillment Center/warehouse by providing ship to location id here. This value should be same as 'shipToParty.partyId' in the purchase order. If not included in filter, this will return purchase orders for all the buyer's warehouses used for vendor group purchase orders.
	ShipToPartyId *string `form:"shipToPartyId,omitempty" json:"shipToPartyId,omitempty"`
}

// GetPurchaseOrdersStatusParamsSortOrder defines parameters for GetPurchaseOrdersStatus.
type GetPurchaseOrdersStatusParamsSortOrder string

// GetPurchaseOrdersStatusParamsPurchaseOrderStatus defines parameters for GetPurchaseOrdersStatus.
type GetPurchaseOrdersStatusParamsPurchaseOrderStatus string

// GetPurchaseOrdersStatusParamsItemConfirmationStatus defines parameters for GetPurchaseOrdersStatus.
type GetPurchaseOrdersStatusParamsItemConfirmationStatus string

// GetPurchaseOrdersStatusParamsItemReceiveStatus defines parameters for GetPurchaseOrdersStatus.
type GetPurchaseOrdersStatusParamsItemReceiveStatus string

// SubmitAcknowledgementJSONRequestBody defines body for SubmitAcknowledgement for application/json ContentType.
type SubmitAcknowledgementJSONRequestBody = SubmitAcknowledgementRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SubmitAcknowledgementWithBody request with any body
	SubmitAcknowledgementWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubmitAcknowledgement(ctx context.Context, body SubmitAcknowledgementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPurchaseOrders request
	GetPurchaseOrders(ctx context.Context, params *GetPurchaseOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPurchaseOrder request
	GetPurchaseOrder(ctx context.Context, purchaseOrderNumber string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPurchaseOrdersStatus request
	GetPurchaseOrdersStatus(ctx context.Context, params *GetPurchaseOrdersStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SubmitAcknowledgementWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitAcknowledgementRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitAcknowledgement(ctx context.Context, body SubmitAcknowledgementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitAcknowledgementRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPurchaseOrders(ctx context.Context, params *GetPurchaseOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPurchaseOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPurchaseOrder(ctx context.Context, purchaseOrderNumber string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPurchaseOrderRequest(c.Server, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPurchaseOrdersStatus(ctx context.Context, params *GetPurchaseOrdersStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPurchaseOrdersStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSubmitAcknowledgementRequest calls the generic SubmitAcknowledgement builder with application/json body
func NewSubmitAcknowledgementRequest(server string, body SubmitAcknowledgementJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitAcknowledgementRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitAcknowledgementRequestWithBody generates requests for SubmitAcknowledgement with any type of body
func NewSubmitAcknowledgementRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/orders/v1/acknowledgements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPurchaseOrdersRequest generates requests for GetPurchaseOrders
func NewGetPurchaseOrdersRequest(server string, params *GetPurchaseOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/orders/v1/purchaseOrders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBefore", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IncludeDetails != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeDetails", runtime.ParamLocationQuery, *params.IncludeDetails); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ChangedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "changedAfter", runtime.ParamLocationQuery, *params.ChangedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ChangedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "changedBefore", runtime.ParamLocationQuery, *params.ChangedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PoItemState != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poItemState", runtime.ParamLocationQuery, *params.PoItemState); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.IsPOChanged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPOChanged", runtime.ParamLocationQuery, *params.IsPOChanged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PurchaseOrderState != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purchaseOrderState", runtime.ParamLocationQuery, *params.PurchaseOrderState); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.OrderingVendorCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderingVendorCode", runtime.ParamLocationQuery, *params.OrderingVendorCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPurchaseOrderRequest generates requests for GetPurchaseOrder
func NewGetPurchaseOrderRequest(server string, purchaseOrderNumber string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "purchaseOrderNumber", runtime.ParamLocationPath, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/orders/v1/purchaseOrders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPurchaseOrdersStatusRequest generates requests for GetPurchaseOrdersStatus
func NewGetPurchaseOrdersStatusRequest(server string, params *GetPurchaseOrdersStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor/orders/v1/purchaseOrdersStatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBefore", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.UpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedAfter", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.UpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedBefore", runtime.ParamLocationQuery, *params.UpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PurchaseOrderNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purchaseOrderNumber", runtime.ParamLocationQuery, *params.PurchaseOrderNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PurchaseOrderStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purchaseOrderStatus", runtime.ParamLocationQuery, *params.PurchaseOrderStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ItemConfirmationStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemConfirmationStatus", runtime.ParamLocationQuery, *params.ItemConfirmationStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ItemReceiveStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemReceiveStatus", runtime.ParamLocationQuery, *params.ItemReceiveStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.OrderingVendorCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderingVendorCode", runtime.ParamLocationQuery, *params.OrderingVendorCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.ShipToPartyId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipToPartyId", runtime.ParamLocationQuery, *params.ShipToPartyId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SubmitAcknowledgementWithBodyWithResponse request with any body
	SubmitAcknowledgementWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitAcknowledgementResp, error)

	SubmitAcknowledgementWithResponse(ctx context.Context, body SubmitAcknowledgementJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitAcknowledgementResp, error)

	// GetPurchaseOrdersWithResponse request
	GetPurchaseOrdersWithResponse(ctx context.Context, params *GetPurchaseOrdersParams, reqEditors ...RequestEditorFn) (*GetPurchaseOrdersResp, error)

	// GetPurchaseOrderWithResponse request
	GetPurchaseOrderWithResponse(ctx context.Context, purchaseOrderNumber string, reqEditors ...RequestEditorFn) (*GetPurchaseOrderResp, error)

	// GetPurchaseOrdersStatusWithResponse request
	GetPurchaseOrdersStatusWithResponse(ctx context.Context, params *GetPurchaseOrdersStatusParams, reqEditors ...RequestEditorFn) (*GetPurchaseOrdersStatusResp, error)
}

type SubmitAcknowledgementResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SubmitAcknowledgementResponse
	JSON400      *SubmitAcknowledgementResponse
	JSON403      *SubmitAcknowledgementResponse
	JSON404      *SubmitAcknowledgementResponse
	JSON413      *SubmitAcknowledgementResponse
	JSON415      *SubmitAcknowledgementResponse
	JSON429      *SubmitAcknowledgementResponse
	JSON500      *SubmitAcknowledgementResponse
	JSON503      *SubmitAcknowledgementResponse
}

// Status returns HTTPResponse.Status
func (r SubmitAcknowledgementResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitAcknowledgementResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPurchaseOrdersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPurchaseOrdersResponse
	JSON400      *GetPurchaseOrdersResponse
	JSON403      *GetPurchaseOrdersResponse
	JSON404      *GetPurchaseOrdersResponse
	JSON415      *GetPurchaseOrdersResponse
	JSON429      *GetPurchaseOrdersResponse
	JSON500      *GetPurchaseOrdersResponse
	JSON503      *GetPurchaseOrdersResponse
}

// Status returns HTTPResponse.Status
func (r GetPurchaseOrdersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPurchaseOrdersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPurchaseOrderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPurchaseOrderResponse
	JSON400      *GetPurchaseOrderResponse
	JSON401      *GetPurchaseOrderResponse
	JSON403      *GetPurchaseOrderResponse
	JSON404      *GetPurchaseOrderResponse
	JSON415      *GetPurchaseOrderResponse
	JSON429      *GetPurchaseOrderResponse
	JSON500      *GetPurchaseOrderResponse
	JSON503      *GetPurchaseOrderResponse
}

// Status returns HTTPResponse.Status
func (r GetPurchaseOrderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPurchaseOrderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPurchaseOrdersStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPurchaseOrdersStatusResponse
	JSON400      *GetPurchaseOrdersStatusResponse
	JSON403      *GetPurchaseOrdersStatusResponse
	JSON404      *GetPurchaseOrdersStatusResponse
	JSON415      *GetPurchaseOrdersStatusResponse
	JSON429      *GetPurchaseOrdersStatusResponse
	JSON500      *GetPurchaseOrdersStatusResponse
	JSON503      *GetPurchaseOrdersStatusResponse
}

// Status returns HTTPResponse.Status
func (r GetPurchaseOrdersStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPurchaseOrdersStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SubmitAcknowledgementWithBodyWithResponse request with arbitrary body returning *SubmitAcknowledgementResp
func (c *ClientWithResponses) SubmitAcknowledgementWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitAcknowledgementResp, error) {
	rsp, err := c.SubmitAcknowledgementWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitAcknowledgementResp(rsp)
}

func (c *ClientWithResponses) SubmitAcknowledgementWithResponse(ctx context.Context, body SubmitAcknowledgementJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitAcknowledgementResp, error) {
	rsp, err := c.SubmitAcknowledgement(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitAcknowledgementResp(rsp)
}

// GetPurchaseOrdersWithResponse request returning *GetPurchaseOrdersResp
func (c *ClientWithResponses) GetPurchaseOrdersWithResponse(ctx context.Context, params *GetPurchaseOrdersParams, reqEditors ...RequestEditorFn) (*GetPurchaseOrdersResp, error) {
	rsp, err := c.GetPurchaseOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPurchaseOrdersResp(rsp)
}

// GetPurchaseOrderWithResponse request returning *GetPurchaseOrderResp
func (c *ClientWithResponses) GetPurchaseOrderWithResponse(ctx context.Context, purchaseOrderNumber string, reqEditors ...RequestEditorFn) (*GetPurchaseOrderResp, error) {
	rsp, err := c.GetPurchaseOrder(ctx, purchaseOrderNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPurchaseOrderResp(rsp)
}

// GetPurchaseOrdersStatusWithResponse request returning *GetPurchaseOrdersStatusResp
func (c *ClientWithResponses) GetPurchaseOrdersStatusWithResponse(ctx context.Context, params *GetPurchaseOrdersStatusParams, reqEditors ...RequestEditorFn) (*GetPurchaseOrdersStatusResp, error) {
	rsp, err := c.GetPurchaseOrdersStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPurchaseOrdersStatusResp(rsp)
}

// ParseSubmitAcknowledgementResp parses an HTTP response from a SubmitAcknowledgementWithResponse call
func ParseSubmitAcknowledgementResp(rsp *http.Response) (*SubmitAcknowledgementResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitAcknowledgementResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest SubmitAcknowledgementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPurchaseOrdersResp parses an HTTP response from a GetPurchaseOrdersWithResponse call
func ParseGetPurchaseOrdersResp(rsp *http.Response) (*GetPurchaseOrdersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPurchaseOrdersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPurchaseOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPurchaseOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPurchaseOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPurchaseOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest GetPurchaseOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetPurchaseOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetPurchaseOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetPurchaseOrdersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPurchaseOrderResp parses an HTTP response from a GetPurchaseOrderWithResponse call
func ParseGetPurchaseOrderResp(rsp *http.Response) (*GetPurchaseOrderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPurchaseOrderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPurchaseOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPurchaseOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPurchaseOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPurchaseOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPurchaseOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest GetPurchaseOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetPurchaseOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetPurchaseOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetPurchaseOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPurchaseOrdersStatusResp parses an HTTP response from a GetPurchaseOrdersStatusWithResponse call
func ParseGetPurchaseOrdersStatusResp(rsp *http.Response) (*GetPurchaseOrdersStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPurchaseOrdersStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPurchaseOrdersStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPurchaseOrdersStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPurchaseOrdersStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPurchaseOrdersStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest GetPurchaseOrdersStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetPurchaseOrdersStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetPurchaseOrdersStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetPurchaseOrdersStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
