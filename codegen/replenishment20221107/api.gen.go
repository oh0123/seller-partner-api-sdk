// Package replenishment20221107 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.4 DO NOT EDIT.
package replenishment20221107

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"
)

// Defines values for AggregationFrequency.
const (
	MONTH   AggregationFrequency = "MONTH"
	QUARTER AggregationFrequency = "QUARTER"
	WEEK    AggregationFrequency = "WEEK"
	YEAR    AggregationFrequency = "YEAR"
)

// Defines values for AutoEnrollmentPreference.
const (
	OPTEDIN  AutoEnrollmentPreference = "OPTED_IN"
	OPTEDOUT AutoEnrollmentPreference = "OPTED_OUT"
)

// Defines values for EligibilityStatus.
const (
	ELIGIBLE                  EligibilityStatus = "ELIGIBLE"
	INELIGIBLE                EligibilityStatus = "INELIGIBLE"
	REPLENISHMENTONLYORDERING EligibilityStatus = "REPLENISHMENT_ONLY_ORDERING"
	SUSPENDED                 EligibilityStatus = "SUSPENDED"
)

// Defines values for EnrollmentMethod.
const (
	AUTOMATIC EnrollmentMethod = "AUTOMATIC"
	MANUAL    EnrollmentMethod = "MANUAL"
)

// Defines values for ListOfferMetricsSortKey.
const (
	ListOfferMetricsSortKeyACTIVESUBSCRIPTIONS                 ListOfferMetricsSortKey = "ACTIVE_SUBSCRIPTIONS"
	ListOfferMetricsSortKeyNEXT30DAYSSHIPPEDSUBSCRIPTIONUNITS  ListOfferMetricsSortKey = "NEXT_30DAYS_SHIPPED_SUBSCRIPTION_UNITS"
	ListOfferMetricsSortKeyNEXT30DAYSTOTALSUBSCRIPTIONSREVENUE ListOfferMetricsSortKey = "NEXT_30DAYS_TOTAL_SUBSCRIPTIONS_REVENUE"
	ListOfferMetricsSortKeyNEXT60DAYSSHIPPEDSUBSCRIPTIONUNITS  ListOfferMetricsSortKey = "NEXT_60DAYS_SHIPPED_SUBSCRIPTION_UNITS"
	ListOfferMetricsSortKeyNEXT60DAYSTOTALSUBSCRIPTIONSREVENUE ListOfferMetricsSortKey = "NEXT_60DAYS_TOTAL_SUBSCRIPTIONS_REVENUE"
	ListOfferMetricsSortKeyNEXT90DAYSSHIPPEDSUBSCRIPTIONUNITS  ListOfferMetricsSortKey = "NEXT_90DAYS_SHIPPED_SUBSCRIPTION_UNITS"
	ListOfferMetricsSortKeyNEXT90DAYSTOTALSUBSCRIPTIONSREVENUE ListOfferMetricsSortKey = "NEXT_90DAYS_TOTAL_SUBSCRIPTIONS_REVENUE"
	ListOfferMetricsSortKeySHIPPEDSUBSCRIPTIONUNITS            ListOfferMetricsSortKey = "SHIPPED_SUBSCRIPTION_UNITS"
	ListOfferMetricsSortKeyTOTALSUBSCRIPTIONSREVENUE           ListOfferMetricsSortKey = "TOTAL_SUBSCRIPTIONS_REVENUE"
)

// Defines values for ListOffersSortKey.
const (
	AMAZONFUNDEDBASEDISCOUNTPERCENTAGE           ListOffersSortKey = "AMAZON_FUNDED_BASE_DISCOUNT_PERCENTAGE"
	AMAZONFUNDEDTIEREDDISCOUNTPERCENTAGE         ListOffersSortKey = "AMAZON_FUNDED_TIERED_DISCOUNT_PERCENTAGE"
	ASIN                                         ListOffersSortKey = "ASIN"
	SELLINGPARTNERFUNDEDBASEDISCOUNTPERCENTAGE   ListOffersSortKey = "SELLING_PARTNER_FUNDED_BASE_DISCOUNT_PERCENTAGE"
	SELLINGPARTNERFUNDEDTIEREDDISCOUNTPERCENTAGE ListOffersSortKey = "SELLING_PARTNER_FUNDED_TIERED_DISCOUNT_PERCENTAGE"
)

// Defines values for Metric.
const (
	MetricACTIVESUBSCRIPTIONS                   Metric = "ACTIVE_SUBSCRIPTIONS"
	MetricNOTDELIVEREDDUETOOOS                  Metric = "NOT_DELIVERED_DUE_TO_OOS"
	MetricSHIPPEDSUBSCRIPTIONUNITS              Metric = "SHIPPED_SUBSCRIPTION_UNITS"
	MetricSUBSCRIBERNONSUBSCRIBERAVERAGEREVENUE Metric = "SUBSCRIBER_NON_SUBSCRIBER_AVERAGE_REVENUE"
	MetricTOTALSUBSCRIPTIONSREVENUE             Metric = "TOTAL_SUBSCRIPTIONS_REVENUE"
)

// Defines values for ProgramType.
const (
	SUBSCRIBEANDSAVE ProgramType = "SUBSCRIBE_AND_SAVE"
)

// Defines values for SortOrder.
const (
	ASC  SortOrder = "ASC"
	DESC SortOrder = "DESC"
)

// Defines values for TimePeriodType.
const (
	FORECAST    TimePeriodType = "FORECAST"
	PERFORMANCE TimePeriodType = "PERFORMANCE"
)

// AggregationFrequency The time period used to group data in the response. Note that this is only valid for the performance time period type.
type AggregationFrequency string

// AutoEnrollmentPreference The auto-enrollment preference indicates whether the offer is opted-in to or opted-out of Amazon's auto-enrollment feature.
type AutoEnrollmentPreference string

// DiscountFunding The discount funding on the offer.
type DiscountFunding struct {
	// Percentage Filters the results to only include offers with the percentage specified.
	Percentage *[]int64 `json:"percentage,omitempty"`
}

// EligibilityStatus The current eligibility status of an offer.
type EligibilityStatus string

// EnrollmentMethod The enrollment method used to enroll the offer into the program.
type EnrollmentMethod string

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	Errors []Error `json:"errors"`
}

// GetSellingPartnerMetricsRequest The request body for the `getSellingPartnerMetrics` operation.
type GetSellingPartnerMetricsRequest struct {
	// AggregationFrequency The time period used to group data in the response. Note that this is only valid for the performance time period type.
	AggregationFrequency *AggregationFrequency `json:"aggregationFrequency,omitempty"`

	// MarketplaceId The marketplace identifier. The supported marketplaces for both sellers and vendors are US, CA, ES, UK, FR, IT, IN, DE and JP. The supported marketplaces for vendors only are BR, AU, MX, AE and NL. Refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids) to find the identifier for the marketplace.
	MarketplaceId MarketplaceId `json:"marketplaceId"`

	// Metrics The list of metrics requested. If no metric value is provided, data for all of the metrics will be returned.
	Metrics *[]Metric `json:"metrics,omitempty"`

	// ProgramTypes A list of replenishment program types.
	ProgramTypes ProgramTypes `json:"programTypes"`

	// TimeInterval A date-time interval in ISO 8601 format which is used to compute metrics. Only the date is required, but you must pass the complete date and time value. For example, November 11, 2022 should be passed as "2022-11-07T00:00:00Z". Note that only data for the trailing 2 years is supported.
	//
	//  **Note**: The `listOfferMetrics` operation only supports a time interval which covers a single unit of the aggregation frequency. For example, for a MONTH aggregation frequency, the duration of the interval between the startDate and endDate can not be more than 1 month.
	TimeInterval TimeInterval `json:"timeInterval"`

	// TimePeriodType The time period type that determines whether the metrics requested are backward-looking (performance) or forward-looking (forecast).
	TimePeriodType TimePeriodType `json:"timePeriodType"`
}

// GetSellingPartnerMetricsResponse The response schema for the `getSellingPartnerMetrics` operation.
type GetSellingPartnerMetricsResponse struct {
	// Metrics A list of metrics data for the selling partner.
	Metrics *[]GetSellingPartnerMetricsResponseMetric `json:"metrics,omitempty"`
}

// GetSellingPartnerMetricsResponseMetric An object which contains metric data for a selling partner.
type GetSellingPartnerMetricsResponseMetric struct {
	// ActiveSubscriptions The number of active subscriptions present at the end of the period. Applicable only for the PERFORMANCE timePeriodType.
	ActiveSubscriptions *int64 `json:"activeSubscriptions,omitempty"`

	// CurrencyCode The currency code in ISO 4217 format.
	CurrencyCode *string `json:"currencyCode,omitempty"`

	// NonSubscriberAverageRevenue The average revenue per non-subscriber of the program over a period of past 12 months for sellers and 6 months for vendors. Applicable only for the PERFORMANCE timePeriodType.
	NonSubscriberAverageRevenue *float32 `json:"nonSubscriberAverageRevenue,omitempty"`

	// NotDeliveredDueToOOS The percentage of items that were not shipped out of the total shipped units over a period of time due to being out of stock. Applicable only for the PERFORMANCE timePeriodType.
	NotDeliveredDueToOOS *float32 `json:"notDeliveredDueToOOS,omitempty"`

	// ShippedSubscriptionUnits The number of units shipped to the subscribers over a period of time. Applicable for both the PERFORMANCE and FORECAST timePeriodType.
	ShippedSubscriptionUnits *int64 `json:"shippedSubscriptionUnits,omitempty"`

	// SubscriberAverageRevenue The average revenue per subscriber of the program over a period of past 12 months for sellers and 6 months for vendors. Applicable only for the PERFORMANCE timePeriodType.
	SubscriberAverageRevenue *float32 `json:"subscriberAverageRevenue,omitempty"`

	// TimeInterval A date-time interval in ISO 8601 format which is used to compute metrics. Only the date is required, but you must pass the complete date and time value. For example, November 11, 2022 should be passed as "2022-11-07T00:00:00Z". Note that only data for the trailing 2 years is supported.
	//
	//  **Note**: The `listOfferMetrics` operation only supports a time interval which covers a single unit of the aggregation frequency. For example, for a MONTH aggregation frequency, the duration of the interval between the startDate and endDate can not be more than 1 month.
	TimeInterval *TimeInterval `json:"timeInterval,omitempty"`

	// TotalSubscriptionsRevenue The revenue generated from subscriptions over a period of time. Applicable for both the PERFORMANCE and FORECAST timePeriodType.
	TotalSubscriptionsRevenue *float32 `json:"totalSubscriptionsRevenue,omitempty"`
}

// ListOfferMetricsRequest The request body for the `listOfferMetrics` operation.
type ListOfferMetricsRequest struct {
	// Filters Use these parameters to filter results. Any result must match all provided parameters. For any parameter that is an array, the result must match at least one element in the provided array.
	Filters ListOfferMetricsRequestFilters `json:"filters"`

	// Pagination Use these parameters to paginate through the response.
	Pagination ListOfferMetricsRequestPagination `json:"pagination"`

	// Sort Use these parameters to sort the response.
	Sort *ListOfferMetricsRequestSort `json:"sort,omitempty"`
}

// ListOfferMetricsRequestFilters Use these parameters to filter results. Any result must match all provided parameters. For any parameter that is an array, the result must match at least one element in the provided array.
type ListOfferMetricsRequestFilters struct {
	// AggregationFrequency The time period used to group data in the response. Note that this is only valid for the performance time period type.
	AggregationFrequency *AggregationFrequency `json:"aggregationFrequency,omitempty"`

	// Asins A list of Amazon Standard Identification Numbers (ASINs).
	Asins *[]string `json:"asins,omitempty"`

	// MarketplaceId The marketplace identifier. The supported marketplaces for both sellers and vendors are US, CA, ES, UK, FR, IT, IN, DE and JP. The supported marketplaces for vendors only are BR, AU, MX, AE and NL. Refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids) to find the identifier for the marketplace.
	MarketplaceId MarketplaceId `json:"marketplaceId"`

	// ProgramTypes A list of replenishment program types.
	ProgramTypes ProgramTypes `json:"programTypes"`

	// TimeInterval A date-time interval in ISO 8601 format which is used to compute metrics. Only the date is required, but you must pass the complete date and time value. For example, November 11, 2022 should be passed as "2022-11-07T00:00:00Z". Note that only data for the trailing 2 years is supported.
	//
	//  **Note**: The `listOfferMetrics` operation only supports a time interval which covers a single unit of the aggregation frequency. For example, for a MONTH aggregation frequency, the duration of the interval between the startDate and endDate can not be more than 1 month.
	TimeInterval TimeInterval `json:"timeInterval"`

	// TimePeriodType The time period type that determines whether the metrics requested are backward-looking (performance) or forward-looking (forecast).
	TimePeriodType TimePeriodType `json:"timePeriodType"`
}

// ListOfferMetricsRequestPagination Use these parameters to paginate through the response.
type ListOfferMetricsRequestPagination struct {
	// Limit The maximum number of results to return in the response.
	Limit int64 `json:"limit"`

	// Offset The offset from which to retrieve the number of results specified by the `limit` value. The first result is at offset 0.
	Offset int64 `json:"offset"`
}

// ListOfferMetricsRequestSort Use these parameters to sort the response.
type ListOfferMetricsRequestSort struct {
	// Key The attribute to use to sort the results.
	Key ListOfferMetricsSortKey `json:"key"`

	// Order The sort order.
	Order SortOrder `json:"order"`
}

// ListOfferMetricsResponse The response schema for the `listOfferMetrics` operation.
type ListOfferMetricsResponse struct {
	// Offers A list of offers and associated metrics.
	Offers *[]ListOfferMetricsResponseOffer `json:"offers,omitempty"`

	// Pagination Use these parameters to paginate through the response.
	Pagination *PaginationResponse `json:"pagination,omitempty"`
}

// ListOfferMetricsResponseOffer An object which contains offer metrics.
type ListOfferMetricsResponseOffer struct {
	// ActiveSubscriptions The number of active subscriptions present at the end of the period. Applicable only for the PERFORMANCE timePeriodType.
	ActiveSubscriptions *int64 `json:"activeSubscriptions,omitempty"`

	// Asin The Amazon Standard Identification Number (ASIN).
	Asin *string `json:"asin,omitempty"`

	// CurrencyCode The currency code in ISO 4217 format.
	CurrencyCode *string `json:"currencyCode,omitempty"`

	// Next30DayShippedSubscriptionUnits The forecasted shipped subscription units for the next 30 days. Applicable only for the FORECAST timePeriodType.
	Next30DayShippedSubscriptionUnits *int64 `json:"next30DayShippedSubscriptionUnits,omitempty"`

	// Next30DayTotalSubscriptionsRevenue The forecasted total subscription revenue for the next 30 days. Applicable only for the FORECAST timePeriodType.
	Next30DayTotalSubscriptionsRevenue *float32 `json:"next30DayTotalSubscriptionsRevenue,omitempty"`

	// Next60DayShippedSubscriptionUnits The forecasted shipped subscription units for the next 60 days. Applicable only for the FORECAST timePeriodType.
	Next60DayShippedSubscriptionUnits *int64 `json:"next60DayShippedSubscriptionUnits,omitempty"`

	// Next60DayTotalSubscriptionsRevenue The forecasted total subscription revenue for the next 60 days. Applicable only for the FORECAST timePeriodType.
	Next60DayTotalSubscriptionsRevenue *float32 `json:"next60DayTotalSubscriptionsRevenue,omitempty"`

	// Next90DayShippedSubscriptionUnits The forecasted shipped subscription units for the next 90 days. Applicable only for the FORECAST timePeriodType.
	Next90DayShippedSubscriptionUnits *int64 `json:"next90DayShippedSubscriptionUnits,omitempty"`

	// Next90DayTotalSubscriptionsRevenue The forecasted total subscription revenue for the next 90 days. Applicable only for the FORECAST timePeriodType.
	Next90DayTotalSubscriptionsRevenue *float32 `json:"next90DayTotalSubscriptionsRevenue,omitempty"`

	// NotDeliveredDueToOOS The percentage of items that were not shipped out of the total shipped units over a period of time due to being out of stock. Applicable only for the PERFORMANCE timePeriodType.
	NotDeliveredDueToOOS *float32 `json:"notDeliveredDueToOOS,omitempty"`

	// RevenuePenetration The percentage of total program revenue out of total product revenue. Applicable only for the PERFORMANCE timePeriodType.
	RevenuePenetration *float32 `json:"revenuePenetration,omitempty"`

	// ShippedSubscriptionUnits The number of units shipped to the subscribers over a period of time. Applicable only for the PERFORMANCE timePeriodType.
	ShippedSubscriptionUnits *int64 `json:"shippedSubscriptionUnits,omitempty"`

	// TimeInterval A date-time interval in ISO 8601 format which is used to compute metrics. Only the date is required, but you must pass the complete date and time value. For example, November 11, 2022 should be passed as "2022-11-07T00:00:00Z". Note that only data for the trailing 2 years is supported.
	//
	//  **Note**: The `listOfferMetrics` operation only supports a time interval which covers a single unit of the aggregation frequency. For example, for a MONTH aggregation frequency, the duration of the interval between the startDate and endDate can not be more than 1 month.
	TimeInterval *TimeInterval `json:"timeInterval,omitempty"`

	// TotalSubscriptionsRevenue The revenue generated from subscriptions over a period of time. Applicable only for the PERFORMANCE timePeriodType.
	TotalSubscriptionsRevenue *float32 `json:"totalSubscriptionsRevenue,omitempty"`
}

// ListOfferMetricsSortKey The attribute to use to sort the results.
type ListOfferMetricsSortKey string

// ListOffersRequest The request body for the `listOffers` operation.
type ListOffersRequest struct {
	// Filters Use these parameters to filter results. Any result must match all of the provided parameters. For any parameter that is an array, the result must match at least one element in the provided array.
	Filters ListOffersRequestFilters `json:"filters"`

	// Pagination Use these parameters to paginate through the response.
	Pagination ListOffersRequestPagination `json:"pagination"`

	// Sort Use these parameters to sort the response.
	Sort *ListOffersRequestSort `json:"sort,omitempty"`
}

// ListOffersRequestFilters Use these parameters to filter results. Any result must match all of the provided parameters. For any parameter that is an array, the result must match at least one element in the provided array.
type ListOffersRequestFilters struct {
	// Asins A list of Amazon Standard Identification Numbers (ASINs).
	Asins *[]string `json:"asins,omitempty"`

	// Eligibilities A list of eligibilities associated with an offer.
	Eligibilities *[]EligibilityStatus `json:"eligibilities,omitempty"`

	// MarketplaceId The marketplace identifier. The supported marketplaces for both sellers and vendors are US, CA, ES, UK, FR, IT, IN, DE and JP. The supported marketplaces for vendors only are BR, AU, MX, AE and NL. Refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids) to find the identifier for the marketplace.
	MarketplaceId MarketplaceId `json:"marketplaceId"`

	// Preferences Offer preferences that you can include in the result filter criteria.
	Preferences *Preference `json:"preferences,omitempty"`

	// ProgramTypes A list of replenishment program types.
	ProgramTypes ProgramTypes `json:"programTypes"`

	// Promotions Offer promotions to include in the result filter criteria.
	Promotions *Promotion `json:"promotions,omitempty"`

	// Skus A list of SKUs to filter. This filter is only supported for sellers and not for vendors.
	Skus *[]string `json:"skus,omitempty"`
}

// ListOffersRequestPagination Use these parameters to paginate through the response.
type ListOffersRequestPagination struct {
	// Limit The maximum number of results to return in the response.
	Limit int64 `json:"limit"`

	// Offset The offset from which to retrieve the number of results specified by the `limit` value. The first result is at offset 0.
	Offset int64 `json:"offset"`
}

// ListOffersRequestSort Use these parameters to sort the response.
type ListOffersRequestSort struct {
	// Key The attribute to use to sort the results.
	Key ListOffersSortKey `json:"key"`

	// Order The sort order.
	Order SortOrder `json:"order"`
}

// ListOffersResponse The response schema for the `listOffers` operation.
type ListOffersResponse struct {
	// Offers A list of offers.
	Offers *[]ListOffersResponseOffer `json:"offers,omitempty"`

	// Pagination Use these parameters to paginate through the response.
	Pagination *PaginationResponse `json:"pagination,omitempty"`
}

// ListOffersResponseOffer An object which contains details about an offer.
type ListOffersResponseOffer struct {
	// Asin The Amazon Standard Identification Number (ASIN).
	Asin *string `json:"asin,omitempty"`

	// Eligibility The current eligibility status of an offer.
	Eligibility *EligibilityStatus `json:"eligibility,omitempty"`

	// MarketplaceId The marketplace identifier. The supported marketplaces for both sellers and vendors are US, CA, ES, UK, FR, IT, IN, DE and JP. The supported marketplaces for vendors only are BR, AU, MX, AE and NL. Refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids) to find the identifier for the marketplace.
	MarketplaceId *MarketplaceId `json:"marketplaceId,omitempty"`

	// OfferProgramConfiguration The offer program configuration contains a set of program properties for an offer.
	OfferProgramConfiguration *OfferProgramConfiguration `json:"offerProgramConfiguration,omitempty"`

	// ProgramType The replenishment program type.
	ProgramType *ProgramType `json:"programType,omitempty"`

	// Sku The SKU. This property is only supported for sellers and not for vendors.
	Sku *string `json:"sku,omitempty"`

	// VendorCodes A list of vendor codes associated with the offer.
	VendorCodes *[]string `json:"vendorCodes,omitempty"`
}

// ListOffersSortKey The attribute to use to sort the results.
type ListOffersSortKey string

// MarketplaceId The marketplace identifier. The supported marketplaces for both sellers and vendors are US, CA, ES, UK, FR, IT, IN, DE and JP. The supported marketplaces for vendors only are BR, AU, MX, AE and NL. Refer to [Marketplace IDs](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids) to find the identifier for the marketplace.
type MarketplaceId = string

// Metric The metric name and description.
type Metric string

// OfferProgramConfiguration The offer program configuration contains a set of program properties for an offer.
type OfferProgramConfiguration struct {
	// EnrollmentMethod The enrollment method used to enroll the offer into the program.
	EnrollmentMethod *EnrollmentMethod `json:"enrollmentMethod,omitempty"`

	// Preferences An object which contains the preferences applied to the offer.
	Preferences *OfferProgramConfigurationPreferences `json:"preferences,omitempty"`

	// Promotions An object which represents all promotions applied to an offer.
	Promotions *OfferProgramConfigurationPromotions `json:"promotions,omitempty"`
}

// OfferProgramConfigurationPreferences An object which contains the preferences applied to the offer.
type OfferProgramConfigurationPreferences struct {
	// AutoEnrollment The auto-enrollment preference indicates whether the offer is opted-in to or opted-out of Amazon's auto-enrollment feature.
	AutoEnrollment *AutoEnrollmentPreference `json:"autoEnrollment,omitempty"`
}

// OfferProgramConfigurationPromotions An object which represents all promotions applied to an offer.
type OfferProgramConfigurationPromotions struct {
	// AmazonFundedBaseDiscount A promotional percentage discount applied to the offer.
	AmazonFundedBaseDiscount *OfferProgramConfigurationPromotionsDiscountFunding `json:"amazonFundedBaseDiscount,omitempty"`

	// AmazonFundedTieredDiscount A promotional percentage discount applied to the offer.
	AmazonFundedTieredDiscount *OfferProgramConfigurationPromotionsDiscountFunding `json:"amazonFundedTieredDiscount,omitempty"`

	// SellingPartnerFundedBaseDiscount A promotional percentage discount applied to the offer.
	SellingPartnerFundedBaseDiscount *OfferProgramConfigurationPromotionsDiscountFunding `json:"sellingPartnerFundedBaseDiscount,omitempty"`

	// SellingPartnerFundedTieredDiscount A promotional percentage discount applied to the offer.
	SellingPartnerFundedTieredDiscount *OfferProgramConfigurationPromotionsDiscountFunding `json:"sellingPartnerFundedTieredDiscount,omitempty"`
}

// OfferProgramConfigurationPromotionsDiscountFunding A promotional percentage discount applied to the offer.
type OfferProgramConfigurationPromotionsDiscountFunding struct {
	// Percentage The percentage discount on the offer.
	Percentage *int64 `json:"percentage,omitempty"`
}

// PaginationResponse Use these parameters to paginate through the response.
type PaginationResponse struct {
	// TotalResults Total number of results matching the given filter criteria.
	TotalResults *int64 `json:"totalResults,omitempty"`
}

// Preference Offer preferences that you can include in the result filter criteria.
type Preference struct {
	// AutoEnrollment Filters the results to only include offers with the auto-enrollment preference specified.
	AutoEnrollment *[]AutoEnrollmentPreference `json:"autoEnrollment,omitempty"`
}

// ProgramType The replenishment program type.
type ProgramType string

// ProgramTypes A list of replenishment program types.
type ProgramTypes = []ProgramType

// Promotion Offer promotions to include in the result filter criteria.
type Promotion struct {
	// AmazonFundedBaseDiscount The discount funding on the offer.
	AmazonFundedBaseDiscount *DiscountFunding `json:"amazonFundedBaseDiscount,omitempty"`

	// AmazonFundedTieredDiscount The discount funding on the offer.
	AmazonFundedTieredDiscount *DiscountFunding `json:"amazonFundedTieredDiscount,omitempty"`

	// SellingPartnerFundedBaseDiscount The discount funding on the offer.
	SellingPartnerFundedBaseDiscount *DiscountFunding `json:"sellingPartnerFundedBaseDiscount,omitempty"`

	// SellingPartnerFundedTieredDiscount The discount funding on the offer.
	SellingPartnerFundedTieredDiscount *DiscountFunding `json:"sellingPartnerFundedTieredDiscount,omitempty"`
}

// SortOrder The sort order.
type SortOrder string

// TimeInterval A date-time interval in ISO 8601 format which is used to compute metrics. Only the date is required, but you must pass the complete date and time value. For example, November 11, 2022 should be passed as "2022-11-07T00:00:00Z". Note that only data for the trailing 2 years is supported.
//
//	**Note**: The `listOfferMetrics` operation only supports a time interval which covers a single unit of the aggregation frequency. For example, for a MONTH aggregation frequency, the duration of the interval between the startDate and endDate can not be more than 1 month.
type TimeInterval struct {
	// EndDate When this object is used as a request parameter, the specified endDate is adjusted based on the aggregation frequency.
	//
	// * For WEEK the metric is computed up to the last day of the week (that is, Sunday based on ISO 8601) that contains the endDate.
	// * For MONTH, the metric is computed up to the last day that contains the endDate.
	// * For QUARTER the metric is computed up to the last day of the quarter that contains the endDate.
	// * For YEAR the metric is computed up to the last day of the year that contains the endDate.
	//  Note: The end date may be adjusted to a lower value based on the data available in our system.
	EndDate time.Time `json:"endDate"`

	// StartDate When this object is used as a request parameter, the specified startDate is adjusted based on the aggregation frequency.
	//
	// * For WEEK the metric is computed from the first day of the week (that is, Sunday based on ISO 8601) that contains the startDate.
	// * For MONTH the metric is computed from the first day of the month that contains the startDate.
	// * For QUARTER the metric is computed from the first day of the quarter that contains the startDate.
	// * For YEAR the metric is computed from the first day of the year that contains the startDate.
	StartDate time.Time `json:"startDate"`
}

// TimePeriodType The time period type that determines whether the metrics requested are backward-looking (performance) or forward-looking (forecast).
type TimePeriodType string

// ListOfferMetricsJSONRequestBody defines body for ListOfferMetrics for application/json ContentType.
type ListOfferMetricsJSONRequestBody = ListOfferMetricsRequest

// ListOffersJSONRequestBody defines body for ListOffers for application/json ContentType.
type ListOffersJSONRequestBody = ListOffersRequest

// GetSellingPartnerMetricsJSONRequestBody defines body for GetSellingPartnerMetrics for application/json ContentType.
type GetSellingPartnerMetricsJSONRequestBody = GetSellingPartnerMetricsRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListOfferMetricsWithBody request with any body
	ListOfferMetricsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	ListOfferMetrics(ctx context.Context, body ListOfferMetricsJSONRequestBody) (*http.Response, error)

	// ListOffersWithBody request with any body
	ListOffersWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	ListOffers(ctx context.Context, body ListOffersJSONRequestBody) (*http.Response, error)

	// GetSellingPartnerMetricsWithBody request with any body
	GetSellingPartnerMetricsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	GetSellingPartnerMetrics(ctx context.Context, body GetSellingPartnerMetricsJSONRequestBody) (*http.Response, error)
}

func (c *Client) ListOfferMetricsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewListOfferMetricsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListOfferMetrics(ctx context.Context, body ListOfferMetricsJSONRequestBody) (*http.Response, error) {
	req, err := NewListOfferMetricsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListOffersWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewListOffersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListOffers(ctx context.Context, body ListOffersJSONRequestBody) (*http.Response, error) {
	req, err := NewListOffersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetSellingPartnerMetricsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetSellingPartnerMetricsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetSellingPartnerMetrics(ctx context.Context, body GetSellingPartnerMetricsJSONRequestBody) (*http.Response, error) {
	req, err := NewGetSellingPartnerMetricsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewListOfferMetricsRequest calls the generic ListOfferMetrics builder with application/json body
func NewListOfferMetricsRequest(server string, body ListOfferMetricsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListOfferMetricsRequestWithBody(server, "application/json", bodyReader)
}

// NewListOfferMetricsRequestWithBody generates requests for ListOfferMetrics with any type of body
func NewListOfferMetricsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/replenishment/2022-11-07/offers/metrics/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOffersRequest calls the generic ListOffers builder with application/json body
func NewListOffersRequest(server string, body ListOffersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListOffersRequestWithBody(server, "application/json", bodyReader)
}

// NewListOffersRequestWithBody generates requests for ListOffers with any type of body
func NewListOffersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/replenishment/2022-11-07/offers/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSellingPartnerMetricsRequest calls the generic GetSellingPartnerMetrics builder with application/json body
func NewGetSellingPartnerMetricsRequest(server string, body GetSellingPartnerMetricsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetSellingPartnerMetricsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetSellingPartnerMetricsRequestWithBody generates requests for GetSellingPartnerMetrics with any type of body
func NewGetSellingPartnerMetricsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/replenishment/2022-11-07/sellingPartners/metrics/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListOfferMetricsWithBodyWithResponse request with any body
	ListOfferMetricsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*ListOfferMetricsResp, error)

	ListOfferMetricsWithResponse(ctx context.Context, body ListOfferMetricsJSONRequestBody) (*ListOfferMetricsResp, error)

	// ListOffersWithBodyWithResponse request with any body
	ListOffersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*ListOffersResp, error)

	ListOffersWithResponse(ctx context.Context, body ListOffersJSONRequestBody) (*ListOffersResp, error)

	// GetSellingPartnerMetricsWithBodyWithResponse request with any body
	GetSellingPartnerMetricsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetSellingPartnerMetricsResp, error)

	GetSellingPartnerMetricsWithResponse(ctx context.Context, body GetSellingPartnerMetricsJSONRequestBody) (*GetSellingPartnerMetricsResp, error)
}

type ListOfferMetricsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListOfferMetricsResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListOfferMetricsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOfferMetricsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOffersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListOffersResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListOffersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOffersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSellingPartnerMetricsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSellingPartnerMetricsResponse
	JSON400      *ErrorList
	JSON401      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetSellingPartnerMetricsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSellingPartnerMetricsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListOfferMetricsWithBodyWithResponse request with arbitrary body returning *ListOfferMetricsResp
func (c *ClientWithResponses) ListOfferMetricsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*ListOfferMetricsResp, error) {
	rsp, err := c.ListOfferMetricsWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseListOfferMetricsResp(rsp)
}

func (c *ClientWithResponses) ListOfferMetricsWithResponse(ctx context.Context, body ListOfferMetricsJSONRequestBody) (*ListOfferMetricsResp, error) {
	rsp, err := c.ListOfferMetrics(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseListOfferMetricsResp(rsp)
}

// ListOffersWithBodyWithResponse request with arbitrary body returning *ListOffersResp
func (c *ClientWithResponses) ListOffersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*ListOffersResp, error) {
	rsp, err := c.ListOffersWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseListOffersResp(rsp)
}

func (c *ClientWithResponses) ListOffersWithResponse(ctx context.Context, body ListOffersJSONRequestBody) (*ListOffersResp, error) {
	rsp, err := c.ListOffers(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseListOffersResp(rsp)
}

// GetSellingPartnerMetricsWithBodyWithResponse request with arbitrary body returning *GetSellingPartnerMetricsResp
func (c *ClientWithResponses) GetSellingPartnerMetricsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetSellingPartnerMetricsResp, error) {
	rsp, err := c.GetSellingPartnerMetricsWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetSellingPartnerMetricsResp(rsp)
}

func (c *ClientWithResponses) GetSellingPartnerMetricsWithResponse(ctx context.Context, body GetSellingPartnerMetricsJSONRequestBody) (*GetSellingPartnerMetricsResp, error) {
	rsp, err := c.GetSellingPartnerMetrics(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseGetSellingPartnerMetricsResp(rsp)
}

// ParseListOfferMetricsResp parses an HTTP response from a ListOfferMetricsWithResponse call
func ParseListOfferMetricsResp(rsp *http.Response) (*ListOfferMetricsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOfferMetricsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListOfferMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListOffersResp parses an HTTP response from a ListOffersWithResponse call
func ParseListOffersResp(rsp *http.Response) (*ListOffersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOffersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListOffersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetSellingPartnerMetricsResp parses an HTTP response from a GetSellingPartnerMetricsWithResponse call
func ParseGetSellingPartnerMetricsResp(rsp *http.Response) (*GetSellingPartnerMetricsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSellingPartnerMetricsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSellingPartnerMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
