// Package financesv20240619 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package financesv20240619

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for ItemRelatedIdentifierItemRelatedIdentifierName.
const (
	COUPONID              ItemRelatedIdentifierItemRelatedIdentifierName = "COUPON_ID"
	ORDERADJUSTMENTITEMID ItemRelatedIdentifierItemRelatedIdentifierName = "ORDER_ADJUSTMENT_ITEM_ID"
	REMOVALSHIPMENTITEMID ItemRelatedIdentifierItemRelatedIdentifierName = "REMOVAL_SHIPMENT_ITEM_ID"
	TRANSACTIONID         ItemRelatedIdentifierItemRelatedIdentifierName = "TRANSACTION_ID"
)

// Defines values for RelatedIdentifierRelatedIdentifierName.
const (
	DEFERREDTRANSACTIONID RelatedIdentifierRelatedIdentifierName = "DEFERRED_TRANSACTION_ID"
	DISBURSEMENTID        RelatedIdentifierRelatedIdentifierName = "DISBURSEMENT_ID"
	EVENTGROUPID          RelatedIdentifierRelatedIdentifierName = "EVENT_GROUP_ID"
	INVOICEID             RelatedIdentifierRelatedIdentifierName = "INVOICE_ID"
	ORDERID               RelatedIdentifierRelatedIdentifierName = "ORDER_ID"
	REFUNDID              RelatedIdentifierRelatedIdentifierName = "REFUND_ID"
	SHIPMENTID            RelatedIdentifierRelatedIdentifierName = "SHIPMENT_ID"
	TRANSFERID            RelatedIdentifierRelatedIdentifierName = "TRANSFER_ID"
)

// AmazonPayContext Additional information related to Amazon Pay.
type AmazonPayContext struct {
	// Channel Channel details of related transaction.
	Channel *string `json:"channel,omitempty"`

	// OrderType The transaction's order type.
	OrderType *string `json:"orderType,omitempty"`

	// StoreName The name of the store that is related to the transaction.
	StoreName *string `json:"storeName,omitempty"`
}

// BigDecimal A signed decimal number.
type BigDecimal = float32

// Breakdown Details about the movement of money in the financial transaction. Breakdowns are further categorized into breakdown types, breakdown amounts, and further breakdowns.
type Breakdown struct {
	// BreakdownAmount A currency type and amount.
	BreakdownAmount *Currency `json:"breakdownAmount,omitempty"`

	// BreakdownType The type of charge.
	BreakdownType *string `json:"breakdownType,omitempty"`

	// Breakdowns Details about the movement of money in the financial transaction. Breakdowns are further categorized into breakdown types, breakdown amounts, and further breakdowns.
	Breakdowns *Breakdown `json:"breakdowns,omitempty"`
}

// Breakdowns A list of breakdowns that provide details on how the total amount is calculated for the transaction.
type Breakdowns = []Breakdown

// Context defines model for Context.
type Context struct {
	// Asin The Amazon Standard Identification Number (ASIN) of the item.
	Asin *string `json:"asin,omitempty"`

	// Channel Channel details of related transaction.
	Channel     *string `json:"channel,omitempty"`
	ContextType string  `json:"contextType"`

	// DeferralReason Deferral policy applied on the transaction.
	//
	// **Examples:** `B2B`,`DD7`
	DeferralReason *string `json:"deferralReason,omitempty"`

	// DeferralStatus The status of the transaction. For example, `HOLD`,`RELEASE`.
	DeferralStatus *string `json:"deferralStatus,omitempty"`

	// EndTime A date in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	EndTime *Date `json:"endTime,omitempty"`

	// FulfillmentNetwork The fulfillment network of the item.
	FulfillmentNetwork *string `json:"fulfillmentNetwork,omitempty"`

	// MaturityDate A date in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	MaturityDate *Date `json:"maturityDate,omitempty"`

	// OrderType The transaction's order type.
	OrderType *string `json:"orderType,omitempty"`

	// PaymentDate A date in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	PaymentDate *Date `json:"paymentDate,omitempty"`

	// PaymentMethod The method of payment.
	PaymentMethod *string `json:"paymentMethod,omitempty"`

	// PaymentReference The reference number of the payment.
	PaymentReference *string `json:"paymentReference,omitempty"`

	// PaymentType The type of payment.
	PaymentType *string `json:"paymentType,omitempty"`

	// QuantityShipped The quantity of the item shipped.
	QuantityShipped *int32 `json:"quantityShipped,omitempty"`

	// Sku The Stock Keeping Unit (SKU) of the item.
	Sku *string `json:"sku,omitempty"`

	// StartTime A date in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	StartTime *Date `json:"startTime,omitempty"`

	// StoreName The name of the store that is related to the transaction.
	StoreName *string `json:"storeName,omitempty"`
}

// Contexts A list of additional information about the item.
type Contexts = []Context

// Currency A currency type and amount.
type Currency struct {
	// CurrencyAmount A signed decimal number.
	CurrencyAmount *BigDecimal `json:"currencyAmount,omitempty"`

	// CurrencyCode The three-digit currency code in ISO 4217 format.
	CurrencyCode *string `json:"currencyCode,omitempty"`
}

// Date A date in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
type Date = time.Time

// DeferredContext Additional information related to deferred transactions.
type DeferredContext struct {
	// DeferralReason Deferral policy applied on the transaction.
	//
	// **Examples:** `B2B`,`DD7`
	DeferralReason *string `json:"deferralReason,omitempty"`

	// DeferralStatus The status of the transaction. For example, `HOLD`,`RELEASE`.
	DeferralStatus *string `json:"deferralStatus,omitempty"`

	// MaturityDate A date in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	MaturityDate *Date `json:"maturityDate,omitempty"`
}

// Error An error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	// Errors The error responses that are returned when the request is unsuccessful.
	Errors []Error `json:"errors"`
}

// Item Additional information about the items in a transaction.
type Item struct {
	// Breakdowns A list of breakdowns that provide details on how the total amount is calculated for the transaction.
	Breakdowns *Breakdowns `json:"breakdowns,omitempty"`

	// Contexts A list of additional information about the item.
	Contexts *Contexts `json:"contexts,omitempty"`

	// Description A description of the items in a transaction.
	Description *string `json:"description,omitempty"`

	// RelatedIdentifiers Related business identifiers of the item in the transaction.
	RelatedIdentifiers *ItemRelatedIdentifiers `json:"relatedIdentifiers,omitempty"`

	// TotalAmount A currency type and amount.
	TotalAmount *Currency `json:"totalAmount,omitempty"`
}

// ItemRelatedIdentifier Related business identifiers of the item.
type ItemRelatedIdentifier struct {
	// ItemRelatedIdentifierName Enumerated set of related item identifier names for the item.
	ItemRelatedIdentifierName *ItemRelatedIdentifierItemRelatedIdentifierName `json:"itemRelatedIdentifierName,omitempty"`

	// ItemRelatedIdentifierValue Corresponding value to `ItemRelatedIdentifierName`.
	ItemRelatedIdentifierValue *string `json:"itemRelatedIdentifierValue,omitempty"`
}

// ItemRelatedIdentifierItemRelatedIdentifierName Enumerated set of related item identifier names for the item.
type ItemRelatedIdentifierItemRelatedIdentifierName string

// ItemRelatedIdentifiers Related business identifiers of the item in the transaction.
type ItemRelatedIdentifiers = []ItemRelatedIdentifier

// Items A list of items in the transaction.
type Items = []Item

// ListTransactionsResponse The response schema for the `listTransactions` operation.
type ListTransactionsResponse struct {
	// NextToken The response includes `nextToken` when the number of results exceeds the specified `pageSize` value. To get the next page of results, call the operation with this token and include the same arguments as the call that produced the token. To get a complete list, call this operation until `nextToken` is null. Note that this operation can return empty pages.
	NextToken *string `json:"nextToken,omitempty"`

	// Transactions A list of transactions within the specified time period.
	Transactions *Transactions `json:"transactions,omitempty"`
}

// MarketplaceDetails Information about the marketplace where the transaction occurred.
type MarketplaceDetails struct {
	// MarketplaceId The identifier of the marketplace where the transaction occured.
	MarketplaceId *string `json:"marketplaceId,omitempty"`

	// MarketplaceName The name of the marketplace where the transaction occurred. For example: `Amazon.com`,`Amazon.in`
	MarketplaceName *string `json:"marketplaceName,omitempty"`
}

// PaymentsContext Additional information related to payments-related transactions.
type PaymentsContext struct {
	// PaymentDate A date in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	PaymentDate *Date `json:"paymentDate,omitempty"`

	// PaymentMethod The method of payment.
	PaymentMethod *string `json:"paymentMethod,omitempty"`

	// PaymentReference The reference number of the payment.
	PaymentReference *string `json:"paymentReference,omitempty"`

	// PaymentType The type of payment.
	PaymentType *string `json:"paymentType,omitempty"`
}

// ProductContext Additional information related to the product.
type ProductContext struct {
	// Asin The Amazon Standard Identification Number (ASIN) of the item.
	Asin *string `json:"asin,omitempty"`

	// FulfillmentNetwork The fulfillment network of the item.
	FulfillmentNetwork *string `json:"fulfillmentNetwork,omitempty"`

	// QuantityShipped The quantity of the item shipped.
	QuantityShipped *int32 `json:"quantityShipped,omitempty"`

	// Sku The Stock Keeping Unit (SKU) of the item.
	Sku *string `json:"sku,omitempty"`
}

// RelatedIdentifier Related business identifier of the transaction.
type RelatedIdentifier struct {
	// RelatedIdentifierName An enumerated set of related business identifier names.
	RelatedIdentifierName *RelatedIdentifierRelatedIdentifierName `json:"relatedIdentifierName,omitempty"`

	// RelatedIdentifierValue Corresponding value of `RelatedIdentifierName`.
	RelatedIdentifierValue *string `json:"relatedIdentifierValue,omitempty"`
}

// RelatedIdentifierRelatedIdentifierName An enumerated set of related business identifier names.
type RelatedIdentifierRelatedIdentifierName string

// RelatedIdentifiers Related business identifiers of the transaction.
type RelatedIdentifiers = []RelatedIdentifier

// SellingPartnerMetadata Metadata that describes the seller.
type SellingPartnerMetadata struct {
	// AccountType The type of account in the transaction.
	AccountType *string `json:"accountType,omitempty"`

	// MarketplaceId The identifier of the marketplace where the transaction occurred.
	MarketplaceId *string `json:"marketplaceId,omitempty"`

	// SellingPartnerId A unique seller identifier.
	SellingPartnerId *string `json:"sellingPartnerId,omitempty"`
}

// TimeRangeContext Additional information that is related to the time range of the transaction.
type TimeRangeContext struct {
	// EndTime A date in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	EndTime *Date `json:"endTime,omitempty"`

	// StartTime A date in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	StartTime *Date `json:"startTime,omitempty"`
}

// Transaction All the information related to a transaction.
type Transaction struct {
	// Breakdowns A list of breakdowns that provide details on how the total amount is calculated for the transaction.
	Breakdowns *Breakdowns `json:"breakdowns,omitempty"`

	// Contexts A list of additional information about the item.
	Contexts *Contexts `json:"contexts,omitempty"`

	// Description Describes the reasons for the transaction.
	//
	// **Example:** 'Order Payment', 'Refund Order'
	Description *string `json:"description,omitempty"`

	// Items A list of items in the transaction.
	Items *Items `json:"items,omitempty"`

	// MarketplaceDetails Information about the marketplace where the transaction occurred.
	MarketplaceDetails *MarketplaceDetails `json:"marketplaceDetails,omitempty"`

	// PostedDate A date in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	PostedDate *Date `json:"postedDate,omitempty"`

	// RelatedIdentifiers Related business identifiers of the transaction.
	RelatedIdentifiers *RelatedIdentifiers `json:"relatedIdentifiers,omitempty"`

	// SellingPartnerMetadata Metadata that describes the seller.
	SellingPartnerMetadata *SellingPartnerMetadata `json:"sellingPartnerMetadata,omitempty"`

	// TotalAmount A currency type and amount.
	TotalAmount *Currency `json:"totalAmount,omitempty"`

	// TransactionId The unique identifier of the transaction.
	TransactionId *string `json:"transactionId,omitempty"`

	// TransactionStatus The status of the transaction.
	//
	// **Possible values:**
	//
	// * `Deferred`
	// * `Released`
	TransactionStatus *string `json:"transactionStatus,omitempty"`

	// TransactionType The type of transaction.
	//
	// **Possible value:** `Shipment`
	TransactionType *string `json:"transactionType,omitempty"`
}

// Transactions A list of transactions within the specified time period.
type Transactions = []Transaction

// ListTransactionsParams defines parameters for ListTransactions.
type ListTransactionsParams struct {
	// PostedAfter The response includes financial events posted after (or on) this date. This date must be in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format. The date-time must be more than two minutes before the time of the request.
	PostedAfter time.Time `form:"postedAfter" json:"postedAfter"`

	// PostedBefore The response includes financial events posted before (but not on) this date. This date must be in [ISO 8601](https://developer-docs.amazon.com/sp-api/docs/iso-8601) date-time format.
	//
	// The date-time must be later than `PostedAfter` and more than two minutes before the request was submitted. If `PostedAfter` and `PostedBefore` are more than 180 days apart, the response is empty.
	//
	// **Default:** Two minutes before the time of the request.
	PostedBefore *time.Time `form:"postedBefore,omitempty" json:"postedBefore,omitempty"`

	// MarketplaceId The ID of the marketplace from which you want to retrieve transactions.
	MarketplaceId *string `form:"marketplaceId,omitempty" json:"marketplaceId,omitempty"`

	// NextToken The response includes `nextToken` when the number of results exceeds the specified `pageSize` value. To get the next page of results, call the operation with this token and include the same arguments as the call that produced the token. To get a complete list, call this operation until `nextToken` is null. Note that this operation can return empty pages.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListTransactions request
	ListTransactions(ctx context.Context, params *ListTransactionsParams) (*http.Response, error)
}

func (c *Client) ListTransactions(ctx context.Context, params *ListTransactionsParams) (*http.Response, error) {
	req, err := NewListTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewListTransactionsRequest generates requests for ListTransactions
func NewListTransactionsRequest(server string, params *ListTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/2024-06-19/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "postedAfter", runtime.ParamLocationQuery, params.PostedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.PostedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "postedBefore", runtime.ParamLocationQuery, *params.PostedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.MarketplaceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, *params.MarketplaceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListTransactionsWithResponse request
	ListTransactionsWithResponse(ctx context.Context, params *ListTransactionsParams) (*ListTransactionsResp, error)
}

type ListTransactionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTransactionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListTransactionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListTransactionsWithResponse request returning *ListTransactionsResp
func (c *ClientWithResponses) ListTransactionsWithResponse(ctx context.Context, params *ListTransactionsParams) (*ListTransactionsResp, error) {
	rsp, err := c.ListTransactions(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionsResp(rsp)
}

// ParseListTransactionsResp parses an HTTP response from a ListTransactionsWithResponse call
func ParseListTransactionsResp(rsp *http.Response) (*ListTransactionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
