// Package financesv20240619 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package financesv20240619

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for ItemRelatedIdentifierItemRelatedIdentifierName.
const (
	COUPONID              ItemRelatedIdentifierItemRelatedIdentifierName = "COUPON_ID"
	ORDERADJUSTMENTITEMID ItemRelatedIdentifierItemRelatedIdentifierName = "ORDER_ADJUSTMENT_ITEM_ID"
	REMOVALSHIPMENTITEMID ItemRelatedIdentifierItemRelatedIdentifierName = "REMOVAL_SHIPMENT_ITEM_ID"
	TRANSACTIONID         ItemRelatedIdentifierItemRelatedIdentifierName = "TRANSACTION_ID"
)

// Defines values for RelatedIdentifierRelatedIdentifierName.
const (
	DEFERREDTRANSACTIONID RelatedIdentifierRelatedIdentifierName = "DEFERRED_TRANSACTION_ID"
	DISBURSEMENTID        RelatedIdentifierRelatedIdentifierName = "DISBURSEMENT_ID"
	EVENTGROUPID          RelatedIdentifierRelatedIdentifierName = "EVENT_GROUP_ID"
	INVOICEID             RelatedIdentifierRelatedIdentifierName = "INVOICE_ID"
	ORDERID               RelatedIdentifierRelatedIdentifierName = "ORDER_ID"
	REFUNDID              RelatedIdentifierRelatedIdentifierName = "REFUND_ID"
	RELEASETRANSACTIONID  RelatedIdentifierRelatedIdentifierName = "RELEASE_TRANSACTION_ID"
	SHIPMENTID            RelatedIdentifierRelatedIdentifierName = "SHIPMENT_ID"
	TRANSFERID            RelatedIdentifierRelatedIdentifierName = "TRANSFER_ID"
)

// AmazonPayContext Additional information related to Amazon Pay.
type AmazonPayContext struct {
	// Channel Channel details of related transaction.
	Channel *string `json:"channel,omitempty"`

	// OrderType Order type of the transaction.
	OrderType *string `json:"orderType,omitempty"`

	// StoreName Store name related to transaction.
	StoreName *string `json:"storeName,omitempty"`
}

// BigDecimal Fields with a schema type of BigDecimal are a signed decimal number (for example CurrencyAmount).
type BigDecimal = float32

// Breakdown Breakdown provides details regarding the money movement under the financial transaction. Breakdowns get categorized further into breakdown types, breakdown amounts, and further breakdowns into a hierarchical structure.
type Breakdown struct {
	// BreakdownAmount A currency type and amount.
	BreakdownAmount *Currency `json:"breakdownAmount,omitempty"`

	// BreakdownType The type of charge.
	BreakdownType *string `json:"breakdownType,omitempty"`

	// Breakdowns Breakdown provides details regarding the money movement under the financial transaction. Breakdowns get categorized further into breakdown types, breakdown amounts, and further breakdowns into a hierarchical structure.
	Breakdowns *Breakdown `json:"breakdowns,omitempty"`
}

// Breakdowns List of breakdowns which will provide the details on how the total amount is calculated for the financial transaction.
type Breakdowns = []Breakdown

// Context defines model for Context.
type Context struct {
	// Asin Amazon Standard Identification Number (ASIN) of the item.
	Asin *string `json:"asin,omitempty"`

	// Channel Channel details of related transaction.
	Channel     *string `json:"channel,omitempty"`
	ContextType string  `json:"contextType"`

	// DeferralReason The deferral policy applied to the transaction.
	//
	// **Examples:** `B2B` (invoiced orders), `DD7` (delivery date policy)
	DeferralReason *string `json:"deferralReason,omitempty"`

	// EndTime Fields with a schema type of date are in ISO 8601 date time format (for example GroupBeginDate).
	EndTime *Date `json:"endTime,omitempty"`

	// FulfillmentNetwork Fulfillment network of the item.
	FulfillmentNetwork *string `json:"fulfillmentNetwork,omitempty"`

	// MaturityDate Fields with a schema type of date are in ISO 8601 date time format (for example GroupBeginDate).
	MaturityDate *Date `json:"maturityDate,omitempty"`

	// OrderType Order type of the transaction.
	OrderType *string `json:"orderType,omitempty"`

	// PaymentDate Fields with a schema type of date are in ISO 8601 date time format (for example GroupBeginDate).
	PaymentDate *Date `json:"paymentDate,omitempty"`

	// PaymentMethod Method of payment made.
	PaymentMethod *string `json:"paymentMethod,omitempty"`

	// PaymentReference Reference number of payment made.
	PaymentReference *string `json:"paymentReference,omitempty"`

	// PaymentType Type of payment made.
	PaymentType *string `json:"paymentType,omitempty"`

	// QuantityShipped Quantity of the item shipped.
	QuantityShipped *int32 `json:"quantityShipped,omitempty"`

	// Sku Stock keeping unit (SKU) of the item.
	Sku *string `json:"sku,omitempty"`

	// StartTime Fields with a schema type of date are in ISO 8601 date time format (for example GroupBeginDate).
	StartTime *Date `json:"startTime,omitempty"`

	// StoreName Store name related to transaction.
	StoreName *string `json:"storeName,omitempty"`
}

// Contexts List of additional Information about the item.
type Contexts = []Context

// Currency A currency type and amount.
type Currency struct {
	// CurrencyAmount Fields with a schema type of BigDecimal are a signed decimal number (for example CurrencyAmount).
	CurrencyAmount *BigDecimal `json:"currencyAmount,omitempty"`

	// CurrencyCode The three-digit currency code in ISO 4217 format.
	CurrencyCode *string `json:"currencyCode,omitempty"`
}

// Date Fields with a schema type of date are in ISO 8601 date time format (for example GroupBeginDate).
type Date = string

// DeferredContext Additional information related to Deferred transactions.
type DeferredContext struct {
	// DeferralReason The deferral policy applied to the transaction.
	//
	// **Examples:** `B2B` (invoiced orders), `DD7` (delivery date policy)
	DeferralReason *string `json:"deferralReason,omitempty"`

	// MaturityDate Fields with a schema type of date are in ISO 8601 date time format (for example GroupBeginDate).
	MaturityDate *Date `json:"maturityDate,omitempty"`
}

// Error Error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	// Errors Error response returned when the request is unsuccessful.
	Errors []Error `json:"errors"`
}

// Item Additional information about the items in Transaction.
type Item struct {
	// Breakdowns List of breakdowns which will provide the details on how the total amount is calculated for the financial transaction.
	Breakdowns *Breakdowns `json:"breakdowns,omitempty"`

	// Contexts List of additional Information about the item.
	Contexts *Contexts `json:"contexts,omitempty"`

	// Description Description of items in the transaction
	Description *string `json:"description,omitempty"`

	// RelatedIdentifiers Related Business identifiers of the item in Transaction.
	RelatedIdentifiers *ItemRelatedIdentifiers `json:"relatedIdentifiers,omitempty"`

	// TotalAmount A currency type and amount.
	TotalAmount *Currency `json:"totalAmount,omitempty"`
}

// ItemRelatedIdentifier Related business identifiers of the item.
type ItemRelatedIdentifier struct {
	// ItemRelatedIdentifierName Enumerated set of related item identifier names for the item.
	ItemRelatedIdentifierName *ItemRelatedIdentifierItemRelatedIdentifierName `json:"itemRelatedIdentifierName,omitempty"`

	// ItemRelatedIdentifierValue Corresponding value of ItemRelatedIdentifierName
	ItemRelatedIdentifierValue *string `json:"itemRelatedIdentifierValue,omitempty"`
}

// ItemRelatedIdentifierItemRelatedIdentifierName Enumerated set of related item identifier names for the item.
type ItemRelatedIdentifierItemRelatedIdentifierName string

// ItemRelatedIdentifiers Related Business identifiers of the item in Transaction.
type ItemRelatedIdentifiers = []ItemRelatedIdentifier

// Items List of items in the transaction
type Items = []Item

// ListTransactionsResponse The Response schema.
type ListTransactionsResponse struct {
	// NextToken When present and not empty, pass this string token in the next request to return the next response page.
	NextToken *string `json:"nextToken,omitempty"`

	// Transactions Contains transactions within a given time period.
	Transactions *Transactions `json:"transactions,omitempty"`
}

// MarketplaceDetails Information about the marketplace where the transaction occurred.
type MarketplaceDetails struct {
	// MarketplaceId The identifier of the marketplace where the transaction was made.
	MarketplaceId *string `json:"marketplaceId,omitempty"`

	// MarketplaceName The name of the marketplace where the transaction occurred.
	//
	// Example: 'Amazon.com','Amazon.in'
	MarketplaceName *string `json:"marketplaceName,omitempty"`
}

// PaymentsContext Additional information related to Payments related transactions.
type PaymentsContext struct {
	// PaymentDate Fields with a schema type of date are in ISO 8601 date time format (for example GroupBeginDate).
	PaymentDate *Date `json:"paymentDate,omitempty"`

	// PaymentMethod Method of payment made.
	PaymentMethod *string `json:"paymentMethod,omitempty"`

	// PaymentReference Reference number of payment made.
	PaymentReference *string `json:"paymentReference,omitempty"`

	// PaymentType Type of payment made.
	PaymentType *string `json:"paymentType,omitempty"`
}

// ProductContext Additional information related to the product.
type ProductContext struct {
	// Asin Amazon Standard Identification Number (ASIN) of the item.
	Asin *string `json:"asin,omitempty"`

	// FulfillmentNetwork Fulfillment network of the item.
	FulfillmentNetwork *string `json:"fulfillmentNetwork,omitempty"`

	// QuantityShipped Quantity of the item shipped.
	QuantityShipped *int32 `json:"quantityShipped,omitempty"`

	// Sku Stock keeping unit (SKU) of the item.
	Sku *string `json:"sku,omitempty"`
}

// RelatedIdentifier Related business identifier of the transaction.
type RelatedIdentifier struct {
	// RelatedIdentifierName Enumerated set of related business identifier names.
	RelatedIdentifierName *RelatedIdentifierRelatedIdentifierName `json:"relatedIdentifierName,omitempty"`

	// RelatedIdentifierValue Corresponding value of RelatedIdentifierName
	RelatedIdentifierValue *string `json:"relatedIdentifierValue,omitempty"`
}

// RelatedIdentifierRelatedIdentifierName Enumerated set of related business identifier names.
type RelatedIdentifierRelatedIdentifierName string

// RelatedIdentifiers Related business identifiers of the transaction.
type RelatedIdentifiers = []RelatedIdentifier

// SellingPartnerMetadata Metadata describing the seller.
type SellingPartnerMetadata struct {
	// AccountType Account type of transaction.
	AccountType *string `json:"accountType,omitempty"`

	// MarketplaceId Marketplace identifier of transaction.
	MarketplaceId *string `json:"marketplaceId,omitempty"`

	// SellingPartnerId Unique seller identifier.
	SellingPartnerId *string `json:"sellingPartnerId,omitempty"`
}

// TimeRangeContext Additional information related to time range for transaction.
type TimeRangeContext struct {
	// EndTime Fields with a schema type of date are in ISO 8601 date time format (for example GroupBeginDate).
	EndTime *Date `json:"endTime,omitempty"`

	// StartTime Fields with a schema type of date are in ISO 8601 date time format (for example GroupBeginDate).
	StartTime *Date `json:"startTime,omitempty"`
}

// Transaction Contains all information related to the transaction.
type Transaction struct {
	// Breakdowns List of breakdowns which will provide the details on how the total amount is calculated for the financial transaction.
	Breakdowns *Breakdowns `json:"breakdowns,omitempty"`

	// Contexts List of additional Information about the item.
	Contexts *Contexts `json:"contexts,omitempty"`

	// Description Describes the reasons for the transaction.
	//
	// Example: 'Order Payment','Refund Order'
	Description *string `json:"description,omitempty"`

	// Items List of items in the transaction
	Items *Items `json:"items,omitempty"`

	// MarketplaceDetails Information about the marketplace where the transaction occurred.
	MarketplaceDetails *MarketplaceDetails `json:"marketplaceDetails,omitempty"`

	// PostedDate Fields with a schema type of date are in ISO 8601 date time format (for example GroupBeginDate).
	PostedDate *Date `json:"postedDate,omitempty"`

	// RelatedIdentifiers Related business identifiers of the transaction.
	RelatedIdentifiers *RelatedIdentifiers `json:"relatedIdentifiers,omitempty"`

	// SellingPartnerMetadata Metadata describing the seller.
	SellingPartnerMetadata *SellingPartnerMetadata `json:"sellingPartnerMetadata,omitempty"`

	// TotalAmount A currency type and amount.
	TotalAmount *Currency `json:"totalAmount,omitempty"`

	// TransactionId The unique identifier for the transaction.
	TransactionId *string `json:"transactionId,omitempty"`

	// TransactionStatus The status of the transaction.
	//
	// **Possible values:**
	//
	// * `DEFERRED`: the transaction is currently deferred.
	// * `RELEASED`: the transaction is currently released.
	// * `DEFERRED_RELEASED`: the transaction was deferred in the past, but is now released. Deferred transactions will have their status updated to `DEFERRED_RELEASED` when released.
	TransactionStatus *string `json:"transactionStatus,omitempty"`

	// TransactionType The type of transaction.
	//
	// Possible values:
	//
	// * Shipment
	TransactionType *string `json:"transactionType,omitempty"`
}

// Transactions Contains transactions within a given time period.
type Transactions = []Transaction

// ListTransactionsParams defines parameters for ListTransactions.
type ListTransactionsParams struct {
	// PostedAfter A date used for selecting transactions posted after (or at) a specified time. The date-time must be no later than two minutes before the request was submitted, in ISO 8601 date time format.
	PostedAfter time.Time `form:"postedAfter" json:"postedAfter"`

	// PostedBefore A date used for selecting transactions posted before (but not at) a specified time. The date-time must be later than PostedAfter and no later than two minutes before the request was submitted, in ISO 8601 date time format. If PostedAfter and PostedBefore are more than 180 days apart, no transactions are returned. You must specify the PostedAfter parameter if you specify the PostedBefore parameter. Default: Now minus two minutes.
	PostedBefore *time.Time `form:"postedBefore,omitempty" json:"postedBefore,omitempty"`

	// MarketplaceId A string token used to select Marketplace ID.
	MarketplaceId *string `form:"marketplaceId,omitempty" json:"marketplaceId,omitempty"`

	// NextToken A string token returned in the response of your previous request.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListTransactions request
	ListTransactions(ctx context.Context, params *ListTransactionsParams) (*http.Response, error)
}

func (c *Client) ListTransactions(ctx context.Context, params *ListTransactionsParams) (*http.Response, error) {
	req, err := NewListTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewListTransactionsRequest generates requests for ListTransactions
func NewListTransactionsRequest(server string, params *ListTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/finances/2024-06-19/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "postedAfter", runtime.ParamLocationQuery, params.PostedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.PostedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "postedBefore", runtime.ParamLocationQuery, *params.PostedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.MarketplaceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, *params.MarketplaceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListTransactionsWithResponse request
	ListTransactionsWithResponse(ctx context.Context, params *ListTransactionsParams) (*ListTransactionsResp, error)
}

type ListTransactionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTransactionsResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ListTransactionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListTransactionsWithResponse request returning *ListTransactionsResp
func (c *ClientWithResponses) ListTransactionsWithResponse(ctx context.Context, params *ListTransactionsParams) (*ListTransactionsResp, error) {
	rsp, err := c.ListTransactions(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionsResp(rsp)
}

// ParseListTransactionsResp parses an HTTP response from a ListTransactionsWithResponse call
func ParseListTransactionsResp(rsp *http.Response) (*ListTransactionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
