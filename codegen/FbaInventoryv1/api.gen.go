// Package fbainventoryv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package fbainventoryv1

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for ResearchingQuantityEntryName.
const (
	ResearchingQuantityInLongTerm  ResearchingQuantityEntryName = "researchingQuantityInLongTerm"
	ResearchingQuantityInMidTerm   ResearchingQuantityEntryName = "researchingQuantityInMidTerm"
	ResearchingQuantityInShortTerm ResearchingQuantityEntryName = "researchingQuantityInShortTerm"
)

// Defines values for GetInventorySummariesParamsGranularityType.
const (
	Marketplace GetInventorySummariesParamsGranularityType = "Marketplace"
)

// AddInventoryRequest The object with the list of Inventory to be added
type AddInventoryRequest struct {
	// InventoryItems List of Inventory to be added
	InventoryItems *InventoryItems `json:"inventoryItems,omitempty"`
}

// AddInventoryResponse The response schema for the AddInventory operation.
type AddInventoryResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// CreateInventoryItemRequest An item to be created in the inventory.
type CreateInventoryItemRequest struct {
	// MarketplaceId The marketplaceId.
	MarketplaceId string `json:"marketplaceId"`

	// ProductName The name of the item.
	ProductName string `json:"productName"`

	// SellerSku The seller SKU of the item.
	SellerSku string `json:"sellerSku"`
}

// CreateInventoryItemResponse The response schema for the CreateInventoryItem operation.
type CreateInventoryItemResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// DeleteInventoryItemResponse The response schema for the DeleteInventoryItem operation.
type DeleteInventoryItemResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`
}

// Error An error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional information that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition in a human-readable form.
	Message *string `json:"message,omitempty"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// GetInventorySummariesResponse The Response schema.
type GetInventorySummariesResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Pagination The process of returning the results to a request in batches of a defined size called pages. This is done to exercise some control over result size and overall throughput. It's a form of traffic management.
	Pagination *Pagination `json:"pagination,omitempty"`

	// Payload The payload schema for the getInventorySummaries operation.
	Payload *GetInventorySummariesResult `json:"payload,omitempty"`
}

// GetInventorySummariesResult The payload schema for the getInventorySummaries operation.
type GetInventorySummariesResult struct {
	// Granularity Describes a granularity at which inventory data can be aggregated. For example, if you use Marketplace granularity, the fulfillable quantity will reflect inventory that could be fulfilled in the given marketplace.
	Granularity Granularity `json:"granularity"`

	// InventorySummaries A list of inventory summaries.
	InventorySummaries InventorySummaries `json:"inventorySummaries"`
}

// Granularity Describes a granularity at which inventory data can be aggregated. For example, if you use Marketplace granularity, the fulfillable quantity will reflect inventory that could be fulfilled in the given marketplace.
type Granularity struct {
	// GranularityId The granularity ID for the specified granularity type. When granularityType is Marketplace, specify the marketplaceId.
	GranularityId *string `json:"granularityId,omitempty"`

	// GranularityType The granularity type for the inventory aggregation level.
	GranularityType *string `json:"granularityType,omitempty"`
}

// InventoryDetails Summarized inventory details. This object will not appear if the details parameter in the request is false.
type InventoryDetails struct {
	// FulfillableQuantity The item quantity that can be picked, packed, and shipped.
	FulfillableQuantity *int `json:"fulfillableQuantity,omitempty"`

	// InboundReceivingQuantity The number of units that have not yet been received at an Amazon fulfillment center for processing, but are part of an inbound shipment with some units that have already been received and processed.
	InboundReceivingQuantity *int `json:"inboundReceivingQuantity,omitempty"`

	// InboundShippedQuantity The number of units in an inbound shipment that you have notified Amazon about and have provided a tracking number.
	InboundShippedQuantity *int `json:"inboundShippedQuantity,omitempty"`

	// InboundWorkingQuantity The number of units in an inbound shipment for which you have notified Amazon.
	InboundWorkingQuantity *int `json:"inboundWorkingQuantity,omitempty"`

	// ResearchingQuantity The number of misplaced or warehouse damaged units that are actively being confirmed at our fulfillment centers.
	ResearchingQuantity *ResearchingQuantity `json:"researchingQuantity,omitempty"`

	// ReservedQuantity The quantity of reserved inventory.
	ReservedQuantity *ReservedQuantity `json:"reservedQuantity,omitempty"`

	// UnfulfillableQuantity The quantity of unfulfillable inventory.
	UnfulfillableQuantity *UnfulfillableQuantity `json:"unfulfillableQuantity,omitempty"`
}

// InventoryItem An item in the list of inventory to be added.
type InventoryItem struct {
	// MarketplaceId The marketplaceId.
	MarketplaceId string `json:"marketplaceId"`

	// Quantity The quantity of item to add.
	Quantity int `json:"quantity"`

	// SellerSku The seller SKU of the item.
	SellerSku string `json:"sellerSku"`
}

// InventoryItems List of Inventory to be added
type InventoryItems = []InventoryItem

// InventorySummaries A list of inventory summaries.
type InventorySummaries = []InventorySummary

// InventorySummary Inventory summary for a specific item.
type InventorySummary struct {
	// Asin The Amazon Standard Identification Number (ASIN) of an item.
	Asin *string `json:"asin,omitempty"`

	// Condition The condition of the item as described by the seller (for example, New Item).
	Condition *string `json:"condition,omitempty"`

	// FnSku Amazon's fulfillment network SKU identifier.
	FnSku *string `json:"fnSku,omitempty"`

	// InventoryDetails Summarized inventory details. This object will not appear if the details parameter in the request is false.
	InventoryDetails *InventoryDetails `json:"inventoryDetails,omitempty"`

	// LastUpdatedTime The date and time that any quantity was last updated.
	LastUpdatedTime *time.Time `json:"lastUpdatedTime,omitempty"`

	// ProductName The localized language product title of the item within the specific marketplace.
	ProductName *string `json:"productName,omitempty"`

	// SellerSku The seller SKU of the item.
	SellerSku *string `json:"sellerSku,omitempty"`

	// Stores A list of seller-enrolled stores that apply to this seller SKU.
	Stores *[]string `json:"stores,omitempty"`

	// TotalQuantity The total number of units in an inbound shipment or in Amazon fulfillment centers.
	TotalQuantity *int `json:"totalQuantity,omitempty"`
}

// Pagination The process of returning the results to a request in batches of a defined size called pages. This is done to exercise some control over result size and overall throughput. It's a form of traffic management.
type Pagination struct {
	// NextToken A generated string used to retrieve the next page of the result. If nextToken is returned, pass the value of nextToken to the next request. If nextToken is not returned, there are no more items to return.
	NextToken *string `json:"nextToken,omitempty"`
}

// ResearchingQuantity The number of misplaced or warehouse damaged units that are actively being confirmed at our fulfillment centers.
type ResearchingQuantity struct {
	// ResearchingQuantityBreakdown A list of quantity details for items currently being researched.
	ResearchingQuantityBreakdown *[]ResearchingQuantityEntry `json:"researchingQuantityBreakdown,omitempty"`

	// TotalResearchingQuantity The total number of units currently being researched in Amazon's fulfillment network.
	TotalResearchingQuantity *int `json:"totalResearchingQuantity,omitempty"`
}

// ResearchingQuantityEntry The misplaced or warehouse damaged inventory that is actively being confirmed at our fulfillment centers.
type ResearchingQuantityEntry struct {
	// Name The duration of the research.
	Name ResearchingQuantityEntryName `json:"name"`

	// Quantity The number of units.
	Quantity int `json:"quantity"`
}

// ResearchingQuantityEntryName The duration of the research.
type ResearchingQuantityEntryName string

// ReservedQuantity The quantity of reserved inventory.
type ReservedQuantity struct {
	// FcProcessingQuantity The number of units that have been sidelined at the fulfillment center for additional processing.
	FcProcessingQuantity *int `json:"fcProcessingQuantity,omitempty"`

	// PendingCustomerOrderQuantity The number of units reserved for customer orders.
	PendingCustomerOrderQuantity *int `json:"pendingCustomerOrderQuantity,omitempty"`

	// PendingTransshipmentQuantity The number of units being transferred from one fulfillment center to another.
	PendingTransshipmentQuantity *int `json:"pendingTransshipmentQuantity,omitempty"`

	// TotalReservedQuantity The total number of units in Amazon's fulfillment network that are currently being picked, packed, and shipped; or are sidelined for measurement, sampling, or other internal processes.
	TotalReservedQuantity *int `json:"totalReservedQuantity,omitempty"`
}

// UnfulfillableQuantity The quantity of unfulfillable inventory.
type UnfulfillableQuantity struct {
	// CarrierDamagedQuantity The number of units in carrier damaged disposition.
	CarrierDamagedQuantity *int `json:"carrierDamagedQuantity,omitempty"`

	// CustomerDamagedQuantity The number of units in customer damaged disposition.
	CustomerDamagedQuantity *int `json:"customerDamagedQuantity,omitempty"`

	// DefectiveQuantity The number of units in defective disposition.
	DefectiveQuantity *int `json:"defectiveQuantity,omitempty"`

	// DistributorDamagedQuantity The number of units in distributor damaged disposition.
	DistributorDamagedQuantity *int `json:"distributorDamagedQuantity,omitempty"`

	// ExpiredQuantity The number of units in expired disposition.
	ExpiredQuantity *int `json:"expiredQuantity,omitempty"`

	// TotalUnfulfillableQuantity The total number of units in Amazon's fulfillment network in unsellable condition.
	TotalUnfulfillableQuantity *int `json:"totalUnfulfillableQuantity,omitempty"`

	// WarehouseDamagedQuantity The number of units in warehouse damaged disposition.
	WarehouseDamagedQuantity *int `json:"warehouseDamagedQuantity,omitempty"`
}

// AddInventoryParams defines parameters for AddInventory.
type AddInventoryParams struct {
	// XAmznIdempotencyToken A unique token/requestId provided with each call to ensure idempotency.
	XAmznIdempotencyToken string `json:"x-amzn-idempotency-token"`
}

// DeleteInventoryItemParams defines parameters for DeleteInventoryItem.
type DeleteInventoryItemParams struct {
	// MarketplaceId The marketplace ID for the marketplace for which the sellerSku is to be deleted.
	MarketplaceId string `form:"marketplaceId" json:"marketplaceId"`
}

// GetInventorySummariesParams defines parameters for GetInventorySummaries.
type GetInventorySummariesParams struct {
	// Details true to return inventory summaries with additional summarized inventory details and quantities. Otherwise, returns inventory summaries only (default value).
	Details *bool `form:"details,omitempty" json:"details,omitempty"`

	// GranularityType The granularity type for the inventory aggregation level.
	GranularityType GetInventorySummariesParamsGranularityType `form:"granularityType" json:"granularityType"`

	// GranularityId The granularity ID for the inventory aggregation level.
	GranularityId string `form:"granularityId" json:"granularityId"`

	// StartDateTime A start date and time in ISO8601 format. If specified, all inventory summaries that have changed since then are returned. You must specify a date and time that is no earlier than 18 months prior to the date and time when you call the API. Note: Changes in inboundWorkingQuantity, inboundShippedQuantity and inboundReceivingQuantity are not detected.
	StartDateTime *time.Time `form:"startDateTime,omitempty" json:"startDateTime,omitempty"`

	// SellerSkus A list of seller SKUs for which to return inventory summaries. You may specify up to 50 SKUs.
	SellerSkus *[]string `form:"sellerSkus,omitempty" json:"sellerSkus,omitempty"`

	// SellerSku A single seller SKU used for querying the specified seller SKU inventory summaries.
	SellerSku *string `form:"sellerSku,omitempty" json:"sellerSku,omitempty"`

	// NextToken String token returned in the response of your previous request. The string token will expire 30 seconds after being created.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// MarketplaceIds The marketplace ID for the marketplace for which to return inventory summaries.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`
}

// GetInventorySummariesParamsGranularityType defines parameters for GetInventorySummaries.
type GetInventorySummariesParamsGranularityType string

// CreateInventoryItemJSONRequestBody defines body for CreateInventoryItem for application/json ContentType.
type CreateInventoryItemJSONRequestBody = CreateInventoryItemRequest

// AddInventoryJSONRequestBody defines body for AddInventory for application/json ContentType.
type AddInventoryJSONRequestBody = AddInventoryRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateInventoryItemWithBody request with any body
	CreateInventoryItemWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateInventoryItem(ctx context.Context, body CreateInventoryItemJSONRequestBody) (*http.Response, error)

	// AddInventoryWithBody request with any body
	AddInventoryWithBody(ctx context.Context, params *AddInventoryParams, contentType string, body io.Reader) (*http.Response, error)

	AddInventory(ctx context.Context, params *AddInventoryParams, body AddInventoryJSONRequestBody) (*http.Response, error)

	// DeleteInventoryItem request
	DeleteInventoryItem(ctx context.Context, sellerSku string, params *DeleteInventoryItemParams) (*http.Response, error)

	// GetInventorySummaries request
	GetInventorySummaries(ctx context.Context, params *GetInventorySummariesParams) (*http.Response, error)
}

func (c *Client) CreateInventoryItemWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateInventoryItemRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateInventoryItem(ctx context.Context, body CreateInventoryItemJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateInventoryItemRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) AddInventoryWithBody(ctx context.Context, params *AddInventoryParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAddInventoryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) AddInventory(ctx context.Context, params *AddInventoryParams, body AddInventoryJSONRequestBody) (*http.Response, error) {
	req, err := NewAddInventoryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) DeleteInventoryItem(ctx context.Context, sellerSku string, params *DeleteInventoryItemParams) (*http.Response, error) {
	req, err := NewDeleteInventoryItemRequest(c.Server, sellerSku, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInventorySummaries(ctx context.Context, params *GetInventorySummariesParams) (*http.Response, error) {
	req, err := NewGetInventorySummariesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewCreateInventoryItemRequest calls the generic CreateInventoryItem builder with application/json body
func NewCreateInventoryItemRequest(server string, body CreateInventoryItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInventoryItemRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateInventoryItemRequestWithBody generates requests for CreateInventoryItem with any type of body
func NewCreateInventoryItemRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inventory/v1/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddInventoryRequest calls the generic AddInventory builder with application/json body
func NewAddInventoryRequest(server string, params *AddInventoryParams, body AddInventoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddInventoryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddInventoryRequestWithBody generates requests for AddInventory with any type of body
func NewAddInventoryRequestWithBody(server string, params *AddInventoryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inventory/v1/items/inventory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-amzn-idempotency-token", runtime.ParamLocationHeader, params.XAmznIdempotencyToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-amzn-idempotency-token", headerParam0)

	}

	return req, nil
}

// NewDeleteInventoryItemRequest generates requests for DeleteInventoryItem
func NewDeleteInventoryItemRequest(server string, sellerSku string, params *DeleteInventoryItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sellerSku", runtime.ParamLocationPath, sellerSku)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inventory/v1/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceId", runtime.ParamLocationQuery, params.MarketplaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInventorySummariesRequest generates requests for GetInventorySummaries
func NewGetInventorySummariesRequest(server string, params *GetInventorySummariesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inventory/v1/summaries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Details != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "details", runtime.ParamLocationQuery, *params.Details); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularityType", runtime.ParamLocationQuery, params.GranularityType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularityId", runtime.ParamLocationQuery, params.GranularityId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.StartDateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDateTime", runtime.ParamLocationQuery, *params.StartDateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SellerSkus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sellerSkus", runtime.ParamLocationQuery, *params.SellerSkus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SellerSku != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sellerSku", runtime.ParamLocationQuery, *params.SellerSku); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, len(v))
				copy(values, v)
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateInventoryItemWithBodyWithResponse request with any body
	CreateInventoryItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateInventoryItemResp, error)

	CreateInventoryItemWithResponse(ctx context.Context, body CreateInventoryItemJSONRequestBody) (*CreateInventoryItemResp, error)

	// AddInventoryWithBodyWithResponse request with any body
	AddInventoryWithBodyWithResponse(ctx context.Context, params *AddInventoryParams, contentType string, body io.Reader) (*AddInventoryResp, error)

	AddInventoryWithResponse(ctx context.Context, params *AddInventoryParams, body AddInventoryJSONRequestBody) (*AddInventoryResp, error)

	// DeleteInventoryItemWithResponse request
	DeleteInventoryItemWithResponse(ctx context.Context, sellerSku string, params *DeleteInventoryItemParams) (*DeleteInventoryItemResp, error)

	// GetInventorySummariesWithResponse request
	GetInventorySummariesWithResponse(ctx context.Context, params *GetInventorySummariesParams) (*GetInventorySummariesResp, error)
}

type CreateInventoryItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateInventoryItemResponse
	JSON400      *CreateInventoryItemResponse
	JSON403      *CreateInventoryItemResponse
	JSON404      *CreateInventoryItemResponse
	JSON429      *CreateInventoryItemResponse
	JSON500      *CreateInventoryItemResponse
	JSON503      *CreateInventoryItemResponse
}

// Status returns HTTPResponse.Status
func (r CreateInventoryItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInventoryItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddInventoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddInventoryResponse
	JSON400      *AddInventoryResponse
	JSON403      *AddInventoryResponse
	JSON404      *AddInventoryResponse
	JSON429      *AddInventoryResponse
	JSON500      *AddInventoryResponse
	JSON503      *AddInventoryResponse
}

// Status returns HTTPResponse.Status
func (r AddInventoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddInventoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInventoryItemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteInventoryItemResponse
	JSON400      *DeleteInventoryItemResponse
	JSON403      *DeleteInventoryItemResponse
	JSON404      *DeleteInventoryItemResponse
	JSON429      *DeleteInventoryItemResponse
	JSON500      *DeleteInventoryItemResponse
	JSON503      *DeleteInventoryItemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteInventoryItemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInventoryItemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInventorySummariesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInventorySummariesResponse
	JSON400      *GetInventorySummariesResponse
	JSON403      *GetInventorySummariesResponse
	JSON404      *GetInventorySummariesResponse
	JSON429      *GetInventorySummariesResponse
	JSON500      *GetInventorySummariesResponse
	JSON503      *GetInventorySummariesResponse
}

// Status returns HTTPResponse.Status
func (r GetInventorySummariesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInventorySummariesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateInventoryItemWithBodyWithResponse request with arbitrary body returning *CreateInventoryItemResp
func (c *ClientWithResponses) CreateInventoryItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateInventoryItemResp, error) {
	rsp, err := c.CreateInventoryItemWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateInventoryItemResp(rsp)
}

func (c *ClientWithResponses) CreateInventoryItemWithResponse(ctx context.Context, body CreateInventoryItemJSONRequestBody) (*CreateInventoryItemResp, error) {
	rsp, err := c.CreateInventoryItem(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateInventoryItemResp(rsp)
}

// AddInventoryWithBodyWithResponse request with arbitrary body returning *AddInventoryResp
func (c *ClientWithResponses) AddInventoryWithBodyWithResponse(ctx context.Context, params *AddInventoryParams, contentType string, body io.Reader) (*AddInventoryResp, error) {
	rsp, err := c.AddInventoryWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAddInventoryResp(rsp)
}

func (c *ClientWithResponses) AddInventoryWithResponse(ctx context.Context, params *AddInventoryParams, body AddInventoryJSONRequestBody) (*AddInventoryResp, error) {
	rsp, err := c.AddInventory(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseAddInventoryResp(rsp)
}

// DeleteInventoryItemWithResponse request returning *DeleteInventoryItemResp
func (c *ClientWithResponses) DeleteInventoryItemWithResponse(ctx context.Context, sellerSku string, params *DeleteInventoryItemParams) (*DeleteInventoryItemResp, error) {
	rsp, err := c.DeleteInventoryItem(ctx, sellerSku, params)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInventoryItemResp(rsp)
}

// GetInventorySummariesWithResponse request returning *GetInventorySummariesResp
func (c *ClientWithResponses) GetInventorySummariesWithResponse(ctx context.Context, params *GetInventorySummariesParams) (*GetInventorySummariesResp, error) {
	rsp, err := c.GetInventorySummaries(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetInventorySummariesResp(rsp)
}

// ParseCreateInventoryItemResp parses an HTTP response from a CreateInventoryItemWithResponse call
func ParseCreateInventoryItemResp(rsp *http.Response) (*CreateInventoryItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInventoryItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreateInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreateInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreateInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest CreateInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CreateInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest CreateInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAddInventoryResp parses an HTTP response from a AddInventoryWithResponse call
func ParseAddInventoryResp(rsp *http.Response) (*AddInventoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddInventoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest AddInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AddInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AddInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest AddInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest AddInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest AddInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteInventoryItemResp parses an HTTP response from a DeleteInventoryItemWithResponse call
func ParseDeleteInventoryItemResp(rsp *http.Response) (*DeleteInventoryItemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInventoryItemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DeleteInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest DeleteInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DeleteInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest DeleteInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest DeleteInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest DeleteInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetInventorySummariesResp parses an HTTP response from a GetInventorySummariesWithResponse call
func ParseGetInventorySummariesResp(rsp *http.Response) (*GetInventorySummariesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInventorySummariesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
