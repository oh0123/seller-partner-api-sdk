// Package fbaInventoryv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.4 DO NOT EDIT.
package fbaInventoryv1

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for ResearchingQuantityEntryName.
const (
	ResearchingQuantityInLongTerm  ResearchingQuantityEntryName = "researchingQuantityInLongTerm"
	ResearchingQuantityInMidTerm   ResearchingQuantityEntryName = "researchingQuantityInMidTerm"
	ResearchingQuantityInShortTerm ResearchingQuantityEntryName = "researchingQuantityInShortTerm"
)

// Defines values for GetInventorySummariesParamsGranularityType.
const (
	Marketplace GetInventorySummariesParamsGranularityType = "Marketplace"
)

// Error An error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occurred.
	Code string `json:"code"`

	// Details Additional information that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition in a human-readable form.
	Message *string `json:"message,omitempty"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList = []Error

// GetInventorySummariesResponse The Response schema.
type GetInventorySummariesResponse struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors *ErrorList `json:"errors,omitempty"`

	// Pagination The process of returning the results to a request in batches of a defined size called pages. This is done to exercise some control over result size and overall throughput. It's a form of traffic management.
	Pagination *Pagination `json:"pagination,omitempty"`

	// Payload The payload schema for the getInventorySummaries operation.
	Payload *GetInventorySummariesResult `json:"payload,omitempty"`
}

// GetInventorySummariesResult The payload schema for the getInventorySummaries operation.
type GetInventorySummariesResult struct {
	// Granularity Describes a granularity at which inventory data can be aggregated. For example, if you use Marketplace granularity, the fulfillable quantity will reflect inventory that could be fulfilled in the given marketplace.
	Granularity Granularity `json:"granularity"`

	// InventorySummaries A list of inventory summaries.
	InventorySummaries InventorySummaries `json:"inventorySummaries"`
}

// Granularity Describes a granularity at which inventory data can be aggregated. For example, if you use Marketplace granularity, the fulfillable quantity will reflect inventory that could be fulfilled in the given marketplace.
type Granularity struct {
	// GranularityId The granularity ID for the specified granularity type. When granularityType is Marketplace, specify the marketplaceId.
	GranularityId *string `json:"granularityId,omitempty"`

	// GranularityType The granularity type for the inventory aggregation level.
	GranularityType *string `json:"granularityType,omitempty"`
}

// InventoryDetails Summarized inventory details. This object will not appear if the details parameter in the request is false.
type InventoryDetails struct {
	// FulfillableQuantity The item quantity that can be picked, packed, and shipped.
	FulfillableQuantity *int `json:"fulfillableQuantity,omitempty"`

	// InboundReceivingQuantity The number of units that have not yet been received at an Amazon fulfillment center for processing, but are part of an inbound shipment with some units that have already been received and processed.
	InboundReceivingQuantity *int `json:"inboundReceivingQuantity,omitempty"`

	// InboundShippedQuantity The number of units in an inbound shipment that you have notified Amazon about and have provided a tracking number.
	InboundShippedQuantity *int `json:"inboundShippedQuantity,omitempty"`

	// InboundWorkingQuantity The number of units in an inbound shipment for which you have notified Amazon.
	InboundWorkingQuantity *int `json:"inboundWorkingQuantity,omitempty"`

	// ResearchingQuantity The number of misplaced or warehouse damaged units that are actively being confirmed at our fulfillment centers.
	ResearchingQuantity *ResearchingQuantity `json:"researchingQuantity,omitempty"`

	// ReservedQuantity The quantity of reserved inventory.
	ReservedQuantity *ReservedQuantity `json:"reservedQuantity,omitempty"`

	// UnfulfillableQuantity The quantity of unfulfillable inventory.
	UnfulfillableQuantity *UnfulfillableQuantity `json:"unfulfillableQuantity,omitempty"`
}

// InventorySummaries A list of inventory summaries.
type InventorySummaries = []InventorySummary

// InventorySummary Inventory summary for a specific item.
type InventorySummary struct {
	// Asin The Amazon Standard Identification Number (ASIN) of an item.
	Asin *string `json:"asin,omitempty"`

	// Condition The condition of the item as described by the seller (for example, New Item).
	Condition *string `json:"condition,omitempty"`

	// FnSku Amazon's fulfillment network SKU identifier.
	FnSku *string `json:"fnSku,omitempty"`

	// InventoryDetails Summarized inventory details. This object will not appear if the details parameter in the request is false.
	InventoryDetails *InventoryDetails `json:"inventoryDetails,omitempty"`

	// LastUpdatedTime The date and time that any quantity was last updated.
	LastUpdatedTime *time.Time `json:"lastUpdatedTime,omitempty"`

	// ProductName The localized language product title of the item within the specific marketplace.
	ProductName *string `json:"productName,omitempty"`

	// SellerSku The seller SKU of the item.
	SellerSku *string `json:"sellerSku,omitempty"`

	// TotalQuantity The total number of units in an inbound shipment or in Amazon fulfillment centers.
	TotalQuantity *int `json:"totalQuantity,omitempty"`
}

// Pagination The process of returning the results to a request in batches of a defined size called pages. This is done to exercise some control over result size and overall throughput. It's a form of traffic management.
type Pagination struct {
	// NextToken A generated string used to retrieve the next page of the result. If nextToken is returned, pass the value of nextToken to the next request. If nextToken is not returned, there are no more items to return.
	NextToken *string `json:"nextToken,omitempty"`
}

// ResearchingQuantity The number of misplaced or warehouse damaged units that are actively being confirmed at our fulfillment centers.
type ResearchingQuantity struct {
	// ResearchingQuantityBreakdown A list of quantity details for items currently being researched.
	ResearchingQuantityBreakdown *[]ResearchingQuantityEntry `json:"researchingQuantityBreakdown,omitempty"`

	// TotalResearchingQuantity The total number of units currently being researched in Amazon's fulfillment network.
	TotalResearchingQuantity *int `json:"totalResearchingQuantity,omitempty"`
}

// ResearchingQuantityEntry The misplaced or warehouse damaged inventory that is actively being confirmed at our fulfillment centers.
type ResearchingQuantityEntry struct {
	// Name The duration of the research.
	Name ResearchingQuantityEntryName `json:"name"`

	// Quantity The number of units.
	Quantity int `json:"quantity"`
}

// ResearchingQuantityEntryName The duration of the research.
type ResearchingQuantityEntryName string

// ReservedQuantity The quantity of reserved inventory.
type ReservedQuantity struct {
	// FcProcessingQuantity The number of units that have been sidelined at the fulfillment center for additional processing.
	FcProcessingQuantity *int `json:"fcProcessingQuantity,omitempty"`

	// PendingCustomerOrderQuantity The number of units reserved for customer orders.
	PendingCustomerOrderQuantity *int `json:"pendingCustomerOrderQuantity,omitempty"`

	// PendingTransshipmentQuantity The number of units being transferred from one fulfillment center to another.
	PendingTransshipmentQuantity *int `json:"pendingTransshipmentQuantity,omitempty"`

	// TotalReservedQuantity The total number of units in Amazon's fulfillment network that are currently being picked, packed, and shipped; or are sidelined for measurement, sampling, or other internal processes.
	TotalReservedQuantity *int `json:"totalReservedQuantity,omitempty"`
}

// UnfulfillableQuantity The quantity of unfulfillable inventory.
type UnfulfillableQuantity struct {
	// CarrierDamagedQuantity The number of units in carrier damaged disposition.
	CarrierDamagedQuantity *int `json:"carrierDamagedQuantity,omitempty"`

	// CustomerDamagedQuantity The number of units in customer damaged disposition.
	CustomerDamagedQuantity *int `json:"customerDamagedQuantity,omitempty"`

	// DefectiveQuantity The number of units in defective disposition.
	DefectiveQuantity *int `json:"defectiveQuantity,omitempty"`

	// DistributorDamagedQuantity The number of units in distributor damaged disposition.
	DistributorDamagedQuantity *int `json:"distributorDamagedQuantity,omitempty"`

	// ExpiredQuantity The number of units in expired disposition.
	ExpiredQuantity *int `json:"expiredQuantity,omitempty"`

	// TotalUnfulfillableQuantity The total number of units in Amazon's fulfillment network in unsellable condition.
	TotalUnfulfillableQuantity *int `json:"totalUnfulfillableQuantity,omitempty"`

	// WarehouseDamagedQuantity The number of units in warehouse damaged disposition.
	WarehouseDamagedQuantity *int `json:"warehouseDamagedQuantity,omitempty"`
}

// GetInventorySummariesParams defines parameters for GetInventorySummaries.
type GetInventorySummariesParams struct {
	// Details true to return inventory summaries with additional summarized inventory details and quantities. Otherwise, returns inventory summaries only (default value).
	Details *bool `form:"details,omitempty" json:"details,omitempty"`

	// GranularityType The granularity type for the inventory aggregation level.
	GranularityType GetInventorySummariesParamsGranularityType `form:"granularityType" json:"granularityType"`

	// GranularityId The granularity ID for the inventory aggregation level.
	GranularityId string `form:"granularityId" json:"granularityId"`

	// StartDateTime A start date and time in ISO8601 format. If specified, all inventory summaries that have changed since then are returned. You must specify a date and time that is no earlier than 18 months prior to the date and time when you call the API. Note: Changes in inboundWorkingQuantity, inboundShippedQuantity and inboundReceivingQuantity are not detected.
	StartDateTime *time.Time `form:"startDateTime,omitempty" json:"startDateTime,omitempty"`

	// SellerSkus A list of seller SKUs for which to return inventory summaries. You may specify up to 50 SKUs.
	SellerSkus *[]string `form:"sellerSkus,omitempty" json:"sellerSkus,omitempty"`

	// SellerSku A single seller SKU used for querying the specified seller SKU inventory summaries.
	SellerSku *string `form:"sellerSku,omitempty" json:"sellerSku,omitempty"`

	// NextToken String token returned in the response of your previous request. The string token will expire 30 seconds after being created.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// MarketplaceIds The marketplace ID for the marketplace for which to return inventory summaries.
	MarketplaceIds []string `form:"marketplaceIds" json:"marketplaceIds"`
}

// GetInventorySummariesParamsGranularityType defines parameters for GetInventorySummaries.
type GetInventorySummariesParamsGranularityType string

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetInventorySummaries request
	GetInventorySummaries(ctx context.Context, params *GetInventorySummariesParams) (*http.Response, error)
}

func (c *Client) GetInventorySummaries(ctx context.Context, params *GetInventorySummariesParams) (*http.Response, error) {
	req, err := NewGetInventorySummariesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewGetInventorySummariesRequest generates requests for GetInventorySummaries
func NewGetInventorySummariesRequest(server string, params *GetInventorySummariesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fba/inventory/v1/summaries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Details != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "details", runtime.ParamLocationQuery, *params.Details); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularityType", runtime.ParamLocationQuery, params.GranularityType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularityId", runtime.ParamLocationQuery, params.GranularityId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.StartDateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDateTime", runtime.ParamLocationQuery, *params.StartDateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SellerSkus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sellerSkus", runtime.ParamLocationQuery, *params.SellerSkus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.SellerSku != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sellerSku", runtime.ParamLocationQuery, *params.SellerSku); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "marketplaceIds", runtime.ParamLocationQuery, params.MarketplaceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetInventorySummariesWithResponse request
	GetInventorySummariesWithResponse(ctx context.Context, params *GetInventorySummariesParams) (*GetInventorySummariesResp, error)
}

type GetInventorySummariesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInventorySummariesResponse
	JSON400      *GetInventorySummariesResponse
	JSON403      *GetInventorySummariesResponse
	JSON404      *GetInventorySummariesResponse
	JSON429      *GetInventorySummariesResponse
	JSON500      *GetInventorySummariesResponse
	JSON503      *GetInventorySummariesResponse
}

// Status returns HTTPResponse.Status
func (r GetInventorySummariesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInventorySummariesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetInventorySummariesWithResponse request returning *GetInventorySummariesResp
func (c *ClientWithResponses) GetInventorySummariesWithResponse(ctx context.Context, params *GetInventorySummariesParams) (*GetInventorySummariesResp, error) {
	rsp, err := c.GetInventorySummaries(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetInventorySummariesResp(rsp)
}

// ParseGetInventorySummariesResp parses an HTTP response from a GetInventorySummariesWithResponse call
func ParseGetInventorySummariesResp(rsp *http.Response) (*GetInventorySummariesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInventorySummariesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetInventorySummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
