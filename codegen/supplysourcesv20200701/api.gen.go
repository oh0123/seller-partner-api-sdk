// Package supplysourcesv20200701 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package supplysourcesv20200701

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"

	"github.com/bytedance/sonic"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ParkingCostType.
const (
	ParkingCostTypeFree  ParkingCostType = "Free"
	ParkingCostTypeOther ParkingCostType = "Other"
)

// Defines values for ParkingSpotIdentificationType.
const (
	ParkingSpotIdentificationTypeNumbered ParkingSpotIdentificationType = "Numbered"
	ParkingSpotIdentificationTypeOther    ParkingSpotIdentificationType = "Other"
)

// Defines values for SupplySourceStatus.
const (
	SupplySourceStatusActive   SupplySourceStatus = "Active"
	SupplySourceStatusInactive SupplySourceStatus = "Inactive"
)

// Defines values for SupplySourceStatusReadOnly.
const (
	SupplySourceStatusReadOnlyActive   SupplySourceStatusReadOnly = "Active"
	SupplySourceStatusReadOnlyArchived SupplySourceStatusReadOnly = "Archived"
	SupplySourceStatusReadOnlyInactive SupplySourceStatusReadOnly = "Inactive"
)

// Defines values for ThroughputUnit.
const (
	Order ThroughputUnit = "Order"
)

// Defines values for TimeUnit.
const (
	Days    TimeUnit = "Days"
	Hours   TimeUnit = "Hours"
	Minutes TimeUnit = "Minutes"
)

// Address A physical address.
type Address struct {
	// AddressLine1 The first line of the address.
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 The additional address information, if required.
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 The additional address information, if required.
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// City The city where the person, business or institution is located.
	City *string `json:"city,omitempty"`

	// CountryCode The two digit country code. In ISO 3166-1 alpha-2 format.
	CountryCode string `json:"countryCode"`

	// County The county where person, business or institution is located.
	County *string `json:"county,omitempty"`

	// District The district where person, business or institution is located.
	District *string `json:"district,omitempty"`

	// Name The name of the person, business or institution at that address.
	Name string `json:"name"`

	// Phone The phone number of the person, business or institution located at that address.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The postal code of that address. It conatins a series of letters or digits or both, sometimes including spaces or punctuation.
	PostalCode *string `json:"postalCode,omitempty"`

	// StateOrRegion The state or region where person, business or institution is located.
	StateOrRegion string `json:"stateOrRegion"`
}

// AddressWithContact The address and contact details.
type AddressWithContact struct {
	// Address A physical address.
	Address *Address `json:"address,omitempty"`

	// ContactDetails The contact details
	ContactDetails *ContactDetails `json:"contactDetails,omitempty"`
}

// ContactDetails The contact details
type ContactDetails struct {
	Primary *struct {
		// Email The email address to which email messages are delivered.
		Email *EmailAddress `json:"email,omitempty"`

		// Phone The phone number of the person, business or institution.
		Phone *string `json:"phone,omitempty"`
	} `json:"primary,omitempty"`
}

// CreateSupplySourceRequest A request to create a supply source.
type CreateSupplySourceRequest struct {
	// Address A physical address.
	Address Address `json:"address"`

	// Alias The custom alias for this supply source
	Alias SupplySourceAlias `json:"alias"`

	// SupplySourceCode The seller-provided unique supply source code.
	SupplySourceCode SupplySourceCode `json:"supplySourceCode"`
}

// CreateSupplySourceResponse The result of creating a new supply source.
type CreateSupplySourceResponse struct {
	// SupplySourceCode The seller-provided unique supply source code.
	SupplySourceCode SupplySourceCode `json:"supplySourceCode"`

	// SupplySourceId An Amazon generated unique supply source ID.
	SupplySourceId SupplySourceId `json:"supplySourceId"`
}

// CurbsidePickupConfiguration The curbside pickup configuration of a supply source.
type CurbsidePickupConfiguration struct {
	// IsSupported When true, curbside pickup is supported by the supply source.
	IsSupported *bool `json:"isSupported,omitempty"`

	// OperationalConfiguration The operational configuration of `supplySources`.
	OperationalConfiguration *OperationalConfiguration `json:"operationalConfiguration,omitempty"`

	// ParkingWithAddressConfiguration The parking configuration with the address.
	ParkingWithAddressConfiguration *ParkingWithAddressConfiguration `json:"parkingWithAddressConfiguration,omitempty"`
}

// DateTime A date and time in the rfc3339 format.
type DateTime = string

// DeliveryChannel The delivery channel of a supply source.
type DeliveryChannel struct {
	IsSupported *bool `json:"isSupported,omitempty"`

	// OperationalConfiguration The operational configuration of `supplySources`.
	OperationalConfiguration *OperationalConfiguration `json:"operationalConfiguration,omitempty"`
}

// Duration The duration of time.
type Duration struct {
	// TimeUnit The time unit
	TimeUnit *TimeUnit `json:"timeUnit,omitempty"`

	// Value An unsigned integer that can be only positive or zero.
	Value *NonNegativeInteger `json:"value,omitempty"`
}

// EmailAddress The email address to which email messages are delivered.
type EmailAddress = string

// Error An error response returned when the request is unsuccessful.
type Error struct {
	// Code An error code that identifies the type of error that occured.
	Code string `json:"code"`

	// Details The additional details that can help the caller understand or fix the issue.
	Details *string `json:"details,omitempty"`

	// Message A message that describes the error condition in a human-readable form.
	Message string `json:"message"`
}

// ErrorList A list of error responses returned when a request is unsuccessful.
type ErrorList struct {
	// Errors A list of error responses returned when a request is unsuccessful.
	Errors []Error `json:"errors"`
}

// GetSupplySourcesResponse The paginated list of supply sources.
type GetSupplySourcesResponse struct {
	// NextPageToken If present, use this pagination token to retrieve the next page of supply sources.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// SupplySources The list of `SupplySource`s.
	SupplySources *SupplySourceList `json:"supplySources,omitempty"`
}

// InStorePickupConfiguration The in-store pickup configuration of a supply source.
type InStorePickupConfiguration struct {
	// IsSupported When true, in-store pickup is supported by the supply source (default: `isSupported` value in `PickupChannel`).
	IsSupported *bool `json:"isSupported,omitempty"`

	// ParkingConfiguration The parking configuration.
	ParkingConfiguration *ParkingConfiguration `json:"parkingConfiguration,omitempty"`
}

// NonNegativeInteger An unsigned integer that can be only positive or zero.
type NonNegativeInteger = int

// OperatingHour The operating hour schema
type OperatingHour struct {
	// EndTime The closing time, ISO 8601 formatted timestamp without date, HH:mm.
	EndTime *string `json:"endTime,omitempty"`

	// StartTime The opening time, ISO 8601 formatted timestamp without date, HH:mm.
	StartTime *string `json:"startTime,omitempty"`
}

// OperatingHours A list of Operating Hours.
type OperatingHours = []OperatingHour

// OperatingHoursByDay The operating hours per day
type OperatingHoursByDay struct {
	// Friday A list of Operating Hours.
	Friday *OperatingHours `json:"friday,omitempty"`

	// Monday A list of Operating Hours.
	Monday *OperatingHours `json:"monday,omitempty"`

	// Saturday A list of Operating Hours.
	Saturday *OperatingHours `json:"saturday,omitempty"`

	// Sunday A list of Operating Hours.
	Sunday *OperatingHours `json:"sunday,omitempty"`

	// Thursday A list of Operating Hours.
	Thursday *OperatingHours `json:"thursday,omitempty"`

	// Tuesday A list of Operating Hours.
	Tuesday *OperatingHours `json:"tuesday,omitempty"`

	// Wednesday A list of Operating Hours.
	Wednesday *OperatingHours `json:"wednesday,omitempty"`
}

// OperationalConfiguration The operational configuration of `supplySources`.
type OperationalConfiguration struct {
	// ContactDetails The contact details
	ContactDetails *ContactDetails `json:"contactDetails,omitempty"`

	// HandlingTime The duration of time.
	HandlingTime *Duration `json:"handlingTime,omitempty"`

	// OperatingHoursByDay The operating hours per day
	OperatingHoursByDay *OperatingHoursByDay `json:"operatingHoursByDay,omitempty"`

	// ThroughputConfig The throughput configuration.
	ThroughputConfig *ThroughputConfig `json:"throughputConfig,omitempty"`
}

// OutboundCapability The outbound capability of a supply source.
type OutboundCapability struct {
	// DeliveryChannel The delivery channel of a supply source.
	DeliveryChannel *DeliveryChannel `json:"deliveryChannel,omitempty"`
	IsSupported     *bool            `json:"isSupported,omitempty"`

	// OperationalConfiguration The operational configuration of `supplySources`.
	OperationalConfiguration *OperationalConfiguration `json:"operationalConfiguration,omitempty"`

	// PickupChannel The pick up channel of a supply source.
	PickupChannel *PickupChannel `json:"pickupChannel,omitempty"`

	// ReturnLocation The address or reference to another `supplySourceId` to act as a return location.
	ReturnLocation *ReturnLocation `json:"returnLocation,omitempty"`
}

// ParkingConfiguration The parking configuration.
type ParkingConfiguration struct {
	// NumberOfParkingSpots An unsigned integer that can be only positive or zero.
	NumberOfParkingSpots *NonNegativeInteger `json:"numberOfParkingSpots,omitempty"`

	// ParkingCostType The parking cost type.
	ParkingCostType *ParkingCostType `json:"parkingCostType,omitempty"`

	// ParkingSpotIdentificationType The type of parking spot identification.
	ParkingSpotIdentificationType *ParkingSpotIdentificationType `json:"parkingSpotIdentificationType,omitempty"`
}

// ParkingCostType The parking cost type.
type ParkingCostType string

// ParkingSpotIdentificationType The type of parking spot identification.
type ParkingSpotIdentificationType string

// ParkingWithAddressConfiguration defines model for ParkingWithAddressConfiguration.
type ParkingWithAddressConfiguration struct {
	// Address A physical address.
	Address *Address `json:"address,omitempty"`

	// NumberOfParkingSpots An unsigned integer that can be only positive or zero.
	NumberOfParkingSpots *NonNegativeInteger `json:"numberOfParkingSpots,omitempty"`

	// ParkingCostType The parking cost type.
	ParkingCostType *ParkingCostType `json:"parkingCostType,omitempty"`

	// ParkingSpotIdentificationType The type of parking spot identification.
	ParkingSpotIdentificationType *ParkingSpotIdentificationType `json:"parkingSpotIdentificationType,omitempty"`
}

// PickupChannel The pick up channel of a supply source.
type PickupChannel struct {
	// CurbsidePickupConfiguration The curbside pickup configuration of a supply source.
	CurbsidePickupConfiguration *CurbsidePickupConfiguration `json:"curbsidePickupConfiguration,omitempty"`

	// InStorePickupConfiguration The in-store pickup configuration of a supply source.
	InStorePickupConfiguration *InStorePickupConfiguration `json:"inStorePickupConfiguration,omitempty"`

	// InventoryHoldPeriod The duration of time.
	InventoryHoldPeriod *Duration `json:"inventoryHoldPeriod,omitempty"`
	IsSupported         *bool     `json:"isSupported,omitempty"`

	// OperationalConfiguration The operational configuration of `supplySources`.
	OperationalConfiguration *OperationalConfiguration `json:"operationalConfiguration,omitempty"`
}

// ReturnLocation The address or reference to another `supplySourceId` to act as a return location.
type ReturnLocation struct {
	// AddressWithContact The address and contact details.
	AddressWithContact *AddressWithContact `json:"addressWithContact,omitempty"`

	// SupplySourceId The Amazon provided `supplySourceId` where orders can be returned to.
	SupplySourceId *string `json:"supplySourceId,omitempty"`
}

// ServicesCapability The services capability of a supply source.
type ServicesCapability struct {
	// IsSupported When true, `SupplySource` supports the Service capability.
	IsSupported *bool `json:"isSupported,omitempty"`

	// OperationalConfiguration The operational configuration of `supplySources`.
	OperationalConfiguration *OperationalConfiguration `json:"operationalConfiguration,omitempty"`
}

// SupplySource The supply source details, including configurations and capabilities.
type SupplySource struct {
	// Address A physical address.
	Address *Address `json:"address,omitempty"`

	// Alias The custom alias for this supply source
	Alias *SupplySourceAlias `json:"alias,omitempty"`

	// Capabilities The capabilities of a supply source.
	Capabilities *SupplySourceCapabilities `json:"capabilities,omitempty"`

	// Configuration Includes configuration and timezone of a supply source.
	Configuration *SupplySourceConfiguration `json:"configuration,omitempty"`

	// CreatedAt A date and time in the rfc3339 format.
	CreatedAt *DateTime `json:"createdAt,omitempty"`

	// Status The `SupplySource` status.
	Status *SupplySourceStatusReadOnly `json:"status,omitempty"`

	// SupplySourceCode The seller-provided unique supply source code.
	SupplySourceCode *SupplySourceCode `json:"supplySourceCode,omitempty"`

	// SupplySourceId An Amazon generated unique supply source ID.
	SupplySourceId *SupplySourceId `json:"supplySourceId,omitempty"`

	// UpdatedAt A date and time in the rfc3339 format.
	UpdatedAt *DateTime `json:"updatedAt,omitempty"`
}

// SupplySourceAlias The custom alias for this supply source
type SupplySourceAlias = string

// SupplySourceCapabilities The capabilities of a supply source.
type SupplySourceCapabilities struct {
	// Outbound The outbound capability of a supply source.
	Outbound *OutboundCapability `json:"outbound,omitempty"`

	// Services The services capability of a supply source.
	Services *ServicesCapability `json:"services,omitempty"`
}

// SupplySourceCode The seller-provided unique supply source code.
type SupplySourceCode = string

// SupplySourceConfiguration Includes configuration and timezone of a supply source.
type SupplySourceConfiguration struct {
	// OperationalConfiguration The operational configuration of `supplySources`.
	OperationalConfiguration *OperationalConfiguration `json:"operationalConfiguration,omitempty"`

	// Timezone Please see RFC 6557, should be a canonical time zone ID as listed here: https://www.joda.org/joda-time/timezones.html.
	Timezone *string `json:"timezone,omitempty"`
}

// SupplySourceId An Amazon generated unique supply source ID.
type SupplySourceId = string

// SupplySourceList The list of `SupplySource`s.
type SupplySourceList = []struct {
	// Address A physical address.
	Address *Address `json:"address,omitempty"`

	// Alias The custom alias for this supply source
	Alias *SupplySourceAlias `json:"alias,omitempty"`

	// SupplySourceCode The seller-provided unique supply source code.
	SupplySourceCode *SupplySourceCode `json:"supplySourceCode,omitempty"`

	// SupplySourceId An Amazon generated unique supply source ID.
	SupplySourceId *SupplySourceId `json:"supplySourceId,omitempty"`
}

// SupplySourceStatus The `SupplySource` status
type SupplySourceStatus string

// SupplySourceStatusReadOnly The `SupplySource` status.
type SupplySourceStatusReadOnly string

// ThroughputCap The throughput capacity
type ThroughputCap struct {
	// TimeUnit The time unit
	TimeUnit *TimeUnit `json:"timeUnit,omitempty"`

	// Value An unsigned integer that can be only positive or zero.
	Value *NonNegativeInteger `json:"value,omitempty"`
}

// ThroughputConfig The throughput configuration.
type ThroughputConfig struct {
	// ThroughputCap The throughput capacity
	ThroughputCap *ThroughputCap `json:"throughputCap,omitempty"`

	// ThroughputUnit The throughput unit
	ThroughputUnit ThroughputUnit `json:"throughputUnit"`
}

// ThroughputUnit The throughput unit
type ThroughputUnit string

// TimeUnit The time unit
type TimeUnit string

// UpdateSupplySourceRequest A request to update the configuration and capabilities of a supply source.
type UpdateSupplySourceRequest struct {
	// Alias The custom alias for this supply source
	Alias *SupplySourceAlias `json:"alias,omitempty"`

	// Capabilities The capabilities of a supply source.
	Capabilities *SupplySourceCapabilities `json:"capabilities,omitempty"`

	// Configuration Includes configuration and timezone of a supply source.
	Configuration *SupplySourceConfiguration `json:"configuration,omitempty"`
}

// UpdateSupplySourceStatusRequest A request to update the status of a supply source.
type UpdateSupplySourceStatusRequest struct {
	// Status The `SupplySource` status
	Status *SupplySourceStatus `json:"status,omitempty"`
}

// GetSupplySourcesParams defines parameters for GetSupplySources.
type GetSupplySourcesParams struct {
	// NextPageToken The pagination token to retrieve a specific page of results.
	NextPageToken *string `form:"nextPageToken,omitempty" json:"nextPageToken,omitempty"`

	// PageSize The number of supply sources to return per paginated request.
	PageSize *float32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// CreateSupplySourceJSONRequestBody defines body for CreateSupplySource for application/json ContentType.
type CreateSupplySourceJSONRequestBody = CreateSupplySourceRequest

// UpdateSupplySourceJSONRequestBody defines body for UpdateSupplySource for application/json ContentType.
type UpdateSupplySourceJSONRequestBody = UpdateSupplySourceRequest

// UpdateSupplySourceStatusJSONRequestBody defines body for UpdateSupplySourceStatus for application/json ContentType.
type UpdateSupplySourceStatusJSONRequestBody = UpdateSupplySourceStatusRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetSupplySources request
	GetSupplySources(ctx context.Context, params *GetSupplySourcesParams) (*http.Response, error)

	// CreateSupplySourceWithBody request with any body
	CreateSupplySourceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateSupplySource(ctx context.Context, body CreateSupplySourceJSONRequestBody) (*http.Response, error)

	// ArchiveSupplySource request
	ArchiveSupplySource(ctx context.Context, supplySourceId string) (*http.Response, error)

	// GetSupplySource request
	GetSupplySource(ctx context.Context, supplySourceId string) (*http.Response, error)

	// UpdateSupplySourceWithBody request with any body
	UpdateSupplySourceWithBody(ctx context.Context, supplySourceId string, contentType string, body io.Reader) (*http.Response, error)

	UpdateSupplySource(ctx context.Context, supplySourceId string, body UpdateSupplySourceJSONRequestBody) (*http.Response, error)

	// UpdateSupplySourceStatusWithBody request with any body
	UpdateSupplySourceStatusWithBody(ctx context.Context, supplySourceId string, contentType string, body io.Reader) (*http.Response, error)

	UpdateSupplySourceStatus(ctx context.Context, supplySourceId string, body UpdateSupplySourceStatusJSONRequestBody) (*http.Response, error)
}

func (c *Client) GetSupplySources(ctx context.Context, params *GetSupplySourcesParams) (*http.Response, error) {
	req, err := NewGetSupplySourcesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateSupplySourceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateSupplySourceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) CreateSupplySource(ctx context.Context, body CreateSupplySourceJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateSupplySourceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ArchiveSupplySource(ctx context.Context, supplySourceId string) (*http.Response, error) {
	req, err := NewArchiveSupplySourceRequest(c.Server, supplySourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetSupplySource(ctx context.Context, supplySourceId string) (*http.Response, error) {
	req, err := NewGetSupplySourceRequest(c.Server, supplySourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateSupplySourceWithBody(ctx context.Context, supplySourceId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateSupplySourceRequestWithBody(c.Server, supplySourceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateSupplySource(ctx context.Context, supplySourceId string, body UpdateSupplySourceJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateSupplySourceRequest(c.Server, supplySourceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateSupplySourceStatusWithBody(ctx context.Context, supplySourceId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateSupplySourceStatusRequestWithBody(c.Server, supplySourceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateSupplySourceStatus(ctx context.Context, supplySourceId string, body UpdateSupplySourceStatusJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateSupplySourceStatusRequest(c.Server, supplySourceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewGetSupplySourcesRequest generates requests for GetSupplySources
func NewGetSupplySourcesRequest(server string, params *GetSupplySourcesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/supplySources/2020-07-01/supplySources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextPageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextPageToken", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, len(v))
					copy(values, v)
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSupplySourceRequest calls the generic CreateSupplySource builder with application/json body
func NewCreateSupplySourceRequest(server string, body CreateSupplySourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSupplySourceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSupplySourceRequestWithBody generates requests for CreateSupplySource with any type of body
func NewCreateSupplySourceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/supplySources/2020-07-01/supplySources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveSupplySourceRequest generates requests for ArchiveSupplySource
func NewArchiveSupplySourceRequest(server string, supplySourceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "supplySourceId", runtime.ParamLocationPath, supplySourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/supplySources/2020-07-01/supplySources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSupplySourceRequest generates requests for GetSupplySource
func NewGetSupplySourceRequest(server string, supplySourceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "supplySourceId", runtime.ParamLocationPath, supplySourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/supplySources/2020-07-01/supplySources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSupplySourceRequest calls the generic UpdateSupplySource builder with application/json body
func NewUpdateSupplySourceRequest(server string, supplySourceId string, body UpdateSupplySourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSupplySourceRequestWithBody(server, supplySourceId, "application/json", bodyReader)
}

// NewUpdateSupplySourceRequestWithBody generates requests for UpdateSupplySource with any type of body
func NewUpdateSupplySourceRequestWithBody(server string, supplySourceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "supplySourceId", runtime.ParamLocationPath, supplySourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/supplySources/2020-07-01/supplySources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateSupplySourceStatusRequest calls the generic UpdateSupplySourceStatus builder with application/json body
func NewUpdateSupplySourceStatusRequest(server string, supplySourceId string, body UpdateSupplySourceStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := sonic.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSupplySourceStatusRequestWithBody(server, supplySourceId, "application/json", bodyReader)
}

// NewUpdateSupplySourceStatusRequestWithBody generates requests for UpdateSupplySourceStatus with any type of body
func NewUpdateSupplySourceStatusRequestWithBody(server string, supplySourceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "supplySourceId", runtime.ParamLocationPath, supplySourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/supplySources/2020-07-01/supplySources/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetSupplySourcesWithResponse request
	GetSupplySourcesWithResponse(ctx context.Context, params *GetSupplySourcesParams) (*GetSupplySourcesResp, error)

	// CreateSupplySourceWithBodyWithResponse request with any body
	CreateSupplySourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateSupplySourceResp, error)

	CreateSupplySourceWithResponse(ctx context.Context, body CreateSupplySourceJSONRequestBody) (*CreateSupplySourceResp, error)

	// ArchiveSupplySourceWithResponse request
	ArchiveSupplySourceWithResponse(ctx context.Context, supplySourceId string) (*ArchiveSupplySourceResp, error)

	// GetSupplySourceWithResponse request
	GetSupplySourceWithResponse(ctx context.Context, supplySourceId string) (*GetSupplySourceResp, error)

	// UpdateSupplySourceWithBodyWithResponse request with any body
	UpdateSupplySourceWithBodyWithResponse(ctx context.Context, supplySourceId string, contentType string, body io.Reader) (*UpdateSupplySourceResp, error)

	UpdateSupplySourceWithResponse(ctx context.Context, supplySourceId string, body UpdateSupplySourceJSONRequestBody) (*UpdateSupplySourceResp, error)

	// UpdateSupplySourceStatusWithBodyWithResponse request with any body
	UpdateSupplySourceStatusWithBodyWithResponse(ctx context.Context, supplySourceId string, contentType string, body io.Reader) (*UpdateSupplySourceStatusResp, error)

	UpdateSupplySourceStatusWithResponse(ctx context.Context, supplySourceId string, body UpdateSupplySourceStatusJSONRequestBody) (*UpdateSupplySourceStatusResp, error)
}

type GetSupplySourcesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSupplySourcesResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetSupplySourcesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSupplySourcesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSupplySourceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateSupplySourceResponse
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r CreateSupplySourceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSupplySourceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveSupplySourceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *ErrorList
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r ArchiveSupplySourceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveSupplySourceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSupplySourceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupplySource
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r GetSupplySourceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSupplySourceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSupplySourceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *ErrorList
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateSupplySourceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSupplySourceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSupplySourceStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *ErrorList
	JSON400      *ErrorList
	JSON403      *ErrorList
	JSON404      *ErrorList
	JSON413      *ErrorList
	JSON415      *ErrorList
	JSON429      *ErrorList
	JSON500      *ErrorList
	JSON503      *ErrorList
}

// Status returns HTTPResponse.Status
func (r UpdateSupplySourceStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSupplySourceStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetSupplySourcesWithResponse request returning *GetSupplySourcesResp
func (c *ClientWithResponses) GetSupplySourcesWithResponse(ctx context.Context, params *GetSupplySourcesParams) (*GetSupplySourcesResp, error) {
	rsp, err := c.GetSupplySources(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetSupplySourcesResp(rsp)
}

// CreateSupplySourceWithBodyWithResponse request with arbitrary body returning *CreateSupplySourceResp
func (c *ClientWithResponses) CreateSupplySourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateSupplySourceResp, error) {
	rsp, err := c.CreateSupplySourceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateSupplySourceResp(rsp)
}

func (c *ClientWithResponses) CreateSupplySourceWithResponse(ctx context.Context, body CreateSupplySourceJSONRequestBody) (*CreateSupplySourceResp, error) {
	rsp, err := c.CreateSupplySource(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateSupplySourceResp(rsp)
}

// ArchiveSupplySourceWithResponse request returning *ArchiveSupplySourceResp
func (c *ClientWithResponses) ArchiveSupplySourceWithResponse(ctx context.Context, supplySourceId string) (*ArchiveSupplySourceResp, error) {
	rsp, err := c.ArchiveSupplySource(ctx, supplySourceId)
	if err != nil {
		return nil, err
	}
	return ParseArchiveSupplySourceResp(rsp)
}

// GetSupplySourceWithResponse request returning *GetSupplySourceResp
func (c *ClientWithResponses) GetSupplySourceWithResponse(ctx context.Context, supplySourceId string) (*GetSupplySourceResp, error) {
	rsp, err := c.GetSupplySource(ctx, supplySourceId)
	if err != nil {
		return nil, err
	}
	return ParseGetSupplySourceResp(rsp)
}

// UpdateSupplySourceWithBodyWithResponse request with arbitrary body returning *UpdateSupplySourceResp
func (c *ClientWithResponses) UpdateSupplySourceWithBodyWithResponse(ctx context.Context, supplySourceId string, contentType string, body io.Reader) (*UpdateSupplySourceResp, error) {
	rsp, err := c.UpdateSupplySourceWithBody(ctx, supplySourceId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSupplySourceResp(rsp)
}

func (c *ClientWithResponses) UpdateSupplySourceWithResponse(ctx context.Context, supplySourceId string, body UpdateSupplySourceJSONRequestBody) (*UpdateSupplySourceResp, error) {
	rsp, err := c.UpdateSupplySource(ctx, supplySourceId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSupplySourceResp(rsp)
}

// UpdateSupplySourceStatusWithBodyWithResponse request with arbitrary body returning *UpdateSupplySourceStatusResp
func (c *ClientWithResponses) UpdateSupplySourceStatusWithBodyWithResponse(ctx context.Context, supplySourceId string, contentType string, body io.Reader) (*UpdateSupplySourceStatusResp, error) {
	rsp, err := c.UpdateSupplySourceStatusWithBody(ctx, supplySourceId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSupplySourceStatusResp(rsp)
}

func (c *ClientWithResponses) UpdateSupplySourceStatusWithResponse(ctx context.Context, supplySourceId string, body UpdateSupplySourceStatusJSONRequestBody) (*UpdateSupplySourceStatusResp, error) {
	rsp, err := c.UpdateSupplySourceStatus(ctx, supplySourceId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSupplySourceStatusResp(rsp)
}

// ParseGetSupplySourcesResp parses an HTTP response from a GetSupplySourcesWithResponse call
func ParseGetSupplySourcesResp(rsp *http.Response) (*GetSupplySourcesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSupplySourcesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSupplySourcesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateSupplySourceResp parses an HTTP response from a CreateSupplySourceWithResponse call
func ParseCreateSupplySourceResp(rsp *http.Response) (*CreateSupplySourceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSupplySourceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateSupplySourceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseArchiveSupplySourceResp parses an HTTP response from a ArchiveSupplySourceWithResponse call
func ParseArchiveSupplySourceResp(rsp *http.Response) (*ArchiveSupplySourceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveSupplySourceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetSupplySourceResp parses an HTTP response from a GetSupplySourceWithResponse call
func ParseGetSupplySourceResp(rsp *http.Response) (*GetSupplySourceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSupplySourceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupplySource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateSupplySourceResp parses an HTTP response from a UpdateSupplySourceWithResponse call
func ParseUpdateSupplySourceResp(rsp *http.Response) (*UpdateSupplySourceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSupplySourceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateSupplySourceStatusResp parses an HTTP response from a UpdateSupplySourceStatusWithResponse call
func ParseUpdateSupplySourceStatusResp(rsp *http.Response) (*UpdateSupplySourceStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSupplySourceStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
